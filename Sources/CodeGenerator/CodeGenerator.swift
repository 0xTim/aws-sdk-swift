//
//  CodeGenerator.swift
//  AWSSDKSwift
//
//  Created by Yuki Takei on 2017/04/04.
//
//

// TODO should use template engine to generate code

import Foundation
import SwiftyJSON
import Core

extension Core.Operation {
    func generateSwiftFunctionCode() -> String {
        var code = ""
        
        if let shape = self.inputShape {
            code += "public func \(name.toSwiftVariableCase())(_ input: \(shape.swiftTypeName))"
        } else {
            code += "public func \(name.toSwiftVariableCase())()"
        }
        
        code += " throws"
        
        if let shape = self.outputShape {
            code += " -> \(shape.swiftTypeName)"
        }
        
        code += " {\n"
        
        if outputShape != nil {
            code += "\(indt(1))return try client.send("
        } else {
            code += "\(indt(1))_ = try client.send("
        }
        
        code += "operation: \"\(name)\", "
        code += "path: \"\(path)\", "
        code += "httpMethod: \"\(httpMethod)\""
        if inputShape != nil {
            code += ", "
            code += "input: input"
        }

        code += ")\n"
        code += "}"
        
        return code
    }
}

extension Member {
    var defaultValue: String {
        if !required {
            return "nil"
        }
        
        switch shape.type {
        case .integer(_), .float(_), .double(_), .long(_):
            return "0"
        case .boolean:
            return "false"
        case .blob(_):
            return "Data()"
        case .timestamp:
            return "Date()"
        case .list(_):
            return "[]"
        case .map(_):
            return "[:]"
        case .structure(_):
            return "\(shape.name)()"
        default:
            return "\"\""
        }
    }
    
    func toSwiftMutableMemberSyntax() -> String {
        let optionalSuffix = required ? "" : "?"
        return "var \(name.toSwiftVariableCase()): \(swiftTypeName)\(optionalSuffix) = \(defaultValue)"
    }
    
    func toSwiftImmutableMemberSyntax() -> String {
        let optionalSuffix = required ? "" : "?"
        return "let \(name.toSwiftVariableCase()): \(swiftTypeName)\(optionalSuffix)"
    }
    
    func toSwiftArgumentSyntax() -> String {
        let optionalSuffix = required ? "" : "?"
        let defaultArgument = required ? "" : " = nil"
        return "\(name.toSwiftLabelCase()): \(swiftTypeName)\(optionalSuffix)\(defaultArgument)"
    }
}

extension AWSService {
//    func generateResponseBuilderCode() -> String {
//        var code = ""
//        code += autoGeneratedHeader
//        code += "import Foundation\n"
//        code += "import Core"
//        code += "\n\n"
//        
//        switch serviceProtocol {
//        case .restxml:
//            code += "struct \(serviceName)ResponseBuilder<T: Initializable> {"
//        case .json, .query:
//            code += "struct \(serviceName)ResponseBuilder<T: Initializable> {"
//        }
//        code += "\n"
//        code += "\(indt(1))let bodyData: Data\n"
//        code += "\(indt(1))let urlResponse: HTTPURLResponse\n\n"
//        code += "\(indt(1))init(bodyData: Data, urlResponse: HTTPURLResponse) {\n"
//        code += "\(indt(2))self.bodyData = bodyData\n"
//        code += "\(indt(2))self.urlResponse = urlResponse\n"
//        code += "\(indt(1))}\n\n"
//
//        code += "\(indt(1))public func build() throws -> T {\n"
//        switch serviceProtocol {
//        case .restxml:
//            code += "\(indt(2))let xmlNode = try XML2Parser(data: bodyData).parse()\n"
//            code += "\(indt(2))let jsonString = XMLNodeSerializer(node: xmlNode).serializeToJSON()\n"
//            code += "\(indt(2))guard let dictionary = try JSONSerialization.jsonObject(with: jsonString.data(using: .utf8)!, options: []) as? [String: Any] else { throw ResponseBuilderError.couldNotParseResponseJSON }\n"
//            code += "\(indt(2))let errorDict = dictionary[\"Error\"] as? [String: Any]\n"
//            code += "\(indt(2))let errorCode = errorDict?[\"Code\"] as? String ?? \"UnknownError\"\n"
//            code += "\(indt(2))let message = errorDict?[\"Message\"] as? String\n"
//        case .json, .query:
//            code += "\(indt(2))guard let dictionary = try JSONSerialization.jsonObject(with: bodyData, options: []) as? [String: Any] else { throw ResponseBuilderError.couldNotParseResponseJSON }\n"
//            code += "\(indt(2))let errorCode = dictionary[\"__type\"] as? String ?? \"UnknownError\"\n"
//            code += "\(indt(2))let message = dictionary.filter({ $0.key.lowercased() == \"message\" }).first?.value as? String\n"
//        }
//        
//        code += "\(indt(2))guard (200..<300).contains(urlResponse.statusCode) else {\n"
//        code += "\(indt(3))if let error = \(serviceName)Error(errorCode: errorCode, message: message) {\n"
//        code += "\(indt(4))throw error\n"
//        code += "\(indt(3))}\n"
//        
//        code += "\(indt(3))if let error = AWSServerError(errorCode: errorCode, message: message) {\n"
//        code += "\(indt(4))throw error\n"
//        code += "\(indt(3))}\n"
//        
//        code += "\(indt(3))throw AWSClientError(errorCode: errorCode, message: message)\n"
//        code += "\(indt(2))}\n"
//        code += "\(indt(2))return try Core.construct(dictionary: dictionary)\n"
//        code += "\(indt(1))}\n"
//        code += "}"
//        
//        return code
//    }
    
    func generateErrorCode() -> String {
        if errorShapeNames.isEmpty { return "" }
        var code = ""
        code += autoGeneratedHeader
        code += "import Core"
        code += "\n\n"
        
        code += "/// Error enum for \(serviceName)\n"
        code += ""
        code += "public enum \(serviceErrorName): AWSErrorType {\n"
        for name in errorShapeNames {
            code += "\(indt(1))case \(name.toSwiftVariableCase())(message: String?)\n"
        }
        code += "}"
        code += "\n\n"
        code += "extension \(serviceErrorName) {\n"
        code += "\(indt(1))public init?(errorCode: String, message: String?){\n"
        code += "\(indt(2))switch errorCode {\n"
        for name in errorShapeNames {
            code += "\(indt(2))case \"\(name)\":\n"
            code += "\(indt(3))self = .\(name.toSwiftVariableCase())(message: message)\n"
        }
        code += "\(indt(2))default:\n"
        code += "\(indt(3))return nil\n"
        code += "\(indt(2))}\n"
        code += "\(indt(1))}\n"
        code += "}"
        
        return code
    }
    
    func generateServiceCode() -> String {
        var code = ""
        code += autoGeneratedHeader
        code += "import Foundation\n"
        code += "import Core\n\n"
        code += "/**\n"
        code += serviceDescription+"\n"
        code += "*/\n"
        code += "public "
        code += "struct \(serviceName) {\n\n"
        code += "\(indt(1))let client: AWSClient\n\n"
        
        var middlewares = "[]"
        switch endpointPrefix {
        case "s3":
            middlewares = "[S3RequestMiddleware()]"
        default:
            break
        }
        
        code += "\(indt(1))public init(accessKeyId: String? = nil, secretAccessKey: String? = nil, region: Core.Region? = nil, endpoint: String? = nil, middlewares: [AWSRequestMiddleware] = []) {\n"
        code += "\(indt(2))self.client = AWSClient(\n"
        code += "\(indt(3))accessKeyId: accessKeyId,\n"
        code += "\(indt(3))secretAccessKey: secretAccessKey,\n"
        code += "\(indt(3))region: region,\n"
        if let target = apiJSON["metadata"]["targetPrefix"].string {
            code += "\(indt(3))amzTarget: \"\(target)\",\n"
        }
        code += "\(indt(3))service: \"\(endpointPrefix)\",\n"
        code += "\(indt(3))serviceProtocol: .\(serviceProtocol),\n"
        code += "\(indt(3))endpoint: endpoint,\n"
        code += "\(indt(3))middlewares: \(middlewares)"
        if !errorShapeNames.isEmpty {
            code += ",\n"
            code += "\(indt(3))possibleErrorTypes: [\(serviceErrorName).self]\n"
        }
        code += indt(2)+")\n"
        code += "\(indt(1))}\n"
        code += "\n"
        for operation in operations {
            let functionCode = operation.generateSwiftFunctionCode()
                .components(separatedBy: "\n")
                .map({ indt(1)+$0 })
                .joined(separator: "\n")
            
            let comment = docJSON["operations"][operation.name].stringValue.tagStriped()
            
            code += "\(indt(1))///  \(comment)\n"
            code += functionCode
            code += "\n\n"
        }
        code += "\n"
        code += "}"
        
        return code
    }
    
    func generateShapesCode() -> String {
        var code = ""
        code += autoGeneratedHeader
        code += "import Foundation\n"
        code += "import Core\n\n"
        code += "extension \(serviceName) {\n\n"
        
        for shape in shapes {
            if errorShapeNames.contains(shape.name) { continue }
            if !shape.isNotSwiftDefinedType() { continue }
            
            switch shape.type {
            case .structure(let type):
                code += "\(indt(1))public struct \(shape.name): AWSShape {\n"
                code += "\(indt(2))/// The key for the payload\n"
                if let payload = type.payload {
                    code += "\(indt(2))public let _payload: String? = \"\(payload)\"\n"
                } else {
                    code += "\(indt(2))public let _payload: String? = nil\n"
                }
                
                let requestParam = type.members.toRequestParam()
                if !requestParam.headerParams.isEmpty {
                    code += "\(indt(2))public var headerParams: [String: String] {\n"
                    code += "\(indt(3))return \(requestParam.headerParams)\n"
                    code += "\(indt(2))}\n"
                }
                
                if !requestParam.queryParams.isEmpty {
                    code += "\(indt(2))public var queryParams: [String: String] {\n"
                    code += "\(indt(3))return \(requestParam.queryParams)\n"
                    code += "\(indt(2))}\n"
                }
                
                if !requestParam.pathParams.isEmpty {
                    code += "\(indt(2))public var pathParams: [String: String] {\n"
                    code += "\(indt(3))return \(requestParam.pathParams)\n"
                    code += "\(indt(2))}\n"
                }
                
                for member in type.members {
                    if let comment = shapeDoc[shape.name]?[member.name], !comment.isEmpty {
                        code += "\(indt(2))/// \(comment)\n"
                    }
                    code += "\(indt(2))public \(member.toSwiftMutableMemberSyntax())\n"
                }
                code += "\n"
                code += "\(indt(2))public init() {}\n\n"
                if type.members.count > 0 {
                    code += "\(indt(2))public init(\(type.members.toSwiftArgumentSyntax())) {\n"
                    for member in type.members {
                        code += "\(indt(3))self.\(member.name.toSwiftVariableCase()) = \(member.name.toSwiftVariableCase())\n"
                    }
                    code += "\(indt(2))}\n\n"
                }
                code += "\(indt(1))}"
                
                code += "\n\n"
                
            default:
                continue
            }
        }
        
        code += "}"
        
        return code
    }
}


extension Collection where Iterator.Element == Member {
    public func toSwiftArgumentSyntax() -> String {
        return self.map({ $0.toSwiftArgumentSyntax() }).joined(separator: ", ")
    }
}


extension ShapeType {
    public func toSwiftType() -> String {
        switch self {
        case .string(_):
            return "String"
            
        case .integer(_):
            return "Int32"
            
        case .structure(_):
            return "Any" // TODO shouldn't be matched here
            
        case .boolean:
            return "Bool"
            
        case .list(let shape):
            return "[\(shape.swiftTypeName)]"
            
        case .map(key: let keyShape, value: let valueShape):
            return "[\(keyShape.swiftTypeName): \(valueShape.swiftTypeName)]"
            
        case .long(_):
            return "Int64"
            
        case .double(_):
            return "Double"
            
        case .float(_):
            return "Float"
            
        case .blob:
            return "Data"
            
        case .timestamp:
            return "Date"
            
        case .unhandledType:
            return "Any"
        }
    }
}

extension Shape {
    public var swiftTypeName: String {
        if isNotSwiftDefinedType() {
            return name.toSwiftClassCase()
        }
        
        return type.toSwiftType()
    }
    
    public func isNotSwiftDefinedType() -> Bool {
        switch type {
        case .structure(_):
            return true
        default:
            return false
        }
    }
    
    public func isException() -> Bool {
        if Array(name.utf8).count < 9 {
            return false
        }
        let suffix = name.substring(from: name.index(name.endIndex, offsetBy: -9))
        return suffix == "Exception"
    }
}

extension Member {
    public var swiftTypeName: String {
        return shape.swiftTypeName
    }
}




