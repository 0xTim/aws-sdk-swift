// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Directconnect {

    public struct CreateLagRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "location", required: true, type: .string), 
            AWSShapeMember(label: "connectionsBandwidth", required: true, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string), 
            AWSShapeMember(label: "numberOfConnections", required: true, type: .integer), 
            AWSShapeMember(label: "lagName", required: true, type: .string)
        ]
        /// The AWS Direct Connect location in which the LAG should be allocated. Example: EqSV5 Default: None
        public let location: String
        /// The bandwidth of the individual physical connections bundled by the LAG. Default: None Available values: 1Gbps, 10Gbps
        public let connectionsBandwidth: String
        /// The ID of an existing connection to migrate to the LAG. Default: None
        public let connectionId: String?
        /// The number of physical connections initially provisioned and bundled by the LAG. Default: None
        public let numberOfConnections: Int32
        /// The name of the LAG. Example: "3x10G LAG to AWS" Default: None
        public let lagName: String

        public init(location: String, connectionsBandwidth: String, connectionId: String? = nil, numberOfConnections: Int32, lagName: String) {
            self.location = location
            self.connectionsBandwidth = connectionsBandwidth
            self.connectionId = connectionId
            self.numberOfConnections = numberOfConnections
            self.lagName = lagName
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case connectionsBandwidth = "connectionsBandwidth"
            case connectionId = "connectionId"
            case numberOfConnections = "numberOfConnections"
            case lagName = "lagName"
        }
    }

    public struct CreateDirectConnectGatewayAssociationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayId", required: true, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: true, type: .string)
        ]
        /// The ID of the direct connect gateway. Example: "abcd1234-dcba-5678-be23-cdef9876ab45" Default: None
        public let directConnectGatewayId: String
        /// The ID of the virtual private gateway. Example: "vgw-abc123ef" Default: None
        public let virtualGatewayId: String

        public init(directConnectGatewayId: String, virtualGatewayId: String) {
            self.directConnectGatewayId = directConnectGatewayId
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayId = "directConnectGatewayId"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

    public struct DescribeTagsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceTags", required: false, type: .list)
        ]
        /// Information about the tags.
        public let resourceTags: [ResourceTag]?

        public init(resourceTags: [ResourceTag]? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "resourceTags"
        }
    }

    public struct VirtualGateways: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGateways", required: false, type: .list)
        ]
        /// A list of virtual private gateways.
        public let virtualGateways: [VirtualGateway]?

        public init(virtualGateways: [VirtualGateway]? = nil) {
            self.virtualGateways = virtualGateways
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateways = "virtualGateways"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the Direct Connect resource. Example: arn:aws:directconnect:us-east-1:123456789012:dxcon/dxcon-fg5678gh
        public let resourceArn: String
        /// The list of tags to add.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct AllocateHostedConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ownerAccount", required: true, type: .string), 
            AWSShapeMember(label: "connectionName", required: true, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "vlan", required: true, type: .integer), 
            AWSShapeMember(label: "bandwidth", required: true, type: .string)
        ]
        /// The numeric account ID of the customer for whom the connection will be provisioned. Example: 123443215678 Default: None
        public let ownerAccount: String
        /// The name of the provisioned connection. Example: "500M Connection to AWS" Default: None
        public let connectionName: String
        /// The ID of the interconnect or LAG on which the connection will be provisioned. Example: dxcon-456abc78 or dxlag-abc123 Default: None
        public let connectionId: String
        /// The dedicated VLAN provisioned to the hosted connection. Example: 101 Default: None
        public let vlan: Int32
        /// The bandwidth of the connection. Example: 500Mbps  Default: None Values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps
        public let bandwidth: String

        public init(ownerAccount: String, connectionName: String, connectionId: String, vlan: Int32, bandwidth: String) {
            self.ownerAccount = ownerAccount
            self.connectionName = connectionName
            self.connectionId = connectionId
            self.vlan = vlan
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case ownerAccount = "ownerAccount"
            case connectionName = "connectionName"
            case connectionId = "connectionId"
            case vlan = "vlan"
            case bandwidth = "bandwidth"
        }
    }

    public struct DeleteDirectConnectGatewayAssociationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayId", required: true, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: true, type: .string)
        ]
        /// The ID of the direct connect gateway. Example: "abcd1234-dcba-5678-be23-cdef9876ab45" Default: None
        public let directConnectGatewayId: String
        /// The ID of the virtual private gateway. Example: "vgw-abc123ef" Default: None
        public let virtualGatewayId: String

        public init(directConnectGatewayId: String, virtualGatewayId: String) {
            self.directConnectGatewayId = directConnectGatewayId
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayId = "directConnectGatewayId"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

    public struct Lag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connections", required: false, type: .list), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "lagState", required: false, type: .enum), 
            AWSShapeMember(label: "awsDevice", required: false, type: .string), 
            AWSShapeMember(label: "numberOfConnections", required: false, type: .integer), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "minimumLinks", required: false, type: .integer), 
            AWSShapeMember(label: "allowsHostedConnections", required: false, type: .boolean), 
            AWSShapeMember(label: "connectionsBandwidth", required: false, type: .string), 
            AWSShapeMember(label: "lagName", required: false, type: .string)
        ]
        /// A list of connections bundled by this LAG.
        public let connections: [Connection]?
        public let location: String?
        public let lagId: String?
        public let lagState: LagState?
        /// The AWS Direct Connection endpoint that hosts the LAG.
        public let awsDevice: String?
        /// The number of physical connections bundled by the LAG, up to a maximum of 10.
        public let numberOfConnections: Int32?
        /// The owner of the LAG.
        public let ownerAccount: String?
        public let region: String?
        /// The minimum number of physical connections that must be operational for the LAG itself to be operational. If the number of operational connections drops below this setting, the LAG state changes to down. This value can help to ensure that a LAG is not overutilized if a significant number of its bundled connections go down.
        public let minimumLinks: Int32?
        /// Indicates whether the LAG can host other connections.  This is intended for use by AWS Direct Connect partners only. 
        public let allowsHostedConnections: Bool?
        /// The individual bandwidth of the physical connections bundled by the LAG. Available values: 1Gbps, 10Gbps
        public let connectionsBandwidth: String?
        /// The name of the LAG.
        public let lagName: String?

        public init(connections: [Connection]? = nil, location: String? = nil, lagId: String? = nil, lagState: LagState? = nil, awsDevice: String? = nil, numberOfConnections: Int32? = nil, ownerAccount: String? = nil, region: String? = nil, minimumLinks: Int32? = nil, allowsHostedConnections: Bool? = nil, connectionsBandwidth: String? = nil, lagName: String? = nil) {
            self.connections = connections
            self.location = location
            self.lagId = lagId
            self.lagState = lagState
            self.awsDevice = awsDevice
            self.numberOfConnections = numberOfConnections
            self.ownerAccount = ownerAccount
            self.region = region
            self.minimumLinks = minimumLinks
            self.allowsHostedConnections = allowsHostedConnections
            self.connectionsBandwidth = connectionsBandwidth
            self.lagName = lagName
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "connections"
            case location = "location"
            case lagId = "lagId"
            case lagState = "lagState"
            case awsDevice = "awsDevice"
            case numberOfConnections = "numberOfConnections"
            case ownerAccount = "ownerAccount"
            case region = "region"
            case minimumLinks = "minimumLinks"
            case allowsHostedConnections = "allowsHostedConnections"
            case connectionsBandwidth = "connectionsBandwidth"
            case lagName = "lagName"
        }
    }

    public struct DeleteVirtualInterfaceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum)
        ]
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceState = "virtualInterfaceState"
        }
    }

    public struct AssociateVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        /// The ID of the virtual interface. Example: dxvif-123dfg56 Default: None
        public let virtualInterfaceId: String
        /// The ID of the LAG or connection with which to associate the virtual interface. Example: dxlag-abc123 or dxcon-abc123 Default: None
        public let connectionId: String

        public init(virtualInterfaceId: String, connectionId: String) {
            self.virtualInterfaceId = virtualInterfaceId
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case connectionId = "connectionId"
        }
    }

    public enum BGPPeerState: String, CustomStringConvertible, Codable {
        case verifying = "verifying"
        case pending = "pending"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct CreateBGPPeerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterface", required: false, type: .structure)
        ]
        public let virtualInterface: VirtualInterface?

        public init(virtualInterface: VirtualInterface? = nil) {
            self.virtualInterface = virtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterface = "virtualInterface"
        }
    }

    public struct DeleteDirectConnectGatewayAssociationResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayAssociation", required: false, type: .structure)
        ]
        /// The direct connect gateway association to be deleted.
        public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?

        public init(directConnectGatewayAssociation: DirectConnectGatewayAssociation? = nil) {
            self.directConnectGatewayAssociation = directConnectGatewayAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAssociation = "directConnectGatewayAssociation"
        }
    }

    public struct DescribeLagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "lagId", required: false, type: .string)
        ]
        /// The ID of the LAG. Example: dxlag-abc123 Default: None
        public let lagId: String?

        public init(lagId: String? = nil) {
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case lagId = "lagId"
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArns", required: true, type: .list)
        ]
        /// The Amazon Resource Names (ARNs) of the Direct Connect resources.
        public let resourceArns: [String]

        public init(resourceArns: [String]) {
            self.resourceArns = resourceArns
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArns = "resourceArns"
        }
    }

    public struct DescribeConnectionLoaResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "loa", required: false, type: .structure)
        ]
        public let loa: Loa?

        public init(loa: Loa? = nil) {
            self.loa = loa
        }

        private enum CodingKeys: String, CodingKey {
            case loa = "loa"
        }
    }

    public enum LagState: String, CustomStringConvertible, Codable {
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct NewPublicVirtualInterfaceAllocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "routeFilterPrefixes", required: false, type: .list), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case routeFilterPrefixes = "routeFilterPrefixes"
            case vlan = "vlan"
        }
    }

    public enum InterconnectState: String, CustomStringConvertible, Codable {
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct CreatePrivateVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "newPrivateVirtualInterface", required: true, type: .structure)
        ]
        public let connectionId: String
        /// Detailed information for the private virtual interface to be created. Default: None
        public let newPrivateVirtualInterface: NewPrivateVirtualInterface

        public init(connectionId: String, newPrivateVirtualInterface: NewPrivateVirtualInterface) {
            self.connectionId = connectionId
            self.newPrivateVirtualInterface = newPrivateVirtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case newPrivateVirtualInterface = "newPrivateVirtualInterface"
        }
    }

    public struct AssociateHostedConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "parentConnectionId", required: true, type: .string)
        ]
        /// The ID of the hosted connection. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the interconnect or the LAG. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let parentConnectionId: String

        public init(connectionId: String, parentConnectionId: String) {
            self.connectionId = connectionId
            self.parentConnectionId = parentConnectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case parentConnectionId = "parentConnectionId"
        }
    }

    public struct DeleteInterconnectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectId", required: true, type: .string)
        ]
        public let interconnectId: String

        public init(interconnectId: String) {
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectId = "interconnectId"
        }
    }

    public struct DescribeInterconnectLoaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "providerName", required: false, type: .string), 
            AWSShapeMember(label: "loaContentType", required: false, type: .enum), 
            AWSShapeMember(label: "interconnectId", required: true, type: .string)
        ]
        /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        public let loaContentType: LoaContentType?
        public let interconnectId: String

        public init(providerName: String? = nil, loaContentType: LoaContentType? = nil, interconnectId: String) {
            self.providerName = providerName
            self.loaContentType = loaContentType
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case loaContentType = "loaContentType"
            case interconnectId = "interconnectId"
        }
    }

    public struct AllocatePrivateVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "newPrivateVirtualInterfaceAllocation", required: true, type: .structure), 
            AWSShapeMember(label: "ownerAccount", required: true, type: .string)
        ]
        /// The connection ID on which the private virtual interface is provisioned. Default: None
        public let connectionId: String
        /// Detailed information for the private virtual interface to be provisioned. Default: None
        public let newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation
        /// The AWS account that will own the new private virtual interface. Default: None
        public let ownerAccount: String

        public init(connectionId: String, newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation, ownerAccount: String) {
            self.connectionId = connectionId
            self.newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case newPrivateVirtualInterfaceAllocation = "newPrivateVirtualInterfaceAllocation"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct DeleteLagRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "lagId", required: true, type: .string)
        ]
        /// The ID of the LAG to delete. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(lagId: String) {
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case lagId = "lagId"
        }
    }

    public struct NewPrivateVirtualInterface: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let directConnectGatewayId: String?
        public let addressFamily: AddressFamily?
        public let virtualGatewayId: String?
        public let asn: Int32
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, directConnectGatewayId: String? = nil, addressFamily: AddressFamily? = nil, virtualGatewayId: String? = nil, asn: Int32, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.directConnectGatewayId = directConnectGatewayId
            self.addressFamily = addressFamily
            self.virtualGatewayId = virtualGatewayId
            self.asn = asn
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case directConnectGatewayId = "directConnectGatewayId"
            case addressFamily = "addressFamily"
            case virtualGatewayId = "virtualGatewayId"
            case asn = "asn"
            case vlan = "vlan"
        }
    }

    public struct NewPublicVirtualInterface: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "routeFilterPrefixes", required: false, type: .list), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case routeFilterPrefixes = "routeFilterPrefixes"
            case vlan = "vlan"
        }
    }

    public struct UpdateLagRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "minimumLinks", required: false, type: .integer), 
            AWSShapeMember(label: "lagId", required: true, type: .string), 
            AWSShapeMember(label: "lagName", required: false, type: .string)
        ]
        /// The minimum number of physical connections that must be operational for the LAG itself to be operational. Default: None
        public let minimumLinks: Int32?
        /// The ID of the LAG to update. Example: dxlag-abc123 Default: None
        public let lagId: String
        /// The name for the LAG. Example: "3x10G LAG to AWS" Default: None
        public let lagName: String?

        public init(minimumLinks: Int32? = nil, lagId: String, lagName: String? = nil) {
            self.minimumLinks = minimumLinks
            self.lagId = lagId
            self.lagName = lagName
        }

        private enum CodingKeys: String, CodingKey {
            case minimumLinks = "minimumLinks"
            case lagId = "lagId"
            case lagName = "lagName"
        }
    }

    public struct Interconnects: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnects", required: false, type: .list)
        ]
        /// A list of interconnects.
        public let interconnects: [Interconnect]?

        public init(interconnects: [Interconnect]? = nil) {
            self.interconnects = interconnects
        }

        private enum CodingKeys: String, CodingKey {
            case interconnects = "interconnects"
        }
    }

    public struct DeleteDirectConnectGatewayRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayId", required: true, type: .string)
        ]
        /// The ID of the direct connect gateway. Example: "abcd1234-dcba-5678-be23-cdef9876ab45" Default: None
        public let directConnectGatewayId: String

        public init(directConnectGatewayId: String) {
            self.directConnectGatewayId = directConnectGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayId = "directConnectGatewayId"
        }
    }

    public struct NewPrivateVirtualInterfaceAllocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case vlan = "vlan"
        }
    }

    public struct DeleteConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct CreatePublicVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "newPublicVirtualInterface", required: true, type: .structure)
        ]
        public let connectionId: String
        /// Detailed information for the public virtual interface to be created. Default: None
        public let newPublicVirtualInterface: NewPublicVirtualInterface

        public init(connectionId: String, newPublicVirtualInterface: NewPublicVirtualInterface) {
            self.connectionId = connectionId
            self.newPublicVirtualInterface = newPublicVirtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case newPublicVirtualInterface = "newPublicVirtualInterface"
        }
    }

    public struct DescribeInterconnectsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectId", required: false, type: .string)
        ]
        public let interconnectId: String?

        public init(interconnectId: String? = nil) {
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectId = "interconnectId"
        }
    }

    public enum VirtualInterfaceState: String, CustomStringConvertible, Codable {
        case confirming = "confirming"
        case verifying = "verifying"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        case rejected = "rejected"
        public var description: String { return self.rawValue }
    }

    public struct DescribeHostedConnectionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        /// The ID of the interconnect or LAG on which the hosted connections are provisioned. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct ResourceTag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the Direct Connect resource.
        public let resourceArn: String?
        /// The tags.
        public let tags: [Tag]?

        public init(resourceArn: String? = nil, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct AssociateConnectionWithLagRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: true, type: .string)
        ]
        /// The ID of the connection. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the LAG with which to associate the connection. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(connectionId: String, lagId: String) {
            self.connectionId = connectionId
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case lagId = "lagId"
        }
    }

    public struct ConfirmConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public enum AddressFamily: String, CustomStringConvertible, Codable {
        case ipv4 = "ipv4"
        case ipv6 = "ipv6"
        public var description: String { return self.rawValue }
    }

    public struct AllocatePublicVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "newPublicVirtualInterfaceAllocation", required: true, type: .structure), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "ownerAccount", required: true, type: .string)
        ]
        /// Detailed information for the public virtual interface to be provisioned. Default: None
        public let newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation
        /// The connection ID on which the public virtual interface is provisioned. Default: None
        public let connectionId: String
        /// The AWS account that will own the new public virtual interface. Default: None
        public let ownerAccount: String

        public init(newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation, connectionId: String, ownerAccount: String) {
            self.newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation
            self.connectionId = connectionId
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case newPublicVirtualInterfaceAllocation = "newPublicVirtualInterfaceAllocation"
            case connectionId = "connectionId"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct ConfirmPublicVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string)
        ]
        public let virtualInterfaceId: String

        public init(virtualInterfaceId: String) {
            self.virtualInterfaceId = virtualInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
        }
    }

    public struct DescribeDirectConnectGatewayAssociationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The ID of the direct connect gateway. Example: "abcd1234-dcba-5678-be23-cdef9876ab45" Default: None
        public let directConnectGatewayId: String?
        /// The ID of the virtual private gateway. Example: "vgw-abc123ef" Default: None
        public let virtualGatewayId: String?
        /// The maximum number of direct connect gateway associations to return per page. Example: 15 Default: None
        public let maxResults: Int32?
        /// The token provided in the previous describe result to retrieve the next page of the result. Default: None
        public let nextToken: String?

        public init(directConnectGatewayId: String? = nil, virtualGatewayId: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.directConnectGatewayId = directConnectGatewayId
            self.virtualGatewayId = virtualGatewayId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayId = "directConnectGatewayId"
            case virtualGatewayId = "virtualGatewayId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeDirectConnectGatewaysRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// The ID of the direct connect gateway. Example: "abcd1234-dcba-5678-be23-cdef9876ab45" Default: None
        public let directConnectGatewayId: String?
        /// The token provided in the previous describe result to retrieve the next page of the result. Default: None
        public let nextToken: String?
        /// The maximum number of direct connect gateways to return per page. Example: 15 Default: None
        public let maxResults: Int32?

        public init(directConnectGatewayId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.directConnectGatewayId = directConnectGatewayId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayId = "directConnectGatewayId"
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public struct CreateInterconnectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "location", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "interconnectName", required: true, type: .string), 
            AWSShapeMember(label: "bandwidth", required: true, type: .string)
        ]
        /// Where the interconnect is located Example: EqSV5 Default: None
        public let location: String
        public let lagId: String?
        /// The name of the interconnect. Example: "1G Interconnect to AWS" Default: None
        public let interconnectName: String
        /// The port bandwidth Example: 1Gbps Default: None Available values: 1Gbps,10Gbps
        public let bandwidth: String

        public init(location: String, lagId: String? = nil, interconnectName: String, bandwidth: String) {
            self.location = location
            self.lagId = lagId
            self.interconnectName = interconnectName
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case lagId = "lagId"
            case interconnectName = "interconnectName"
            case bandwidth = "bandwidth"
        }
    }

    public struct Connections: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connections", required: false, type: .list)
        ]
        /// A list of connections.
        public let connections: [Connection]?

        public init(connections: [Connection]? = nil) {
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "connections"
        }
    }

    public struct DescribeDirectConnectGatewayAttachmentsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayAttachments", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the direct connect gateway attachments.
        public let directConnectGatewayAttachments: [DirectConnectGatewayAttachment]?
        public let nextToken: String?

        public init(directConnectGatewayAttachments: [DirectConnectGatewayAttachment]? = nil, nextToken: String? = nil) {
            self.directConnectGatewayAttachments = directConnectGatewayAttachments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAttachments = "directConnectGatewayAttachments"
            case nextToken = "nextToken"
        }
    }

    public struct DirectConnectGatewayAttachment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceOwnerAccount", required: false, type: .string), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "attachmentState", required: false, type: .enum), 
            AWSShapeMember(label: "virtualInterfaceRegion", required: false, type: .string), 
            AWSShapeMember(label: "stateChangeError", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string)
        ]
        /// The AWS account ID of the owner of the virtual interface.
        public let virtualInterfaceOwnerAccount: String?
        public let directConnectGatewayId: String?
        public let attachmentState: DirectConnectGatewayAttachmentState?
        public let virtualInterfaceRegion: String?
        public let stateChangeError: String?
        public let virtualInterfaceId: String?

        public init(virtualInterfaceOwnerAccount: String? = nil, directConnectGatewayId: String? = nil, attachmentState: DirectConnectGatewayAttachmentState? = nil, virtualInterfaceRegion: String? = nil, stateChangeError: String? = nil, virtualInterfaceId: String? = nil) {
            self.virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccount
            self.directConnectGatewayId = directConnectGatewayId
            self.attachmentState = attachmentState
            self.virtualInterfaceRegion = virtualInterfaceRegion
            self.stateChangeError = stateChangeError
            self.virtualInterfaceId = virtualInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceOwnerAccount = "virtualInterfaceOwnerAccount"
            case directConnectGatewayId = "directConnectGatewayId"
            case attachmentState = "attachmentState"
            case virtualInterfaceRegion = "virtualInterfaceRegion"
            case stateChangeError = "stateChangeError"
            case virtualInterfaceId = "virtualInterfaceId"
        }
    }

    public enum DirectConnectGatewayAttachmentState: String, CustomStringConvertible, Codable {
        case attaching = "attaching"
        case attached = "attached"
        case detaching = "detaching"
        case detached = "detached"
        public var description: String { return self.rawValue }
    }

    public struct DescribeInterconnectLoaResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "loa", required: false, type: .structure)
        ]
        public let loa: Loa?

        public init(loa: Loa? = nil) {
            self.loa = loa
        }

        private enum CodingKeys: String, CodingKey {
            case loa = "loa"
        }
    }

    public struct CreateDirectConnectGatewayAssociationResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayAssociation", required: false, type: .structure)
        ]
        /// The direct connect gateway association to be created.
        public let directConnectGatewayAssociation: DirectConnectGatewayAssociation?

        public init(directConnectGatewayAssociation: DirectConnectGatewayAssociation? = nil) {
            self.directConnectGatewayAssociation = directConnectGatewayAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAssociation = "directConnectGatewayAssociation"
        }
    }

    public struct CreateDirectConnectGatewayRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayName", required: true, type: .string), 
            AWSShapeMember(label: "amazonSideAsn", required: false, type: .long)
        ]
        /// The name of the direct connect gateway. Example: "My direct connect gateway" Default: None
        public let directConnectGatewayName: String
        /// The autonomous system number (ASN) for Border Gateway Protocol (BGP) to be configured on the Amazon side of the connection. The ASN must be in the private range of 64,512 to 65,534 or 4,200,000,000 to 4,294,967,294  Example: 65200 Default: 64512
        public let amazonSideAsn: Int64?

        public init(directConnectGatewayName: String, amazonSideAsn: Int64? = nil) {
            self.directConnectGatewayName = directConnectGatewayName
            self.amazonSideAsn = amazonSideAsn
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayName = "directConnectGatewayName"
            case amazonSideAsn = "amazonSideAsn"
        }
    }

    public struct Connection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "loaIssueTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "bandwidth", required: false, type: .string), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "awsDevice", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string), 
            AWSShapeMember(label: "connectionState", required: false, type: .enum), 
            AWSShapeMember(label: "connectionName", required: false, type: .string), 
            AWSShapeMember(label: "vlan", required: false, type: .integer), 
            AWSShapeMember(label: "partnerName", required: false, type: .string)
        ]
        /// The time of the most recent call to DescribeLoa for this connection.
        public let loaIssueTime: TimeStamp?
        /// Bandwidth of the connection. Example: 1Gbps (for regular connections), or 500Mbps (for hosted connections) Default: None
        public let bandwidth: String?
        public let location: String?
        public let lagId: String?
        /// The Direct Connection endpoint which the physical connection terminates on.
        public let awsDevice: String?
        public let connectionId: String?
        public let region: String?
        /// The AWS account that will own the new connection.
        public let ownerAccount: String?
        public let connectionState: ConnectionState?
        public let connectionName: String?
        public let vlan: Int32?
        /// The name of the AWS Direct Connect service provider associated with the connection.
        public let partnerName: String?

        public init(loaIssueTime: TimeStamp? = nil, bandwidth: String? = nil, location: String? = nil, lagId: String? = nil, awsDevice: String? = nil, connectionId: String? = nil, region: String? = nil, ownerAccount: String? = nil, connectionState: ConnectionState? = nil, connectionName: String? = nil, vlan: Int32? = nil, partnerName: String? = nil) {
            self.loaIssueTime = loaIssueTime
            self.bandwidth = bandwidth
            self.location = location
            self.lagId = lagId
            self.awsDevice = awsDevice
            self.connectionId = connectionId
            self.region = region
            self.ownerAccount = ownerAccount
            self.connectionState = connectionState
            self.connectionName = connectionName
            self.vlan = vlan
            self.partnerName = partnerName
        }

        private enum CodingKeys: String, CodingKey {
            case loaIssueTime = "loaIssueTime"
            case bandwidth = "bandwidth"
            case location = "location"
            case lagId = "lagId"
            case awsDevice = "awsDevice"
            case connectionId = "connectionId"
            case region = "region"
            case ownerAccount = "ownerAccount"
            case connectionState = "connectionState"
            case connectionName = "connectionName"
            case vlan = "vlan"
            case partnerName = "partnerName"
        }
    }

    public struct DescribeConnectionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: false, type: .string)
        ]
        public let connectionId: String?

        public init(connectionId: String? = nil) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct DescribeDirectConnectGatewayAssociationsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayAssociations", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the direct connect gateway associations.
        public let directConnectGatewayAssociations: [DirectConnectGatewayAssociation]?
        public let nextToken: String?

        public init(directConnectGatewayAssociations: [DirectConnectGatewayAssociation]? = nil, nextToken: String? = nil) {
            self.directConnectGatewayAssociations = directConnectGatewayAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAssociations = "directConnectGatewayAssociations"
            case nextToken = "nextToken"
        }
    }

    public struct Lags: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "lags", required: false, type: .list)
        ]
        /// A list of LAGs.
        public let lags: [Lag]?

        public init(lags: [Lag]? = nil) {
            self.lags = lags
        }

        private enum CodingKeys: String, CodingKey {
            case lags = "lags"
        }
    }

    public struct DeleteInterconnectResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectState", required: false, type: .enum)
        ]
        public let interconnectState: InterconnectState?

        public init(interconnectState: InterconnectState? = nil) {
            self.interconnectState = interconnectState
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectState = "interconnectState"
        }
    }

    public struct ConfirmPrivateVirtualInterfaceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum)
        ]
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceState = "virtualInterfaceState"
        }
    }

    public struct TagResourceResponse: AWSShape {

    }

    public enum ConnectionState: String, CustomStringConvertible, Codable {
        case ordering = "ordering"
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        case rejected = "rejected"
        public var description: String { return self.rawValue }
    }

    public struct BGPPeer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bgpPeerState", required: false, type: .enum), 
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "bgpStatus", required: false, type: .enum), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum)
        ]
        public let bgpPeerState: BGPPeerState?
        public let customerAddress: String?
        public let bgpStatus: BGPStatus?
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32?
        public let addressFamily: AddressFamily?

        public init(bgpPeerState: BGPPeerState? = nil, customerAddress: String? = nil, bgpStatus: BGPStatus? = nil, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32? = nil, addressFamily: AddressFamily? = nil) {
            self.bgpPeerState = bgpPeerState
            self.customerAddress = customerAddress
            self.bgpStatus = bgpStatus
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
        }

        private enum CodingKeys: String, CodingKey {
            case bgpPeerState = "bgpPeerState"
            case customerAddress = "customerAddress"
            case bgpStatus = "bgpStatus"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
        }
    }

    public struct DisassociateConnectionFromLagRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: true, type: .string)
        ]
        /// The ID of the connection to disassociate from the LAG. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the LAG. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(connectionId: String, lagId: String) {
            self.connectionId = connectionId
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case lagId = "lagId"
        }
    }

    public struct DescribeDirectConnectGatewaysResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGateways", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Information about the direct connect gateways.
        public let directConnectGateways: [DirectConnectGateway]?
        public let nextToken: String?

        public init(directConnectGateways: [DirectConnectGateway]? = nil, nextToken: String? = nil) {
            self.directConnectGateways = directConnectGateways
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGateways = "directConnectGateways"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeVirtualInterfacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string)
        ]
        public let virtualInterfaceId: String?
        public let connectionId: String?

        public init(virtualInterfaceId: String? = nil, connectionId: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case connectionId = "connectionId"
        }
    }

    public struct CreateBGPPeerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "newBGPPeer", required: false, type: .structure)
        ]
        /// The ID of the virtual interface on which the BGP peer will be provisioned. Example: dxvif-456abc78 Default: None
        public let virtualInterfaceId: String?
        /// Detailed information for the BGP peer to be created. Default: None
        public let newBGPPeer: NewBGPPeer?

        public init(virtualInterfaceId: String? = nil, newBGPPeer: NewBGPPeer? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.newBGPPeer = newBGPPeer
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case newBGPPeer = "newBGPPeer"
        }
    }

    public struct DeleteBGPPeerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterface", required: false, type: .structure)
        ]
        public let virtualInterface: VirtualInterface?

        public init(virtualInterface: VirtualInterface? = nil) {
            self.virtualInterface = virtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterface = "virtualInterface"
        }
    }

    public struct DescribeLoaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "providerName", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "loaContentType", required: false, type: .enum)
        ]
        /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        /// The ID of a connection, LAG, or interconnect for which to get the LOA-CFA information. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let connectionId: String
        /// A standard media type indicating the content type of the LOA-CFA document. Currently, the only supported value is "application/pdf". Default: application/pdf
        public let loaContentType: LoaContentType?

        public init(providerName: String? = nil, connectionId: String, loaContentType: LoaContentType? = nil) {
            self.providerName = providerName
            self.connectionId = connectionId
            self.loaContentType = loaContentType
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case connectionId = "connectionId"
            case loaContentType = "loaContentType"
        }
    }

    public struct DeleteBGPPeerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "customerAddress", required: false, type: .string)
        ]
        /// The ID of the virtual interface from which the BGP peer will be deleted. Example: dxvif-456abc78 Default: None
        public let virtualInterfaceId: String?
        public let asn: Int32?
        public let customerAddress: String?

        public init(virtualInterfaceId: String? = nil, asn: Int32? = nil, customerAddress: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.asn = asn
            self.customerAddress = customerAddress
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case asn = "asn"
            case customerAddress = "customerAddress"
        }
    }

    public struct Interconnect: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "loaIssueTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "interconnectState", required: false, type: .enum), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "awsDevice", required: false, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "interconnectName", required: false, type: .string), 
            AWSShapeMember(label: "interconnectId", required: false, type: .string), 
            AWSShapeMember(label: "bandwidth", required: false, type: .string)
        ]
        /// The time of the most recent call to DescribeInterconnectLoa for this Interconnect.
        public let loaIssueTime: TimeStamp?
        public let interconnectState: InterconnectState?
        public let location: String?
        /// The Direct Connection endpoint which the physical connection terminates on.
        public let awsDevice: String?
        public let lagId: String?
        public let region: String?
        public let interconnectName: String?
        public let interconnectId: String?
        public let bandwidth: String?

        public init(loaIssueTime: TimeStamp? = nil, interconnectState: InterconnectState? = nil, location: String? = nil, awsDevice: String? = nil, lagId: String? = nil, region: String? = nil, interconnectName: String? = nil, interconnectId: String? = nil, bandwidth: String? = nil) {
            self.loaIssueTime = loaIssueTime
            self.interconnectState = interconnectState
            self.location = location
            self.awsDevice = awsDevice
            self.lagId = lagId
            self.region = region
            self.interconnectName = interconnectName
            self.interconnectId = interconnectId
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case loaIssueTime = "loaIssueTime"
            case interconnectState = "interconnectState"
            case location = "location"
            case awsDevice = "awsDevice"
            case lagId = "lagId"
            case region = "region"
            case interconnectName = "interconnectName"
            case interconnectId = "interconnectId"
            case bandwidth = "bandwidth"
        }
    }

    public struct AllocateConnectionOnInterconnectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bandwidth", required: true, type: .string), 
            AWSShapeMember(label: "connectionName", required: true, type: .string), 
            AWSShapeMember(label: "interconnectId", required: true, type: .string), 
            AWSShapeMember(label: "vlan", required: true, type: .integer), 
            AWSShapeMember(label: "ownerAccount", required: true, type: .string)
        ]
        /// Bandwidth of the connection. Example: "500Mbps" Default: None Values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps
        public let bandwidth: String
        /// Name of the provisioned connection. Example: "500M Connection to AWS" Default: None
        public let connectionName: String
        /// ID of the interconnect on which the connection will be provisioned. Example: dxcon-456abc78 Default: None
        public let interconnectId: String
        /// The dedicated VLAN provisioned to the connection. Example: 101 Default: None
        public let vlan: Int32
        /// Numeric account Id of the customer for whom the connection will be provisioned. Example: 123443215678 Default: None
        public let ownerAccount: String

        public init(bandwidth: String, connectionName: String, interconnectId: String, vlan: Int32, ownerAccount: String) {
            self.bandwidth = bandwidth
            self.connectionName = connectionName
            self.interconnectId = interconnectId
            self.vlan = vlan
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "bandwidth"
            case connectionName = "connectionName"
            case interconnectId = "interconnectId"
            case vlan = "vlan"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct DescribeConnectionsOnInterconnectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectId", required: true, type: .string)
        ]
        /// ID of the interconnect on which a list of connection is provisioned. Example: dxcon-abc123 Default: None
        public let interconnectId: String

        public init(interconnectId: String) {
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectId = "interconnectId"
        }
    }

    public enum LoaContentType: String, CustomStringConvertible, Codable {
        case applicationPdf = "application/pdf"
        public var description: String { return self.rawValue }
    }

    public struct VirtualInterfaces: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaces", required: false, type: .list)
        ]
        /// A list of virtual interfaces.
        public let virtualInterfaces: [VirtualInterface]?

        public init(virtualInterfaces: [VirtualInterface]? = nil) {
            self.virtualInterfaces = virtualInterfaces
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaces = "virtualInterfaces"
        }
    }

    public enum BGPStatus: String, CustomStringConvertible, Codable {
        case up = "up"
        case down = "down"
        public var description: String { return self.rawValue }
    }

    public struct DirectConnectGatewayAssociation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGatewayOwnerAccount", required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayRegion", required: false, type: .string), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "stateChangeError", required: false, type: .string), 
            AWSShapeMember(label: "associationState", required: false, type: .enum)
        ]
        /// The AWS account ID of the owner of the virtual private gateway.
        public let virtualGatewayOwnerAccount: String?
        public let virtualGatewayRegion: String?
        public let directConnectGatewayId: String?
        public let virtualGatewayId: String?
        public let stateChangeError: String?
        public let associationState: DirectConnectGatewayAssociationState?

        public init(virtualGatewayOwnerAccount: String? = nil, virtualGatewayRegion: String? = nil, directConnectGatewayId: String? = nil, virtualGatewayId: String? = nil, stateChangeError: String? = nil, associationState: DirectConnectGatewayAssociationState? = nil) {
            self.virtualGatewayOwnerAccount = virtualGatewayOwnerAccount
            self.virtualGatewayRegion = virtualGatewayRegion
            self.directConnectGatewayId = directConnectGatewayId
            self.virtualGatewayId = virtualGatewayId
            self.stateChangeError = stateChangeError
            self.associationState = associationState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGatewayOwnerAccount = "virtualGatewayOwnerAccount"
            case virtualGatewayRegion = "virtualGatewayRegion"
            case directConnectGatewayId = "directConnectGatewayId"
            case virtualGatewayId = "virtualGatewayId"
            case stateChangeError = "stateChangeError"
            case associationState = "associationState"
        }
    }

    public struct UntagResourceResponse: AWSShape {

    }

    public struct Location: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "locationCode", required: false, type: .string), 
            AWSShapeMember(label: "locationName", required: false, type: .string)
        ]
        /// The code used to indicate the AWS Direct Connect location.
        public let locationCode: String?
        /// The name of the AWS Direct Connect location. The name includes the colocation partner name and the physical site of the lit building.
        public let locationName: String?

        public init(locationCode: String? = nil, locationName: String? = nil) {
            self.locationCode = locationCode
            self.locationName = locationName
        }

        private enum CodingKeys: String, CodingKey {
            case locationCode = "locationCode"
            case locationName = "locationName"
        }
    }

    public struct Loa: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "loaContentType", required: false, type: .enum), 
            AWSShapeMember(label: "loaContent", required: false, type: .blob)
        ]
        public let loaContentType: LoaContentType?
        public let loaContent: Data?

        public init(loaContentType: LoaContentType? = nil, loaContent: Data? = nil) {
            self.loaContentType = loaContentType
            self.loaContent = loaContent
        }

        private enum CodingKeys: String, CodingKey {
            case loaContentType = "loaContentType"
            case loaContent = "loaContent"
        }
    }

    public struct VirtualInterface: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceType", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "routeFilterPrefixes", required: false, type: .list), 
            AWSShapeMember(label: "amazonSideAsn", required: false, type: .long), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: false, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "customerRouterConfig", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "bgpPeers", required: false, type: .list), 
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "vlan", required: false, type: .integer), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string)
        ]
        public let customerAddress: String?
        public let virtualInterfaceType: String?
        public let connectionId: String?
        /// The AWS account that will own the new virtual interface.
        public let ownerAccount: String?
        public let asn: Int32?
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        /// The autonomous system number (ASN) for the Amazon side of the connection.
        public let amazonSideAsn: Int64?
        public let location: String?
        public let virtualInterfaceName: String?
        public let authKey: String?
        public let amazonAddress: String?
        /// Information for generating the customer router configuration.
        public let customerRouterConfig: String?
        public let virtualInterfaceState: VirtualInterfaceState?
        public let directConnectGatewayId: String?
        public let bgpPeers: [BGPPeer]?
        public let virtualInterfaceId: String?
        public let vlan: Int32?
        public let virtualGatewayId: String?

        public init(customerAddress: String? = nil, virtualInterfaceType: String? = nil, connectionId: String? = nil, ownerAccount: String? = nil, asn: Int32? = nil, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, amazonSideAsn: Int64? = nil, location: String? = nil, virtualInterfaceName: String? = nil, authKey: String? = nil, amazonAddress: String? = nil, customerRouterConfig: String? = nil, virtualInterfaceState: VirtualInterfaceState? = nil, directConnectGatewayId: String? = nil, bgpPeers: [BGPPeer]? = nil, virtualInterfaceId: String? = nil, vlan: Int32? = nil, virtualGatewayId: String? = nil) {
            self.customerAddress = customerAddress
            self.virtualInterfaceType = virtualInterfaceType
            self.connectionId = connectionId
            self.ownerAccount = ownerAccount
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.amazonSideAsn = amazonSideAsn
            self.location = location
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.customerRouterConfig = customerRouterConfig
            self.virtualInterfaceState = virtualInterfaceState
            self.directConnectGatewayId = directConnectGatewayId
            self.bgpPeers = bgpPeers
            self.virtualInterfaceId = virtualInterfaceId
            self.vlan = vlan
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceType = "virtualInterfaceType"
            case connectionId = "connectionId"
            case ownerAccount = "ownerAccount"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case routeFilterPrefixes = "routeFilterPrefixes"
            case amazonSideAsn = "amazonSideAsn"
            case location = "location"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case customerRouterConfig = "customerRouterConfig"
            case virtualInterfaceState = "virtualInterfaceState"
            case directConnectGatewayId = "directConnectGatewayId"
            case bgpPeers = "bgpPeers"
            case virtualInterfaceId = "virtualInterfaceId"
            case vlan = "vlan"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

    public struct ConfirmPublicVirtualInterfaceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum)
        ]
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceState = "virtualInterfaceState"
        }
    }

    public struct DirectConnectGateway: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGatewayState", required: false, type: .enum), 
            AWSShapeMember(label: "directConnectGatewayName", required: false, type: .string), 
            AWSShapeMember(label: "stateChangeError", required: false, type: .string), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "amazonSideAsn", required: false, type: .long), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string)
        ]
        public let directConnectGatewayState: DirectConnectGatewayState?
        public let directConnectGatewayName: String?
        public let stateChangeError: String?
        public let directConnectGatewayId: String?
        /// The autonomous system number (ASN) for the Amazon side of the connection.
        public let amazonSideAsn: Int64?
        /// The AWS account ID of the owner of the direct connect gateway.
        public let ownerAccount: String?

        public init(directConnectGatewayState: DirectConnectGatewayState? = nil, directConnectGatewayName: String? = nil, stateChangeError: String? = nil, directConnectGatewayId: String? = nil, amazonSideAsn: Int64? = nil, ownerAccount: String? = nil) {
            self.directConnectGatewayState = directConnectGatewayState
            self.directConnectGatewayName = directConnectGatewayName
            self.stateChangeError = stateChangeError
            self.directConnectGatewayId = directConnectGatewayId
            self.amazonSideAsn = amazonSideAsn
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayState = "directConnectGatewayState"
            case directConnectGatewayName = "directConnectGatewayName"
            case stateChangeError = "stateChangeError"
            case directConnectGatewayId = "directConnectGatewayId"
            case amazonSideAsn = "amazonSideAsn"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct Locations: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "locations", required: false, type: .list)
        ]
        /// A list of colocation hubs where network providers have equipment. Most regions have multiple locations available.
        public let locations: [Location]?

        public init(locations: [Location]? = nil) {
            self.locations = locations
        }

        private enum CodingKeys: String, CodingKey {
            case locations = "locations"
        }
    }

    public struct DeleteDirectConnectGatewayResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGateway", required: false, type: .structure)
        ]
        /// The direct connect gateway to be deleted.
        public let directConnectGateway: DirectConnectGateway?

        public init(directConnectGateway: DirectConnectGateway? = nil) {
            self.directConnectGateway = directConnectGateway
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGateway = "directConnectGateway"
        }
    }

    public struct DescribeConnectionLoaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "providerName", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "loaContentType", required: false, type: .enum)
        ]
        /// The name of the APN partner or service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        public let connectionId: String
        public let loaContentType: LoaContentType?

        public init(providerName: String? = nil, connectionId: String, loaContentType: LoaContentType? = nil) {
            self.providerName = providerName
            self.connectionId = connectionId
            self.loaContentType = loaContentType
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case connectionId = "connectionId"
            case loaContentType = "loaContentType"
        }
    }

    public struct DescribeDirectConnectGatewayAttachmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string)
        ]
        /// The token provided in the previous describe result to retrieve the next page of the result. Default: None
        public let nextToken: String?
        /// The ID of the direct connect gateway. Example: "abcd1234-dcba-5678-be23-cdef9876ab45" Default: None
        public let directConnectGatewayId: String?
        /// The maximum number of direct connect gateway attachments to return per page. Example: 15 Default: None
        public let maxResults: Int32?
        /// The ID of the virtual interface. Example: "dxvif-abc123ef" Default: None
        public let virtualInterfaceId: String?

        public init(nextToken: String? = nil, directConnectGatewayId: String? = nil, maxResults: Int32? = nil, virtualInterfaceId: String? = nil) {
            self.nextToken = nextToken
            self.directConnectGatewayId = directConnectGatewayId
            self.maxResults = maxResults
            self.virtualInterfaceId = virtualInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case directConnectGatewayId = "directConnectGatewayId"
            case maxResults = "maxResults"
            case virtualInterfaceId = "virtualInterfaceId"
        }
    }

    public struct CreateDirectConnectGatewayResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "directConnectGateway", required: false, type: .structure)
        ]
        /// The direct connect gateway to be created.
        public let directConnectGateway: DirectConnectGateway?

        public init(directConnectGateway: DirectConnectGateway? = nil) {
            self.directConnectGateway = directConnectGateway
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGateway = "directConnectGateway"
        }
    }

    public struct ConfirmPrivateVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string), 
            AWSShapeMember(label: "directConnectGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string)
        ]
        public let virtualInterfaceId: String
        /// ID of the direct connect gateway that will be attached to the virtual interface.  A direct connect gateway can be managed via the AWS Direct Connect console or the CreateDirectConnectGateway action. Default: None
        public let directConnectGatewayId: String?
        /// ID of the virtual private gateway that will be attached to the virtual interface.  A virtual private gateway can be managed via the Amazon Virtual Private Cloud (VPC) console or the EC2 CreateVpnGateway action. Default: None
        public let virtualGatewayId: String?

        public init(virtualInterfaceId: String, directConnectGatewayId: String? = nil, virtualGatewayId: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.directConnectGatewayId = directConnectGatewayId
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case directConnectGatewayId = "directConnectGatewayId"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

    public struct CreateConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionName", required: true, type: .string), 
            AWSShapeMember(label: "location", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "bandwidth", required: true, type: .string)
        ]
        public let connectionName: String
        public let location: String
        public let lagId: String?
        public let bandwidth: String

        public init(connectionName: String, location: String, lagId: String? = nil, bandwidth: String) {
            self.connectionName = connectionName
            self.location = location
            self.lagId = lagId
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "connectionName"
            case location = "location"
            case lagId = "lagId"
            case bandwidth = "bandwidth"
        }
    }

    public struct NewBGPPeer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "authKey", required: false, type: .string)
        ]
        public let amazonAddress: String?
        public let customerAddress: String?
        public let addressFamily: AddressFamily?
        public let asn: Int32?
        public let authKey: String?

        public init(amazonAddress: String? = nil, customerAddress: String? = nil, addressFamily: AddressFamily? = nil, asn: Int32? = nil, authKey: String? = nil) {
            self.amazonAddress = amazonAddress
            self.customerAddress = customerAddress
            self.addressFamily = addressFamily
            self.asn = asn
            self.authKey = authKey
        }

        private enum CodingKeys: String, CodingKey {
            case amazonAddress = "amazonAddress"
            case customerAddress = "customerAddress"
            case addressFamily = "addressFamily"
            case asn = "asn"
            case authKey = "authKey"
        }
    }

    public enum DirectConnectGatewayAssociationState: String, CustomStringConvertible, Codable {
        case associating = "associating"
        case associated = "associated"
        case disassociating = "disassociating"
        case disassociated = "disassociated"
        public var description: String { return self.rawValue }
    }

    public struct ConfirmConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionState", required: false, type: .enum)
        ]
        public let connectionState: ConnectionState?

        public init(connectionState: ConnectionState? = nil) {
            self.connectionState = connectionState
        }

        private enum CodingKeys: String, CodingKey {
            case connectionState = "connectionState"
        }
    }

    public struct RouteFilterPrefix: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cidr", required: false, type: .string)
        ]
        /// CIDR notation for the advertised route. Multiple routes are separated by commas. IPv6 CIDRs must be at least a /64 or shorter Example: 10.10.10.0/24,10.10.11.0/24,2001:db8::/64
        public let cidr: String?

        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "cidr"
        }
    }

    public enum DirectConnectGatewayState: String, CustomStringConvertible, Codable {
        case pending = "pending"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct DeleteVirtualInterfaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string)
        ]
        public let virtualInterfaceId: String

        public init(virtualInterfaceId: String) {
            self.virtualInterfaceId = virtualInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the Direct Connect resource.
        public let resourceArn: String
        /// The list of tag keys to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct VirtualGateway: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGatewayState", required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string)
        ]
        public let virtualGatewayState: String?
        public let virtualGatewayId: String?

        public init(virtualGatewayState: String? = nil, virtualGatewayId: String? = nil) {
            self.virtualGatewayState = virtualGatewayState
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGatewayState = "virtualGatewayState"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

}