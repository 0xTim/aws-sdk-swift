// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Directconnect {

    public struct CreateLagRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "location", required: true, type: .string), 
            AWSShapeMember(label: "connectionsBandwidth", required: true, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string), 
            AWSShapeMember(label: "numberOfConnections", required: true, type: .integer), 
            AWSShapeMember(label: "lagName", required: true, type: .string)
        ]
        /// The AWS Direct Connect location in which the LAG should be allocated. Example: EqSV5 Default: None
        public let location: String
        /// The bandwidth of the individual physical connections bundled by the LAG. Default: None Available values: 1Gbps, 10Gbps
        public let connectionsBandwidth: String
        /// The ID of an existing connection to migrate to the LAG. Default: None
        public let connectionId: String?
        /// The number of physical connections initially provisioned and bundled by the LAG. Default: None
        public let numberOfConnections: Int32
        /// The name of the LAG. Example: "3x10G LAG to AWS" Default: None
        public let lagName: String

        public init(location: String, connectionsBandwidth: String, connectionId: String? = nil, numberOfConnections: Int32, lagName: String) {
            self.location = location
            self.connectionsBandwidth = connectionsBandwidth
            self.connectionId = connectionId
            self.numberOfConnections = numberOfConnections
            self.lagName = lagName
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case connectionsBandwidth = "connectionsBandwidth"
            case connectionId = "connectionId"
            case numberOfConnections = "numberOfConnections"
            case lagName = "lagName"
        }
    }

    public struct DescribeTagsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceTags", required: false, type: .list)
        ]
        /// Information about the tags.
        public let resourceTags: [ResourceTag]?

        public init(resourceTags: [ResourceTag]? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "resourceTags"
        }
    }

    public struct VirtualGateways: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGateways", required: false, type: .list)
        ]
        /// A list of virtual private gateways.
        public let virtualGateways: [VirtualGateway]?

        public init(virtualGateways: [VirtualGateway]? = nil) {
            self.virtualGateways = virtualGateways
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateways = "virtualGateways"
        }
    }

    public struct TagResourceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the Direct Connect resource. Example: arn:aws:directconnect:us-east-1:123456789012:dxcon/dxcon-fg5678gh
        public let resourceArn: String
        /// The list of tags to add.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct AllocateHostedConnectionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ownerAccount", required: true, type: .string), 
            AWSShapeMember(label: "connectionName", required: true, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "vlan", required: true, type: .integer), 
            AWSShapeMember(label: "bandwidth", required: true, type: .string)
        ]
        /// The numeric account ID of the customer for whom the connection will be provisioned. Example: 123443215678 Default: None
        public let ownerAccount: String
        /// The name of the provisioned connection. Example: "500M Connection to AWS" Default: None
        public let connectionName: String
        /// The ID of the interconnect or LAG on which the connection will be provisioned. Example: dxcon-456abc78 or dxlag-abc123 Default: None
        public let connectionId: String
        /// The dedicated VLAN provisioned to the hosted connection. Example: 101 Default: None
        public let vlan: Int32
        /// The bandwidth of the connection. Example: 500Mbps  Default: None Values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps
        public let bandwidth: String

        public init(ownerAccount: String, connectionName: String, connectionId: String, vlan: Int32, bandwidth: String) {
            self.ownerAccount = ownerAccount
            self.connectionName = connectionName
            self.connectionId = connectionId
            self.vlan = vlan
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case ownerAccount = "ownerAccount"
            case connectionName = "connectionName"
            case connectionId = "connectionId"
            case vlan = "vlan"
            case bandwidth = "bandwidth"
        }
    }

    public struct Lag: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connections", required: false, type: .list), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "lagState", required: false, type: .enum), 
            AWSShapeMember(label: "awsDevice", required: false, type: .string), 
            AWSShapeMember(label: "numberOfConnections", required: false, type: .integer), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "minimumLinks", required: false, type: .integer), 
            AWSShapeMember(label: "allowsHostedConnections", required: false, type: .boolean), 
            AWSShapeMember(label: "connectionsBandwidth", required: false, type: .string), 
            AWSShapeMember(label: "lagName", required: false, type: .string)
        ]
        /// A list of connections bundled by this LAG.
        public let connections: [Connection]?
        public let location: String?
        public let lagId: String?
        public let lagState: LagState?
        /// The AWS Direct Connection endpoint that hosts the LAG.
        public let awsDevice: String?
        /// The number of physical connections bundled by the LAG, up to a maximum of 10.
        public let numberOfConnections: Int32?
        /// The owner of the LAG.
        public let ownerAccount: String?
        public let region: String?
        /// The minimum number of physical connections that must be operational for the LAG itself to be operational. If the number of operational connections drops below this setting, the LAG state changes to down. This value can help to ensure that a LAG is not overutilized if a significant number of its bundled connections go down.
        public let minimumLinks: Int32?
        /// Indicates whether the LAG can host other connections.  This is intended for use by AWS Direct Connect partners only. 
        public let allowsHostedConnections: Bool?
        /// The individual bandwidth of the physical connections bundled by the LAG. Available values: 1Gbps, 10Gbps
        public let connectionsBandwidth: String?
        /// The name of the LAG.
        public let lagName: String?

        public init(connections: [Connection]? = nil, location: String? = nil, lagId: String? = nil, lagState: LagState? = nil, awsDevice: String? = nil, numberOfConnections: Int32? = nil, ownerAccount: String? = nil, region: String? = nil, minimumLinks: Int32? = nil, allowsHostedConnections: Bool? = nil, connectionsBandwidth: String? = nil, lagName: String? = nil) {
            self.connections = connections
            self.location = location
            self.lagId = lagId
            self.lagState = lagState
            self.awsDevice = awsDevice
            self.numberOfConnections = numberOfConnections
            self.ownerAccount = ownerAccount
            self.region = region
            self.minimumLinks = minimumLinks
            self.allowsHostedConnections = allowsHostedConnections
            self.connectionsBandwidth = connectionsBandwidth
            self.lagName = lagName
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "connections"
            case location = "location"
            case lagId = "lagId"
            case lagState = "lagState"
            case awsDevice = "awsDevice"
            case numberOfConnections = "numberOfConnections"
            case ownerAccount = "ownerAccount"
            case region = "region"
            case minimumLinks = "minimumLinks"
            case allowsHostedConnections = "allowsHostedConnections"
            case connectionsBandwidth = "connectionsBandwidth"
            case lagName = "lagName"
        }
    }

    public struct DeleteVirtualInterfaceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum)
        ]
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceState = "virtualInterfaceState"
        }
    }

    public struct AssociateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        /// The ID of the virtual interface. Example: dxvif-123dfg56 Default: None
        public let virtualInterfaceId: String
        /// The ID of the LAG or connection with which to associate the virtual interface. Example: dxlag-abc123 or dxcon-abc123 Default: None
        public let connectionId: String

        public init(virtualInterfaceId: String, connectionId: String) {
            self.virtualInterfaceId = virtualInterfaceId
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case connectionId = "connectionId"
        }
    }

    public enum BGPPeerState: String, CustomStringConvertible, Codable {
        case verifying = "verifying"
        case pending = "pending"
        case available = "available"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct CreateBGPPeerResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterface", required: false, type: .structure)
        ]
        public let virtualInterface: VirtualInterface?

        public init(virtualInterface: VirtualInterface? = nil) {
            self.virtualInterface = virtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterface = "virtualInterface"
        }
    }

    public struct DescribeLagsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "lagId", required: false, type: .string)
        ]
        /// The ID of the LAG. Example: dxlag-abc123 Default: None
        public let lagId: String?

        public init(lagId: String? = nil) {
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case lagId = "lagId"
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArns", required: true, type: .list)
        ]
        /// The Amazon Resource Names (ARNs) of the Direct Connect resources.
        public let resourceArns: [String]

        public init(resourceArns: [String]) {
            self.resourceArns = resourceArns
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArns = "resourceArns"
        }
    }

    public struct DescribeConnectionLoaResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "loa", required: false, type: .structure)
        ]
        public let loa: Loa?

        public init(loa: Loa? = nil) {
            self.loa = loa
        }

        private enum CodingKeys: String, CodingKey {
            case loa = "loa"
        }
    }

    public enum LagState: String, CustomStringConvertible, Codable {
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct NewPublicVirtualInterfaceAllocation: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "routeFilterPrefixes", required: false, type: .list), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case routeFilterPrefixes = "routeFilterPrefixes"
            case vlan = "vlan"
        }
    }

    public enum InterconnectState: String, CustomStringConvertible, Codable {
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        public var description: String { return self.rawValue }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct CreatePrivateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "newPrivateVirtualInterface", required: true, type: .structure)
        ]
        public let connectionId: String
        /// Detailed information for the private virtual interface to be created. Default: None
        public let newPrivateVirtualInterface: NewPrivateVirtualInterface

        public init(connectionId: String, newPrivateVirtualInterface: NewPrivateVirtualInterface) {
            self.connectionId = connectionId
            self.newPrivateVirtualInterface = newPrivateVirtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case newPrivateVirtualInterface = "newPrivateVirtualInterface"
        }
    }

    public struct AssociateHostedConnectionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "parentConnectionId", required: true, type: .string)
        ]
        /// The ID of the hosted connection. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the interconnect or the LAG. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let parentConnectionId: String

        public init(connectionId: String, parentConnectionId: String) {
            self.connectionId = connectionId
            self.parentConnectionId = parentConnectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case parentConnectionId = "parentConnectionId"
        }
    }

    public struct DeleteInterconnectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectId", required: true, type: .string)
        ]
        public let interconnectId: String

        public init(interconnectId: String) {
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectId = "interconnectId"
        }
    }

    public struct DescribeInterconnectLoaRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "providerName", required: false, type: .string), 
            AWSShapeMember(label: "loaContentType", required: false, type: .enum), 
            AWSShapeMember(label: "interconnectId", required: true, type: .string)
        ]
        /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        public let loaContentType: LoaContentType?
        public let interconnectId: String

        public init(providerName: String? = nil, loaContentType: LoaContentType? = nil, interconnectId: String) {
            self.providerName = providerName
            self.loaContentType = loaContentType
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case loaContentType = "loaContentType"
            case interconnectId = "interconnectId"
        }
    }

    public struct NewPublicVirtualInterface: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "routeFilterPrefixes", required: false, type: .list), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case routeFilterPrefixes = "routeFilterPrefixes"
            case vlan = "vlan"
        }
    }

    public struct Interconnects: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnects", required: false, type: .list)
        ]
        /// A list of interconnects.
        public let interconnects: [Interconnect]?

        public init(interconnects: [Interconnect]? = nil) {
            self.interconnects = interconnects
        }

        private enum CodingKeys: String, CodingKey {
            case interconnects = "interconnects"
        }
    }

    public struct AllocatePrivateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "newPrivateVirtualInterfaceAllocation", required: true, type: .structure), 
            AWSShapeMember(label: "ownerAccount", required: true, type: .string)
        ]
        /// The connection ID on which the private virtual interface is provisioned. Default: None
        public let connectionId: String
        /// Detailed information for the private virtual interface to be provisioned. Default: None
        public let newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation
        /// The AWS account that will own the new private virtual interface. Default: None
        public let ownerAccount: String

        public init(connectionId: String, newPrivateVirtualInterfaceAllocation: NewPrivateVirtualInterfaceAllocation, ownerAccount: String) {
            self.connectionId = connectionId
            self.newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case newPrivateVirtualInterfaceAllocation = "newPrivateVirtualInterfaceAllocation"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct DeleteLagRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "lagId", required: true, type: .string)
        ]
        /// The ID of the LAG to delete. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(lagId: String) {
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case lagId = "lagId"
        }
    }

    public struct UpdateLagRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "minimumLinks", required: false, type: .integer), 
            AWSShapeMember(label: "lagId", required: true, type: .string), 
            AWSShapeMember(label: "lagName", required: false, type: .string)
        ]
        /// The minimum number of physical connections that must be operational for the LAG itself to be operational. Default: None
        public let minimumLinks: Int32?
        /// The ID of the LAG to update. Example: dxlag-abc123 Default: None
        public let lagId: String
        /// The name for the LAG. Example: "3x10G LAG to AWS" Default: None
        public let lagName: String?

        public init(minimumLinks: Int32? = nil, lagId: String, lagName: String? = nil) {
            self.minimumLinks = minimumLinks
            self.lagId = lagId
            self.lagName = lagName
        }

        private enum CodingKeys: String, CodingKey {
            case minimumLinks = "minimumLinks"
            case lagId = "lagId"
            case lagName = "lagName"
        }
    }

    public struct NewPrivateVirtualInterface: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "virtualGatewayId", required: true, type: .string), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let virtualGatewayId: String
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, virtualGatewayId: String, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.virtualGatewayId = virtualGatewayId
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case virtualGatewayId = "virtualGatewayId"
            case vlan = "vlan"
        }
    }

    public struct DescribeHostedConnectionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        /// The ID of the interconnect or LAG on which the hosted connections are provisioned. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct DeleteConnectionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct NewPrivateVirtualInterfaceAllocation: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: true, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: true, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "vlan", required: true, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceName: String
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32
        public let addressFamily: AddressFamily?
        public let vlan: Int32

        public init(customerAddress: String? = nil, virtualInterfaceName: String, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32, addressFamily: AddressFamily? = nil, vlan: Int32) {
            self.customerAddress = customerAddress
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case vlan = "vlan"
        }
    }

    public struct CreatePublicVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "newPublicVirtualInterface", required: true, type: .structure)
        ]
        public let connectionId: String
        /// Detailed information for the public virtual interface to be created. Default: None
        public let newPublicVirtualInterface: NewPublicVirtualInterface

        public init(connectionId: String, newPublicVirtualInterface: NewPublicVirtualInterface) {
            self.connectionId = connectionId
            self.newPublicVirtualInterface = newPublicVirtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case newPublicVirtualInterface = "newPublicVirtualInterface"
        }
    }

    public enum VirtualInterfaceState: String, CustomStringConvertible, Codable {
        case confirming = "confirming"
        case verifying = "verifying"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        case rejected = "rejected"
        public var description: String { return self.rawValue }
    }

    public struct DescribeInterconnectsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectId", required: false, type: .string)
        ]
        public let interconnectId: String?

        public init(interconnectId: String? = nil) {
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectId = "interconnectId"
        }
    }

    public struct ResourceTag: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the Direct Connect resource.
        public let resourceArn: String?
        /// The tags.
        public let tags: [Tag]?

        public init(resourceArn: String? = nil, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct ConfirmConnectionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string)
        ]
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct AssociateConnectionWithLagRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: true, type: .string)
        ]
        /// The ID of the connection. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the LAG with which to associate the connection. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(connectionId: String, lagId: String) {
            self.connectionId = connectionId
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case lagId = "lagId"
        }
    }

    public enum AddressFamily: String, CustomStringConvertible, Codable {
        case ipv4 = "ipv4"
        case ipv6 = "ipv6"
        public var description: String { return self.rawValue }
    }

    public struct AllocatePublicVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "newPublicVirtualInterfaceAllocation", required: true, type: .structure), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "ownerAccount", required: true, type: .string)
        ]
        /// Detailed information for the public virtual interface to be provisioned. Default: None
        public let newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation
        /// The connection ID on which the public virtual interface is provisioned. Default: None
        public let connectionId: String
        /// The AWS account that will own the new public virtual interface. Default: None
        public let ownerAccount: String

        public init(newPublicVirtualInterfaceAllocation: NewPublicVirtualInterfaceAllocation, connectionId: String, ownerAccount: String) {
            self.newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation
            self.connectionId = connectionId
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case newPublicVirtualInterfaceAllocation = "newPublicVirtualInterfaceAllocation"
            case connectionId = "connectionId"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct ConfirmPublicVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string)
        ]
        public let virtualInterfaceId: String

        public init(virtualInterfaceId: String) {
            self.virtualInterfaceId = virtualInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
        }
    }

    public struct CreateInterconnectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "location", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "interconnectName", required: true, type: .string), 
            AWSShapeMember(label: "bandwidth", required: true, type: .string)
        ]
        /// Where the interconnect is located Example: EqSV5 Default: None
        public let location: String
        public let lagId: String?
        /// The name of the interconnect. Example: "1G Interconnect to AWS" Default: None
        public let interconnectName: String
        /// The port bandwidth Example: 1Gbps Default: None Available values: 1Gbps,10Gbps
        public let bandwidth: String

        public init(location: String, lagId: String? = nil, interconnectName: String, bandwidth: String) {
            self.location = location
            self.lagId = lagId
            self.interconnectName = interconnectName
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case lagId = "lagId"
            case interconnectName = "interconnectName"
            case bandwidth = "bandwidth"
        }
    }

    public struct Connections: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connections", required: false, type: .list)
        ]
        /// A list of connections.
        public let connections: [Connection]?

        public init(connections: [Connection]? = nil) {
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "connections"
        }
    }

    public struct DescribeInterconnectLoaResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "loa", required: false, type: .structure)
        ]
        public let loa: Loa?

        public init(loa: Loa? = nil) {
            self.loa = loa
        }

        private enum CodingKeys: String, CodingKey {
            case loa = "loa"
        }
    }

    public struct Connection: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "loaIssueTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "bandwidth", required: false, type: .string), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "awsDevice", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string), 
            AWSShapeMember(label: "connectionState", required: false, type: .enum), 
            AWSShapeMember(label: "connectionName", required: false, type: .string), 
            AWSShapeMember(label: "vlan", required: false, type: .integer), 
            AWSShapeMember(label: "partnerName", required: false, type: .string)
        ]
        /// The time of the most recent call to DescribeLoa for this connection.
        public let loaIssueTime: TimeStamp?
        /// Bandwidth of the connection. Example: 1Gbps (for regular connections), or 500Mbps (for hosted connections) Default: None
        public let bandwidth: String?
        public let location: String?
        public let lagId: String?
        /// The Direct Connection endpoint which the physical connection terminates on.
        public let awsDevice: String?
        public let connectionId: String?
        public let region: String?
        /// The AWS account that will own the new connection.
        public let ownerAccount: String?
        public let connectionState: ConnectionState?
        public let connectionName: String?
        public let vlan: Int32?
        /// The name of the AWS Direct Connect service provider associated with the connection.
        public let partnerName: String?

        public init(loaIssueTime: TimeStamp? = nil, bandwidth: String? = nil, location: String? = nil, lagId: String? = nil, awsDevice: String? = nil, connectionId: String? = nil, region: String? = nil, ownerAccount: String? = nil, connectionState: ConnectionState? = nil, connectionName: String? = nil, vlan: Int32? = nil, partnerName: String? = nil) {
            self.loaIssueTime = loaIssueTime
            self.bandwidth = bandwidth
            self.location = location
            self.lagId = lagId
            self.awsDevice = awsDevice
            self.connectionId = connectionId
            self.region = region
            self.ownerAccount = ownerAccount
            self.connectionState = connectionState
            self.connectionName = connectionName
            self.vlan = vlan
            self.partnerName = partnerName
        }

        private enum CodingKeys: String, CodingKey {
            case loaIssueTime = "loaIssueTime"
            case bandwidth = "bandwidth"
            case location = "location"
            case lagId = "lagId"
            case awsDevice = "awsDevice"
            case connectionId = "connectionId"
            case region = "region"
            case ownerAccount = "ownerAccount"
            case connectionState = "connectionState"
            case connectionName = "connectionName"
            case vlan = "vlan"
            case partnerName = "partnerName"
        }
    }

    public struct DescribeConnectionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: false, type: .string)
        ]
        public let connectionId: String?

        public init(connectionId: String? = nil) {
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
        }
    }

    public struct Lags: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "lags", required: false, type: .list)
        ]
        /// A list of LAGs.
        public let lags: [Lag]?

        public init(lags: [Lag]? = nil) {
            self.lags = lags
        }

        private enum CodingKeys: String, CodingKey {
            case lags = "lags"
        }
    }

    public struct DeleteInterconnectResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectState", required: false, type: .enum)
        ]
        public let interconnectState: InterconnectState?

        public init(interconnectState: InterconnectState? = nil) {
            self.interconnectState = interconnectState
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectState = "interconnectState"
        }
    }

    public struct TagResourceResponse: AWSShape {
        /// The key for the payload

    }

    public struct BGPPeer: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "bgpPeerState", required: false, type: .enum), 
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "bgpStatus", required: false, type: .enum), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum)
        ]
        public let bgpPeerState: BGPPeerState?
        public let customerAddress: String?
        public let bgpStatus: BGPStatus?
        public let authKey: String?
        public let amazonAddress: String?
        public let asn: Int32?
        public let addressFamily: AddressFamily?

        public init(bgpPeerState: BGPPeerState? = nil, customerAddress: String? = nil, bgpStatus: BGPStatus? = nil, authKey: String? = nil, amazonAddress: String? = nil, asn: Int32? = nil, addressFamily: AddressFamily? = nil) {
            self.bgpPeerState = bgpPeerState
            self.customerAddress = customerAddress
            self.bgpStatus = bgpStatus
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.addressFamily = addressFamily
        }

        private enum CodingKeys: String, CodingKey {
            case bgpPeerState = "bgpPeerState"
            case customerAddress = "customerAddress"
            case bgpStatus = "bgpStatus"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case asn = "asn"
            case addressFamily = "addressFamily"
        }
    }

    public struct DisassociateConnectionFromLagRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: true, type: .string)
        ]
        /// The ID of the connection to disassociate from the LAG. Example: dxcon-abc123 Default: None
        public let connectionId: String
        /// The ID of the LAG. Example: dxlag-abc123 Default: None
        public let lagId: String

        public init(connectionId: String, lagId: String) {
            self.connectionId = connectionId
            self.lagId = lagId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case lagId = "lagId"
        }
    }

    public struct CreateBGPPeerRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "newBGPPeer", required: false, type: .structure)
        ]
        /// The ID of the virtual interface on which the BGP peer will be provisioned. Example: dxvif-456abc78 Default: None
        public let virtualInterfaceId: String?
        /// Detailed information for the BGP peer to be created. Default: None
        public let newBGPPeer: NewBGPPeer?

        public init(virtualInterfaceId: String? = nil, newBGPPeer: NewBGPPeer? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.newBGPPeer = newBGPPeer
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case newBGPPeer = "newBGPPeer"
        }
    }

    public enum ConnectionState: String, CustomStringConvertible, Codable {
        case ordering = "ordering"
        case requested = "requested"
        case pending = "pending"
        case available = "available"
        case down = "down"
        case deleting = "deleting"
        case deleted = "deleted"
        case rejected = "rejected"
        public var description: String { return self.rawValue }
    }

    public struct ConfirmPrivateVirtualInterfaceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum)
        ]
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceState = "virtualInterfaceState"
        }
    }

    public struct DeleteBGPPeerResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterface", required: false, type: .structure)
        ]
        public let virtualInterface: VirtualInterface?

        public init(virtualInterface: VirtualInterface? = nil) {
            self.virtualInterface = virtualInterface
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterface = "virtualInterface"
        }
    }

    public struct DescribeVirtualInterfacesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string)
        ]
        public let virtualInterfaceId: String?
        public let connectionId: String?

        public init(virtualInterfaceId: String? = nil, connectionId: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case connectionId = "connectionId"
        }
    }

    public struct DescribeLoaRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "providerName", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "loaContentType", required: false, type: .enum)
        ]
        /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        /// The ID of a connection, LAG, or interconnect for which to get the LOA-CFA information. Example: dxcon-abc123 or dxlag-abc123 Default: None
        public let connectionId: String
        /// A standard media type indicating the content type of the LOA-CFA document. Currently, the only supported value is "application/pdf". Default: application/pdf
        public let loaContentType: LoaContentType?

        public init(providerName: String? = nil, connectionId: String, loaContentType: LoaContentType? = nil) {
            self.providerName = providerName
            self.connectionId = connectionId
            self.loaContentType = loaContentType
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case connectionId = "connectionId"
            case loaContentType = "loaContentType"
        }
    }

    public struct DeleteBGPPeerRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "customerAddress", required: false, type: .string)
        ]
        /// The ID of the virtual interface from which the BGP peer will be deleted. Example: dxvif-456abc78 Default: None
        public let virtualInterfaceId: String?
        public let asn: Int32?
        public let customerAddress: String?

        public init(virtualInterfaceId: String? = nil, asn: Int32? = nil, customerAddress: String? = nil) {
            self.virtualInterfaceId = virtualInterfaceId
            self.asn = asn
            self.customerAddress = customerAddress
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case asn = "asn"
            case customerAddress = "customerAddress"
        }
    }

    public struct Interconnect: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "loaIssueTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "interconnectState", required: false, type: .enum), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "awsDevice", required: false, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "interconnectName", required: false, type: .string), 
            AWSShapeMember(label: "interconnectId", required: false, type: .string), 
            AWSShapeMember(label: "bandwidth", required: false, type: .string)
        ]
        /// The time of the most recent call to DescribeInterconnectLoa for this Interconnect.
        public let loaIssueTime: TimeStamp?
        public let interconnectState: InterconnectState?
        public let location: String?
        /// The Direct Connection endpoint which the physical connection terminates on.
        public let awsDevice: String?
        public let lagId: String?
        public let region: String?
        public let interconnectName: String?
        public let interconnectId: String?
        public let bandwidth: String?

        public init(loaIssueTime: TimeStamp? = nil, interconnectState: InterconnectState? = nil, location: String? = nil, awsDevice: String? = nil, lagId: String? = nil, region: String? = nil, interconnectName: String? = nil, interconnectId: String? = nil, bandwidth: String? = nil) {
            self.loaIssueTime = loaIssueTime
            self.interconnectState = interconnectState
            self.location = location
            self.awsDevice = awsDevice
            self.lagId = lagId
            self.region = region
            self.interconnectName = interconnectName
            self.interconnectId = interconnectId
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case loaIssueTime = "loaIssueTime"
            case interconnectState = "interconnectState"
            case location = "location"
            case awsDevice = "awsDevice"
            case lagId = "lagId"
            case region = "region"
            case interconnectName = "interconnectName"
            case interconnectId = "interconnectId"
            case bandwidth = "bandwidth"
        }
    }

    public struct AllocateConnectionOnInterconnectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "bandwidth", required: true, type: .string), 
            AWSShapeMember(label: "connectionName", required: true, type: .string), 
            AWSShapeMember(label: "interconnectId", required: true, type: .string), 
            AWSShapeMember(label: "vlan", required: true, type: .integer), 
            AWSShapeMember(label: "ownerAccount", required: true, type: .string)
        ]
        /// Bandwidth of the connection. Example: "500Mbps" Default: None Values: 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps
        public let bandwidth: String
        /// Name of the provisioned connection. Example: "500M Connection to AWS" Default: None
        public let connectionName: String
        /// ID of the interconnect on which the connection will be provisioned. Example: dxcon-456abc78 Default: None
        public let interconnectId: String
        /// The dedicated VLAN provisioned to the connection. Example: 101 Default: None
        public let vlan: Int32
        /// Numeric account Id of the customer for whom the connection will be provisioned. Example: 123443215678 Default: None
        public let ownerAccount: String

        public init(bandwidth: String, connectionName: String, interconnectId: String, vlan: Int32, ownerAccount: String) {
            self.bandwidth = bandwidth
            self.connectionName = connectionName
            self.interconnectId = interconnectId
            self.vlan = vlan
            self.ownerAccount = ownerAccount
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "bandwidth"
            case connectionName = "connectionName"
            case interconnectId = "interconnectId"
            case vlan = "vlan"
            case ownerAccount = "ownerAccount"
        }
    }

    public struct DescribeConnectionsOnInterconnectRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "interconnectId", required: true, type: .string)
        ]
        /// ID of the interconnect on which a list of connection is provisioned. Example: dxcon-abc123 Default: None
        public let interconnectId: String

        public init(interconnectId: String) {
            self.interconnectId = interconnectId
        }

        private enum CodingKeys: String, CodingKey {
            case interconnectId = "interconnectId"
        }
    }

    public enum LoaContentType: String, CustomStringConvertible, Codable {
        case applicationPdf = "application/pdf"
        public var description: String { return self.rawValue }
    }

    public struct VirtualInterfaces: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaces", required: false, type: .list)
        ]
        /// A list of virtual interfaces.
        public let virtualInterfaces: [VirtualInterface]?

        public init(virtualInterfaces: [VirtualInterface]? = nil) {
            self.virtualInterfaces = virtualInterfaces
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaces = "virtualInterfaces"
        }
    }

    public enum BGPStatus: String, CustomStringConvertible, Codable {
        case up = "up"
        case down = "down"
        public var description: String { return self.rawValue }
    }

    public struct UntagResourceResponse: AWSShape {
        /// The key for the payload

    }

    public struct Location: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "locationCode", required: false, type: .string), 
            AWSShapeMember(label: "locationName", required: false, type: .string)
        ]
        /// The code used to indicate the AWS Direct Connect location.
        public let locationCode: String?
        /// The name of the AWS Direct Connect location. The name includes the colocation partner name and the physical site of the lit building.
        public let locationName: String?

        public init(locationCode: String? = nil, locationName: String? = nil) {
            self.locationCode = locationCode
            self.locationName = locationName
        }

        private enum CodingKeys: String, CodingKey {
            case locationCode = "locationCode"
            case locationName = "locationName"
        }
    }

    public struct Loa: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "loaContentType", required: false, type: .enum), 
            AWSShapeMember(label: "loaContent", required: false, type: .blob)
        ]
        public let loaContentType: LoaContentType?
        public let loaContent: Data?

        public init(loaContentType: LoaContentType? = nil, loaContent: Data? = nil) {
            self.loaContentType = loaContentType
            self.loaContent = loaContent
        }

        private enum CodingKeys: String, CodingKey {
            case loaContentType = "loaContentType"
            case loaContent = "loaContent"
        }
    }

    public struct VirtualInterface: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceType", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: false, type: .string), 
            AWSShapeMember(label: "ownerAccount", required: false, type: .string), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "routeFilterPrefixes", required: false, type: .list), 
            AWSShapeMember(label: "location", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceName", required: false, type: .string), 
            AWSShapeMember(label: "authKey", required: false, type: .string), 
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "customerRouterConfig", required: false, type: .string), 
            AWSShapeMember(label: "bgpPeers", required: false, type: .list), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceId", required: false, type: .string), 
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum), 
            AWSShapeMember(label: "vlan", required: false, type: .integer)
        ]
        public let customerAddress: String?
        public let virtualInterfaceType: String?
        public let connectionId: String?
        /// The AWS account that will own the new virtual interface.
        public let ownerAccount: String?
        public let asn: Int32?
        public let addressFamily: AddressFamily?
        public let routeFilterPrefixes: [RouteFilterPrefix]?
        public let location: String?
        public let virtualInterfaceName: String?
        public let authKey: String?
        public let amazonAddress: String?
        /// Information for generating the customer router configuration.
        public let customerRouterConfig: String?
        public let bgpPeers: [BGPPeer]?
        public let virtualGatewayId: String?
        public let virtualInterfaceId: String?
        public let virtualInterfaceState: VirtualInterfaceState?
        public let vlan: Int32?

        public init(customerAddress: String? = nil, virtualInterfaceType: String? = nil, connectionId: String? = nil, ownerAccount: String? = nil, asn: Int32? = nil, addressFamily: AddressFamily? = nil, routeFilterPrefixes: [RouteFilterPrefix]? = nil, location: String? = nil, virtualInterfaceName: String? = nil, authKey: String? = nil, amazonAddress: String? = nil, customerRouterConfig: String? = nil, bgpPeers: [BGPPeer]? = nil, virtualGatewayId: String? = nil, virtualInterfaceId: String? = nil, virtualInterfaceState: VirtualInterfaceState? = nil, vlan: Int32? = nil) {
            self.customerAddress = customerAddress
            self.virtualInterfaceType = virtualInterfaceType
            self.connectionId = connectionId
            self.ownerAccount = ownerAccount
            self.asn = asn
            self.addressFamily = addressFamily
            self.routeFilterPrefixes = routeFilterPrefixes
            self.location = location
            self.virtualInterfaceName = virtualInterfaceName
            self.authKey = authKey
            self.amazonAddress = amazonAddress
            self.customerRouterConfig = customerRouterConfig
            self.bgpPeers = bgpPeers
            self.virtualGatewayId = virtualGatewayId
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualInterfaceState = virtualInterfaceState
            self.vlan = vlan
        }

        private enum CodingKeys: String, CodingKey {
            case customerAddress = "customerAddress"
            case virtualInterfaceType = "virtualInterfaceType"
            case connectionId = "connectionId"
            case ownerAccount = "ownerAccount"
            case asn = "asn"
            case addressFamily = "addressFamily"
            case routeFilterPrefixes = "routeFilterPrefixes"
            case location = "location"
            case virtualInterfaceName = "virtualInterfaceName"
            case authKey = "authKey"
            case amazonAddress = "amazonAddress"
            case customerRouterConfig = "customerRouterConfig"
            case bgpPeers = "bgpPeers"
            case virtualGatewayId = "virtualGatewayId"
            case virtualInterfaceId = "virtualInterfaceId"
            case virtualInterfaceState = "virtualInterfaceState"
            case vlan = "vlan"
        }
    }

    public struct ConfirmPublicVirtualInterfaceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceState", required: false, type: .enum)
        ]
        public let virtualInterfaceState: VirtualInterfaceState?

        public init(virtualInterfaceState: VirtualInterfaceState? = nil) {
            self.virtualInterfaceState = virtualInterfaceState
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceState = "virtualInterfaceState"
        }
    }

    public struct Locations: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "locations", required: false, type: .list)
        ]
        /// A list of colocation hubs where network providers have equipment. Most regions have multiple locations available.
        public let locations: [Location]?

        public init(locations: [Location]? = nil) {
            self.locations = locations
        }

        private enum CodingKeys: String, CodingKey {
            case locations = "locations"
        }
    }

    public struct CreateConnectionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionName", required: true, type: .string), 
            AWSShapeMember(label: "location", required: true, type: .string), 
            AWSShapeMember(label: "lagId", required: false, type: .string), 
            AWSShapeMember(label: "bandwidth", required: true, type: .string)
        ]
        public let connectionName: String
        public let location: String
        public let lagId: String?
        public let bandwidth: String

        public init(connectionName: String, location: String, lagId: String? = nil, bandwidth: String) {
            self.connectionName = connectionName
            self.location = location
            self.lagId = lagId
            self.bandwidth = bandwidth
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "connectionName"
            case location = "location"
            case lagId = "lagId"
            case bandwidth = "bandwidth"
        }
    }

    public struct DescribeConnectionLoaRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "providerName", required: false, type: .string), 
            AWSShapeMember(label: "connectionId", required: true, type: .string), 
            AWSShapeMember(label: "loaContentType", required: false, type: .enum)
        ]
        /// The name of the APN partner or service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect. Default: None
        public let providerName: String?
        public let connectionId: String
        public let loaContentType: LoaContentType?

        public init(providerName: String? = nil, connectionId: String, loaContentType: LoaContentType? = nil) {
            self.providerName = providerName
            self.connectionId = connectionId
            self.loaContentType = loaContentType
        }

        private enum CodingKeys: String, CodingKey {
            case providerName = "providerName"
            case connectionId = "connectionId"
            case loaContentType = "loaContentType"
        }
    }

    public struct ConfirmPrivateVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: true, type: .string)
        ]
        public let virtualInterfaceId: String
        /// ID of the virtual private gateway that will be attached to the virtual interface.  A virtual private gateway can be managed via the Amazon Virtual Private Cloud (VPC) console or the EC2 CreateVpnGateway action. Default: None
        public let virtualGatewayId: String

        public init(virtualInterfaceId: String, virtualGatewayId: String) {
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

    public struct NewBGPPeer: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "amazonAddress", required: false, type: .string), 
            AWSShapeMember(label: "customerAddress", required: false, type: .string), 
            AWSShapeMember(label: "addressFamily", required: false, type: .enum), 
            AWSShapeMember(label: "asn", required: false, type: .integer), 
            AWSShapeMember(label: "authKey", required: false, type: .string)
        ]
        public let amazonAddress: String?
        public let customerAddress: String?
        public let addressFamily: AddressFamily?
        public let asn: Int32?
        public let authKey: String?

        public init(amazonAddress: String? = nil, customerAddress: String? = nil, addressFamily: AddressFamily? = nil, asn: Int32? = nil, authKey: String? = nil) {
            self.amazonAddress = amazonAddress
            self.customerAddress = customerAddress
            self.addressFamily = addressFamily
            self.asn = asn
            self.authKey = authKey
        }

        private enum CodingKeys: String, CodingKey {
            case amazonAddress = "amazonAddress"
            case customerAddress = "customerAddress"
            case addressFamily = "addressFamily"
            case asn = "asn"
            case authKey = "authKey"
        }
    }

    public struct ConfirmConnectionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionState", required: false, type: .enum)
        ]
        public let connectionState: ConnectionState?

        public init(connectionState: ConnectionState? = nil) {
            self.connectionState = connectionState
        }

        private enum CodingKeys: String, CodingKey {
            case connectionState = "connectionState"
        }
    }

    public struct RouteFilterPrefix: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "cidr", required: false, type: .string)
        ]
        /// CIDR notation for the advertised route. Multiple routes are separated by commas. IPv6 CIDRs must be at least a /64 or shorter Example: 10.10.10.0/24,10.10.11.0/24,2001:db8::/64
        public let cidr: String?

        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "cidr"
        }
    }

    public struct DeleteVirtualInterfaceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualInterfaceId", required: true, type: .string)
        ]
        public let virtualInterfaceId: String

        public init(virtualInterfaceId: String) {
            self.virtualInterfaceId = virtualInterfaceId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualInterfaceId = "virtualInterfaceId"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the Direct Connect resource.
        public let resourceArn: String
        /// The list of tag keys to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct VirtualGateway: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGatewayState", required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayId", required: false, type: .string)
        ]
        public let virtualGatewayState: String?
        public let virtualGatewayId: String?

        public init(virtualGatewayState: String? = nil, virtualGatewayId: String? = nil) {
            self.virtualGatewayState = virtualGatewayState
            self.virtualGatewayId = virtualGatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGatewayState = "virtualGatewayState"
            case virtualGatewayId = "virtualGatewayId"
        }
    }

}