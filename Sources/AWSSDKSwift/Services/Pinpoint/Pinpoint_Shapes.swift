// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Pinpoint {

    public struct UpdateEndpointsBatchResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageBody"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageBody", required: true, type: .structure)
        ]
        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        private enum CodingKeys: String, CodingKey {
            case messageBody = "MessageBody"
        }
    }

    public struct DeleteGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct DeleteApnsSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct AttributesResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .list), 
            AWSShapeMember(label: "AttributeType", required: false, type: .string)
        ]
        /// The unique ID for the application.
        public let applicationId: String?
        /// The attributes for the application.
        public let attributes: [String]?
        /// The attribute type for the application.
        public let attributeType: String?

        public init(applicationId: String? = nil, attributes: [String]? = nil, attributeType: String? = nil) {
            self.applicationId = applicationId
            self.attributes = attributes
            self.attributeType = attributeType
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case attributes = "Attributes"
            case attributeType = "AttributeType"
        }
    }

    public struct GetAdmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GPSPointDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Coordinates", required: false, type: .structure), 
            AWSShapeMember(label: "RangeInKilometers", required: false, type: .double)
        ]
        /// Coordinate to measure distance from.
        public let coordinates: GPSCoordinates?
        /// Range in kilometers from the coordinate.
        public let rangeInKilometers: Double?

        public init(coordinates: GPSCoordinates? = nil, rangeInKilometers: Double? = nil) {
            self.coordinates = coordinates
            self.rangeInKilometers = rangeInKilometers
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
            case rangeInKilometers = "RangeInKilometers"
        }
    }

    public struct PutEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct DeleteBaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct UpdateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteSegmentRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WriteSegmentRequest", required: true, type: .structure), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let writeSegmentRequest: WriteSegmentRequest
        public let segmentId: String
        public let applicationId: String

        public init(writeSegmentRequest: WriteSegmentRequest, segmentId: String, applicationId: String) {
            self.writeSegmentRequest = writeSegmentRequest
            self.segmentId = segmentId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case writeSegmentRequest = "WriteSegmentRequest"
            case segmentId = "segment-id"
            case applicationId = "application-id"
        }
    }

    public struct ChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Application id
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Is this channel archived
        public let isArchived: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who made the last change
        public let lastModifiedBy: String?

        public init(lastModifiedDate: String? = nil, applicationId: String? = nil, creationDate: String? = nil, hasCredential: Bool? = nil, isArchived: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.hasCredential = hasCredential
            self.isArchived = isArchived
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case creationDate = "CreationDate"
            case hasCredential = "HasCredential"
            case isArchived = "IsArchived"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct DeleteSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public enum SourceType: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        public var description: String { return self.rawValue }
    }

    public struct UpdateBaiduChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let baiduChannelRequest: BaiduChannelRequest
        public let applicationId: String

        public init(baiduChannelRequest: BaiduChannelRequest, applicationId: String) {
            self.baiduChannelRequest = baiduChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelRequest = "BaiduChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct SegmentGroupList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Include", required: false, type: .enum), 
            AWSShapeMember(label: "Groups", required: false, type: .list)
        ]
        /// How should the groups be applied for the result
        public let include: Include?
        /// List of dimension groups to evaluate.
        public let groups: [SegmentGroup]?

        public init(include: Include? = nil, groups: [SegmentGroup]? = nil) {
            self.include = include
            self.groups = groups
        }

        private enum CodingKeys: String, CodingKey {
            case include = "Include"
            case groups = "Groups"
        }
    }

    public struct DirectMessageConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "ADMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "BaiduMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultPushNotificationMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultMessage", required: false, type: .structure), 
            AWSShapeMember(label: "SMSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "GCMMessage", required: false, type: .structure)
        ]
        /// The message to APNS channels. Overrides the default push notification message.
        public let aPNSMessage: APNSMessage?
        /// The message to ADM channels. Overrides the default push notification message.
        public let aDMMessage: ADMMessage?
        /// The message to Baidu GCM channels. Overrides the default push notification message.
        public let baiduMessage: BaiduMessage?
        /// The default push notification message for all push channels.
        public let defaultPushNotificationMessage: DefaultPushNotificationMessage?
        /// The default message for all channels.
        public let defaultMessage: DefaultMessage?
        /// The message to SMS channels. Overrides the default message.
        public let sMSMessage: SMSMessage?
        /// The message to GCM channels. Overrides the default push notification message.
        public let gCMMessage: GCMMessage?

        public init(aPNSMessage: APNSMessage? = nil, aDMMessage: ADMMessage? = nil, baiduMessage: BaiduMessage? = nil, defaultPushNotificationMessage: DefaultPushNotificationMessage? = nil, defaultMessage: DefaultMessage? = nil, sMSMessage: SMSMessage? = nil, gCMMessage: GCMMessage? = nil) {
            self.aPNSMessage = aPNSMessage
            self.aDMMessage = aDMMessage
            self.baiduMessage = baiduMessage
            self.defaultPushNotificationMessage = defaultPushNotificationMessage
            self.defaultMessage = defaultMessage
            self.sMSMessage = sMSMessage
            self.gCMMessage = gCMMessage
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSMessage = "APNSMessage"
            case aDMMessage = "ADMMessage"
            case baiduMessage = "BaiduMessage"
            case defaultPushNotificationMessage = "DefaultPushNotificationMessage"
            case defaultMessage = "DefaultMessage"
            case sMSMessage = "SMSMessage"
            case gCMMessage = "GCMMessage"
        }
    }

    public enum MessageType: String, CustomStringConvertible, Codable {
        case transactional = "TRANSACTIONAL"
        case promotional = "PROMOTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct UpdateApnsVoipSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest
        public let applicationId: String

        public init(aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest, applicationId: String) {
            self.aPNSVoipSandboxChannelRequest = aPNSVoipSandboxChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelRequest = "APNSVoipSandboxChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct EndpointMessageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UpdatedToken", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer), 
            AWSShapeMember(label: "MessageId", required: false, type: .string), 
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "DeliveryStatus", required: false, type: .enum), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string)
        ]
        /// If token was updated as part of delivery. (This is GCM Specific)
        public let updatedToken: String?
        /// Downstream service status code.
        public let statusCode: Int32?
        /// Unique message identifier associated with the message that was sent.
        public let messageId: String?
        /// Address that endpoint message was delivered to.
        public let address: String?
        /// Delivery status of message.
        public let deliveryStatus: DeliveryStatus?
        /// Status message for message delivery.
        public let statusMessage: String?

        public init(updatedToken: String? = nil, statusCode: Int32? = nil, messageId: String? = nil, address: String? = nil, deliveryStatus: DeliveryStatus? = nil, statusMessage: String? = nil) {
            self.updatedToken = updatedToken
            self.statusCode = statusCode
            self.messageId = messageId
            self.address = address
            self.deliveryStatus = deliveryStatus
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case updatedToken = "UpdatedToken"
            case statusCode = "StatusCode"
            case messageId = "MessageId"
            case address = "Address"
            case deliveryStatus = "DeliveryStatus"
            case statusMessage = "StatusMessage"
        }
    }

    public struct GetEmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct GetApnsSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetSegmentExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string)
        ]
        public let token: String?
        public let applicationId: String
        public let segmentId: String
        public let pageSize: String?

        public init(token: String? = nil, applicationId: String, segmentId: String, pageSize: String? = nil) {
            self.token = token
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.pageSize = pageSize
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case pageSize = "page-size"
        }
    }

    public enum AttributeType: String, CustomStringConvertible, Codable {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct CampaignHook: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WebUrl", required: false, type: .string), 
            AWSShapeMember(label: "Mode", required: false, type: .enum), 
            AWSShapeMember(label: "LambdaFunctionName", required: false, type: .string)
        ]
        /// Web URL to call for hook. If the URL has authentication specified it will be added as authentication to the request
        public let webUrl: String?
        /// What mode Lambda should be invoked in.
        public let mode: Mode?
        /// Lambda function name or arn to be called for delivery
        public let lambdaFunctionName: String?

        public init(webUrl: String? = nil, mode: Mode? = nil, lambdaFunctionName: String? = nil) {
            self.webUrl = webUrl
            self.mode = mode
            self.lambdaFunctionName = lambdaFunctionName
        }

        private enum CodingKeys: String, CodingKey {
            case webUrl = "WebUrl"
            case mode = "Mode"
            case lambdaFunctionName = "LambdaFunctionName"
        }
    }

    public struct GetSegmentVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Version", location: .uri(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let version: String
        public let segmentId: String
        public let applicationId: String

        public init(version: String, segmentId: String, applicationId: String) {
            self.version = version
            self.segmentId = segmentId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case version = "version"
            case segmentId = "segment-id"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct DeleteGcmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct EndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "User", required: false, type: .structure), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "OptOut", required: false, type: .string)
        ]
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// The destination for messages that you send to this endpoint. The address varies by channel. For mobile push channels, use the token provided by the push notification service, such as the APNs device token or the FCM registration token. For the SMS channel, use a phone number in E.164 format, such as +1206XXX5550100. For the email channel, use an email address.
        public let address: String?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Custom attributes that describe the endpoint by associating a name with an array of values. For example, an attribute named "interests" might have the values ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create a segment of users to engage with a messaging campaign.
        /// The following characters are not recommended in attribute names: # : ? \ /. The Amazon Pinpoint console does not display attributes that include these characters in the name. This limitation does not apply to attribute values.
        public let attributes: [String: [String]]?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// Unused.
        public let endpointStatus: String?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?

        public init(location: EndpointLocation? = nil, effectiveDate: String? = nil, address: String? = nil, metrics: [String: Double]? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, endpointStatus: String? = nil, demographic: EndpointDemographic? = nil, user: EndpointUser? = nil, requestId: String? = nil, optOut: String? = nil) {
            self.location = location
            self.effectiveDate = effectiveDate
            self.address = address
            self.metrics = metrics
            self.attributes = attributes
            self.channelType = channelType
            self.endpointStatus = endpointStatus
            self.demographic = demographic
            self.user = user
            self.requestId = requestId
            self.optOut = optOut
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case effectiveDate = "EffectiveDate"
            case address = "Address"
            case metrics = "Metrics"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case endpointStatus = "EndpointStatus"
            case demographic = "Demographic"
            case user = "User"
            case requestId = "RequestId"
            case optOut = "OptOut"
        }
    }

    public struct GetApnsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct EndpointSendConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "TitleOverride", required: false, type: .string), 
            AWSShapeMember(label: "BodyOverride", required: false, type: .string), 
            AWSShapeMember(label: "Context", required: false, type: .map)
        ]
        /// A map of substitution values for the message to be merged with the DefaultMessage's substitutions. Substitutions on this map take precedence over the all other substitutions.
        public let substitutions: [String: [String]]?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Title override. If specified will override default title if applicable.
        public let titleOverride: String?
        /// Body override. If specified will override default body.
        public let bodyOverride: String?
        /// A map of custom attributes to attributes to be attached to the message for this address. This payload is added to the push notification's 'data.pinpoint' object or added to the email/sms delivery receipt event attributes.
        public let context: [String: String]?

        public init(substitutions: [String: [String]]? = nil, rawContent: String? = nil, titleOverride: String? = nil, bodyOverride: String? = nil, context: [String: String]? = nil) {
            self.substitutions = substitutions
            self.rawContent = rawContent
            self.titleOverride = titleOverride
            self.bodyOverride = bodyOverride
            self.context = context
        }

        private enum CodingKeys: String, CodingKey {
            case substitutions = "Substitutions"
            case rawContent = "RawContent"
            case titleOverride = "TitleOverride"
            case bodyOverride = "BodyOverride"
            case context = "Context"
        }
    }

    public struct CreateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct GetSmsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct EndpointLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PostalCode", required: false, type: .string), 
            AWSShapeMember(label: "Latitude", required: false, type: .double), 
            AWSShapeMember(label: "City", required: false, type: .string), 
            AWSShapeMember(label: "Region", required: false, type: .string), 
            AWSShapeMember(label: "Longitude", required: false, type: .double), 
            AWSShapeMember(label: "Country", required: false, type: .string)
        ]
        /// The postal code or zip code of the endpoint.
        public let postalCode: String?
        /// The latitude of the endpoint location. Rounded to one decimal (Roughly corresponding to a mile).
        public let latitude: Double?
        /// The city where the endpoint is located.
        public let city: String?
        /// The region of the endpoint location. For example, corresponds to a state in US.
        public let region: String?
        /// The longitude of the endpoint location. Rounded to one decimal (Roughly corresponding to a mile).
        public let longitude: Double?
        /// Country according to ISO 3166-1 Alpha-2 codes. For example, US.
        public let country: String?

        public init(postalCode: String? = nil, latitude: Double? = nil, city: String? = nil, region: String? = nil, longitude: Double? = nil, country: String? = nil) {
            self.postalCode = postalCode
            self.latitude = latitude
            self.city = city
            self.region = region
            self.longitude = longitude
            self.country = country
        }

        private enum CodingKeys: String, CodingKey {
            case postalCode = "PostalCode"
            case latitude = "Latitude"
            case city = "City"
            case region = "Region"
            case longitude = "Longitude"
            case country = "Country"
        }
    }

    public struct ChannelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", required: false, type: .map)
        ]
        /// A map of channels, with the ChannelType as the key and the Channel as the value.
        public let channels: [String: ChannelResponse]?

        public init(channels: [String: ChannelResponse]? = nil) {
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
        }
    }

    public struct SendMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let messageRequest: MessageRequest
        public let applicationId: String

        public init(messageRequest: MessageRequest, applicationId: String) {
            self.messageRequest = messageRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case messageRequest = "MessageRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateApnsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSChannelRequest: APNSChannelRequest
        public let applicationId: String

        public init(aPNSChannelRequest: APNSChannelRequest, applicationId: String) {
            self.aPNSChannelRequest = aPNSChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelRequest = "APNSChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct UpdateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct EmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Identity", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// The ARN of an identity verified with SES.
        public let identity: String?
        /// The ARN of an IAM Role used to submit events to Mobile Analytics' event ingestion service
        public let roleArn: String?
        /// The email address used to send emails from.
        public let fromAddress: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(identity: String? = nil, roleArn: String? = nil, fromAddress: String? = nil, enabled: Bool? = nil) {
            self.identity = identity
            self.roleArn = roleArn
            self.fromAddress = fromAddress
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case identity = "Identity"
            case roleArn = "RoleArn"
            case fromAddress = "FromAddress"
            case enabled = "Enabled"
        }
    }

    public struct GetAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct CampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "Hook", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultState", required: false, type: .structure), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer)
        ]
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The campaign limits settings.
        public let limits: CampaignLimits?
        /// The campaign status.
        /// An A/B test campaign will have a status of COMPLETED only when all treatments have a status of COMPLETED.
        public let state: CampaignState?
        /// The custom name of the campaign.
        public let name: String?
        /// The ID of the segment to which the campaign sends messages.
        public let segmentId: String?
        /// Campaign hook information.
        public let hook: CampaignHook?
        /// The status of the campaign's default treatment. Only present for A/B test campaigns.
        public let defaultState: CampaignState?
        /// The campaign version number.
        public let version: Int32?
        /// Indicates whether the campaign is paused. A paused campaign does not send messages unless you resume it by setting IsPaused to false.
        public let isPaused: Bool?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// Treatments that are defined in addition to the default treatment.
        public let additionalTreatments: [TreatmentResource]?
        /// The date the campaign was created in ISO 8601 format.
        public let creationDate: String?
        /// The date the campaign was last updated in ISO 8601 format.	
        public let lastModifiedDate: String?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The unique campaign ID.
        public let id: String?
        /// A description of the campaign.
        public let description: String?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The allocated percentage of end users who will not receive messages from this campaign.
        public let holdoutPercent: Int32?
        /// The ID of the application to which the campaign applies.
        public let applicationId: String?
        /// The version of the segment to which the campaign sends messages.
        public let segmentVersion: Int32?

        public init(treatmentName: String? = nil, limits: CampaignLimits? = nil, state: CampaignState? = nil, name: String? = nil, segmentId: String? = nil, hook: CampaignHook? = nil, defaultState: CampaignState? = nil, version: Int32? = nil, isPaused: Bool? = nil, messageConfiguration: MessageConfiguration? = nil, additionalTreatments: [TreatmentResource]? = nil, creationDate: String? = nil, lastModifiedDate: String? = nil, treatmentDescription: String? = nil, id: String? = nil, description: String? = nil, schedule: Schedule? = nil, holdoutPercent: Int32? = nil, applicationId: String? = nil, segmentVersion: Int32? = nil) {
            self.treatmentName = treatmentName
            self.limits = limits
            self.state = state
            self.name = name
            self.segmentId = segmentId
            self.hook = hook
            self.defaultState = defaultState
            self.version = version
            self.isPaused = isPaused
            self.messageConfiguration = messageConfiguration
            self.additionalTreatments = additionalTreatments
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.treatmentDescription = treatmentDescription
            self.id = id
            self.description = description
            self.schedule = schedule
            self.holdoutPercent = holdoutPercent
            self.applicationId = applicationId
            self.segmentVersion = segmentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case treatmentName = "TreatmentName"
            case limits = "Limits"
            case state = "State"
            case name = "Name"
            case segmentId = "SegmentId"
            case hook = "Hook"
            case defaultState = "DefaultState"
            case version = "Version"
            case isPaused = "IsPaused"
            case messageConfiguration = "MessageConfiguration"
            case additionalTreatments = "AdditionalTreatments"
            case creationDate = "CreationDate"
            case lastModifiedDate = "LastModifiedDate"
            case treatmentDescription = "TreatmentDescription"
            case id = "Id"
            case description = "Description"
            case schedule = "Schedule"
            case holdoutPercent = "HoldoutPercent"
            case applicationId = "ApplicationId"
            case segmentVersion = "SegmentVersion"
        }
    }

    public struct ExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "S3UrlPrefix", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The ID of the segment to export endpoints from. If not present, Amazon Pinpoint exports all of the endpoints that belong to the application.
        public let segmentId: String?
        /// A URL that points to the location within an Amazon S3 bucket that will receive the export. The location is typically a folder with multiple files.
        /// The URL should follow this format: s3://bucket-name/folder-name/
        /// Amazon Pinpoint will export endpoints to this location.
        public let s3UrlPrefix: String?
        /// The version of the segment to export if specified.
        public let segmentVersion: Int32?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that endpoints will be exported to.
        public let roleArn: String?

        public init(segmentId: String? = nil, s3UrlPrefix: String? = nil, segmentVersion: Int32? = nil, roleArn: String? = nil) {
            self.segmentId = segmentId
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentVersion = segmentVersion
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case segmentId = "SegmentId"
            case s3UrlPrefix = "S3UrlPrefix"
            case segmentVersion = "SegmentVersion"
            case roleArn = "RoleArn"
        }
    }

    public struct DeleteAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]
        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct SegmentsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// An identifier used to retrieve the next page of results. The token is null if no additional pages exist.
        public let nextToken: String?
        /// The list of segments.
        public let item: [SegmentResponse]?

        public init(nextToken: String? = nil, item: [SegmentResponse]? = nil) {
            self.nextToken = nextToken
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case item = "Item"
        }
    }

    public struct GetAppsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationsResponse", required: true, type: .structure)
        ]
        public let applicationsResponse: ApplicationsResponse

        public init(applicationsResponse: ApplicationsResponse) {
            self.applicationsResponse = applicationsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationsResponse = "ApplicationsResponse"
        }
    }

    public struct SetDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Values", required: false, type: .list), 
            AWSShapeMember(label: "DimensionType", required: false, type: .enum)
        ]
        /// The criteria values for the segment dimension. Endpoints with matching attribute values are included or excluded from the segment, depending on the setting for Type.
        public let values: [String]?
        /// The type of dimension:
        /// INCLUSIVE - Endpoints that match the criteria are included in the segment.
        /// EXCLUSIVE - Endpoints that match the criteria are excluded from the segment.
        public let dimensionType: DimensionType?

        public init(values: [String]? = nil, dimensionType: DimensionType? = nil) {
            self.values = values
            self.dimensionType = dimensionType
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
            case dimensionType = "DimensionType"
        }
    }

    public struct CreateImportJobRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let importJobRequest: ImportJobRequest
        public let applicationId: String

        public init(importJobRequest: ImportJobRequest, applicationId: String) {
            self.importJobRequest = importJobRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case importJobRequest = "ImportJobRequest"
            case applicationId = "application-id"
        }
    }

    public struct GetGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct SegmentReference: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// Segment Id.
        public let id: String?
        /// If specified contains a specific version of the segment included.
        public let version: Int32?

        public init(id: String? = nil, version: Int32? = nil) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case version = "Version"
        }
    }

    public struct DeleteApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public enum CampaignStatus: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case executing = "EXECUTING"
        case pendingNextRun = "PENDING_NEXT_RUN"
        case completed = "COMPLETED"
        case paused = "PAUSED"
        case deleted = "DELETED"
        public var description: String { return self.rawValue }
    }

    public struct DefaultPushNotificationMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string)
        ]
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The message title that displays above the message on the user's device.
        public let title: String?

        public init(body: String? = nil, substitutions: [String: [String]]? = nil, url: String? = nil, action: Action? = nil, silentPush: Bool? = nil, data: [String: String]? = nil, title: String? = nil) {
            self.body = body
            self.substitutions = substitutions
            self.url = url
            self.action = action
            self.silentPush = silentPush
            self.data = data
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case substitutions = "Substitutions"
            case url = "Url"
            case action = "Action"
            case silentPush = "SilentPush"
            case data = "Data"
            case title = "Title"
        }
    }

    public struct UpdateEndpointsBatchRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointBatchRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointBatchRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointBatchRequest: EndpointBatchRequest
        public let applicationId: String

        public init(endpointBatchRequest: EndpointBatchRequest, applicationId: String) {
            self.endpointBatchRequest = endpointBatchRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case endpointBatchRequest = "EndpointBatchRequest"
            case applicationId = "application-id"
        }
    }

    public struct GetCampaignVersionResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct GetAppsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string)
        ]
        public let token: String?
        public let pageSize: String?

        public init(token: String? = nil, pageSize: String? = nil) {
            self.token = token
            self.pageSize = pageSize
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case pageSize = "page-size"
        }
    }

    public struct GetEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct NumberValidateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IsoCountryCode", required: false, type: .string), 
            AWSShapeMember(label: "PhoneNumber", required: false, type: .string)
        ]
        /// (Optional) The two-character ISO country code for the country where the phone number was originally registered.
        public let isoCountryCode: String?
        /// The phone number to get information about.
        public let phoneNumber: String?

        public init(isoCountryCode: String? = nil, phoneNumber: String? = nil) {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
        }

        private enum CodingKeys: String, CodingKey {
            case isoCountryCode = "IsoCountryCode"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct DeleteEventStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct APNSMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "CollapseId", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "Badge", required: false, type: .integer), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "MediaUrl", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "ThreadId", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .string), 
            AWSShapeMember(label: "PreferredAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Category", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// An ID that, if assigned to multiple messages, causes APNs to coalesce the messages into a single push notification instead of delivering each message individually. The value must not exceed 64 bytes. Amazon Pinpoint uses this value to set the apns-collapse-id request header when it sends the message to APNs.
        public let collapseId: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Include this key when you want the system to modify the badge of your app icon. If this key is not included in the dictionary, the badge is not changed. To remove the badge, set the value of this key to 0.
        public let badge: Int32?
        /// The length of time (in seconds) that APNs stores and attempts to deliver the message. If the value is 0, APNs does not store the message or attempt to deliver it more than once. Amazon Pinpoint uses this value to set the apns-expiration request header when it sends the message to APNs.
        public let timeToLive: Int32?
        /// The URL that points to a video used in the push notification.
        public let mediaUrl: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// Provide this key with a string value that represents the app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.
        public let threadId: String?
        /// The message priority. Amazon Pinpoint uses this value to set the apns-priority request header when it sends the message to APNs. Accepts the following values:
        /// "5" - Low priority. Messages might be delayed, delivered in groups, and throttled.
        /// "10" - High priority. Messages are sent immediately. High priority messages must cause an alert, sound, or badge on the receiving device.
        /// The default value is "10".
        /// The equivalent values for FCM or GCM messages are "normal" and "high". Amazon Pinpoint accepts these values for APNs messages and converts them.
        /// For more information about the apns-priority parameter, see Communicating with APNs in the APNs Local and Remote Notification Programming Guide.
        public let priority: String?
        /// The preferred authentication method, either "CERTIFICATE" or "TOKEN"
        public let preferredAuthenticationMethod: String?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// Provide this key with a string value that represents the notification's type. This value corresponds to the value in the identifier property of one of your app's registered categories.
        public let category: String?
        /// Include this key when you want the system to play a sound. The value of this key is the name of a sound file in your app's main bundle or in the Library/Sounds folder of your app's data container. If the sound file cannot be found, or if you specify defaultfor the value, the system plays the default alert sound.
        public let sound: String?

        public init(action: Action? = nil, collapseId: String? = nil, silentPush: Bool? = nil, rawContent: String? = nil, badge: Int32? = nil, timeToLive: Int32? = nil, mediaUrl: String? = nil, url: String? = nil, substitutions: [String: [String]]? = nil, threadId: String? = nil, priority: String? = nil, preferredAuthenticationMethod: String? = nil, title: String? = nil, data: [String: String]? = nil, body: String? = nil, category: String? = nil, sound: String? = nil) {
            self.action = action
            self.collapseId = collapseId
            self.silentPush = silentPush
            self.rawContent = rawContent
            self.badge = badge
            self.timeToLive = timeToLive
            self.mediaUrl = mediaUrl
            self.url = url
            self.substitutions = substitutions
            self.threadId = threadId
            self.priority = priority
            self.preferredAuthenticationMethod = preferredAuthenticationMethod
            self.title = title
            self.data = data
            self.body = body
            self.category = category
            self.sound = sound
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case collapseId = "CollapseId"
            case silentPush = "SilentPush"
            case rawContent = "RawContent"
            case badge = "Badge"
            case timeToLive = "TimeToLive"
            case mediaUrl = "MediaUrl"
            case url = "Url"
            case substitutions = "Substitutions"
            case threadId = "ThreadId"
            case priority = "Priority"
            case preferredAuthenticationMethod = "PreferredAuthenticationMethod"
            case title = "Title"
            case data = "Data"
            case body = "Body"
            case category = "Category"
            case sound = "Sound"
        }
    }

    public struct DeleteUserEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserId", location: .uri(locationName: "user-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let userId: String
        public let applicationId: String

        public init(userId: String, applicationId: String) {
            self.userId = userId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "user-id"
            case applicationId = "application-id"
        }
    }

    public struct SendMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageResponse", required: true, type: .structure)
        ]
        public let messageResponse: MessageResponse

        public init(messageResponse: MessageResponse) {
            self.messageResponse = messageResponse
        }

        private enum CodingKeys: String, CodingKey {
            case messageResponse = "MessageResponse"
        }
    }

    public struct SegmentDemographics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeviceType", required: false, type: .structure), 
            AWSShapeMember(label: "Make", required: false, type: .structure), 
            AWSShapeMember(label: "Platform", required: false, type: .structure), 
            AWSShapeMember(label: "Model", required: false, type: .structure), 
            AWSShapeMember(label: "Channel", required: false, type: .structure), 
            AWSShapeMember(label: "AppVersion", required: false, type: .structure)
        ]
        /// The device type criteria for the segment.
        public let deviceType: SetDimension?
        /// The device make criteria for the segment.
        public let make: SetDimension?
        /// The device platform criteria for the segment.
        public let platform: SetDimension?
        /// The device model criteria for the segment.
        public let model: SetDimension?
        /// The channel criteria for the segment.
        public let channel: SetDimension?
        /// The app version criteria for the segment.
        public let appVersion: SetDimension?

        public init(deviceType: SetDimension? = nil, make: SetDimension? = nil, platform: SetDimension? = nil, model: SetDimension? = nil, channel: SetDimension? = nil, appVersion: SetDimension? = nil) {
            self.deviceType = deviceType
            self.make = make
            self.platform = platform
            self.model = model
            self.channel = channel
            self.appVersion = appVersion
        }

        private enum CodingKeys: String, CodingKey {
            case deviceType = "DeviceType"
            case make = "Make"
            case platform = "Platform"
            case model = "Model"
            case channel = "Channel"
            case appVersion = "AppVersion"
        }
    }

    public struct PutEventStreamRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteEventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WriteEventStream", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let writeEventStream: WriteEventStream
        public let applicationId: String

        public init(writeEventStream: WriteEventStream, applicationId: String) {
            self.writeEventStream = writeEventStream
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case writeEventStream = "WriteEventStream"
            case applicationId = "application-id"
        }
    }

    public struct DeleteBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]
        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct EndpointUser: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserAttributes", required: false, type: .map), 
            AWSShapeMember(label: "UserId", required: false, type: .string)
        ]
        /// Custom attributes that describe an end user by associating a name with an array of values. For example, an attribute named "interests" might have the values ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create a segment of users to engage with a messaging campaign.
        /// The following characters are not recommended in attribute names: # : ? \ /. The Amazon Pinpoint console does not display attributes that include these characters in the name. This limitation does not apply to attribute values.
        public let userAttributes: [String: [String]]?
        /// The unique ID of the user.
        public let userId: String?

        public init(userAttributes: [String: [String]]? = nil, userId: String? = nil) {
            self.userAttributes = userAttributes
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userAttributes = "UserAttributes"
            case userId = "UserId"
        }
    }

    public struct GetSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct GetApnsVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct SendUsersMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SendUsersMessageRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SendUsersMessageRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let sendUsersMessageRequest: SendUsersMessageRequest
        public let applicationId: String

        public init(sendUsersMessageRequest: SendUsersMessageRequest, applicationId: String) {
            self.sendUsersMessageRequest = sendUsersMessageRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case sendUsersMessageRequest = "SendUsersMessageRequest"
            case applicationId = "application-id"
        }
    }

    public struct ADMChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// Platform type. Will be "ADM"
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Is this channel archived
        public let isArchived: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(lastModifiedDate: String? = nil, applicationId: String? = nil, platform: String? = nil, creationDate: String? = nil, hasCredential: Bool? = nil, isArchived: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.platform = platform
            self.creationDate = creationDate
            self.hasCredential = hasCredential
            self.isArchived = isArchived
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case hasCredential = "HasCredential"
            case isArchived = "IsArchived"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct UpdateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct DeleteApnsVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public enum DeliveryStatus: String, CustomStringConvertible, Codable {
        case successful = "SUCCESSFUL"
        case throttled = "THROTTLED"
        case temporaryFailure = "TEMPORARY_FAILURE"
        case permanentFailure = "PERMANENT_FAILURE"
        case unknownFailure = "UNKNOWN_FAILURE"
        case optOut = "OPT_OUT"
        case duplicate = "DUPLICATE"
        public var description: String { return self.rawValue }
    }

    public struct GetSegmentVersionResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct TreatmentResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "State", required: false, type: .structure), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "SizePercent", required: false, type: .integer), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]
        /// The treatment status.
        public let state: CampaignState?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The allocated percentage of users for this treatment.
        public let sizePercent: Int32?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The unique treatment ID.
        public let id: String?

        public init(state: CampaignState? = nil, messageConfiguration: MessageConfiguration? = nil, treatmentName: String? = nil, sizePercent: Int32? = nil, schedule: Schedule? = nil, treatmentDescription: String? = nil, id: String? = nil) {
            self.state = state
            self.messageConfiguration = messageConfiguration
            self.treatmentName = treatmentName
            self.sizePercent = sizePercent
            self.schedule = schedule
            self.treatmentDescription = treatmentDescription
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case messageConfiguration = "MessageConfiguration"
            case treatmentName = "TreatmentName"
            case sizePercent = "SizePercent"
            case schedule = "Schedule"
            case treatmentDescription = "TreatmentDescription"
            case id = "Id"
        }
    }

    public struct GetCampaignActivitiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string)
        ]
        public let token: String?
        public let applicationId: String
        public let pageSize: String?
        public let campaignId: String

        public init(token: String? = nil, applicationId: String, pageSize: String? = nil, campaignId: String) {
            self.token = token
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.campaignId = campaignId
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case applicationId = "application-id"
            case pageSize = "page-size"
            case campaignId = "campaign-id"
        }
    }

    public struct DeleteAppRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct CreateAppRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CreateApplicationRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreateApplicationRequest", required: true, type: .structure)
        ]
        public let createApplicationRequest: CreateApplicationRequest

        public init(createApplicationRequest: CreateApplicationRequest) {
            self.createApplicationRequest = createApplicationRequest
        }

        private enum CodingKeys: String, CodingKey {
            case createApplicationRequest = "CreateApplicationRequest"
        }
    }

    public struct DeleteSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let segmentId: String
        public let applicationId: String

        public init(segmentId: String, applicationId: String) {
            self.segmentId = segmentId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case segmentId = "segment-id"
            case applicationId = "application-id"
        }
    }

    public struct GetExportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobsResponse", required: true, type: .structure)
        ]
        public let exportJobsResponse: ExportJobsResponse

        public init(exportJobsResponse: ExportJobsResponse) {
            self.exportJobsResponse = exportJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobsResponse = "ExportJobsResponse"
        }
    }

    public struct GetAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]
        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct ApplicationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?
        /// List of applications returned in this page.
        public let item: [ApplicationResponse]?

        public init(nextToken: String? = nil, item: [ApplicationResponse]? = nil) {
            self.nextToken = nextToken
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case item = "Item"
        }
    }

    public struct DeleteEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EventStream"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        private enum CodingKeys: String, CodingKey {
            case eventStream = "EventStream"
        }
    }

    public struct GetImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let pageSize: String?
        public let token: String?
        public let applicationId: String

        public init(pageSize: String? = nil, token: String? = nil, applicationId: String) {
            self.pageSize = pageSize
            self.token = token
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "page-size"
            case token = "token"
            case applicationId = "application-id"
        }
    }

    public struct ADMMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "MD5", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "ExpiresAfter", required: false, type: .string), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string), 
            AWSShapeMember(label: "ConsolidationKey", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// Optional. Base-64-encoded MD5 checksum of the data parameter. Used to verify data integrity
        public let md5: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// Optional. Number of seconds ADM should retain the message if the device is offline
        public let expiresAfter: String?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?
        /// Optional. Arbitrary string used to indicate multiple messages are logically the same and that ADM is allowed to drop previously enqueued messages in favor of this one.
        public let consolidationKey: String?

        public init(action: Action? = nil, silentPush: Bool? = nil, rawContent: String? = nil, url: String? = nil, imageUrl: String? = nil, substitutions: [String: [String]]? = nil, md5: String? = nil, data: [String: String]? = nil, title: String? = nil, imageIconUrl: String? = nil, expiresAfter: String? = nil, body: String? = nil, smallImageIconUrl: String? = nil, iconReference: String? = nil, sound: String? = nil, consolidationKey: String? = nil) {
            self.action = action
            self.silentPush = silentPush
            self.rawContent = rawContent
            self.url = url
            self.imageUrl = imageUrl
            self.substitutions = substitutions
            self.md5 = md5
            self.data = data
            self.title = title
            self.imageIconUrl = imageIconUrl
            self.expiresAfter = expiresAfter
            self.body = body
            self.smallImageIconUrl = smallImageIconUrl
            self.iconReference = iconReference
            self.sound = sound
            self.consolidationKey = consolidationKey
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case silentPush = "SilentPush"
            case rawContent = "RawContent"
            case url = "Url"
            case imageUrl = "ImageUrl"
            case substitutions = "Substitutions"
            case md5 = "MD5"
            case data = "Data"
            case title = "Title"
            case imageIconUrl = "ImageIconUrl"
            case expiresAfter = "ExpiresAfter"
            case body = "Body"
            case smallImageIconUrl = "SmallImageIconUrl"
            case iconReference = "IconReference"
            case sound = "Sound"
            case consolidationKey = "ConsolidationKey"
        }
    }

    public struct GetApnsVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteSmsChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct GetSegmentImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobsResponse", required: true, type: .structure)
        ]
        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobsResponse = "ImportJobsResponse"
        }
    }

    public struct GetCampaignsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let pageSize: String?
        public let token: String?
        public let applicationId: String

        public init(pageSize: String? = nil, token: String? = nil, applicationId: String) {
            self.pageSize = pageSize
            self.token = token
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "page-size"
            case token = "token"
            case applicationId = "application-id"
        }
    }

    public struct UpdateAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]
        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct Schedule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Frequency", required: false, type: .enum), 
            AWSShapeMember(label: "EndTime", required: false, type: .string), 
            AWSShapeMember(label: "IsLocalTime", required: false, type: .boolean), 
            AWSShapeMember(label: "Timezone", required: false, type: .string), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure), 
            AWSShapeMember(label: "StartTime", required: false, type: .string)
        ]
        /// How often the campaign delivers messages.
        /// Valid values: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY
        public let frequency: Frequency?
        /// The scheduled time that the campaign ends in ISO 8601 format.
        public let endTime: String?
        /// Indicates whether the campaign schedule takes effect according to each user's local time.
        public let isLocalTime: Bool?
        /// The starting UTC offset for the schedule if the value for isLocalTime is true
        /// Valid values: 
        /// UTC
        /// UTC+01
        /// UTC+02
        /// UTC+03
        /// UTC+03:30
        /// UTC+04
        /// UTC+04:30
        /// UTC+05
        /// UTC+05:30
        /// UTC+05:45
        /// UTC+06
        /// UTC+06:30
        /// UTC+07
        /// UTC+08
        /// UTC+09
        /// UTC+09:30
        /// UTC+10
        /// UTC+10:30
        /// UTC+11
        /// UTC+12
        /// UTC+13
        /// UTC-02
        /// UTC-03
        /// UTC-04
        /// UTC-05
        /// UTC-06
        /// UTC-07
        /// UTC-08
        /// UTC-09
        /// UTC-10
        /// UTC-11
        public let timezone: String?
        /// The time during which the campaign sends no messages.
        public let quietTime: QuietTime?
        /// The scheduled time that the campaign begins in ISO 8601 format.
        public let startTime: String?

        public init(frequency: Frequency? = nil, endTime: String? = nil, isLocalTime: Bool? = nil, timezone: String? = nil, quietTime: QuietTime? = nil, startTime: String? = nil) {
            self.frequency = frequency
            self.endTime = endTime
            self.isLocalTime = isLocalTime
            self.timezone = timezone
            self.quietTime = quietTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case frequency = "Frequency"
            case endTime = "EndTime"
            case isLocalTime = "IsLocalTime"
            case timezone = "Timezone"
            case quietTime = "QuietTime"
            case startTime = "StartTime"
        }
    }

    public struct EndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// The list of endpoints.
        public let item: [EndpointResponse]?

        public init(item: [EndpointResponse]? = nil) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct SMSMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "MessageType", required: false, type: .enum), 
            AWSShapeMember(label: "Keyword", required: false, type: .string), 
            AWSShapeMember(label: "OriginationNumber", required: false, type: .string), 
            AWSShapeMember(label: "Body", required: false, type: .string)
        ]
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The sender ID that is shown as the message sender on the recipient's device. Support for sender IDs varies by country or region.
        public let senderId: String?
        /// Is this a transaction priority message or lower priority.
        public let messageType: MessageType?
        /// The SMS program name that you provided to AWS Support when you requested your dedicated number.
        public let keyword: String?
        /// The phone number that the SMS message originates from. Specify one of the dedicated long codes or short codes that you requested from AWS Support and that is assigned to your account. If this attribute is not specified, Amazon Pinpoint randomly assigns a long code.
        public let originationNumber: String?
        /// The body of the SMS message.
        public let body: String?

        public init(substitutions: [String: [String]]? = nil, senderId: String? = nil, messageType: MessageType? = nil, keyword: String? = nil, originationNumber: String? = nil, body: String? = nil) {
            self.substitutions = substitutions
            self.senderId = senderId
            self.messageType = messageType
            self.keyword = keyword
            self.originationNumber = originationNumber
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case substitutions = "Substitutions"
            case senderId = "SenderId"
            case messageType = "MessageType"
            case keyword = "Keyword"
            case originationNumber = "OriginationNumber"
            case body = "Body"
        }
    }

    public struct AddressConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "TitleOverride", required: false, type: .string), 
            AWSShapeMember(label: "BodyOverride", required: false, type: .string), 
            AWSShapeMember(label: "Context", required: false, type: .map)
        ]
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// A map of substitution values for the message to be merged with the DefaultMessage's substitutions. Substitutions on this map take precedence over the all other substitutions.
        public let substitutions: [String: [String]]?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Title override. If specified will override default title if applicable.
        public let titleOverride: String?
        /// Body override. If specified will override default body.
        public let bodyOverride: String?
        /// A map of custom attributes to attributes to be attached to the message for this address. This payload is added to the push notification's 'data.pinpoint' object or added to the email/sms delivery receipt event attributes.
        public let context: [String: String]?

        public init(channelType: ChannelType? = nil, substitutions: [String: [String]]? = nil, rawContent: String? = nil, titleOverride: String? = nil, bodyOverride: String? = nil, context: [String: String]? = nil) {
            self.channelType = channelType
            self.substitutions = substitutions
            self.rawContent = rawContent
            self.titleOverride = titleOverride
            self.bodyOverride = bodyOverride
            self.context = context
        }

        private enum CodingKeys: String, CodingKey {
            case channelType = "ChannelType"
            case substitutions = "Substitutions"
            case rawContent = "RawContent"
            case titleOverride = "TitleOverride"
            case bodyOverride = "BodyOverride"
            case context = "Context"
        }
    }

    public struct GetEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointId: String
        public let applicationId: String

        public init(endpointId: String, applicationId: String) {
            self.endpointId = endpointId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case endpointId = "endpoint-id"
            case applicationId = "application-id"
        }
    }

    public struct CampaignLimits: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Total", required: false, type: .integer), 
            AWSShapeMember(label: "MaximumDuration", required: false, type: .integer), 
            AWSShapeMember(label: "Daily", required: false, type: .integer), 
            AWSShapeMember(label: "MessagesPerSecond", required: false, type: .integer)
        ]
        /// The maximum total number of messages that the campaign can send.
        public let total: Int32?
        /// The length of time (in seconds) that the campaign can run before it ends and message deliveries stop. This duration begins at the scheduled start time for the campaign. The minimum value is 60.
        public let maximumDuration: Int32?
        /// The maximum number of messages that the campaign can send daily.
        public let daily: Int32?
        /// The number of messages that the campaign can send per second. The minimum value is 50, and the maximum is 20000.
        public let messagesPerSecond: Int32?

        public init(total: Int32? = nil, maximumDuration: Int32? = nil, daily: Int32? = nil, messagesPerSecond: Int32? = nil) {
            self.total = total
            self.maximumDuration = maximumDuration
            self.daily = daily
            self.messagesPerSecond = messagesPerSecond
        }

        private enum CodingKeys: String, CodingKey {
            case total = "Total"
            case maximumDuration = "MaximumDuration"
            case daily = "Daily"
            case messagesPerSecond = "MessagesPerSecond"
        }
    }

    public struct UpdateApnsSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSSandboxChannelRequest: APNSSandboxChannelRequest
        public let applicationId: String

        public init(aPNSSandboxChannelRequest: APNSSandboxChannelRequest, applicationId: String) {
            self.aPNSSandboxChannelRequest = aPNSSandboxChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelRequest = "APNSSandboxChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct APNSVoipSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The certificate private key.
        public let privateKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?

        public init(bundleId: String? = nil, defaultAuthenticationMethod: String? = nil, certificate: String? = nil, teamId: String? = nil, privateKey: String? = nil, enabled: Bool? = nil, tokenKeyId: String? = nil, tokenKey: String? = nil) {
            self.bundleId = bundleId
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.certificate = certificate
            self.teamId = teamId
            self.privateKey = privateKey
            self.enabled = enabled
            self.tokenKeyId = tokenKeyId
            self.tokenKey = tokenKey
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case certificate = "Certificate"
            case teamId = "TeamId"
            case privateKey = "PrivateKey"
            case enabled = "Enabled"
            case tokenKeyId = "TokenKeyId"
            case tokenKey = "TokenKey"
        }
    }

    public struct SendUsersMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SendUsersMessageResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SendUsersMessageResponse", required: true, type: .structure)
        ]
        public let sendUsersMessageResponse: SendUsersMessageResponse

        public init(sendUsersMessageResponse: SendUsersMessageResponse) {
            self.sendUsersMessageResponse = sendUsersMessageResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sendUsersMessageResponse = "SendUsersMessageResponse"
        }
    }

    public struct UpdateAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Blacklist", required: false, type: .list)
        ]
        /// The GLOB wildcard for removing the attributes in the application
        public let blacklist: [String]?

        public init(blacklist: [String]? = nil) {
            self.blacklist = blacklist
        }

        private enum CodingKeys: String, CodingKey {
            case blacklist = "Blacklist"
        }
    }

    public struct APNSChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The certificate private key.
        public let privateKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?

        public init(bundleId: String? = nil, defaultAuthenticationMethod: String? = nil, certificate: String? = nil, teamId: String? = nil, privateKey: String? = nil, enabled: Bool? = nil, tokenKeyId: String? = nil, tokenKey: String? = nil) {
            self.bundleId = bundleId
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.certificate = certificate
            self.teamId = teamId
            self.privateKey = privateKey
            self.enabled = enabled
            self.tokenKeyId = tokenKeyId
            self.tokenKey = tokenKey
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case certificate = "Certificate"
            case teamId = "TeamId"
            case privateKey = "PrivateKey"
            case enabled = "Enabled"
            case tokenKeyId = "TokenKeyId"
            case tokenKey = "TokenKey"
        }
    }

    public struct EndpointBatchRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// List of items to update. Maximum 100 items
        public let item: [EndpointBatchItem]?

        public init(item: [EndpointBatchItem]? = nil) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct NumberValidateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CountryCodeNumeric", required: false, type: .string), 
            AWSShapeMember(label: "CleansedPhoneNumberE164", required: false, type: .string), 
            AWSShapeMember(label: "PhoneTypeCode", required: false, type: .integer), 
            AWSShapeMember(label: "County", required: false, type: .string), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "ZipCode", required: false, type: .string), 
            AWSShapeMember(label: "CountryCodeIso2", required: false, type: .string), 
            AWSShapeMember(label: "OriginalCountryCodeIso2", required: false, type: .string), 
            AWSShapeMember(label: "PhoneType", required: false, type: .string), 
            AWSShapeMember(label: "Carrier", required: false, type: .string), 
            AWSShapeMember(label: "CleansedPhoneNumberNational", required: false, type: .string), 
            AWSShapeMember(label: "Timezone", required: false, type: .string), 
            AWSShapeMember(label: "OriginalPhoneNumber", required: false, type: .string), 
            AWSShapeMember(label: "City", required: false, type: .string)
        ]
        /// The numeric country code for the country where the phone number was originally registered.
        public let countryCodeNumeric: String?
        /// The cleansed (standardized) phone number in E.164 format.
        public let cleansedPhoneNumberE164: String?
        /// The phone type as an integer. Possible values include 0 (MOBILE), 1 (LANDLINE), 2 (VOIP), 3 (INVALID), and 4 (OTHER).
        public let phoneTypeCode: Int32?
        /// The county where the phone number was originally registered.
        public let county: String?
        /// The country where the phone number was originally registered.
        public let country: String?
        /// The zip code for the location where the phone number was originally registered.
        public let zipCode: String?
        /// The two-character ISO country code for the country where the phone number was originally registered.
        public let countryCodeIso2: String?
        /// The two-character ISO country code that was included in the request body.
        public let originalCountryCodeIso2: String?
        /// A description of the phone type. Possible values include MOBILE, LANDLINE, VOIP, INVALID, and OTHER.
        public let phoneType: String?
        /// The carrier that the phone number is registered with.
        public let carrier: String?
        /// The cleansed phone number in national format.
        public let cleansedPhoneNumberNational: String?
        /// The time zone for the location where the phone number was originally registered.
        public let timezone: String?
        /// The phone number that you included in the request body.
        public let originalPhoneNumber: String?
        /// The city where the phone number was originally registered.
        public let city: String?

        public init(countryCodeNumeric: String? = nil, cleansedPhoneNumberE164: String? = nil, phoneTypeCode: Int32? = nil, county: String? = nil, country: String? = nil, zipCode: String? = nil, countryCodeIso2: String? = nil, originalCountryCodeIso2: String? = nil, phoneType: String? = nil, carrier: String? = nil, cleansedPhoneNumberNational: String? = nil, timezone: String? = nil, originalPhoneNumber: String? = nil, city: String? = nil) {
            self.countryCodeNumeric = countryCodeNumeric
            self.cleansedPhoneNumberE164 = cleansedPhoneNumberE164
            self.phoneTypeCode = phoneTypeCode
            self.county = county
            self.country = country
            self.zipCode = zipCode
            self.countryCodeIso2 = countryCodeIso2
            self.originalCountryCodeIso2 = originalCountryCodeIso2
            self.phoneType = phoneType
            self.carrier = carrier
            self.cleansedPhoneNumberNational = cleansedPhoneNumberNational
            self.timezone = timezone
            self.originalPhoneNumber = originalPhoneNumber
            self.city = city
        }

        private enum CodingKeys: String, CodingKey {
            case countryCodeNumeric = "CountryCodeNumeric"
            case cleansedPhoneNumberE164 = "CleansedPhoneNumberE164"
            case phoneTypeCode = "PhoneTypeCode"
            case county = "County"
            case country = "Country"
            case zipCode = "ZipCode"
            case countryCodeIso2 = "CountryCodeIso2"
            case originalCountryCodeIso2 = "OriginalCountryCodeIso2"
            case phoneType = "PhoneType"
            case carrier = "Carrier"
            case cleansedPhoneNumberNational = "CleansedPhoneNumberNational"
            case timezone = "Timezone"
            case originalPhoneNumber = "OriginalPhoneNumber"
            case city = "City"
        }
    }

    public struct APNSSandboxChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// The platform type. Will be APNS_SANDBOX.
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Indicates whether the channel is configured with a key for APNs token authentication. Provide a token key by setting the TokenKey attribute.
        public let hasTokenKey: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(defaultAuthenticationMethod: String? = nil, lastModifiedDate: String? = nil, applicationId: String? = nil, platform: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.platform = platform
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case isArchived = "IsArchived"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct CreateExportJobRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "ExportJobRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let exportJobRequest: ExportJobRequest

        public init(applicationId: String, exportJobRequest: ExportJobRequest) {
            self.applicationId = applicationId
            self.exportJobRequest = exportJobRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case exportJobRequest = "ExportJobRequest"
        }
    }

    public struct GetCampaignVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "Version", location: .uri(locationName: "version"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let campaignId: String
        public let version: String
        public let applicationId: String

        public init(campaignId: String, version: String, applicationId: String) {
            self.campaignId = campaignId
            self.version = version
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "campaign-id"
            case version = "version"
            case applicationId = "application-id"
        }
    }

    public struct CreateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct ApplicationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The unique application ID.
        public let id: String?
        /// The display name of the application.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DeleteApnsVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct WriteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "Hook", required: false, type: .structure), 
            AWSShapeMember(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer)
        ]
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The campaign limits settings.
        public let limits: CampaignLimits?
        /// The custom name of the campaign.
        public let name: String?
        /// The ID of the segment to which the campaign sends messages.
        public let segmentId: String?
        /// Campaign hook information.
        public let hook: CampaignHook?
        /// Indicates whether the campaign is paused. A paused campaign does not send messages unless you resume it by setting IsPaused to false.
        public let isPaused: Bool?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// Treatments that are defined in addition to the default treatment.
        public let additionalTreatments: [WriteTreatmentResource]?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// A description of the campaign.
        public let description: String?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The allocated percentage of end users who will not receive messages from this campaign.
        public let holdoutPercent: Int32?
        /// The version of the segment to which the campaign sends messages.
        public let segmentVersion: Int32?

        public init(treatmentName: String? = nil, limits: CampaignLimits? = nil, name: String? = nil, segmentId: String? = nil, hook: CampaignHook? = nil, isPaused: Bool? = nil, messageConfiguration: MessageConfiguration? = nil, additionalTreatments: [WriteTreatmentResource]? = nil, treatmentDescription: String? = nil, description: String? = nil, schedule: Schedule? = nil, holdoutPercent: Int32? = nil, segmentVersion: Int32? = nil) {
            self.treatmentName = treatmentName
            self.limits = limits
            self.name = name
            self.segmentId = segmentId
            self.hook = hook
            self.isPaused = isPaused
            self.messageConfiguration = messageConfiguration
            self.additionalTreatments = additionalTreatments
            self.treatmentDescription = treatmentDescription
            self.description = description
            self.schedule = schedule
            self.holdoutPercent = holdoutPercent
            self.segmentVersion = segmentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case treatmentName = "TreatmentName"
            case limits = "Limits"
            case name = "Name"
            case segmentId = "SegmentId"
            case hook = "Hook"
            case isPaused = "IsPaused"
            case messageConfiguration = "MessageConfiguration"
            case additionalTreatments = "AdditionalTreatments"
            case treatmentDescription = "TreatmentDescription"
            case description = "Description"
            case schedule = "Schedule"
            case holdoutPercent = "HoldoutPercent"
            case segmentVersion = "SegmentVersion"
        }
    }

    public struct GetSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public struct RemoveAttributesRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "UpdateAttributesRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UpdateAttributesRequest", required: true, type: .structure), 
            AWSShapeMember(label: "AttributeType", location: .uri(locationName: "attribute-type"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let updateAttributesRequest: UpdateAttributesRequest
        public let attributeType: String
        public let applicationId: String

        public init(updateAttributesRequest: UpdateAttributesRequest, attributeType: String, applicationId: String) {
            self.updateAttributesRequest = updateAttributesRequest
            self.attributeType = attributeType
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case updateAttributesRequest = "UpdateAttributesRequest"
            case attributeType = "attribute-type"
            case applicationId = "application-id"
        }
    }

    public struct MessageConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "ADMMessage", required: false, type: .structure), 
            AWSShapeMember(label: "BaiduMessage", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultMessage", required: false, type: .structure), 
            AWSShapeMember(label: "EmailMessage", required: false, type: .structure), 
            AWSShapeMember(label: "SMSMessage", required: false, type: .structure), 
            AWSShapeMember(label: "GCMMessage", required: false, type: .structure)
        ]
        /// The message that the campaign delivers to APNS channels. Overrides the default message.
        public let aPNSMessage: Message?
        /// The message that the campaign delivers to ADM channels. Overrides the default message.
        public let aDMMessage: Message?
        /// The message that the campaign delivers to Baidu channels. Overrides the default message.
        public let baiduMessage: Message?
        /// The default message for all channels.
        public let defaultMessage: Message?
        /// The email message configuration.
        public let emailMessage: CampaignEmailMessage?
        /// The SMS message configuration.
        public let sMSMessage: CampaignSmsMessage?
        /// The message that the campaign delivers to GCM channels. Overrides the default message.
        public let gCMMessage: Message?

        public init(aPNSMessage: Message? = nil, aDMMessage: Message? = nil, baiduMessage: Message? = nil, defaultMessage: Message? = nil, emailMessage: CampaignEmailMessage? = nil, sMSMessage: CampaignSmsMessage? = nil, gCMMessage: Message? = nil) {
            self.aPNSMessage = aPNSMessage
            self.aDMMessage = aDMMessage
            self.baiduMessage = baiduMessage
            self.defaultMessage = defaultMessage
            self.emailMessage = emailMessage
            self.sMSMessage = sMSMessage
            self.gCMMessage = gCMMessage
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSMessage = "APNSMessage"
            case aDMMessage = "ADMMessage"
            case baiduMessage = "BaiduMessage"
            case defaultMessage = "DefaultMessage"
            case emailMessage = "EmailMessage"
            case sMSMessage = "SMSMessage"
            case gCMMessage = "GCMMessage"
        }
    }

    public struct GetSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let segmentId: String
        public let applicationId: String

        public init(segmentId: String, applicationId: String) {
            self.segmentId = segmentId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case segmentId = "segment-id"
            case applicationId = "application-id"
        }
    }

    public struct UpdateEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "MessageBody"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageBody", required: true, type: .structure)
        ]
        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        private enum CodingKeys: String, CodingKey {
            case messageBody = "MessageBody"
        }
    }

    public struct GetCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct MessageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "EndpointResult", required: false, type: .map), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Result", required: false, type: .map)
        ]
        /// Original request Id for which this message was delivered.
        public let requestId: String?
        /// A map containing a multi part response for each address, with the endpointId as the key and the result as the value.
        public let endpointResult: [String: EndpointMessageResult]?
        /// Application id of the message.
        public let applicationId: String?
        /// A map containing a multi part response for each address, with the address as the key(Email address, phone number or push token) and the result as the value.
        public let result: [String: MessageResult]?

        public init(requestId: String? = nil, endpointResult: [String: EndpointMessageResult]? = nil, applicationId: String? = nil, result: [String: MessageResult]? = nil) {
            self.requestId = requestId
            self.endpointResult = endpointResult
            self.applicationId = applicationId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case requestId = "RequestId"
            case endpointResult = "EndpointResult"
            case applicationId = "ApplicationId"
            case result = "Result"
        }
    }

    public struct MessageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Addresses", required: false, type: .map), 
            AWSShapeMember(label: "Endpoints", required: false, type: .map), 
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure)
        ]
        /// A map of key-value pairs, where each key is an address and each value is an AddressConfiguration object. An address can be a push notification token, a phone number, or an email address.
        public let addresses: [String: AddressConfiguration]?
        /// A map of key-value pairs, where each key is an endpoint ID and each value is an EndpointSendConfiguration object. Within an EndpointSendConfiguration object, you can tailor the message for an endpoint by specifying message overrides or substitutions.
        public let endpoints: [String: EndpointSendConfiguration]?
        /// A map of custom attributes to attributes to be attached to the message. This payload is added to the push notification's 'data.pinpoint' object or added to the email/sms delivery receipt event attributes.
        public let context: [String: String]?
        /// Message configuration.
        public let messageConfiguration: DirectMessageConfiguration?

        public init(addresses: [String: AddressConfiguration]? = nil, endpoints: [String: EndpointSendConfiguration]? = nil, context: [String: String]? = nil, messageConfiguration: DirectMessageConfiguration? = nil) {
            self.addresses = addresses
            self.endpoints = endpoints
            self.context = context
            self.messageConfiguration = messageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case addresses = "Addresses"
            case endpoints = "Endpoints"
            case context = "Context"
            case messageConfiguration = "MessageConfiguration"
        }
    }

    public enum Format: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public struct UpdateApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationSettingsResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]
        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSettingsResource = "ApplicationSettingsResource"
        }
    }

    public struct MessageBody: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "RequestID", required: false, type: .string)
        ]
        /// The error message that's returned from the API.
        public let message: String?
        /// The unique message body ID.
        public let requestID: String?

        public init(message: String? = nil, requestID: String? = nil) {
            self.message = message
            self.requestID = requestID
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case requestID = "RequestID"
        }
    }

    public struct GetImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobsResponse", required: true, type: .structure)
        ]
        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobsResponse = "ImportJobsResponse"
        }
    }

    public struct DeleteSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentResponse = "SegmentResponse"
        }
    }

    public struct ActivityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Result", required: false, type: .string), 
            AWSShapeMember(label: "Start", required: false, type: .string), 
            AWSShapeMember(label: "TotalEndpointCount", required: false, type: .integer), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "TimezonesCompletedCount", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "End", required: false, type: .string), 
            AWSShapeMember(label: "TimezonesTotalCount", required: false, type: .integer), 
            AWSShapeMember(label: "SuccessfulEndpointCount", required: false, type: .integer), 
            AWSShapeMember(label: "ScheduledStart", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "CampaignId", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentId", required: false, type: .string)
        ]
        /// Indicates whether the activity succeeded.
        /// Valid values: SUCCESS, FAIL
        public let result: String?
        /// The actual start time of the activity in ISO 8601 format.
        public let start: String?
        /// The total number of endpoints to which the campaign attempts to deliver messages.
        public let totalEndpointCount: Int32?
        /// The state of the activity.
        /// Valid values: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, COMPLETED
        public let state: String?
        /// The total number of timezones completed.
        public let timezonesCompletedCount: Int32?
        /// The unique activity ID.
        public let id: String?
        /// The actual time the activity was marked CANCELLED or COMPLETED. Provided in ISO 8601 format.
        public let end: String?
        /// The total number of unique timezones present in the segment.
        public let timezonesTotalCount: Int32?
        /// The total number of endpoints to which the campaign successfully delivered messages.
        public let successfulEndpointCount: Int32?
        /// The scheduled start time for the activity in ISO 8601 format.
        public let scheduledStart: String?
        /// The ID of the application to which the campaign applies.
        public let applicationId: String?
        /// The ID of the campaign to which the activity applies.
        public let campaignId: String?
        /// The ID of a variation of the campaign used for A/B testing.
        public let treatmentId: String?

        public init(result: String? = nil, start: String? = nil, totalEndpointCount: Int32? = nil, state: String? = nil, timezonesCompletedCount: Int32? = nil, id: String? = nil, end: String? = nil, timezonesTotalCount: Int32? = nil, successfulEndpointCount: Int32? = nil, scheduledStart: String? = nil, applicationId: String? = nil, campaignId: String? = nil, treatmentId: String? = nil) {
            self.result = result
            self.start = start
            self.totalEndpointCount = totalEndpointCount
            self.state = state
            self.timezonesCompletedCount = timezonesCompletedCount
            self.id = id
            self.end = end
            self.timezonesTotalCount = timezonesTotalCount
            self.successfulEndpointCount = successfulEndpointCount
            self.scheduledStart = scheduledStart
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.treatmentId = treatmentId
        }

        private enum CodingKeys: String, CodingKey {
            case result = "Result"
            case start = "Start"
            case totalEndpointCount = "TotalEndpointCount"
            case state = "State"
            case timezonesCompletedCount = "TimezonesCompletedCount"
            case id = "Id"
            case end = "End"
            case timezonesTotalCount = "TimezonesTotalCount"
            case successfulEndpointCount = "SuccessfulEndpointCount"
            case scheduledStart = "ScheduledStart"
            case applicationId = "ApplicationId"
            case campaignId = "CampaignId"
            case treatmentId = "TreatmentId"
        }
    }

    public struct GetSegmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let pageSize: String?
        public let token: String?
        public let applicationId: String

        public init(pageSize: String? = nil, token: String? = nil, applicationId: String) {
            self.pageSize = pageSize
            self.token = token
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "page-size"
            case token = "token"
            case applicationId = "application-id"
        }
    }

    public struct GetUserEndpointsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointsResponse", required: true, type: .structure)
        ]
        public let endpointsResponse: EndpointsResponse

        public init(endpointsResponse: EndpointsResponse) {
            self.endpointsResponse = endpointsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointsResponse = "EndpointsResponse"
        }
    }

    public struct GetChannelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct PhoneNumberValidateRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "NumberValidateRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberValidateRequest", required: true, type: .structure)
        ]
        public let numberValidateRequest: NumberValidateRequest

        public init(numberValidateRequest: NumberValidateRequest) {
            self.numberValidateRequest = numberValidateRequest
        }

        private enum CodingKeys: String, CodingKey {
            case numberValidateRequest = "NumberValidateRequest"
        }
    }

    public struct EmailChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Identity", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "MessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean)
        ]
        /// The ARN of an identity verified with SES.
        public let identity: String?
        /// The email address used to send emails from.
        public let fromAddress: String?
        /// Messages per second that can be sent
        public let messagesPerSecond: Int32?
        /// The ARN of an IAM Role used to submit events to Mobile Analytics' event ingestion service
        public let roleArn: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Version of channel
        public let version: Int32?
        /// Platform type. Will be "EMAIL"
        public let platform: String?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// The unique ID of the application to which the email channel belongs.
        public let applicationId: String?
        /// Is this channel archived
        public let isArchived: Bool?

        public init(identity: String? = nil, fromAddress: String? = nil, messagesPerSecond: Int32? = nil, roleArn: String? = nil, enabled: Bool? = nil, version: Int32? = nil, platform: String? = nil, hasCredential: Bool? = nil, creationDate: String? = nil, lastModifiedDate: String? = nil, id: String? = nil, lastModifiedBy: String? = nil, applicationId: String? = nil, isArchived: Bool? = nil) {
            self.identity = identity
            self.fromAddress = fromAddress
            self.messagesPerSecond = messagesPerSecond
            self.roleArn = roleArn
            self.enabled = enabled
            self.version = version
            self.platform = platform
            self.hasCredential = hasCredential
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.id = id
            self.lastModifiedBy = lastModifiedBy
            self.applicationId = applicationId
            self.isArchived = isArchived
        }

        private enum CodingKeys: String, CodingKey {
            case identity = "Identity"
            case fromAddress = "FromAddress"
            case messagesPerSecond = "MessagesPerSecond"
            case roleArn = "RoleArn"
            case enabled = "Enabled"
            case version = "Version"
            case platform = "Platform"
            case hasCredential = "HasCredential"
            case creationDate = "CreationDate"
            case lastModifiedDate = "LastModifiedDate"
            case id = "Id"
            case lastModifiedBy = "LastModifiedBy"
            case applicationId = "ApplicationId"
            case isArchived = "IsArchived"
        }
    }

    public struct UpdateEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct UpdateSmsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let sMSChannelRequest: SMSChannelRequest
        public let applicationId: String

        public init(sMSChannelRequest: SMSChannelRequest, applicationId: String) {
            self.sMSChannelRequest = sMSChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelRequest = "SMSChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct DeleteApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct BaiduChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Credential", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Application id
        public let applicationId: String?
        /// The Baidu API key from Baidu.
        public let credential: String?
        /// The platform type. Will be BAIDU
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who made the last change
        public let lastModifiedBy: String?

        public init(lastModifiedDate: String? = nil, applicationId: String? = nil, credential: String? = nil, platform: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, hasCredential: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.credential = credential
            self.platform = platform
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.hasCredential = hasCredential
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case credential = "Credential"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case isArchived = "IsArchived"
            case hasCredential = "HasCredential"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct GetExportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobResponse", required: true, type: .structure)
        ]
        public let exportJobResponse: ExportJobResponse

        public init(exportJobResponse: ExportJobResponse) {
            self.exportJobResponse = exportJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobResponse = "ExportJobResponse"
        }
    }

    public struct GetSegmentVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsResponse", required: true, type: .structure)
        ]
        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsResponse = "SegmentsResponse"
        }
    }

    public struct CampaignEmailMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HtmlBody", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "FromAddress", required: false, type: .string), 
            AWSShapeMember(label: "Body", required: false, type: .string)
        ]
        /// The email html body.
        public let htmlBody: String?
        /// The email title (Or subject).
        public let title: String?
        /// The email address used to send the email from. Defaults to use FromAddress specified in the Email Channel.
        public let fromAddress: String?
        /// The email text body.
        public let body: String?

        public init(htmlBody: String? = nil, title: String? = nil, fromAddress: String? = nil, body: String? = nil) {
            self.htmlBody = htmlBody
            self.title = title
            self.fromAddress = fromAddress
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case htmlBody = "HtmlBody"
            case title = "Title"
            case fromAddress = "FromAddress"
            case body = "Body"
        }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum RecencyType: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct MetricDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ComparisonOperator", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]
        /// GREATER_THAN | LESS_THAN | GREATER_THAN_OR_EQUAL | LESS_THAN_OR_EQUAL | EQUAL
        public let comparisonOperator: String?
        /// Value to be compared.
        public let value: Double?

        public init(comparisonOperator: String? = nil, value: Double? = nil) {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case value = "Value"
        }
    }

    public struct GetImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobResponse", required: true, type: .structure)
        ]
        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobResponse = "ImportJobResponse"
        }
    }

    public struct MessageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UpdatedToken", required: false, type: .string), 
            AWSShapeMember(label: "StatusCode", required: false, type: .integer), 
            AWSShapeMember(label: "MessageId", required: false, type: .string), 
            AWSShapeMember(label: "DeliveryStatus", required: false, type: .enum), 
            AWSShapeMember(label: "StatusMessage", required: false, type: .string)
        ]
        /// If token was updated as part of delivery. (This is GCM Specific)
        public let updatedToken: String?
        /// Downstream service status code.
        public let statusCode: Int32?
        /// Unique message identifier associated with the message that was sent.
        public let messageId: String?
        /// Delivery status of message.
        public let deliveryStatus: DeliveryStatus?
        /// Status message for message delivery.
        public let statusMessage: String?

        public init(updatedToken: String? = nil, statusCode: Int32? = nil, messageId: String? = nil, deliveryStatus: DeliveryStatus? = nil, statusMessage: String? = nil) {
            self.updatedToken = updatedToken
            self.statusCode = statusCode
            self.messageId = messageId
            self.deliveryStatus = deliveryStatus
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case updatedToken = "UpdatedToken"
            case statusCode = "StatusCode"
            case messageId = "MessageId"
            case deliveryStatus = "DeliveryStatus"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DeleteEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointResponse", required: true, type: .structure)
        ]
        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointResponse = "EndpointResponse"
        }
    }

    public struct SegmentBehaviors: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Recency", required: false, type: .structure)
        ]
        /// The recency of use.
        public let recency: RecencyDimension?

        public init(recency: RecencyDimension? = nil) {
            self.recency = recency
        }

        private enum CodingKeys: String, CodingKey {
            case recency = "Recency"
        }
    }

    public struct GetEventStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct SegmentLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GPSPoint", required: false, type: .structure), 
            AWSShapeMember(label: "Country", required: false, type: .structure)
        ]
        /// The GPS Point dimension.
        public let gPSPoint: GPSPointDimension?
        /// The country filter according to ISO 3166-1 Alpha-2 codes.
        public let country: SetDimension?

        public init(gPSPoint: GPSPointDimension? = nil, country: SetDimension? = nil) {
            self.gPSPoint = gPSPoint
            self.country = country
        }

        private enum CodingKeys: String, CodingKey {
            case gPSPoint = "GPSPoint"
            case country = "Country"
        }
    }

    public struct APNSVoipChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The certificate private key.
        public let privateKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?

        public init(bundleId: String? = nil, defaultAuthenticationMethod: String? = nil, certificate: String? = nil, teamId: String? = nil, privateKey: String? = nil, enabled: Bool? = nil, tokenKeyId: String? = nil, tokenKey: String? = nil) {
            self.bundleId = bundleId
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.certificate = certificate
            self.teamId = teamId
            self.privateKey = privateKey
            self.enabled = enabled
            self.tokenKeyId = tokenKeyId
            self.tokenKey = tokenKey
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case certificate = "Certificate"
            case teamId = "TeamId"
            case privateKey = "PrivateKey"
            case enabled = "Enabled"
            case tokenKeyId = "TokenKeyId"
            case tokenKey = "TokenKey"
        }
    }

    public struct ImportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of import jobs for the application.
        public let item: [ImportJobResponse]?

        public init(nextToken: String? = nil, item: [ImportJobResponse]? = nil) {
            self.nextToken = nextToken
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case item = "Item"
        }
    }

    public struct UpdateApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public enum ChannelType: String, CustomStringConvertible, Codable {
        case gcm = "GCM"
        case apns = "APNS"
        case apnsSandbox = "APNS_SANDBOX"
        case apnsVoip = "APNS_VOIP"
        case apnsVoipSandbox = "APNS_VOIP_SANDBOX"
        case adm = "ADM"
        case sms = "SMS"
        case email = "EMAIL"
        case baidu = "BAIDU"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum Include: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case any = "ANY"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct GetCampaignActivitiesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ActivitiesResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ActivitiesResponse", required: true, type: .structure)
        ]
        public let activitiesResponse: ActivitiesResponse

        public init(activitiesResponse: ActivitiesResponse) {
            self.activitiesResponse = activitiesResponse
        }

        private enum CodingKeys: String, CodingKey {
            case activitiesResponse = "ActivitiesResponse"
        }
    }

    public struct DeleteAdmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct ExportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "CompletionDate", required: false, type: .string), 
            AWSShapeMember(label: "Definition", required: false, type: .structure), 
            AWSShapeMember(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeMember(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Failures", required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string)
        ]
        /// The number of pieces that have successfully completed as of the time of the request.
        public let completedPieces: Int32?
        /// The date the job completed in ISO 8601 format.
        public let completionDate: String?
        /// The export job settings.
        public let definition: ExportJobResource?
        /// The total number of pieces that must be processed to finish the job. Each piece is an approximately equal portion of the endpoints.
        public let totalPieces: Int32?
        /// The status of the job.
        /// Valid values: CREATED, INITIALIZING, PROCESSING, COMPLETING, COMPLETED, FAILING, FAILED
        /// The job status is FAILED if one or more pieces failed.
        public let jobStatus: JobStatus?
        /// The number of endpoints that were not processed; for example, because of syntax errors.
        public let totalFailures: Int32?
        /// The number of endpoints that were processed by the job.
        public let totalProcessed: Int32?
        /// The job type. Will be 'EXPORT'.
        public let `type`: String?
        /// The date the job was created in ISO 8601 format.
        public let creationDate: String?
        /// The number of pieces that failed to be processed as of the time of the request.
        public let failedPieces: Int32?
        /// The unique ID of the job.
        public let id: String?
        /// Provides up to 100 of the first failed entries for the job, if any exist.
        public let failures: [String]?
        /// The unique ID of the application to which the job applies.
        public let applicationId: String?

        public init(completedPieces: Int32? = nil, completionDate: String? = nil, definition: ExportJobResource? = nil, totalPieces: Int32? = nil, jobStatus: JobStatus? = nil, totalFailures: Int32? = nil, totalProcessed: Int32? = nil, type: String? = nil, creationDate: String? = nil, failedPieces: Int32? = nil, id: String? = nil, failures: [String]? = nil, applicationId: String? = nil) {
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.definition = definition
            self.totalPieces = totalPieces
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalProcessed = totalProcessed
            self.`type` = `type`
            self.creationDate = creationDate
            self.failedPieces = failedPieces
            self.id = id
            self.failures = failures
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case completedPieces = "CompletedPieces"
            case completionDate = "CompletionDate"
            case definition = "Definition"
            case totalPieces = "TotalPieces"
            case jobStatus = "JobStatus"
            case totalFailures = "TotalFailures"
            case totalProcessed = "TotalProcessed"
            case `type` = "Type"
            case creationDate = "CreationDate"
            case failedPieces = "FailedPieces"
            case id = "Id"
            case failures = "Failures"
            case applicationId = "ApplicationId"
        }
    }

    public struct WriteSegmentRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentGroups", required: false, type: .structure), 
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// Segment definition groups. We currently only support one. If specified Dimensions must be empty.
        public let segmentGroups: SegmentGroupList?
        /// The segment dimensions attributes.
        public let dimensions: SegmentDimensions?
        /// The name of segment
        public let name: String?

        public init(segmentGroups: SegmentGroupList? = nil, dimensions: SegmentDimensions? = nil, name: String? = nil) {
            self.segmentGroups = segmentGroups
            self.dimensions = dimensions
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case segmentGroups = "SegmentGroups"
            case dimensions = "Dimensions"
            case name = "Name"
        }
    }

    public struct ADMChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientId", required: false, type: .string), 
            AWSShapeMember(label: "ClientSecret", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// Client ID as gotten from Amazon
        public let clientId: String?
        /// Client secret as gotten from Amazon
        public let clientSecret: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(clientId: String? = nil, clientSecret: String? = nil, enabled: Bool? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "ClientId"
            case clientSecret = "ClientSecret"
            case enabled = "Enabled"
        }
    }

    public struct UpdateGcmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let gCMChannelRequest: GCMChannelRequest
        public let applicationId: String

        public init(gCMChannelRequest: GCMChannelRequest, applicationId: String) {
            self.gCMChannelRequest = gCMChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelRequest = "GCMChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct CampaignSmsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "MessageType", required: false, type: .enum), 
            AWSShapeMember(label: "Body", required: false, type: .string)
        ]
        /// Sender ID of sent message.
        public let senderId: String?
        /// Is this is a transactional SMS message, otherwise a promotional message.
        public let messageType: MessageType?
        /// The SMS text body.
        public let body: String?

        public init(senderId: String? = nil, messageType: MessageType? = nil, body: String? = nil) {
            self.senderId = senderId
            self.messageType = messageType
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case senderId = "SenderId"
            case messageType = "MessageType"
            case body = "Body"
        }
    }

    public struct Message: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "MediaUrl", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "JsonBody", required: false, type: .string), 
            AWSShapeMember(label: "ImageSmallIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Title", required: false, type: .string)
        ]
        /// The message body. Can include up to 140 characters.
        public let body: String?
        /// The URL that points to the media resource, for example a .mp4 or .gif file.
        public let mediaUrl: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// The action that occurs if the user taps a push notification delivered by the campaign:
        /// OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action.
        /// DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app.
        /// URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify.
        public let action: Action?
        /// The JSON payload used for a silent push.
        public let jsonBody: String?
        /// The URL that points to the small icon image for the push notification icon, for example, the app icon.
        public let imageSmallIconUrl: String?
        /// This parameter specifies how long (in seconds) the message should be kept if the service is unable to deliver the notification the first time. If the value is 0, it treats the notification as if it expires immediately and does not store the notification or attempt to redeliver it. This value is converted to the expiration field when sent to the service. It only applies to APNs and GCM
        public let timeToLive: Int32?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Indicates if the message should display on the users device.
        /// Silent pushes can be used for Remote Configuration and Phone Home use cases. 
        public let silentPush: Bool?
        /// The URL that points to the icon image for the push notification icon, for example, the app icon.
        public let imageIconUrl: String?
        /// The message title that displays above the message on the user's device.
        public let title: String?

        public init(body: String? = nil, mediaUrl: String? = nil, url: String? = nil, imageUrl: String? = nil, action: Action? = nil, jsonBody: String? = nil, imageSmallIconUrl: String? = nil, timeToLive: Int32? = nil, rawContent: String? = nil, silentPush: Bool? = nil, imageIconUrl: String? = nil, title: String? = nil) {
            self.body = body
            self.mediaUrl = mediaUrl
            self.url = url
            self.imageUrl = imageUrl
            self.action = action
            self.jsonBody = jsonBody
            self.imageSmallIconUrl = imageSmallIconUrl
            self.timeToLive = timeToLive
            self.rawContent = rawContent
            self.silentPush = silentPush
            self.imageIconUrl = imageIconUrl
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case mediaUrl = "MediaUrl"
            case url = "Url"
            case imageUrl = "ImageUrl"
            case action = "Action"
            case jsonBody = "JsonBody"
            case imageSmallIconUrl = "ImageSmallIconUrl"
            case timeToLive = "TimeToLive"
            case rawContent = "RawContent"
            case silentPush = "SilentPush"
            case imageIconUrl = "ImageIconUrl"
            case title = "Title"
        }
    }

    public struct AttributeDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Values", required: false, type: .list), 
            AWSShapeMember(label: "AttributeType", required: false, type: .enum)
        ]
        /// The criteria values for the segment dimension. Endpoints with matching attribute values are included or excluded from the segment, depending on the setting for Type.
        public let values: [String]?
        /// The type of dimension:
        /// INCLUSIVE - Endpoints that match the criteria are included in the segment.
        /// EXCLUSIVE - Endpoints that match the criteria are excluded from the segment.
        public let attributeType: AttributeType?

        public init(values: [String]? = nil, attributeType: AttributeType? = nil) {
            self.values = values
            self.attributeType = attributeType
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
            case attributeType = "AttributeType"
        }
    }

    public struct GCMMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "CollapseKey", required: false, type: .string), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Priority", required: false, type: .string), 
            AWSShapeMember(label: "RestrictedPackageName", required: false, type: .string), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// The length of time (in seconds) that FCM or GCM stores and attempts to deliver the message. If unspecified, the value defaults to the maximum, which is 2,419,200 seconds (28 days). Amazon Pinpoint uses this value to set the FCM or GCM time_to_live parameter.
        public let timeToLive: Int32?
        /// This parameter identifies a group of messages (e.g., with collapse_key: "Updates Available") that can be collapsed, so that only the last message gets sent when delivery can be resumed. This is intended to avoid sending too many of the same messages when the device comes back online or becomes active.
        public let collapseKey: String?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The message priority. Amazon Pinpoint uses this value to set the FCM or GCM priority parameter when it sends the message. Accepts the following values:
        /// "Normal" - Messages might be delayed. Delivery is optimized for battery usage on the receiving device. Use normal priority unless immediate delivery is required.
        /// "High" - Messages are sent immediately and might wake a sleeping device.
        /// The equivalent values for APNs messages are "5" and "10". Amazon Pinpoint accepts these values here and converts them.
        /// For more information, see About FCM Messages in the Firebase documentation.
        public let priority: String?
        /// This parameter specifies the package name of the application where the registration tokens must match in order to receive the message.
        public let restrictedPackageName: String?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?

        public init(action: Action? = nil, silentPush: Bool? = nil, rawContent: String? = nil, timeToLive: Int32? = nil, collapseKey: String? = nil, url: String? = nil, imageUrl: String? = nil, substitutions: [String: [String]]? = nil, priority: String? = nil, restrictedPackageName: String? = nil, data: [String: String]? = nil, title: String? = nil, imageIconUrl: String? = nil, body: String? = nil, smallImageIconUrl: String? = nil, iconReference: String? = nil, sound: String? = nil) {
            self.action = action
            self.silentPush = silentPush
            self.rawContent = rawContent
            self.timeToLive = timeToLive
            self.collapseKey = collapseKey
            self.url = url
            self.imageUrl = imageUrl
            self.substitutions = substitutions
            self.priority = priority
            self.restrictedPackageName = restrictedPackageName
            self.data = data
            self.title = title
            self.imageIconUrl = imageIconUrl
            self.body = body
            self.smallImageIconUrl = smallImageIconUrl
            self.iconReference = iconReference
            self.sound = sound
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case silentPush = "SilentPush"
            case rawContent = "RawContent"
            case timeToLive = "TimeToLive"
            case collapseKey = "CollapseKey"
            case url = "Url"
            case imageUrl = "ImageUrl"
            case substitutions = "Substitutions"
            case priority = "Priority"
            case restrictedPackageName = "RestrictedPackageName"
            case data = "Data"
            case title = "Title"
            case imageIconUrl = "ImageIconUrl"
            case body = "Body"
            case smallImageIconUrl = "SmallImageIconUrl"
            case iconReference = "IconReference"
            case sound = "Sound"
        }
    }

    public struct DefaultMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map)
        ]
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.substitutions = substitutions
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case substitutions = "Substitutions"
        }
    }

    public struct GetApplicationSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct CreateImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ImportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportJobResponse", required: true, type: .structure)
        ]
        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case importJobResponse = "ImportJobResponse"
        }
    }

    public enum Duration: String, CustomStringConvertible, Codable {
        case hr24 = "HR_24"
        case day7 = "DAY_7"
        case day14 = "DAY_14"
        case day30 = "DAY_30"
        public var description: String { return self.rawValue }
    }

    public struct GetApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
        }
    }

    public struct DeleteEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct BaiduMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .enum), 
            AWSShapeMember(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeMember(label: "RawContent", required: false, type: .string), 
            AWSShapeMember(label: "TimeToLive", required: false, type: .integer), 
            AWSShapeMember(label: "Url", required: false, type: .string), 
            AWSShapeMember(label: "ImageUrl", required: false, type: .string), 
            AWSShapeMember(label: "Substitutions", required: false, type: .map), 
            AWSShapeMember(label: "Data", required: false, type: .map), 
            AWSShapeMember(label: "Title", required: false, type: .string), 
            AWSShapeMember(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "Body", required: false, type: .string), 
            AWSShapeMember(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeMember(label: "IconReference", required: false, type: .string), 
            AWSShapeMember(label: "Sound", required: false, type: .string)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// This parameter specifies how long (in seconds) the message should be kept in Baidu storage if the device is offline. The and the default value and the maximum time to live supported is 7 days (604800 seconds)
        public let timeToLive: Int32?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// Default message substitutions. Can be overridden by individual address substitutions.
        public let substitutions: [String: [String]]?
        /// The data payload used for a silent push. This payload is added to the notifications' data.pinpoint.jsonBody' object
        public let data: [String: String]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?

        public init(action: Action? = nil, silentPush: Bool? = nil, rawContent: String? = nil, timeToLive: Int32? = nil, url: String? = nil, imageUrl: String? = nil, substitutions: [String: [String]]? = nil, data: [String: String]? = nil, title: String? = nil, imageIconUrl: String? = nil, body: String? = nil, smallImageIconUrl: String? = nil, iconReference: String? = nil, sound: String? = nil) {
            self.action = action
            self.silentPush = silentPush
            self.rawContent = rawContent
            self.timeToLive = timeToLive
            self.url = url
            self.imageUrl = imageUrl
            self.substitutions = substitutions
            self.data = data
            self.title = title
            self.imageIconUrl = imageIconUrl
            self.body = body
            self.smallImageIconUrl = smallImageIconUrl
            self.iconReference = iconReference
            self.sound = sound
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case silentPush = "SilentPush"
            case rawContent = "RawContent"
            case timeToLive = "TimeToLive"
            case url = "Url"
            case imageUrl = "ImageUrl"
            case substitutions = "Substitutions"
            case data = "Data"
            case title = "Title"
            case imageIconUrl = "ImageIconUrl"
            case body = "Body"
            case smallImageIconUrl = "SmallImageIconUrl"
            case iconReference = "IconReference"
            case sound = "Sound"
        }
    }

    public struct GetSegmentExportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobsResponse", required: true, type: .structure)
        ]
        public let exportJobsResponse: ExportJobsResponse

        public init(exportJobsResponse: ExportJobsResponse) {
            self.exportJobsResponse = exportJobsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobsResponse = "ExportJobsResponse"
        }
    }

    public struct GetEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelResponse = "EmailChannelResponse"
        }
    }

    public struct GetApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationSettingsResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]
        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSettingsResource = "ApplicationSettingsResource"
        }
    }

    public struct APNSSandboxChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "TeamId", required: false, type: .string), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "TokenKeyId", required: false, type: .string), 
            AWSShapeMember(label: "TokenKey", required: false, type: .string)
        ]
        /// The bundle id used for APNs Tokens.
        public let bundleId: String?
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// The team id used for APNs Tokens.
        public let teamId: String?
        /// The certificate private key.
        public let privateKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The token key used for APNs Tokens.
        public let tokenKeyId: String?
        /// The token key used for APNs Tokens.
        public let tokenKey: String?

        public init(bundleId: String? = nil, defaultAuthenticationMethod: String? = nil, certificate: String? = nil, teamId: String? = nil, privateKey: String? = nil, enabled: Bool? = nil, tokenKeyId: String? = nil, tokenKey: String? = nil) {
            self.bundleId = bundleId
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.certificate = certificate
            self.teamId = teamId
            self.privateKey = privateKey
            self.enabled = enabled
            self.tokenKeyId = tokenKeyId
            self.tokenKey = tokenKey
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case certificate = "Certificate"
            case teamId = "TeamId"
            case privateKey = "PrivateKey"
            case enabled = "Enabled"
            case tokenKeyId = "TokenKeyId"
            case tokenKey = "TokenKey"
        }
    }

    public struct SegmentGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "SourceSegments", required: false, type: .list)
        ]
        /// List of dimensions to include or exclude.
        public let dimensions: [SegmentDimensions]?
        /// Include or exclude the source.
        public let sourceType: SourceType?
        /// How should the dimensions be applied for the result
        public let `type`: `Type`?
        /// Segments that define the source of this segment. Currently a maximum of 1 import segment is supported.
        public let sourceSegments: [SegmentReference]?

        public init(dimensions: [SegmentDimensions]? = nil, sourceType: SourceType? = nil, type: `Type`? = nil, sourceSegments: [SegmentReference]? = nil) {
            self.dimensions = dimensions
            self.sourceType = sourceType
            self.`type` = `type`
            self.sourceSegments = sourceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case sourceType = "SourceType"
            case `type` = "Type"
            case sourceSegments = "SourceSegments"
        }
    }

    public struct GetCampaignsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignsResponse", required: true, type: .structure)
        ]
        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignsResponse = "CampaignsResponse"
        }
    }

    public struct DeleteUserEndpointsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointsResponse", required: true, type: .structure)
        ]
        public let endpointsResponse: EndpointsResponse

        public init(endpointsResponse: EndpointsResponse) {
            self.endpointsResponse = endpointsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointsResponse = "EndpointsResponse"
        }
    }

    public struct DeleteApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct UpdateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteCampaignRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WriteCampaignRequest", required: true, type: .structure), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let writeCampaignRequest: WriteCampaignRequest
        public let campaignId: String
        public let applicationId: String

        public init(writeCampaignRequest: WriteCampaignRequest, campaignId: String, applicationId: String) {
            self.writeCampaignRequest = writeCampaignRequest
            self.campaignId = campaignId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case writeCampaignRequest = "WriteCampaignRequest"
            case campaignId = "campaign-id"
            case applicationId = "application-id"
        }
    }

    public struct GetSegmentsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SegmentsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsResponse", required: true, type: .structure)
        ]
        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsResponse = "SegmentsResponse"
        }
    }

    public struct SMSChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PromotionalMessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "SenderId", required: false, type: .string), 
            AWSShapeMember(label: "TransactionalMessagesPerSecond", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "ShortCode", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean)
        ]
        /// Promotional messages per second that can be sent
        public let promotionalMessagesPerSecond: Int32?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Version of channel
        public let version: Int32?
        /// Platform type. Will be "SMS"
        public let platform: String?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Sender identifier of your messages.
        public let senderId: String?
        /// Transactional messages per second that can be sent
        public let transactionalMessagesPerSecond: Int32?
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// The unique ID of the application to which the SMS channel belongs.
        public let applicationId: String?
        /// The short code registered with the phone provider.
        public let shortCode: String?
        /// Is this channel archived
        public let isArchived: Bool?

        public init(promotionalMessagesPerSecond: Int32? = nil, enabled: Bool? = nil, version: Int32? = nil, platform: String? = nil, hasCredential: Bool? = nil, creationDate: String? = nil, lastModifiedDate: String? = nil, id: String? = nil, senderId: String? = nil, transactionalMessagesPerSecond: Int32? = nil, lastModifiedBy: String? = nil, applicationId: String? = nil, shortCode: String? = nil, isArchived: Bool? = nil) {
            self.promotionalMessagesPerSecond = promotionalMessagesPerSecond
            self.enabled = enabled
            self.version = version
            self.platform = platform
            self.hasCredential = hasCredential
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.id = id
            self.senderId = senderId
            self.transactionalMessagesPerSecond = transactionalMessagesPerSecond
            self.lastModifiedBy = lastModifiedBy
            self.applicationId = applicationId
            self.shortCode = shortCode
            self.isArchived = isArchived
        }

        private enum CodingKeys: String, CodingKey {
            case promotionalMessagesPerSecond = "PromotionalMessagesPerSecond"
            case enabled = "Enabled"
            case version = "Version"
            case platform = "Platform"
            case hasCredential = "HasCredential"
            case creationDate = "CreationDate"
            case lastModifiedDate = "LastModifiedDate"
            case id = "Id"
            case senderId = "SenderId"
            case transactionalMessagesPerSecond = "TransactionalMessagesPerSecond"
            case lastModifiedBy = "LastModifiedBy"
            case applicationId = "ApplicationId"
            case shortCode = "ShortCode"
            case isArchived = "IsArchived"
        }
    }

    public struct CreateAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]
        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct GetApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSChannelResponse = "APNSChannelResponse"
        }
    }

    public struct DeleteApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct WriteTreatmentResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "TreatmentName", required: false, type: .string), 
            AWSShapeMember(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeMember(label: "SizePercent", required: false, type: .integer), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure)
        ]
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The allocated percentage of users for this treatment.
        public let sizePercent: Int32?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?

        public init(schedule: Schedule? = nil, treatmentName: String? = nil, treatmentDescription: String? = nil, sizePercent: Int32? = nil, messageConfiguration: MessageConfiguration? = nil) {
            self.schedule = schedule
            self.treatmentName = treatmentName
            self.treatmentDescription = treatmentDescription
            self.sizePercent = sizePercent
            self.messageConfiguration = messageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "Schedule"
            case treatmentName = "TreatmentName"
            case treatmentDescription = "TreatmentDescription"
            case sizePercent = "SizePercent"
            case messageConfiguration = "MessageConfiguration"
        }
    }

    public struct GetAppResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ApplicationResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationResponse", required: true, type: .structure)
        ]
        public let applicationResponse: ApplicationResponse

        public init(applicationResponse: ApplicationResponse) {
            self.applicationResponse = applicationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case applicationResponse = "ApplicationResponse"
        }
    }

    public struct APNSVoipChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Application id
        public let applicationId: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// If the channel is registered with a token key for authentication.
        public let hasTokenKey: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who made the last change
        public let lastModifiedBy: String?

        public init(defaultAuthenticationMethod: String? = nil, lastModifiedDate: String? = nil, applicationId: String? = nil, platform: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.platform = platform
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case isArchived = "IsArchived"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct EndpointDemographic: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PlatformVersion", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "ModelVersion", required: false, type: .string), 
            AWSShapeMember(label: "Locale", required: false, type: .string), 
            AWSShapeMember(label: "Model", required: false, type: .string), 
            AWSShapeMember(label: "AppVersion", required: false, type: .string), 
            AWSShapeMember(label: "Make", required: false, type: .string), 
            AWSShapeMember(label: "Timezone", required: false, type: .string)
        ]
        /// The endpoint platform version.
        public let platformVersion: String?
        /// The endpoint platform, such as ios or android.
        public let platform: String?
        /// The endpoint model version.
        public let modelVersion: String?
        /// The endpoint locale in the following format: The ISO 639-1 alpha-2 code, followed by an underscore, followed by an ISO 3166-1 alpha-2 value.
        public let locale: String?
        /// The endpoint model, such as iPhone.
        public let model: String?
        /// The version of the application associated with the endpoint.
        public let appVersion: String?
        /// The endpoint make, such as such as Apple or Samsung.
        public let make: String?
        /// The timezone of the endpoint. Specified as a tz database value, such as Americas/Los_Angeles.
        public let timezone: String?

        public init(platformVersion: String? = nil, platform: String? = nil, modelVersion: String? = nil, locale: String? = nil, model: String? = nil, appVersion: String? = nil, make: String? = nil, timezone: String? = nil) {
            self.platformVersion = platformVersion
            self.platform = platform
            self.modelVersion = modelVersion
            self.locale = locale
            self.model = model
            self.appVersion = appVersion
            self.make = make
            self.timezone = timezone
        }

        private enum CodingKeys: String, CodingKey {
            case platformVersion = "PlatformVersion"
            case platform = "Platform"
            case modelVersion = "ModelVersion"
            case locale = "Locale"
            case model = "Model"
            case appVersion = "AppVersion"
            case make = "Make"
            case timezone = "Timezone"
        }
    }

    public enum DimensionType: String, CustomStringConvertible, Codable {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct GetSegmentVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string)
        ]
        public let token: String?
        public let applicationId: String
        public let segmentId: String
        public let pageSize: String?

        public init(token: String? = nil, applicationId: String, segmentId: String, pageSize: String? = nil) {
            self.token = token
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.pageSize = pageSize
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case pageSize = "page-size"
        }
    }

    public struct GetExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let pageSize: String?
        public let token: String?
        public let applicationId: String

        public init(pageSize: String? = nil, token: String? = nil, applicationId: String) {
            self.pageSize = pageSize
            self.token = token
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "page-size"
            case token = "token"
            case applicationId = "application-id"
        }
    }

    public struct RemoveAttributesResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "AttributesResource"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributesResource", required: true, type: .structure)
        ]
        public let attributesResource: AttributesResource

        public init(attributesResource: AttributesResource) {
            self.attributesResource = attributesResource
        }

        private enum CodingKeys: String, CodingKey {
            case attributesResource = "AttributesResource"
        }
    }

    public struct GetCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let campaignId: String
        public let applicationId: String

        public init(campaignId: String, applicationId: String) {
            self.campaignId = campaignId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "campaign-id"
            case applicationId = "application-id"
        }
    }

    public struct SegmentResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentType", required: false, type: .enum), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "SegmentGroups", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "ImportDefinition", required: false, type: .structure)
        ]
        /// The segment dimensions attributes.
        public let dimensions: SegmentDimensions?
        /// The segment type:
        /// DIMENSIONAL - A dynamic segment built from selection criteria based on endpoint data reported by your app. You create this type of segment by using the segment builder in the Amazon Pinpoint console or by making a POST request to the segments resource.
        /// IMPORT - A static segment built from an imported set of endpoint definitions. You create this type of segment by importing a segment in the Amazon Pinpoint console or by making a POST request to the jobs/import resource.
        public let segmentType: SegmentType?
        /// The ID of the application to which the segment applies.
        public let applicationId: String?
        /// The date the segment was last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The name of segment
        public let name: String?
        /// The date the segment was created in ISO 8601 format.
        public let creationDate: String?
        /// Segment definition groups. We currently only support one. If specified Dimensions must be empty.
        public let segmentGroups: SegmentGroupList?
        /// The unique segment ID.
        public let id: String?
        /// The segment version number.
        public let version: Int32?
        /// The import job settings.
        public let importDefinition: SegmentImportResource?

        public init(dimensions: SegmentDimensions? = nil, segmentType: SegmentType? = nil, applicationId: String? = nil, lastModifiedDate: String? = nil, name: String? = nil, creationDate: String? = nil, segmentGroups: SegmentGroupList? = nil, id: String? = nil, version: Int32? = nil, importDefinition: SegmentImportResource? = nil) {
            self.dimensions = dimensions
            self.segmentType = segmentType
            self.applicationId = applicationId
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.creationDate = creationDate
            self.segmentGroups = segmentGroups
            self.id = id
            self.version = version
            self.importDefinition = importDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
            case segmentType = "SegmentType"
            case applicationId = "ApplicationId"
            case lastModifiedDate = "LastModifiedDate"
            case name = "Name"
            case creationDate = "CreationDate"
            case segmentGroups = "SegmentGroups"
            case id = "Id"
            case version = "Version"
            case importDefinition = "ImportDefinition"
        }
    }

    public struct UpdateGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "GCMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case gCMChannelResponse = "GCMChannelResponse"
        }
    }

    public struct UpdateSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "SMSChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case sMSChannelResponse = "SMSChannelResponse"
        }
    }

    public enum SegmentType: String, CustomStringConvertible, Codable {
        case dimensional = "DIMENSIONAL"
        case `import` = "IMPORT"
        public var description: String { return self.rawValue }
    }

    public struct UpdateBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]
        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct APNSVoipSandboxChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// Application id
        public let applicationId: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// If the channel is registered with a token key for authentication.
        public let hasTokenKey: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who made the last change
        public let lastModifiedBy: String?

        public init(defaultAuthenticationMethod: String? = nil, lastModifiedDate: String? = nil, applicationId: String? = nil, platform: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.platform = platform
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case isArchived = "IsArchived"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct GCMChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Credential", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// The GCM API key from Google.
        public let credential: String?
        /// The platform type. Will be GCM
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used. Present only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(lastModifiedDate: String? = nil, applicationId: String? = nil, credential: String? = nil, platform: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, hasCredential: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.credential = credential
            self.platform = platform
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.hasCredential = hasCredential
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case credential = "Credential"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case isArchived = "IsArchived"
            case hasCredential = "HasCredential"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct ExportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of export jobs for the application.
        public let item: [ExportJobResponse]?

        public init(nextToken: String? = nil, item: [ExportJobResponse]? = nil) {
            self.nextToken = nextToken
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case item = "Item"
        }
    }

    public struct GetSegmentImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string)
        ]
        public let token: String?
        public let applicationId: String
        public let segmentId: String
        public let pageSize: String?

        public init(token: String? = nil, applicationId: String, segmentId: String, pageSize: String? = nil) {
            self.token = token
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.pageSize = pageSize
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case applicationId = "application-id"
            case segmentId = "segment-id"
            case pageSize = "page-size"
        }
    }

    public struct GetCampaignVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string)
        ]
        public let token: String?
        public let applicationId: String
        public let pageSize: String?
        public let campaignId: String

        public init(token: String? = nil, applicationId: String, pageSize: String? = nil, campaignId: String) {
            self.token = token
            self.applicationId = applicationId
            self.pageSize = pageSize
            self.campaignId = campaignId
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case applicationId = "application-id"
            case pageSize = "page-size"
            case campaignId = "campaign-id"
        }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case initializing = "INITIALIZING"
        case processing = "PROCESSING"
        case completing = "COMPLETING"
        case completed = "COMPLETED"
        case failing = "FAILING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct QuietTime: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Start", required: false, type: .string), 
            AWSShapeMember(label: "End", required: false, type: .string)
        ]
        /// The default start time for quiet time in ISO 8601 format.
        public let start: String?
        /// The default end time for quiet time in ISO 8601 format.
        public let end: String?

        public init(start: String? = nil, end: String? = nil) {
            self.start = start
            self.end = end
        }

        private enum CodingKeys: String, CodingKey {
            case start = "Start"
            case end = "End"
        }
    }

    public struct UpdateApplicationSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteApplicationSettingsRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeMember(label: "WriteApplicationSettingsRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeApplicationSettingsRequest: WriteApplicationSettingsRequest

        public init(applicationId: String, writeApplicationSettingsRequest: WriteApplicationSettingsRequest) {
            self.applicationId = applicationId
            self.writeApplicationSettingsRequest = writeApplicationSettingsRequest
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
            case writeApplicationSettingsRequest = "WriteApplicationSettingsRequest"
        }
    }

    public struct ExportJobResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "S3UrlPrefix", required: false, type: .string), 
            AWSShapeMember(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The ID of the segment to export endpoints from. If not present, Amazon Pinpoint exports all of the endpoints that belong to the application.
        public let segmentId: String?
        /// A URL that points to the location within an Amazon S3 bucket that will receive the export. The location is typically a folder with multiple files.
        /// The URL should follow this format: s3://bucket-name/folder-name/
        /// Amazon Pinpoint will export endpoints to this location.
        public let s3UrlPrefix: String?
        /// The version of the segment to export if specified.
        public let segmentVersion: Int32?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that endpoints will be exported to.
        public let roleArn: String?

        public init(segmentId: String? = nil, s3UrlPrefix: String? = nil, segmentVersion: Int32? = nil, roleArn: String? = nil) {
            self.segmentId = segmentId
            self.s3UrlPrefix = s3UrlPrefix
            self.segmentVersion = segmentVersion
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case segmentId = "SegmentId"
            case s3UrlPrefix = "S3UrlPrefix"
            case segmentVersion = "SegmentVersion"
            case roleArn = "RoleArn"
        }
    }

    public struct WriteApplicationSettingsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CloudWatchMetricsEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "CampaignHook", required: false, type: .structure), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure)
        ]
        /// The CloudWatchMetrics settings for the app.
        public let cloudWatchMetricsEnabled: Bool?
        /// The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own.
        public let limits: CampaignLimits?
        /// Default campaign hook information.
        public let campaignHook: CampaignHook?
        /// The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own.
        public let quietTime: QuietTime?

        public init(cloudWatchMetricsEnabled: Bool? = nil, limits: CampaignLimits? = nil, campaignHook: CampaignHook? = nil, quietTime: QuietTime? = nil) {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.limits = limits
            self.campaignHook = campaignHook
            self.quietTime = quietTime
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case limits = "Limits"
            case campaignHook = "CampaignHook"
            case quietTime = "QuietTime"
        }
    }

    public struct CreateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteCampaignRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WriteCampaignRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let writeCampaignRequest: WriteCampaignRequest
        public let applicationId: String

        public init(writeCampaignRequest: WriteCampaignRequest, applicationId: String) {
            self.writeCampaignRequest = writeCampaignRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case writeCampaignRequest = "WriteCampaignRequest"
            case applicationId = "application-id"
        }
    }

    public struct GetEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointResponse", required: true, type: .structure)
        ]
        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        private enum CodingKeys: String, CodingKey {
            case endpointResponse = "EndpointResponse"
        }
    }

    public struct ImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "CompletionDate", required: false, type: .string), 
            AWSShapeMember(label: "Definition", required: false, type: .structure), 
            AWSShapeMember(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeMember(label: "JobStatus", required: false, type: .enum), 
            AWSShapeMember(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeMember(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Failures", required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string)
        ]
        /// The number of pieces that have successfully imported as of the time of the request.
        public let completedPieces: Int32?
        /// The date the import job completed in ISO 8601 format.
        public let completionDate: String?
        /// The import job settings.
        public let definition: ImportJobResource?
        /// The total number of pieces that must be imported to finish the job. Each piece is an approximately equal portion of the endpoints to import.
        public let totalPieces: Int32?
        /// The status of the import job.
        /// Valid values: CREATED, INITIALIZING, PROCESSING, COMPLETING, COMPLETED, FAILING, FAILED
        /// The job status is FAILED if one or more pieces failed to import.
        public let jobStatus: JobStatus?
        /// The number of endpoints that failed to import; for example, because of syntax errors.
        public let totalFailures: Int32?
        /// The number of endpoints that were processed by the import job.
        public let totalProcessed: Int32?
        /// The job type. Will be Import.
        public let `type`: String?
        /// The date the import job was created in ISO 8601 format.
        public let creationDate: String?
        /// The number of pieces that have failed to import as of the time of the request.
        public let failedPieces: Int32?
        /// The unique ID of the import job.
        public let id: String?
        /// Provides up to 100 of the first failed entries for the job, if any exist.
        public let failures: [String]?
        /// The unique ID of the application to which the import job applies.
        public let applicationId: String?

        public init(completedPieces: Int32? = nil, completionDate: String? = nil, definition: ImportJobResource? = nil, totalPieces: Int32? = nil, jobStatus: JobStatus? = nil, totalFailures: Int32? = nil, totalProcessed: Int32? = nil, type: String? = nil, creationDate: String? = nil, failedPieces: Int32? = nil, id: String? = nil, failures: [String]? = nil, applicationId: String? = nil) {
            self.completedPieces = completedPieces
            self.completionDate = completionDate
            self.definition = definition
            self.totalPieces = totalPieces
            self.jobStatus = jobStatus
            self.totalFailures = totalFailures
            self.totalProcessed = totalProcessed
            self.`type` = `type`
            self.creationDate = creationDate
            self.failedPieces = failedPieces
            self.id = id
            self.failures = failures
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case completedPieces = "CompletedPieces"
            case completionDate = "CompletionDate"
            case definition = "Definition"
            case totalPieces = "TotalPieces"
            case jobStatus = "JobStatus"
            case totalFailures = "TotalFailures"
            case totalProcessed = "TotalProcessed"
            case `type` = "Type"
            case creationDate = "CreationDate"
            case failedPieces = "FailedPieces"
            case id = "Id"
            case failures = "Failures"
            case applicationId = "ApplicationId"
        }
    }

    public struct SegmentDimensions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "UserAttributes", required: false, type: .map), 
            AWSShapeMember(label: "Behavior", required: false, type: .structure)
        ]
        /// Custom segment attributes.
        public let attributes: [String: AttributeDimension]?
        /// Custom segment metrics.
        public let metrics: [String: MetricDimension]?
        /// The segment location attributes.
        public let location: SegmentLocation?
        /// The segment demographics attributes.
        public let demographic: SegmentDemographics?
        /// Custom segment user attributes.
        public let userAttributes: [String: AttributeDimension]?
        /// The segment behaviors attributes.
        public let behavior: SegmentBehaviors?

        public init(attributes: [String: AttributeDimension]? = nil, metrics: [String: MetricDimension]? = nil, location: SegmentLocation? = nil, demographic: SegmentDemographics? = nil, userAttributes: [String: AttributeDimension]? = nil, behavior: SegmentBehaviors? = nil) {
            self.attributes = attributes
            self.metrics = metrics
            self.location = location
            self.demographic = demographic
            self.userAttributes = userAttributes
            self.behavior = behavior
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case metrics = "Metrics"
            case location = "Location"
            case demographic = "Demographic"
            case userAttributes = "UserAttributes"
            case behavior = "Behavior"
        }
    }

    public struct EndpointBatchItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "User", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string)
        ]
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// The destination for messages that you send to this endpoint. The address varies by channel. For mobile push channels, use the token provided by the push notification service, such as the APNs device token or the FCM registration token. For the SMS channel, use a phone number in E.164 format, such as +1206XXX5550100. For the email channel, use an email address.
        public let address: String?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Custom attributes that describe the endpoint by associating a name with an array of values. For example, an attribute named "interests" might have the values ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create a segment of users to engage with a messaging campaign.
        /// The following characters are not recommended in attribute names: # : ? \ /. The Amazon Pinpoint console does not display attributes that include these characters in the name. This limitation does not apply to attribute values.
        public let attributes: [String: [String]]?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?
        /// Unused.
        public let endpointStatus: String?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?
        /// The unique Id for the Endpoint in the batch.
        public let id: String?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?

        public init(location: EndpointLocation? = nil, effectiveDate: String? = nil, address: String? = nil, metrics: [String: Double]? = nil, attributes: [String: [String]]? = nil, channelType: ChannelType? = nil, endpointStatus: String? = nil, demographic: EndpointDemographic? = nil, user: EndpointUser? = nil, id: String? = nil, optOut: String? = nil, requestId: String? = nil) {
            self.location = location
            self.effectiveDate = effectiveDate
            self.address = address
            self.metrics = metrics
            self.attributes = attributes
            self.channelType = channelType
            self.endpointStatus = endpointStatus
            self.demographic = demographic
            self.user = user
            self.id = id
            self.optOut = optOut
            self.requestId = requestId
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case effectiveDate = "EffectiveDate"
            case address = "Address"
            case metrics = "Metrics"
            case attributes = "Attributes"
            case channelType = "ChannelType"
            case endpointStatus = "EndpointStatus"
            case demographic = "Demographic"
            case user = "User"
            case id = "Id"
            case optOut = "OptOut"
            case requestId = "RequestId"
        }
    }

    public struct PhoneNumberValidateResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "NumberValidateResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberValidateResponse", required: true, type: .structure)
        ]
        public let numberValidateResponse: NumberValidateResponse

        public init(numberValidateResponse: NumberValidateResponse) {
            self.numberValidateResponse = numberValidateResponse
        }

        private enum CodingKeys: String, CodingKey {
            case numberValidateResponse = "NumberValidateResponse"
        }
    }

    public struct RecencyDimension: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RecencyType", required: false, type: .enum), 
            AWSShapeMember(label: "Duration", required: false, type: .enum)
        ]
        /// The recency dimension type:
        /// ACTIVE - Users who have used your app within the specified duration are included in the segment.
        /// INACTIVE - Users who have not used your app within the specified duration are included in the segment.
        public let recencyType: RecencyType?
        /// The length of time during which users have been active or inactive with your app.
        /// Valid values: HR_24, DAY_7, DAY_14, DAY_30
        public let duration: Duration?

        public init(recencyType: RecencyType? = nil, duration: Duration? = nil) {
            self.recencyType = recencyType
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case recencyType = "RecencyType"
            case duration = "Duration"
        }
    }

    public enum Frequency: String, CustomStringConvertible, Codable {
        case once = "ONCE"
        case hourly = "HOURLY"
        case daily = "DAILY"
        case weekly = "WEEKLY"
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public struct GetBaiduChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "BaiduChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BaiduChannelResponse", required: true, type: .structure)
        ]
        public let baiduChannelResponse: BaiduChannelResponse

        public init(baiduChannelResponse: BaiduChannelResponse) {
            self.baiduChannelResponse = baiduChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case baiduChannelResponse = "BaiduChannelResponse"
        }
    }

    public struct GetApnsVoipSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipSandboxChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse

        public init(aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse) {
            self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
        }
    }

    public struct ActivitiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// List of campaign activities
        public let item: [ActivityResponse]?

        public init(item: [ActivityResponse]? = nil) {
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case item = "Item"
        }
    }

    public struct EndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Address", required: false, type: .string), 
            AWSShapeMember(label: "OptOut", required: false, type: .string), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "CohortId", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "User", required: false, type: .structure), 
            AWSShapeMember(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeMember(label: "Demographic", required: false, type: .structure), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "ChannelType", required: false, type: .enum)
        ]
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// The address or token of the endpoint as provided by your push provider (e.g. DeviceToken or RegistrationId).
        public let address: String?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL - User has opted out of all messages.
        /// NONE - Users has not opted out and receives all messages.
        public let optOut: String?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// A number from 0 - 99 that represents the cohort the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an app. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for a campaign.
        public let cohortId: String?
        /// Custom attributes that describe the endpoint by associating a name with an array of values. For example, an attribute named "interests" might have the values ["science", "politics", "travel"]. You can use these attributes as selection criteria when you create a segment of users to engage with a messaging campaign.
        /// The following characters are not recommended in attribute names: # : ? \ /. The Amazon Pinpoint console does not display attributes that include these characters in the name. This limitation does not apply to attribute values.
        public let attributes: [String: [String]]?
        /// Custom metrics that your app reports to Amazon Pinpoint.
        public let metrics: [String: Double]?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?
        /// Unused.
        public let endpointStatus: String?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        /// The last time the endpoint was created. Provided in ISO 8601 format.
        public let creationDate: String?
        /// The unique ID that you assigned to the endpoint. The ID should be a globally unique identifier (GUID) to ensure that it is unique compared to all other endpoints for the application.
        public let id: String?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// The ID of the application associated with the endpoint.
        public let applicationId: String?
        /// The channel type.
        /// Valid values: GCM | APNS | APNS_SANDBOX | APNS_VOIP | APNS_VOIP_SANDBOX | ADM | SMS | EMAIL | BAIDU
        public let channelType: ChannelType?

        public init(location: EndpointLocation? = nil, address: String? = nil, optOut: String? = nil, requestId: String? = nil, cohortId: String? = nil, attributes: [String: [String]]? = nil, metrics: [String: Double]? = nil, user: EndpointUser? = nil, endpointStatus: String? = nil, demographic: EndpointDemographic? = nil, creationDate: String? = nil, id: String? = nil, effectiveDate: String? = nil, applicationId: String? = nil, channelType: ChannelType? = nil) {
            self.location = location
            self.address = address
            self.optOut = optOut
            self.requestId = requestId
            self.cohortId = cohortId
            self.attributes = attributes
            self.metrics = metrics
            self.user = user
            self.endpointStatus = endpointStatus
            self.demographic = demographic
            self.creationDate = creationDate
            self.id = id
            self.effectiveDate = effectiveDate
            self.applicationId = applicationId
            self.channelType = channelType
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case address = "Address"
            case optOut = "OptOut"
            case requestId = "RequestId"
            case cohortId = "CohortId"
            case attributes = "Attributes"
            case metrics = "Metrics"
            case user = "User"
            case endpointStatus = "EndpointStatus"
            case demographic = "Demographic"
            case creationDate = "CreationDate"
            case id = "Id"
            case effectiveDate = "EffectiveDate"
            case applicationId = "ApplicationId"
            case channelType = "ChannelType"
        }
    }

    public struct CreateApplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The display name of the application. Used in the Amazon Pinpoint console.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointId: String
        public let applicationId: String

        public init(endpointId: String, applicationId: String) {
            self.endpointId = endpointId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case endpointId = "endpoint-id"
            case applicationId = "application-id"
        }
    }

    public struct GetUserEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserId", location: .uri(locationName: "user-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let userId: String
        public let applicationId: String

        public init(userId: String, applicationId: String) {
            self.userId = userId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "user-id"
            case applicationId = "application-id"
        }
    }

    public struct ImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeMember(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3Url", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: false, type: .enum), 
            AWSShapeMember(label: "SegmentName", required: false, type: .string), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string)
        ]
        /// Sets whether the endpoints create a segment when they are imported.
        public let defineSegment: Bool?
        /// Sets whether the endpoints are registered with Amazon Pinpoint when they are imported.
        public let registerEndpoints: Bool?
        /// The ID of the segment to update if the import job is meant to update an existing segment.
        public let segmentId: String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that contains the endpoints to import.
        public let roleArn: String?
        /// A URL that points to the location within an Amazon S3 bucket that contains the endpoints to import. The location can be a folder or a single file.
        /// The URL should follow this format: s3://bucket-name/folder-name/file-name
        /// Amazon Pinpoint will import endpoints from this location and any subfolders it contains.
        public let s3Url: String?
        /// The format of the files that contain the endpoint definitions.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// A custom name for the segment created by the import job. Use if DefineSegment is true.
        public let segmentName: String?
        /// DEPRECATED. Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?

        public init(defineSegment: Bool? = nil, registerEndpoints: Bool? = nil, segmentId: String? = nil, roleArn: String? = nil, s3Url: String? = nil, format: Format? = nil, segmentName: String? = nil, externalId: String? = nil) {
            self.defineSegment = defineSegment
            self.registerEndpoints = registerEndpoints
            self.segmentId = segmentId
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.format = format
            self.segmentName = segmentName
            self.externalId = externalId
        }

        private enum CodingKeys: String, CodingKey {
            case defineSegment = "DefineSegment"
            case registerEndpoints = "RegisterEndpoints"
            case segmentId = "SegmentId"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case format = "Format"
            case segmentName = "SegmentName"
            case externalId = "ExternalId"
        }
    }

    public struct GetApnsVoipChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelResponse", required: true, type: .structure)
        ]
        public let aPNSVoipChannelResponse: APNSVoipChannelResponse

        public init(aPNSVoipChannelResponse: APNSVoipChannelResponse) {
            self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
        }
    }

    public struct UpdateApnsVoipChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "APNSVoipChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "APNSVoipChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSVoipChannelRequest: APNSVoipChannelRequest
        public let applicationId: String

        public init(aPNSVoipChannelRequest: APNSVoipChannelRequest, applicationId: String) {
            self.aPNSVoipChannelRequest = aPNSVoipChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aPNSVoipChannelRequest = "APNSVoipChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct GPSCoordinates: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Latitude", required: false, type: .double), 
            AWSShapeMember(label: "Longitude", required: false, type: .double)
        ]
        /// Latitude
        public let latitude: Double?
        /// Longitude
        public let longitude: Double?

        public init(latitude: Double? = nil, longitude: Double? = nil) {
            self.latitude = latitude
            self.longitude = longitude
        }

        private enum CodingKeys: String, CodingKey {
            case latitude = "Latitude"
            case longitude = "Longitude"
        }
    }

    public struct BaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecretKey", required: false, type: .string), 
            AWSShapeMember(label: "ApiKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// Platform credential Secret key from Baidu.
        public let secretKey: String?
        /// Platform credential API key from Baidu.
        public let apiKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(secretKey: String? = nil, apiKey: String? = nil, enabled: Bool? = nil) {
            self.secretKey = secretKey
            self.apiKey = apiKey
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case secretKey = "SecretKey"
            case apiKey = "ApiKey"
            case enabled = "Enabled"
        }
    }

    public struct SMSChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ShortCode", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SenderId", required: false, type: .string)
        ]
        /// ShortCode registered with phone provider.
        public let shortCode: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Sender identifier of your messages.
        public let senderId: String?

        public init(shortCode: String? = nil, enabled: Bool? = nil, senderId: String? = nil) {
            self.shortCode = shortCode
            self.enabled = enabled
            self.senderId = senderId
        }

        private enum CodingKeys: String, CodingKey {
            case shortCode = "ShortCode"
            case enabled = "Enabled"
            case senderId = "SenderId"
        }
    }

    public struct CampaignState: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignStatus", required: false, type: .enum)
        ]
        /// The status of the campaign, or the status of a treatment that belongs to an A/B test campaign.
        /// Valid values: SCHEDULED, EXECUTING, PENDING_NEXT_RUN, COMPLETED, PAUSED
        public let campaignStatus: CampaignStatus?

        public init(campaignStatus: CampaignStatus? = nil) {
            self.campaignStatus = campaignStatus
        }

        private enum CodingKeys: String, CodingKey {
            case campaignStatus = "CampaignStatus"
        }
    }

    public struct UpdateAdmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aDMChannelRequest: ADMChannelRequest
        public let applicationId: String

        public init(aDMChannelRequest: ADMChannelRequest, applicationId: String) {
            self.aDMChannelRequest = aDMChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelRequest = "ADMChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct ImportJobResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeMember(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeMember(label: "SegmentId", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "S3Url", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: false, type: .enum), 
            AWSShapeMember(label: "SegmentName", required: false, type: .string), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string)
        ]
        /// Sets whether the endpoints create a segment when they are imported.
        public let defineSegment: Bool?
        /// Sets whether the endpoints are registered with Amazon Pinpoint when they are imported.
        public let registerEndpoints: Bool?
        /// The ID of the segment to update if the import job is meant to update an existing segment.
        public let segmentId: String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that contains the endpoints to import.
        public let roleArn: String?
        /// A URL that points to the location within an Amazon S3 bucket that contains the endpoints to import. The location can be a folder or a single file.
        /// The URL should follow this format: s3://bucket-name/folder-name/file-name
        /// Amazon Pinpoint will import endpoints from this location and any subfolders it contains.
        public let s3Url: String?
        /// The format of the files that contain the endpoint definitions.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// A custom name for the segment created by the import job. Use if DefineSegment is true.
        public let segmentName: String?
        /// DEPRECATED. Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?

        public init(defineSegment: Bool? = nil, registerEndpoints: Bool? = nil, segmentId: String? = nil, roleArn: String? = nil, s3Url: String? = nil, format: Format? = nil, segmentName: String? = nil, externalId: String? = nil) {
            self.defineSegment = defineSegment
            self.registerEndpoints = registerEndpoints
            self.segmentId = segmentId
            self.roleArn = roleArn
            self.s3Url = s3Url
            self.format = format
            self.segmentName = segmentName
            self.externalId = externalId
        }

        private enum CodingKeys: String, CodingKey {
            case defineSegment = "DefineSegment"
            case registerEndpoints = "RegisterEndpoints"
            case segmentId = "SegmentId"
            case roleArn = "RoleArn"
            case s3Url = "S3Url"
            case format = "Format"
            case segmentName = "SegmentName"
            case externalId = "ExternalId"
        }
    }

    public struct UpdateEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EndpointRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointRequest", required: true, type: .structure), 
            AWSShapeMember(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointRequest: EndpointRequest
        public let endpointId: String
        public let applicationId: String

        public init(endpointRequest: EndpointRequest, endpointId: String, applicationId: String) {
            self.endpointRequest = endpointRequest
            self.endpointId = endpointId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case endpointRequest = "EndpointRequest"
            case endpointId = "endpoint-id"
            case applicationId = "application-id"
        }
    }

    public struct GetExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let jobId: String
        public let applicationId: String

        public init(jobId: String, applicationId: String) {
            self.jobId = jobId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "job-id"
            case applicationId = "application-id"
        }
    }

    public struct CreateExportJobResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ExportJobResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExportJobResponse", required: true, type: .structure)
        ]
        public let exportJobResponse: ExportJobResponse

        public init(exportJobResponse: ExportJobResponse) {
            self.exportJobResponse = exportJobResponse
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobResponse = "ExportJobResponse"
        }
    }

    public struct SendUsersMessageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Result", required: false, type: .map), 
            AWSShapeMember(label: "RequestId", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string)
        ]
        /// An object that shows the endpoints that were messaged for each user. The object provides a list of user IDs. For each user ID, it provides the endpoint IDs that were messaged. For each endpoint ID, it provides an EndpointMessageResult object.
        public let result: [String: [String: EndpointMessageResult]]?
        /// The unique ID assigned to the users-messages request.
        public let requestId: String?
        /// The unique ID of the Amazon Pinpoint project used to send the message.
        public let applicationId: String?

        public init(result: [String: [String: EndpointMessageResult]]? = nil, requestId: String? = nil, applicationId: String? = nil) {
            self.result = result
            self.requestId = requestId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case result = "Result"
            case requestId = "RequestId"
            case applicationId = "ApplicationId"
        }
    }

    public struct GetGcmChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct DeleteCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignResponse = "CampaignResponse"
        }
    }

    public struct DeleteAdmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ADMChannelResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ADMChannelResponse", required: true, type: .structure)
        ]
        public let aDMChannelResponse: ADMChannelResponse

        public init(aDMChannelResponse: ADMChannelResponse) {
            self.aDMChannelResponse = aDMChannelResponse
        }

        private enum CodingKeys: String, CodingKey {
            case aDMChannelResponse = "ADMChannelResponse"
        }
    }

    public struct WriteEventStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationStreamArn", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis stream or Firehose delivery stream to which you want to publish events.
        ///  Firehose ARN: arn:aws:firehose:REGION:ACCOUNT_ID:deliverystream/STREAM_NAME
        ///  Kinesis ARN: arn:aws:kinesis:REGION:ACCOUNT_ID:stream/STREAM_NAME
        public let destinationStreamArn: String?
        /// The IAM role that authorizes Amazon Pinpoint to publish events to the stream in your account.
        public let roleArn: String?

        public init(destinationStreamArn: String? = nil, roleArn: String? = nil) {
            self.destinationStreamArn = destinationStreamArn
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinationStreamArn = "DestinationStreamArn"
            case roleArn = "RoleArn"
        }
    }

    public struct DeleteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let campaignId: String
        public let applicationId: String

        public init(campaignId: String, applicationId: String) {
            self.campaignId = campaignId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "campaign-id"
            case applicationId = "application-id"
        }
    }

    public struct ApplicationSettingsResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "CampaignHook", required: false, type: .structure), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "QuietTime", required: false, type: .structure)
        ]
        /// The unique ID for the application.
        public let applicationId: String?
        /// The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own.
        public let limits: CampaignLimits?
        /// Default campaign hook.
        public let campaignHook: CampaignHook?
        /// The date that the settings were last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own.
        public let quietTime: QuietTime?

        public init(applicationId: String? = nil, limits: CampaignLimits? = nil, campaignHook: CampaignHook? = nil, lastModifiedDate: String? = nil, quietTime: QuietTime? = nil) {
            self.applicationId = applicationId
            self.limits = limits
            self.campaignHook = campaignHook
            self.lastModifiedDate = lastModifiedDate
            self.quietTime = quietTime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "ApplicationId"
            case limits = "Limits"
            case campaignHook = "CampaignHook"
            case lastModifiedDate = "LastModifiedDate"
            case quietTime = "QuietTime"
        }
    }

    public struct UpdateEmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "EmailChannelRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EmailChannelRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let emailChannelRequest: EmailChannelRequest
        public let applicationId: String

        public init(emailChannelRequest: EmailChannelRequest, applicationId: String) {
            self.emailChannelRequest = emailChannelRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case emailChannelRequest = "EmailChannelRequest"
            case applicationId = "application-id"
        }
    }

    public struct GetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let jobId: String
        public let applicationId: String

        public init(jobId: String, applicationId: String) {
            self.jobId = jobId
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "job-id"
            case applicationId = "application-id"
        }
    }

    public struct GetChannelsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "ChannelsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelsResponse", required: true, type: .structure)
        ]
        public let channelsResponse: ChannelsResponse

        public init(channelsResponse: ChannelsResponse) {
            self.channelsResponse = channelsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case channelsResponse = "ChannelsResponse"
        }
    }

    public enum Mode: String, CustomStringConvertible, Codable {
        case delivery = "DELIVERY"
        case filter = "FILTER"
        public var description: String { return self.rawValue }
    }

    public enum Action: String, CustomStringConvertible, Codable {
        case openApp = "OPEN_APP"
        case deepLink = "DEEP_LINK"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public struct EventStream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "DestinationStreamArn", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// DEPRECATED. Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The IAM user who last modified the event stream.
        public let lastUpdatedBy: String?
        /// The ID of the application from which events should be published.
        public let applicationId: String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis stream or Firehose delivery stream to which you want to publish events.
        ///  Firehose ARN: arn:aws:firehose:REGION:ACCOUNT_ID:deliverystream/STREAM_NAME
        ///  Kinesis ARN: arn:aws:kinesis:REGION:ACCOUNT_ID:stream/STREAM_NAME
        public let destinationStreamArn: String?
        /// The date the event stream was last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The IAM role that authorizes Amazon Pinpoint to publish events to the stream in your account.
        public let roleArn: String?

        public init(externalId: String? = nil, lastUpdatedBy: String? = nil, applicationId: String? = nil, destinationStreamArn: String? = nil, lastModifiedDate: String? = nil, roleArn: String? = nil) {
            self.externalId = externalId
            self.lastUpdatedBy = lastUpdatedBy
            self.applicationId = applicationId
            self.destinationStreamArn = destinationStreamArn
            self.lastModifiedDate = lastModifiedDate
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "ExternalId"
            case lastUpdatedBy = "LastUpdatedBy"
            case applicationId = "ApplicationId"
            case destinationStreamArn = "DestinationStreamArn"
            case lastModifiedDate = "LastModifiedDate"
            case roleArn = "RoleArn"
        }
    }

    public struct APNSChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultAuthenticationMethod", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .string), 
            AWSShapeMember(label: "CreationDate", required: false, type: .string), 
            AWSShapeMember(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeMember(label: "HasCredential", required: false, type: .boolean), 
            AWSShapeMember(label: "HasTokenKey", required: false, type: .boolean), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer), 
            AWSShapeMember(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// The default authentication method used for APNs.
        public let defaultAuthenticationMethod: String?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Not used. Retained for backwards compatibility.
        public let hasCredential: Bool?
        /// Indicates whether the channel is configured with a key for APNs token authentication. Provide a token key by setting the TokenKey attribute.
        public let hasTokenKey: Bool?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Channel ID. Not used. Present only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(defaultAuthenticationMethod: String? = nil, lastModifiedDate: String? = nil, applicationId: String? = nil, platform: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, hasCredential: Bool? = nil, hasTokenKey: Bool? = nil, enabled: Bool? = nil, id: String? = nil, version: Int32? = nil, lastModifiedBy: String? = nil) {
            self.defaultAuthenticationMethod = defaultAuthenticationMethod
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.platform = platform
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.hasCredential = hasCredential
            self.hasTokenKey = hasTokenKey
            self.enabled = enabled
            self.id = id
            self.version = version
            self.lastModifiedBy = lastModifiedBy
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
            case lastModifiedDate = "LastModifiedDate"
            case applicationId = "ApplicationId"
            case platform = "Platform"
            case creationDate = "CreationDate"
            case isArchived = "IsArchived"
            case hasCredential = "HasCredential"
            case hasTokenKey = "HasTokenKey"
            case enabled = "Enabled"
            case id = "Id"
            case version = "Version"
            case lastModifiedBy = "LastModifiedBy"
        }
    }

    public struct CampaignsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Item", required: false, type: .list)
        ]
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?
        /// A list of campaigns.
        public let item: [CampaignResponse]?

        public init(nextToken: String? = nil, item: [CampaignResponse]? = nil) {
            self.nextToken = nextToken
            self.item = item
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case item = "Item"
        }
    }

    public struct GetBaiduChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct SendUsersMessageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Context", required: false, type: .map), 
            AWSShapeMember(label: "Users", required: false, type: .map), 
            AWSShapeMember(label: "MessageConfiguration", required: false, type: .structure)
        ]
        /// A map of custom attribute-value pairs. Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the push notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.
        public let context: [String: String]?
        /// A map that associates user IDs with EndpointSendConfiguration objects. Within an EndpointSendConfiguration object, you can tailor the message for a user by specifying message overrides or substitutions.
        public let users: [String: EndpointSendConfiguration]?
        /// Message definitions for the default message and any messages that are tailored for specific channels.
        public let messageConfiguration: DirectMessageConfiguration?

        public init(context: [String: String]? = nil, users: [String: EndpointSendConfiguration]? = nil, messageConfiguration: DirectMessageConfiguration? = nil) {
            self.context = context
            self.users = users
            self.messageConfiguration = messageConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case context = "Context"
            case users = "Users"
            case messageConfiguration = "MessageConfiguration"
        }
    }

    public struct GetCampaignVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "CampaignsResponse"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CampaignsResponse", required: true, type: .structure)
        ]
        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        private enum CodingKeys: String, CodingKey {
            case campaignsResponse = "CampaignsResponse"
        }
    }

    public struct DeleteEmailChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "application-id"
        }
    }

    public struct SegmentImportResource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "Format", required: false, type: .enum), 
            AWSShapeMember(label: "S3Url", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "Size", required: false, type: .integer), 
            AWSShapeMember(label: "ChannelCounts", required: false, type: .map)
        ]
        /// DEPRECATED. Your AWS account ID, which you assigned to the ExternalID key in an IAM trust policy. Used by Amazon Pinpoint to assume an IAM role. This requirement is removed, and external IDs are not recommended for IAM roles assumed by Amazon Pinpoint.
        public let externalId: String?
        /// The format of the endpoint files that were imported to create this segment.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// A URL that points to the Amazon S3 location from which the endpoints for this segment were imported.
        public let s3Url: String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the endpoints in Amazon S3.
        public let roleArn: String?
        /// The number of endpoints that were successfully imported to create this segment.
        public let size: Int32?
        /// Channel type counts
        public let channelCounts: [String: Int32]?

        public init(externalId: String? = nil, format: Format? = nil, s3Url: String? = nil, roleArn: String? = nil, size: Int32? = nil, channelCounts: [String: Int32]? = nil) {
            self.externalId = externalId
            self.format = format
            self.s3Url = s3Url
            self.roleArn = roleArn
            self.size = size
            self.channelCounts = channelCounts
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "ExternalId"
            case format = "Format"
            case s3Url = "S3Url"
            case roleArn = "RoleArn"
            case size = "Size"
            case channelCounts = "ChannelCounts"
        }
    }

    public struct CreateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "WriteSegmentRequest"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WriteSegmentRequest", required: true, type: .structure), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let writeSegmentRequest: WriteSegmentRequest
        public let applicationId: String

        public init(writeSegmentRequest: WriteSegmentRequest, applicationId: String) {
            self.writeSegmentRequest = writeSegmentRequest
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case writeSegmentRequest = "WriteSegmentRequest"
            case applicationId = "application-id"
        }
    }

    public struct GCMChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApiKey", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// Platform credential API key from Google.
        public let apiKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(apiKey: String? = nil, enabled: Bool? = nil) {
            self.apiKey = apiKey
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "ApiKey"
            case enabled = "Enabled"
        }
    }

}