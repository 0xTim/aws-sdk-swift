// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Appsync {

    public struct UpdateResolverResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resolver", required: false, type: .structure)
        ]
        /// The updated Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct DeleteApiKeyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "id", location: .uri(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The ID for the API key.
        public let id: String
        /// The API ID.
        public let apiId: String

        public init(id: String, apiId: String) {
            self.id = id
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case apiId = "apiId"
        }
    }

    public enum TypeDefinitionFormat: String, CustomStringConvertible, Codable {
        case sdl = "SDL"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public struct ListResolversResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resolvers", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The Resolver objects.
        public let resolvers: [Resolver]?
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(resolvers: [Resolver]? = nil, nextToken: String? = nil) {
            self.resolvers = resolvers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case resolvers = "resolvers"
            case nextToken = "nextToken"
        }
    }

    public struct GetResolverRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "fieldName", location: .uri(locationName: "fieldName"), required: true, type: .string)
        ]
        /// The resolver type name.
        public let typeName: String
        /// The API ID.
        public let apiId: String
        /// The resolver field name.
        public let fieldName: String

        public init(typeName: String, apiId: String, fieldName: String) {
            self.typeName = typeName
            self.apiId = apiId
            self.fieldName = fieldName
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case fieldName = "fieldName"
        }
    }

    public struct GetGraphqlApiRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The API ID for the GraphQL API.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
        }
    }

    public struct CreateGraphqlApiRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "userPoolConfig", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "authenticationType", required: true, type: .enum)
        ]
        /// The Amazon Cognito User Pool configuration.
        public let userPoolConfig: UserPoolConfig?
        /// A user-supplied name for the GraphqlApi.
        public let name: String
        /// The authentication type: API key, IAM, or Amazon Cognito User Pools.
        public let authenticationType: AuthenticationType

        public init(userPoolConfig: UserPoolConfig? = nil, name: String, authenticationType: AuthenticationType) {
            self.userPoolConfig = userPoolConfig
            self.name = name
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case userPoolConfig = "userPoolConfig"
            case name = "name"
            case authenticationType = "authenticationType"
        }
    }

    public struct UpdateTypeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "definition", required: false, type: .string), 
            AWSShapeMember(label: "format", required: true, type: .enum)
        ]
        /// The new type name.
        public let typeName: String
        /// The API ID.
        public let apiId: String
        /// The new definition.
        public let definition: String?
        /// The new type format: SDL or JSON.
        public let format: TypeDefinitionFormat

        public init(typeName: String, apiId: String, definition: String? = nil, format: TypeDefinitionFormat) {
            self.typeName = typeName
            self.apiId = apiId
            self.definition = definition
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case definition = "definition"
            case format = "format"
        }
    }

    public struct GetTypeResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .structure)
        ]
        /// The Type object.
        public let `type`: `Type`?

        public init(type: `Type`? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct ListTypesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "types", required: false, type: .list)
        ]
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The Type objects.
        public let types: [`Type`]?

        public init(nextToken: String? = nil, types: [`Type`]? = nil) {
            self.nextToken = nextToken
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case types = "types"
        }
    }

    public struct DeleteDataSourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The name of the data source.
        public let name: String
        /// The API ID.
        public let apiId: String

        public init(name: String, apiId: String) {
            self.name = name
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case apiId = "apiId"
        }
    }

    public struct GetDataSourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataSource", required: false, type: .structure)
        ]
        /// The DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct CreateDataSourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataSource", required: false, type: .structure)
        ]
        /// The DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct GetGraphqlApiResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "graphqlApi", required: false, type: .structure)
        ]
        /// The GraphqlApi object.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct GetDataSourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The name of the data source.
        public let name: String
        /// The API ID.
        public let apiId: String

        public init(name: String, apiId: String) {
            self.name = name
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case apiId = "apiId"
        }
    }

    public struct DeleteApiKeyResponse: AWSShape {

    }

    public struct ListDataSourcesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?
        /// The maximum number of results you want the request to return.
        public let maxResults: Int32?
        /// The API ID.
        public let apiId: String

        public init(nextToken: String? = nil, maxResults: Int32? = nil, apiId: String) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
            case apiId = "apiId"
        }
    }

    public struct GetResolverResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resolver", required: false, type: .structure)
        ]
        /// The Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct CreateResolverRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "dataSourceName", required: true, type: .string), 
            AWSShapeMember(label: "responseMappingTemplate", required: false, type: .string), 
            AWSShapeMember(label: "fieldName", required: true, type: .string), 
            AWSShapeMember(label: "requestMappingTemplate", required: true, type: .string)
        ]
        /// The name of the Type.
        public let typeName: String
        /// The ID for the GraphQL API for which the resolver is being created.
        public let apiId: String
        /// The name of the data source for which the resolver is being created.
        public let dataSourceName: String
        /// The mapping template to be used for responses from the data source.
        public let responseMappingTemplate: String?
        /// The name of the field to attach the resolver to.
        public let fieldName: String
        /// The mapping template to be used for requests. A resolver use a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).
        public let requestMappingTemplate: String

        public init(typeName: String, apiId: String, dataSourceName: String, responseMappingTemplate: String? = nil, fieldName: String, requestMappingTemplate: String) {
            self.typeName = typeName
            self.apiId = apiId
            self.dataSourceName = dataSourceName
            self.responseMappingTemplate = responseMappingTemplate
            self.fieldName = fieldName
            self.requestMappingTemplate = requestMappingTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case dataSourceName = "dataSourceName"
            case responseMappingTemplate = "responseMappingTemplate"
            case fieldName = "fieldName"
            case requestMappingTemplate = "requestMappingTemplate"
        }
    }

    public enum OutputType: String, CustomStringConvertible, Codable {
        case sdl = "SDL"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum DefaultAction: String, CustomStringConvertible, Codable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public struct GraphqlApi: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "apiId", required: false, type: .string), 
            AWSShapeMember(label: "uris", required: false, type: .map), 
            AWSShapeMember(label: "userPoolConfig", required: false, type: .structure), 
            AWSShapeMember(label: "authenticationType", required: false, type: .enum), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The API name.
        public let name: String?
        /// The API ID.
        public let apiId: String?
        /// The URIs.
        public let uris: [String: String]?
        /// The Amazon Cognito User Pool configuration.
        public let userPoolConfig: UserPoolConfig?
        /// The authentication type.
        public let authenticationType: AuthenticationType?
        /// The ARN.
        public let arn: String?

        public init(name: String? = nil, apiId: String? = nil, uris: [String: String]? = nil, userPoolConfig: UserPoolConfig? = nil, authenticationType: AuthenticationType? = nil, arn: String? = nil) {
            self.name = name
            self.apiId = apiId
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.authenticationType = authenticationType
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case apiId = "apiId"
            case uris = "uris"
            case userPoolConfig = "userPoolConfig"
            case authenticationType = "authenticationType"
            case arn = "arn"
        }
    }

    public struct GetSchemaCreationStatusResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "details", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// Detailed information about the status of the schema creation operation.
        public let details: String?
        /// The current state of the schema (PROCESSING, ACTIVE, or DELETING). Once the schema is in the ACTIVE state, you can add data.
        public let status: SchemaStatus?

        public init(details: String? = nil, status: SchemaStatus? = nil) {
            self.details = details
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case status = "status"
        }
    }

    public struct ListApiKeysResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiKeys", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The ApiKey objects.
        public let apiKeys: [ApiKey]?
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(apiKeys: [ApiKey]? = nil, nextToken: String? = nil) {
            self.apiKeys = apiKeys
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeys = "apiKeys"
            case nextToken = "nextToken"
        }
    }

    public struct ListGraphqlApisRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?
        /// The maximum number of results you want the request to return.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public struct ListDataSourcesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "dataSources", required: false, type: .list)
        ]
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The DataSource objects.
        public let dataSources: [DataSource]?

        public init(nextToken: String? = nil, dataSources: [DataSource]? = nil) {
            self.nextToken = nextToken
            self.dataSources = dataSources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case dataSources = "dataSources"
        }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable {
        case awsLambda = "AWS_LAMBDA"
        case amazonDynamodb = "AMAZON_DYNAMODB"
        case amazonElasticsearch = "AMAZON_ELASTICSEARCH"
        public var description: String { return self.rawValue }
    }

    public struct DeleteTypeResponse: AWSShape {

    }

    public struct UpdateGraphqlApiResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "graphqlApi", required: false, type: .structure)
        ]
        /// The udpated GraphqlApi object.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct UpdateResolverRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "dataSourceName", required: true, type: .string), 
            AWSShapeMember(label: "responseMappingTemplate", required: false, type: .string), 
            AWSShapeMember(label: "fieldName", location: .uri(locationName: "fieldName"), required: true, type: .string), 
            AWSShapeMember(label: "requestMappingTemplate", required: true, type: .string)
        ]
        /// The new type name.
        public let typeName: String
        /// The API ID.
        public let apiId: String
        /// The new data source name.
        public let dataSourceName: String
        /// The new response mapping template.
        public let responseMappingTemplate: String?
        /// The new field name.
        public let fieldName: String
        /// The new request mapping template.
        public let requestMappingTemplate: String

        public init(typeName: String, apiId: String, dataSourceName: String, responseMappingTemplate: String? = nil, fieldName: String, requestMappingTemplate: String) {
            self.typeName = typeName
            self.apiId = apiId
            self.dataSourceName = dataSourceName
            self.responseMappingTemplate = responseMappingTemplate
            self.fieldName = fieldName
            self.requestMappingTemplate = requestMappingTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case dataSourceName = "dataSourceName"
            case responseMappingTemplate = "responseMappingTemplate"
            case fieldName = "fieldName"
            case requestMappingTemplate = "requestMappingTemplate"
        }
    }

    public struct UserPoolConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultAction", required: true, type: .enum), 
            AWSShapeMember(label: "appIdClientRegex", required: false, type: .string), 
            AWSShapeMember(label: "awsRegion", required: true, type: .string), 
            AWSShapeMember(label: "userPoolId", required: true, type: .string)
        ]
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito User Pool authentication doesn't match the Amazon Cognito User Pool configuration.
        public let defaultAction: DefaultAction
        /// A regular expression for validating the incoming Amazon Cognito User Pool app client ID.
        public let appIdClientRegex: String?
        /// The AWS region in which the user pool was created.
        public let awsRegion: String
        /// The user pool ID.
        public let userPoolId: String

        public init(defaultAction: DefaultAction, appIdClientRegex: String? = nil, awsRegion: String, userPoolId: String) {
            self.defaultAction = defaultAction
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "defaultAction"
            case appIdClientRegex = "appIdClientRegex"
            case awsRegion = "awsRegion"
            case userPoolId = "userPoolId"
        }
    }

    public struct DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dynamodbConfig", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "dataSourceArn", required: false, type: .string), 
            AWSShapeMember(label: "lambdaConfig", required: false, type: .structure), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "serviceRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "elasticsearchConfig", required: false, type: .structure), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// DynamoDB settings.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// The name of the data source.
        public let name: String?
        /// The data source ARN.
        public let dataSourceArn: String?
        /// Lambda settings.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// The description of the data source.
        public let description: String?
        /// The IAM service role ARN for the data source. The system assumes this role when accessing the data source.
        public let serviceRoleArn: String?
        /// Amazon Elasticsearch settings.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// The type of the data source.
        public let `type`: DataSourceType?

        public init(dynamodbConfig: DynamodbDataSourceConfig? = nil, name: String? = nil, dataSourceArn: String? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, description: String? = nil, serviceRoleArn: String? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, type: DataSourceType? = nil) {
            self.dynamodbConfig = dynamodbConfig
            self.name = name
            self.dataSourceArn = dataSourceArn
            self.lambdaConfig = lambdaConfig
            self.description = description
            self.serviceRoleArn = serviceRoleArn
            self.elasticsearchConfig = elasticsearchConfig
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case dynamodbConfig = "dynamodbConfig"
            case name = "name"
            case dataSourceArn = "dataSourceArn"
            case lambdaConfig = "lambdaConfig"
            case description = "description"
            case serviceRoleArn = "serviceRoleArn"
            case elasticsearchConfig = "elasticsearchConfig"
            case `type` = "type"
        }
    }

    public struct CreateGraphqlApiResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "graphqlApi", required: false, type: .structure)
        ]
        /// The GraphqlApi.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct `Type`: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "format", required: false, type: .enum), 
            AWSShapeMember(label: "definition", required: false, type: .string), 
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The type description.
        public let description: String?
        /// The type name.
        public let name: String?
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat?
        /// The type definition.
        public let definition: String?
        /// The type ARN.
        public let arn: String?

        public init(description: String? = nil, name: String? = nil, format: TypeDefinitionFormat? = nil, definition: String? = nil, arn: String? = nil) {
            self.description = description
            self.name = name
            self.format = format
            self.definition = definition
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case format = "format"
            case definition = "definition"
            case arn = "arn"
        }
    }

    public struct GetTypeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum)
        ]
        /// The type name.
        public let typeName: String
        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat

        public init(typeName: String, apiId: String, format: TypeDefinitionFormat) {
            self.typeName = typeName
            self.apiId = apiId
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case format = "format"
        }
    }

    public struct CreateResolverResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resolver", required: false, type: .structure)
        ]
        /// The Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct DynamodbDataSourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "awsRegion", required: true, type: .string), 
            AWSShapeMember(label: "useCallerCredentials", required: false, type: .boolean), 
            AWSShapeMember(label: "tableName", required: true, type: .string)
        ]
        /// The AWS region.
        public let awsRegion: String
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public let useCallerCredentials: Bool?
        /// The table name.
        public let tableName: String

        public init(awsRegion: String, useCallerCredentials: Bool? = nil, tableName: String) {
            self.awsRegion = awsRegion
            self.useCallerCredentials = useCallerCredentials
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case useCallerCredentials = "useCallerCredentials"
            case tableName = "tableName"
        }
    }

    public struct UpdateDataSourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataSource", required: false, type: .structure)
        ]
        /// The updated DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct ListApiKeysRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The maximum number of results you want the request to return.
        public let maxResults: Int32?
        /// The API ID.
        public let apiId: String

        public init(nextToken: String? = nil, maxResults: Int32? = nil, apiId: String) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
            case apiId = "apiId"
        }
    }

    public struct ApiKey: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "id", required: false, type: .string), 
            AWSShapeMember(label: "expires", required: false, type: .long), 
            AWSShapeMember(label: "description", required: false, type: .string)
        ]
        /// The API key ID.
        public let id: String?
        /// The time when the API key expires.
        public let expires: Int64?
        /// A description of the purpose of the API key.
        public let description: String?

        public init(id: String? = nil, expires: Int64? = nil, description: String? = nil) {
            self.id = id
            self.expires = expires
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case expires = "expires"
            case description = "description"
        }
    }

    public struct DeleteGraphqlApiRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
        }
    }

    public struct UpdateTypeResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .structure)
        ]
        /// The updated Type object.
        public let `type`: `Type`?

        public init(type: `Type`? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct LambdaDataSourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "lambdaFunctionArn", required: true, type: .string)
        ]
        /// The ARN for the Lambda function.
        public let lambdaFunctionArn: String

        public init(lambdaFunctionArn: String) {
            self.lambdaFunctionArn = lambdaFunctionArn
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctionArn = "lambdaFunctionArn"
        }
    }

    public struct CreateApiKeyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiKey", required: false, type: .structure)
        ]
        /// The API key.
        public let apiKey: ApiKey?

        public init(apiKey: ApiKey? = nil) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct ListResolversRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// The type name.
        public let typeName: String
        /// The API ID.
        public let apiId: String
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?
        /// The maximum number of results you want the request to return.
        public let maxResults: Int32?

        public init(typeName: String, apiId: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.typeName = typeName
            self.apiId = apiId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable {
        case apiKey = "API_KEY"
        case awsIam = "AWS_IAM"
        case amazonCognitoUserPools = "AMAZON_COGNITO_USER_POOLS"
        public var description: String { return self.rawValue }
    }

    public struct ElasticsearchDataSourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "awsRegion", required: true, type: .string), 
            AWSShapeMember(label: "endpoint", required: true, type: .string)
        ]
        /// The AWS region.
        public let awsRegion: String
        /// The endpoint.
        public let endpoint: String

        public init(awsRegion: String, endpoint: String) {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case endpoint = "endpoint"
        }
    }

    public struct CreateTypeResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .structure)
        ]
        /// The Type object.
        public let `type`: `Type`?

        public init(type: `Type`? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct StartSchemaCreationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "definition", required: true, type: .blob), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The schema definition, in GraphQL schema language format.
        public let definition: Data
        /// The API ID.
        public let apiId: String

        public init(definition: Data, apiId: String) {
            self.definition = definition
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case apiId = "apiId"
        }
    }

    public struct GetSchemaCreationStatusRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
        }
    }

    public struct Resolver: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resolverArn", required: false, type: .string), 
            AWSShapeMember(label: "typeName", required: false, type: .string), 
            AWSShapeMember(label: "dataSourceName", required: false, type: .string), 
            AWSShapeMember(label: "responseMappingTemplate", required: false, type: .string), 
            AWSShapeMember(label: "fieldName", required: false, type: .string), 
            AWSShapeMember(label: "requestMappingTemplate", required: false, type: .string)
        ]
        /// The resolver ARN.
        public let resolverArn: String?
        /// The resolver type name.
        public let typeName: String?
        /// The resolver data source name.
        public let dataSourceName: String?
        /// The response mapping template.
        public let responseMappingTemplate: String?
        /// The resolver field name.
        public let fieldName: String?
        /// The request mapping template.
        public let requestMappingTemplate: String?

        public init(resolverArn: String? = nil, typeName: String? = nil, dataSourceName: String? = nil, responseMappingTemplate: String? = nil, fieldName: String? = nil, requestMappingTemplate: String? = nil) {
            self.resolverArn = resolverArn
            self.typeName = typeName
            self.dataSourceName = dataSourceName
            self.responseMappingTemplate = responseMappingTemplate
            self.fieldName = fieldName
            self.requestMappingTemplate = requestMappingTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case resolverArn = "resolverArn"
            case typeName = "typeName"
            case dataSourceName = "dataSourceName"
            case responseMappingTemplate = "responseMappingTemplate"
            case fieldName = "fieldName"
            case requestMappingTemplate = "requestMappingTemplate"
        }
    }

    public struct UpdateDataSourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dynamodbConfig", required: false, type: .structure), 
            AWSShapeMember(label: "name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "lambdaConfig", required: false, type: .structure), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "serviceRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "elasticsearchConfig", required: false, type: .structure), 
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]
        /// The new DynamoDB configuration.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// The new name for the data source.
        public let name: String
        /// The API ID.
        public let apiId: String
        /// The new Lambda configuration.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// The new description for the data source.
        public let description: String?
        /// The new service role ARN for the data source.
        public let serviceRoleArn: String?
        /// The new Elasticsearch configuration.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// The new data source type.
        public let `type`: DataSourceType

        public init(dynamodbConfig: DynamodbDataSourceConfig? = nil, name: String, apiId: String, lambdaConfig: LambdaDataSourceConfig? = nil, description: String? = nil, serviceRoleArn: String? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, type: DataSourceType) {
            self.dynamodbConfig = dynamodbConfig
            self.name = name
            self.apiId = apiId
            self.lambdaConfig = lambdaConfig
            self.description = description
            self.serviceRoleArn = serviceRoleArn
            self.elasticsearchConfig = elasticsearchConfig
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case dynamodbConfig = "dynamodbConfig"
            case name = "name"
            case apiId = "apiId"
            case lambdaConfig = "lambdaConfig"
            case description = "description"
            case serviceRoleArn = "serviceRoleArn"
            case elasticsearchConfig = "elasticsearchConfig"
            case `type` = "type"
        }
    }

    public struct UpdateGraphqlApiRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "userPoolConfig", required: false, type: .structure), 
            AWSShapeMember(label: "authenticationType", required: false, type: .enum)
        ]
        /// The new name for the GraphqlApi object.
        public let name: String
        /// The API ID.
        public let apiId: String
        /// The new Amazon Cognito User Pool configuration for the GraphqlApi object.
        public let userPoolConfig: UserPoolConfig?
        /// The new authentication type for the GraphqlApi object.
        public let authenticationType: AuthenticationType?

        public init(name: String, apiId: String, userPoolConfig: UserPoolConfig? = nil, authenticationType: AuthenticationType? = nil) {
            self.name = name
            self.apiId = apiId
            self.userPoolConfig = userPoolConfig
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case apiId = "apiId"
            case userPoolConfig = "userPoolConfig"
            case authenticationType = "authenticationType"
        }
    }

    public struct StartSchemaCreationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The current state of the schema (PROCESSING, ACTIVE, or DELETING). Once the schema is in the ACTIVE state, you can add data.
        public let status: SchemaStatus?

        public init(status: SchemaStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ListTypesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum)
        ]
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?
        /// The maximum number of results you want the request to return.
        public let maxResults: Int32?
        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat

        public init(nextToken: String? = nil, maxResults: Int32? = nil, apiId: String, format: TypeDefinitionFormat) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.apiId = apiId
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
            case apiId = "apiId"
            case format = "format"
        }
    }

    public struct DeleteDataSourceResponse: AWSShape {

    }

    public struct CreateTypeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "definition", required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "format", required: true, type: .enum)
        ]
        /// The type definition, in GraphQL Schema Definition Language (SDL) format. For more information, see the GraphQL SDL documentation.
        public let definition: String
        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat

        public init(definition: String, apiId: String, format: TypeDefinitionFormat) {
            self.definition = definition
            self.apiId = apiId
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case apiId = "apiId"
            case format = "format"
        }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable {
        case processing = "PROCESSING"
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public struct DeleteResolverResponse: AWSShape {

    }

    public struct ListGraphqlApisResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "graphqlApis", required: false, type: .list)
        ]
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The GraphqlApi objects.
        public let graphqlApis: [GraphqlApi]?

        public init(nextToken: String? = nil, graphqlApis: [GraphqlApi]? = nil) {
            self.nextToken = nextToken
            self.graphqlApis = graphqlApis
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case graphqlApis = "graphqlApis"
        }
    }

    public struct GetIntrospectionSchemaResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "schema"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schema", required: false, type: .blob)
        ]
        /// The schema, in GraphQL Schema Definition Language (SDL) format. For more information, see the GraphQL SDL documentation.
        public let schema: Data?

        public init(schema: Data? = nil) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct DeleteGraphqlApiResponse: AWSShape {

    }

    public struct DeleteResolverRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "fieldName", location: .uri(locationName: "fieldName"), required: true, type: .string)
        ]
        /// The name of the resolver type.
        public let typeName: String
        /// The API ID.
        public let apiId: String
        /// The resolver field name.
        public let fieldName: String

        public init(typeName: String, apiId: String, fieldName: String) {
            self.typeName = typeName
            self.apiId = apiId
            self.fieldName = fieldName
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
            case fieldName = "fieldName"
        }
    }

    public struct CreateApiKeyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// A description of the purpose of the API key.
        public let description: String?
        /// The ID for your GraphQL API.
        public let apiId: String

        public init(description: String? = nil, apiId: String) {
            self.description = description
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case apiId = "apiId"
        }
    }

    public struct DeleteTypeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "typeName", location: .uri(locationName: "typeName"), required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string)
        ]
        /// The type name.
        public let typeName: String
        /// The API ID.
        public let apiId: String

        public init(typeName: String, apiId: String) {
            self.typeName = typeName
            self.apiId = apiId
        }

        private enum CodingKeys: String, CodingKey {
            case typeName = "typeName"
            case apiId = "apiId"
        }
    }

    public struct CreateDataSourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dynamodbConfig", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "lambdaConfig", required: false, type: .structure), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "serviceRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "elasticsearchConfig", required: false, type: .structure), 
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]
        /// DynamoDB settings.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// A user-supplied name for the DataSource.
        public let name: String
        /// The API ID for the GraphQL API for the DataSource.
        public let apiId: String
        /// AWS Lambda settings.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// A description of the DataSource.
        public let description: String?
        /// The IAM service role ARN for the data source. The system assumes this role when accessing the data source.
        public let serviceRoleArn: String?
        /// Amazon Elasticsearch settings.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// The type of the DataSource.
        public let `type`: DataSourceType

        public init(dynamodbConfig: DynamodbDataSourceConfig? = nil, name: String, apiId: String, lambdaConfig: LambdaDataSourceConfig? = nil, description: String? = nil, serviceRoleArn: String? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, type: DataSourceType) {
            self.dynamodbConfig = dynamodbConfig
            self.name = name
            self.apiId = apiId
            self.lambdaConfig = lambdaConfig
            self.description = description
            self.serviceRoleArn = serviceRoleArn
            self.elasticsearchConfig = elasticsearchConfig
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case dynamodbConfig = "dynamodbConfig"
            case name = "name"
            case apiId = "apiId"
            case lambdaConfig = "lambdaConfig"
            case description = "description"
            case serviceRoleArn = "serviceRoleArn"
            case elasticsearchConfig = "elasticsearchConfig"
            case `type` = "type"
        }
    }

    public struct GetIntrospectionSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiId", location: .uri(locationName: "apiId"), required: true, type: .string), 
            AWSShapeMember(label: "format", location: .querystring(locationName: "format"), required: true, type: .enum)
        ]
        /// The API ID.
        public let apiId: String
        /// The schema format: SDL or JSON.
        public let format: OutputType

        public init(apiId: String, format: OutputType) {
            self.apiId = apiId
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case format = "format"
        }
    }

}