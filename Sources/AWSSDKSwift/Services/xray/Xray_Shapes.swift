// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Xray {

    public struct BatchGetTracesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Pagination token. Not used.
        public var nextToken: String? = nil
        /// Full traces for the specified requests.
        public var traces: [Trace]? = nil
        /// Trace IDs of requests that haven't been processed.
        public var unprocessedTraceIds: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let traces = dictionary["Traces"] as? [[String: Any]] {
                self.traces = try traces.map({ try Trace(dictionary: $0) })
            }
            if let unprocessedTraceIds = dictionary["UnprocessedTraceIds"] as? [String] {
                self.unprocessedTraceIds = unprocessedTraceIds
            }
        }
    }

    public struct EdgeStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The aggregate response time of completed requests.
        public var totalResponseTime: Double? = nil
        /// Information about requests that failed with a 5xx Server Error status code.
        public var faultStatistics: FaultStatistics? = nil
        /// The number of requests that completed with a 2xx Success status code.
        public var okCount: Int64? = nil
        /// Information about requests that failed with a 4xx Client Error status code.
        public var errorStatistics: ErrorStatistics? = nil
        /// The total number of completed requests.
        public var totalCount: Int64? = nil

        public init() {}

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalResponseTime = dictionary["TotalResponseTime"] as? Double
            if let faultStatistics = dictionary["FaultStatistics"] as? [String: Any] { self.faultStatistics = try Xray.FaultStatistics(dictionary: faultStatistics) }
            self.okCount = dictionary["OkCount"] as? Int64
            if let errorStatistics = dictionary["ErrorStatistics"] as? [String: Any] { self.errorStatistics = try Xray.ErrorStatistics(dictionary: errorStatistics) }
            self.totalCount = dictionary["TotalCount"] as? Int64
        }
    }

    public struct Segment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The segment document.
        public var document: String? = nil
        /// The segment's ID.
        public var id: String? = nil

        public init() {}

        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.document = dictionary["Document"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public struct Alias: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of the alias.
        public var type: String? = nil
        /// The canonical name of the alias.
        public var name: String? = nil
        /// A list of names for the alias, including the canonical name.
        public var names: [String]? = nil

        public init() {}

        public init(type: String? = nil, name: String? = nil, names: [String]? = nil) {
            self.type = type
            self.name = name
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["Type"] as? String
            self.name = dictionary["Name"] as? String
            if let names = dictionary["Names"] as? [String] {
                self.names = names
            }
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Services to which the annotation applies.
        public var serviceIds: [ServiceId]? = nil
        /// Values of the annotation.
        public var annotationValue: AnnotationValue? = nil

        public init() {}

        public init(serviceIds: [ServiceId]? = nil, annotationValue: AnnotationValue? = nil) {
            self.serviceIds = serviceIds
            self.annotationValue = annotationValue
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            }
            if let annotationValue = dictionary["AnnotationValue"] as? [String: Any] { self.annotationValue = try Xray.AnnotationValue(dictionary: annotationValue) }
        }
    }

    public struct HistogramEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The value of the entry.
        public var value: Double? = nil
        /// The prevalence of the entry.
        public var count: Int32? = nil

        public init() {}

        public init(value: Double? = nil, count: Int32? = nil) {
            self.value = value
            self.count = count
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Double
            self.count = dictionary["Count"] as? Int32
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The segment's ID.
        public var id: String? = nil
        /// The error that caused processing to fail.
        public var errorCode: String? = nil
        /// The error message.
        public var message: String? = nil

        public init() {}

        public init(id: String? = nil, errorCode: String? = nil, message: String? = nil) {
            self.id = id
            self.errorCode = errorCode
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct GetTraceSummariesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of traces that were processed to get this set of summaries.
        public var tracesProcessedCount: Int64? = nil
        /// Trace IDs and metadata for traces that were found in the specified time frame.
        public var traceSummaries: [TraceSummary]? = nil
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public var nextToken: String? = nil
        /// The start time of this page of results.
        public var approximateTime: Date? = nil

        public init() {}

        public init(tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil, nextToken: String? = nil, approximateTime: Date? = nil) {
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
            self.nextToken = nextToken
            self.approximateTime = approximateTime
        }

        public init(dictionary: [String: Any]) throws {
            self.tracesProcessedCount = dictionary["TracesProcessedCount"] as? Int64
            if let traceSummaries = dictionary["TraceSummaries"] as? [[String: Any]] {
                self.traceSummaries = try traceSummaries.map({ try TraceSummary(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.approximateTime = dictionary["ApproximateTime"] as? Date
        }
    }

    public struct Edge: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start time of the first segment on the edge.
        public var startTime: Date? = nil
        /// Response statistics for segments on the edge.
        public var summaryStatistics: EdgeStatistics? = nil
        /// The end time of the last segment on the edge.
        public var endTime: Date? = nil
        /// Identifier of the edge. Unique within a service map.
        public var referenceId: Int32? = nil
        /// Aliases for the edge.
        public var aliases: [Alias]? = nil
        /// Histogram describing the prominence of response times on the edge.
        public var responseTimeHistogram: [HistogramEntry]? = nil

        public init() {}

        public init(startTime: Date? = nil, summaryStatistics: EdgeStatistics? = nil, endTime: Date? = nil, referenceId: Int32? = nil, aliases: [Alias]? = nil, responseTimeHistogram: [HistogramEntry]? = nil) {
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
            self.endTime = endTime
            self.referenceId = referenceId
            self.aliases = aliases
            self.responseTimeHistogram = responseTimeHistogram
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            if let summaryStatistics = dictionary["SummaryStatistics"] as? [String: Any] { self.summaryStatistics = try Xray.EdgeStatistics(dictionary: summaryStatistics) }
            self.endTime = dictionary["EndTime"] as? Date
            self.referenceId = dictionary["ReferenceId"] as? Int32
            if let aliases = dictionary["Aliases"] as? [[String: Any]] {
                self.aliases = try aliases.map({ try Alias(dictionary: $0) })
            }
            if let responseTimeHistogram = dictionary["ResponseTimeHistogram"] as? [[String: Any]] {
                self.responseTimeHistogram = try responseTimeHistogram.map({ try HistogramEntry(dictionary: $0) })
            }
        }
    }

    public struct ErrorStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The total number of requests that failed with a 4xx Client Error status code.
        public var totalCount: Int64? = nil
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public var otherCount: Int64? = nil
        /// The number of requests that failed with a 419 throttling status code.
        public var throttleCount: Int64? = nil

        public init() {}

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil, throttleCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
            self.throttleCount = throttleCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalCount = dictionary["TotalCount"] as? Int64
            self.otherCount = dictionary["OtherCount"] as? Int64
            self.throttleCount = dictionary["ThrottleCount"] as? Int64
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The end of the time frame for which to generate a graph.
        public var endTime: Date = Date()
        /// Pagination token. Not used.
        public var nextToken: String? = nil
        /// The start of the time frame for which to generate a graph.
        public var startTime: Date = Date()

        public init() {}

        public init(endTime: Date, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public init(dictionary: [String: Any]) throws {
            guard let endTime = dictionary["EndTime"] as? Date else { throw InitializableError.missingRequiredParam("EndTime") }
            self.endTime = endTime
            self.nextToken = dictionary["NextToken"] as? String
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Segments that failed processing.
        public var unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil

        public init() {}

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        public init(dictionary: [String: Any]) throws {
            if let unprocessedTraceSegments = dictionary["UnprocessedTraceSegments"] as? [[String: Any]] {
                self.unprocessedTraceSegments = try unprocessedTraceSegments.map({ try UnprocessedTraceSegment(dictionary: $0) })
            }
        }
    }

    public struct AnnotationValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Value for a Boolean annotation.
        public var booleanValue: Bool? = nil
        /// Value for a String annotation.
        public var stringValue: String? = nil
        /// Value for a Number annotation.
        public var numberValue: Double? = nil

        public init() {}

        public init(booleanValue: Bool? = nil, stringValue: String? = nil, numberValue: Double? = nil) {
            self.booleanValue = booleanValue
            self.stringValue = stringValue
            self.numberValue = numberValue
        }

        public init(dictionary: [String: Any]) throws {
            self.booleanValue = dictionary["BooleanValue"] as? Bool
            self.stringValue = dictionary["StringValue"] as? String
            self.numberValue = dictionary["NumberValue"] as? Double
        }
    }

    public struct GetServiceGraphResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start of the time frame for which the graph was generated.
        public var startTime: Date? = nil
        /// The end of the time frame for which the graph was generated.
        public var endTime: Date? = nil
        /// The services that have processed a traced request during the specified time frame.
        public var services: [Service]? = nil
        /// Pagination token. Not used.
        public var nextToken: String? = nil

        public init() {}

        public init(startTime: Date? = nil, endTime: Date? = nil, services: [Service]? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.services = services
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            self.endTime = dictionary["EndTime"] as? Date
            if let services = dictionary["Services"] as? [[String: Any]] {
                self.services = try services.map({ try Service(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TraceUser: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Services that the user's request hit.
        public var serviceIds: [ServiceId]? = nil
        /// The user's name.
        public var userName: String? = nil

        public init() {}

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            }
            self.userName = dictionary["UserName"] as? String
        }
    }

    public struct FaultStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The total number of requests that failed with a 5xx Server Error status code.
        public var totalCount: Int64? = nil
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public var otherCount: Int64? = nil

        public init() {}

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalCount = dictionary["TotalCount"] as? Int64
            self.otherCount = dictionary["OtherCount"] as? Int64
        }
    }

    public struct Http: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IP address of the requestor.
        public var clientIp: String? = nil
        /// The request URL.
        public var httpURL: String? = nil
        /// The request method.
        public var httpMethod: String? = nil
        /// The response status.
        public var httpStatus: Int32? = nil
        /// The request's user agent string.
        public var userAgent: String? = nil

        public init() {}

        public init(clientIp: String? = nil, httpURL: String? = nil, httpMethod: String? = nil, httpStatus: Int32? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpURL = httpURL
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.userAgent = userAgent
        }

        public init(dictionary: [String: Any]) throws {
            self.clientIp = dictionary["ClientIp"] as? String
            self.httpURL = dictionary["HttpURL"] as? String
            self.httpMethod = dictionary["HttpMethod"] as? String
            self.httpStatus = dictionary["HttpStatus"] as? Int32
            self.userAgent = dictionary["UserAgent"] as? String
        }
    }

    public struct ServiceStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The aggregate response time of completed requests.
        public var totalResponseTime: Double? = nil
        /// Information about requests that failed with a 5xx Server Error status code.
        public var faultStatistics: FaultStatistics? = nil
        /// The number of requests that completed with a 2xx Success status code.
        public var okCount: Int64? = nil
        /// Information about requests that failed with a 4xx Client Error status code.
        public var errorStatistics: ErrorStatistics? = nil
        /// The total number of completed requests.
        public var totalCount: Int64? = nil

        public init() {}

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalResponseTime = dictionary["TotalResponseTime"] as? Double
            if let faultStatistics = dictionary["FaultStatistics"] as? [String: Any] { self.faultStatistics = try Xray.FaultStatistics(dictionary: faultStatistics) }
            self.okCount = dictionary["OkCount"] as? Int64
            if let errorStatistics = dictionary["ErrorStatistics"] as? [String: Any] { self.errorStatistics = try Xray.ErrorStatistics(dictionary: errorStatistics) }
            self.totalCount = dictionary["TotalCount"] as? Int64
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Trace IDs of requests for which to generate a service graph.
        public var traceIds: [String] = []
        /// Pagination token. Not used.
        public var nextToken: String? = nil

        public init() {}

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceIds = dictionary["TraceIds"] as? [String] else { throw InitializableError.missingRequiredParam("TraceIds") }
            self.traceIds = traceIds
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct GetTraceGraphResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The services that have processed one of the specified requests.
        public var services: [Service]? = nil
        /// Pagination token. Not used.
        public var nextToken: String? = nil

        public init() {}

        public init(services: [Service]? = nil, nextToken: String? = nil) {
            self.services = services
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let services = dictionary["Services"] as? [[String: Any]] {
                self.services = try services.map({ try Service(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct Trace: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Segment documents for the segments and subsegments that comprise the trace.
        public var segments: [Segment]? = nil
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public var duration: Double? = nil
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public var id: String? = nil

        public init() {}

        public init(segments: [Segment]? = nil, duration: Double? = nil, id: String? = nil) {
            self.segments = segments
            self.duration = duration
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let segments = dictionary["Segments"] as? [[String: Any]] {
                self.segments = try segments.map({ try Segment(dictionary: $0) })
            }
            self.duration = dictionary["Duration"] as? Double
            self.id = dictionary["Id"] as? String
        }
    }

    public struct PutTraceSegmentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A JSON document defining one or more segments or subsegments. Segments must include the following fields.  Required Segment Document Fields     name - The name of the service that handled the request.    id - A 64-bit identifier for the segment, unique among segments in the same trace, in 16 hexadecimal digits.    trace_id - A unique identifier that connects all segments and subsegments originating from a single client request.    start_time - Time the segment or subsegment was created, in floating point seconds in epoch time, accurate to milliseconds. For example, 1480615200.010 or 1.480615200010E9.    end_time - Time the segment or subsegment was closed. For example, 1480615200.090 or 1.480615200090E9. Specify either an end_time or in_progress.    in_progress - Set to true instead of specifying an end_time to record that a segment has been started, but is not complete. Send an in progress segment when your application receives a request that will take a long time to serve, to trace the fact that the request was received. When the response is sent, send the complete segment to overwrite the in-progress segment.   A trace_id consists of three numbers separated by hyphens. For example, 1-58406520-a006649127e371903a2de979. This includes:  Trace ID Format    The version number, i.e. 1.   The time of the original request, in Unix epoch time, in 8 hexadecimal digits. For example, 10:00AM December 2nd, 2016 PST in epoch time is 1480615200 seconds, or 58406520 in hexadecimal.   A 96-bit identifier for the trace, globally unique, in 24 hexadecimal digits.  
        public var traceSegmentDocuments: [String] = []

        public init() {}

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceSegmentDocuments = dictionary["TraceSegmentDocuments"] as? [String] else { throw InitializableError.missingRequiredParam("TraceSegmentDocuments") }
            self.traceSegmentDocuments = traceSegmentDocuments
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start of the time frame for which to retrieve traces.
        public var startTime: Date = Date()
        /// The end of the time frame for which to retrieve traces.
        public var endTime: Date = Date()
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public var filterExpression: String? = nil
        /// Set to true to get summaries for only a subset of available traces.
        public var sampling: Bool? = nil
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public var nextToken: String? = nil

        public init() {}

        public init(startTime: Date, endTime: Date, filterExpression: String? = nil, sampling: Bool? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.sampling = sampling
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            guard let endTime = dictionary["EndTime"] as? Date else { throw InitializableError.missingRequiredParam("EndTime") }
            self.endTime = endTime
            self.filterExpression = dictionary["FilterExpression"] as? String
            self.sampling = dictionary["Sampling"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public var eC2InstanceId: String? = nil
        public var hostname: String? = nil
        public var telemetryRecords: [TelemetryRecord] = []
        public var resourceARN: String? = nil

        public init() {}

        public init(eC2InstanceId: String? = nil, hostname: String? = nil, telemetryRecords: [TelemetryRecord], resourceARN: String? = nil) {
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
            self.telemetryRecords = telemetryRecords
            self.resourceARN = resourceARN
        }

        public init(dictionary: [String: Any]) throws {
            self.eC2InstanceId = dictionary["EC2InstanceId"] as? String
            self.hostname = dictionary["Hostname"] as? String
            guard let telemetryRecords = dictionary["TelemetryRecords"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TelemetryRecords") }
            self.telemetryRecords = try telemetryRecords.map({ try TelemetryRecord(dictionary: $0) })
            self.resourceARN = dictionary["ResourceARN"] as? String
        }
    }

    public struct Service: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The start time of the first segment that the service generated.
        public var startTime: Date? = nil
        /// Aggregated statistics for the service.
        public var summaryStatistics: ServiceStatistics? = nil
        /// Histogram mapping the spread of trace durations
        public var durationHistogram: [HistogramEntry]? = nil
        /// Identifier of the AWS account in which the service runs.
        public var accountId: String? = nil
        /// Indicates that the service was the first service to process a request.
        public var root: Bool? = nil
        /// The canonical name of the service.
        public var name: String? = nil
        /// The service's state.
        public var state: String? = nil
        /// The end time of the last segment that the service generated.
        public var endTime: Date? = nil
        /// Identifier for the service. Unique within the service map.
        public var referenceId: Int32? = nil
        /// A list of names for the service, including the canonical name.
        public var names: [String]? = nil
        /// Connections to downstream services.
        public var edges: [Edge]? = nil
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public var type: String? = nil

        public init() {}

        public init(startTime: Date? = nil, summaryStatistics: ServiceStatistics? = nil, durationHistogram: [HistogramEntry]? = nil, accountId: String? = nil, root: Bool? = nil, name: String? = nil, state: String? = nil, endTime: Date? = nil, referenceId: Int32? = nil, names: [String]? = nil, edges: [Edge]? = nil, type: String? = nil) {
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
            self.durationHistogram = durationHistogram
            self.accountId = accountId
            self.root = root
            self.name = name
            self.state = state
            self.endTime = endTime
            self.referenceId = referenceId
            self.names = names
            self.edges = edges
            self.type = type
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            if let summaryStatistics = dictionary["SummaryStatistics"] as? [String: Any] { self.summaryStatistics = try Xray.ServiceStatistics(dictionary: summaryStatistics) }
            if let durationHistogram = dictionary["DurationHistogram"] as? [[String: Any]] {
                self.durationHistogram = try durationHistogram.map({ try HistogramEntry(dictionary: $0) })
            }
            self.accountId = dictionary["AccountId"] as? String
            self.root = dictionary["Root"] as? Bool
            self.name = dictionary["Name"] as? String
            self.state = dictionary["State"] as? String
            self.endTime = dictionary["EndTime"] as? Date
            self.referenceId = dictionary["ReferenceId"] as? Int32
            if let names = dictionary["Names"] as? [String] {
                self.names = names
            }
            if let edges = dictionary["Edges"] as? [[String: Any]] {
                self.edges = try edges.map({ try Edge(dictionary: $0) })
            }
            self.type = dictionary["Type"] as? String
        }
    }

    public struct ServiceId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public var accountId: String? = nil
        public var names: [String]? = nil
        public var type: String? = nil
        public var name: String? = nil

        public init() {}

        public init(accountId: String? = nil, names: [String]? = nil, type: String? = nil, name: String? = nil) {
            self.accountId = accountId
            self.names = names
            self.type = type
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.accountId = dictionary["AccountId"] as? String
            if let names = dictionary["Names"] as? [String] {
                self.names = names
            }
            self.type = dictionary["Type"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public var connectionRefusedCount: Int32? = nil
        public var timeoutCount: Int32? = nil
        public var unknownHostCount: Int32? = nil
        public var hTTPCode5XXCount: Int32? = nil
        public var otherCount: Int32? = nil
        public var hTTPCode4XXCount: Int32? = nil

        public init() {}

        public init(connectionRefusedCount: Int32? = nil, timeoutCount: Int32? = nil, unknownHostCount: Int32? = nil, hTTPCode5XXCount: Int32? = nil, otherCount: Int32? = nil, hTTPCode4XXCount: Int32? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
        }

        public init(dictionary: [String: Any]) throws {
            self.connectionRefusedCount = dictionary["ConnectionRefusedCount"] as? Int32
            self.timeoutCount = dictionary["TimeoutCount"] as? Int32
            self.unknownHostCount = dictionary["UnknownHostCount"] as? Int32
            self.hTTPCode5XXCount = dictionary["HTTPCode5XXCount"] as? Int32
            self.otherCount = dictionary["OtherCount"] as? Int32
            self.hTTPCode4XXCount = dictionary["HTTPCode4XXCount"] as? Int32
        }
    }

    public struct TelemetryRecord: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public var segmentsRejectedCount: Int32? = nil
        public var timestamp: Date? = nil
        public var segmentsReceivedCount: Int32? = nil
        public var segmentsSentCount: Int32? = nil
        public var segmentsSpilloverCount: Int32? = nil
        public var backendConnectionErrors: BackendConnectionErrors? = nil

        public init() {}

        public init(segmentsRejectedCount: Int32? = nil, timestamp: Date? = nil, segmentsReceivedCount: Int32? = nil, segmentsSentCount: Int32? = nil, segmentsSpilloverCount: Int32? = nil, backendConnectionErrors: BackendConnectionErrors? = nil) {
            self.segmentsRejectedCount = segmentsRejectedCount
            self.timestamp = timestamp
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.backendConnectionErrors = backendConnectionErrors
        }

        public init(dictionary: [String: Any]) throws {
            self.segmentsRejectedCount = dictionary["SegmentsRejectedCount"] as? Int32
            self.timestamp = dictionary["Timestamp"] as? Date
            self.segmentsReceivedCount = dictionary["SegmentsReceivedCount"] as? Int32
            self.segmentsSentCount = dictionary["SegmentsSentCount"] as? Int32
            self.segmentsSpilloverCount = dictionary["SegmentsSpilloverCount"] as? Int32
            if let backendConnectionErrors = dictionary["BackendConnectionErrors"] as? [String: Any] { self.backendConnectionErrors = try Xray.BackendConnectionErrors(dictionary: backendConnectionErrors) }
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specify the trace IDs of requests for which to retrieve segments.
        public var traceIds: [String] = []
        /// Pagination token. Not used.
        public var nextToken: String? = nil

        public init() {}

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceIds = dictionary["TraceIds"] as? [String] else { throw InitializableError.missingRequiredParam("TraceIds") }
            self.traceIds = traceIds
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TraceSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// One or more of the segment documents is in progress.
        public var isPartial: Bool? = nil
        /// Service IDs from the trace's segment documents.
        public var serviceIds: [ServiceId]? = nil
        /// Information about the HTTP request served by the trace.
        public var http: Http? = nil
        /// One or more of the segment documents has a 400 series error.
        public var hasError: Bool? = nil
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public var id: String? = nil
        /// One or more of the segment documents has a 429 throttling error.
        public var hasThrottle: Bool? = nil
        /// Users from the trace's segment documents.
        public var users: [TraceUser]? = nil
        /// Annotations from the trace's segment documents.
        public var annotations: [String: [ValueWithServiceIds]]? = nil
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public var duration: Double? = nil
        /// One or more of the segment documents has a 500 series error.
        public var hasFault: Bool? = nil
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public var responseTime: Double? = nil

        public init() {}

        public init(isPartial: Bool? = nil, serviceIds: [ServiceId]? = nil, http: Http? = nil, hasError: Bool? = nil, id: String? = nil, hasThrottle: Bool? = nil, users: [TraceUser]? = nil, annotations: [String: [ValueWithServiceIds]]? = nil, duration: Double? = nil, hasFault: Bool? = nil, responseTime: Double? = nil) {
            self.isPartial = isPartial
            self.serviceIds = serviceIds
            self.http = http
            self.hasError = hasError
            self.id = id
            self.hasThrottle = hasThrottle
            self.users = users
            self.annotations = annotations
            self.duration = duration
            self.hasFault = hasFault
            self.responseTime = responseTime
        }

        public init(dictionary: [String: Any]) throws {
            self.isPartial = dictionary["IsPartial"] as? Bool
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            }
            if let http = dictionary["Http"] as? [String: Any] { self.http = try Xray.Http(dictionary: http) }
            self.hasError = dictionary["HasError"] as? Bool
            self.id = dictionary["Id"] as? String
            self.hasThrottle = dictionary["HasThrottle"] as? Bool
            if let users = dictionary["Users"] as? [[String: Any]] {
                self.users = try users.map({ try TraceUser(dictionary: $0) })
            }
            if let annotations = dictionary["Annotations"] as? [String: Any] {
                var annotationsDict: [String: [ValueWithServiceIds]] = [:]
                for (key, value) in annotations {
                    guard let valueWithServiceIds = value as? [[String: Any]] else { throw InitializableError.convertingError }
                    let valueWithServiceIdsList: [ValueWithServiceIds] = try valueWithServiceIds.map { try ValueWithServiceIds(dictionary: $0) }
                    annotationsDict[key] = valueWithServiceIdsList
                }
                self.annotations = annotationsDict
            }
            self.duration = dictionary["Duration"] as? Double
            self.hasFault = dictionary["HasFault"] as? Bool
            self.responseTime = dictionary["ResponseTime"] as? Double
        }
    }

}