// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Xray {

    public struct BatchGetTracesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Traces", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedTraceIds", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traces = "Traces"
            case unprocessedTraceIds = "UnprocessedTraceIds"
        }
    }

    public struct EdgeStatistics: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "OkCount", required: false, type: .long), 
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalResponseTime = "TotalResponseTime"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case errorStatistics = "ErrorStatistics"
            case totalCount = "TotalCount"
        }
    }

    public struct Segment: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Document", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]
        /// The segment document
        public let document: String?
        /// The segment's ID.
        public let id: String?

        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case document = "Document"
            case id = "Id"
        }
    }

    public struct Alias: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The type of the alias.
        public let `type`: String?
        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?

        public init(type: String? = nil, name: String? = nil, names: [String]? = nil) {
            self.`type` = `type`
            self.name = name
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case name = "Name"
            case names = "Names"
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "AnnotationValue", required: false, type: .structure)
        ]
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?

        public init(serviceIds: [ServiceId]? = nil, annotationValue: AnnotationValue? = nil) {
            self.serviceIds = serviceIds
            self.annotationValue = annotationValue
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIds = "ServiceIds"
            case annotationValue = "AnnotationValue"
        }
    }

    public struct HistogramEntry: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .double), 
            AWSShapeMember(label: "Count", required: false, type: .integer)
        ]
        /// The value of the entry.
        public let value: Double?
        /// The prevalence of the entry.
        public let count: Int32?

        public init(value: Double? = nil, count: Int32? = nil) {
            self.value = value
            self.count = count
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case count = "Count"
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]
        /// The segment's ID.
        public let id: String?
        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(id: String? = nil, errorCode: String? = nil, message: String? = nil) {
            self.id = id
            self.errorCode = errorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct GetTraceSummariesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TracesProcessedCount", required: false, type: .long), 
            AWSShapeMember(label: "TraceSummaries", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ApproximateTime", required: false, type: .timestamp)
        ]
        /// The number of traces that were processed to get this set of summaries.
        public let tracesProcessedCount: Int64?
        /// Trace IDs and metadata for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The start time of this page of results.
        public let approximateTime: Double?

        public init(tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil, nextToken: String? = nil, approximateTime: Double? = nil) {
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
            self.nextToken = nextToken
            self.approximateTime = approximateTime
        }

        private enum CodingKeys: String, CodingKey {
            case tracesProcessedCount = "TracesProcessedCount"
            case traceSummaries = "TraceSummaries"
            case nextToken = "NextToken"
            case approximateTime = "ApproximateTime"
        }
    }

    public struct Edge: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "Aliases", required: false, type: .list), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list)
        ]
        /// The start time of the first segment on the edge.
        public let startTime: Double?
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?
        /// The end time of the last segment on the edge.
        public let endTime: Double?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int32?
        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// A histogram that maps the spread of client response times on an edge.
        public let responseTimeHistogram: [HistogramEntry]?

        public init(startTime: Double? = nil, summaryStatistics: EdgeStatistics? = nil, endTime: Double? = nil, referenceId: Int32? = nil, aliases: [Alias]? = nil, responseTimeHistogram: [HistogramEntry]? = nil) {
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
            self.endTime = endTime
            self.referenceId = referenceId
            self.aliases = aliases
            self.responseTimeHistogram = responseTimeHistogram
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case summaryStatistics = "SummaryStatistics"
            case endTime = "EndTime"
            case referenceId = "ReferenceId"
            case aliases = "Aliases"
            case responseTimeHistogram = "ResponseTimeHistogram"
        }
    }

    public struct ErrorStatistics: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "OtherCount", required: false, type: .long), 
            AWSShapeMember(label: "ThrottleCount", required: false, type: .long)
        ]
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil, throttleCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
            self.throttleCount = throttleCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalCount = "TotalCount"
            case otherCount = "OtherCount"
            case throttleCount = "ThrottleCount"
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]
        /// The end of the time frame for which to generate a graph.
        public let endTime: Double
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The start of the time frame for which to generate a graph.
        public let startTime: Double

        public init(endTime: Double, nextToken: String? = nil, startTime: Double) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedTraceSegments", required: false, type: .list)
        ]
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceSegments = "UnprocessedTraceSegments"
        }
    }

    public struct AnnotationValue: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "BooleanValue", required: false, type: .boolean), 
            AWSShapeMember(label: "StringValue", required: false, type: .string), 
            AWSShapeMember(label: "NumberValue", required: false, type: .double)
        ]
        /// Value for a Boolean annotation.
        public let booleanValue: Bool?
        /// Value for a String annotation.
        public let stringValue: String?
        /// Value for a Number annotation.
        public let numberValue: Double?

        public init(booleanValue: Bool? = nil, stringValue: String? = nil, numberValue: Double? = nil) {
            self.booleanValue = booleanValue
            self.stringValue = stringValue
            self.numberValue = numberValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "BooleanValue"
            case stringValue = "StringValue"
            case numberValue = "NumberValue"
        }
    }

    public struct GetServiceGraphResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Services", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The start of the time frame for which the graph was generated.
        public let startTime: Double?
        /// The end of the time frame for which the graph was generated.
        public let endTime: Double?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(startTime: Double? = nil, endTime: Double? = nil, services: [Service]? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.services = services
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case endTime = "EndTime"
            case services = "Services"
            case nextToken = "NextToken"
        }
    }

    public struct TraceUser: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "UserName", required: false, type: .string)
        ]
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIds = "ServiceIds"
            case userName = "UserName"
        }
    }

    public struct FaultStatistics: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "OtherCount", required: false, type: .long)
        ]
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalCount = "TotalCount"
            case otherCount = "OtherCount"
        }
    }

    public struct Http: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientIp", required: false, type: .string), 
            AWSShapeMember(label: "HttpURL", required: false, type: .string), 
            AWSShapeMember(label: "HttpMethod", required: false, type: .string), 
            AWSShapeMember(label: "HttpStatus", required: false, type: .integer), 
            AWSShapeMember(label: "UserAgent", required: false, type: .string)
        ]
        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request URL.
        public let httpURL: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int32?
        /// The request's user agent string.
        public let userAgent: String?

        public init(clientIp: String? = nil, httpURL: String? = nil, httpMethod: String? = nil, httpStatus: Int32? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpURL = httpURL
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.userAgent = userAgent
        }

        private enum CodingKeys: String, CodingKey {
            case clientIp = "ClientIp"
            case httpURL = "HttpURL"
            case httpMethod = "HttpMethod"
            case httpStatus = "HttpStatus"
            case userAgent = "UserAgent"
        }
    }

    public struct ServiceStatistics: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "OkCount", required: false, type: .long), 
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalResponseTime = "TotalResponseTime"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case errorStatistics = "ErrorStatistics"
            case totalCount = "TotalCount"
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceIds", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case traceIds = "TraceIds"
            case nextToken = "NextToken"
        }
    }

    public struct GetTraceGraphResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Services", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The services that have processed one of the specified requests.
        public let services: [Service]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(services: [Service]? = nil, nextToken: String? = nil) {
            self.services = services
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case services = "Services"
            case nextToken = "NextToken"
        }
    }

    public struct Trace: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Segments", required: false, type: .list), 
            AWSShapeMember(label: "Duration", required: false, type: .double), 
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?

        public init(segments: [Segment]? = nil, duration: Double? = nil, id: String? = nil) {
            self.segments = segments
            self.duration = duration
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case segments = "Segments"
            case duration = "Duration"
            case id = "Id"
        }
    }

    public struct PutTraceSegmentsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceSegmentDocuments", required: true, type: .list)
        ]
        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case traceSegmentDocuments = "TraceSegmentDocuments"
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "Sampling", required: false, type: .boolean), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The start of the time frame for which to retrieve traces.
        public let startTime: Double
        /// The end of the time frame for which to retrieve traces.
        public let endTime: Double
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(startTime: Double, endTime: Double, filterExpression: String? = nil, sampling: Bool? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.sampling = sampling
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case endTime = "EndTime"
            case filterExpression = "FilterExpression"
            case sampling = "Sampling"
            case nextToken = "NextToken"
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {
        /// The key for the payload

    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EC2InstanceId", required: false, type: .string), 
            AWSShapeMember(label: "Hostname", required: false, type: .string), 
            AWSShapeMember(label: "TelemetryRecords", required: true, type: .list), 
            AWSShapeMember(label: "ResourceARN", required: false, type: .string)
        ]
        public let eC2InstanceId: String?
        public let hostname: String?
        public let telemetryRecords: [TelemetryRecord]
        public let resourceARN: String?

        public init(eC2InstanceId: String? = nil, hostname: String? = nil, telemetryRecords: [TelemetryRecord], resourceARN: String? = nil) {
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
            self.telemetryRecords = telemetryRecords
            self.resourceARN = resourceARN
        }

        private enum CodingKeys: String, CodingKey {
            case eC2InstanceId = "EC2InstanceId"
            case hostname = "Hostname"
            case telemetryRecords = "TelemetryRecords"
            case resourceARN = "ResourceARN"
        }
    }

    public struct Service: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "DurationHistogram", required: false, type: .list), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "Edges", required: false, type: .list), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Root", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// The service's state.
        public let state: String?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int32?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The start time of the first segment that the service generated.
        public let startTime: Double?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The canonical name of the service.
        public let name: String?
        /// The end time of the last segment that the service generated.
        public let endTime: Double?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public let `type`: String?

        public init(accountId: String? = nil, summaryStatistics: ServiceStatistics? = nil, durationHistogram: [HistogramEntry]? = nil, state: String? = nil, referenceId: Int32? = nil, edges: [Edge]? = nil, responseTimeHistogram: [HistogramEntry]? = nil, startTime: Double? = nil, root: Bool? = nil, name: String? = nil, endTime: Double? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.summaryStatistics = summaryStatistics
            self.durationHistogram = durationHistogram
            self.state = state
            self.referenceId = referenceId
            self.edges = edges
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.root = root
            self.name = name
            self.endTime = endTime
            self.names = names
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case summaryStatistics = "SummaryStatistics"
            case durationHistogram = "DurationHistogram"
            case state = "State"
            case referenceId = "ReferenceId"
            case edges = "Edges"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case startTime = "StartTime"
            case root = "Root"
            case name = "Name"
            case endTime = "EndTime"
            case names = "Names"
            case `type` = "Type"
        }
    }

    public struct ServiceId: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        public let accountId: String?
        public let names: [String]?
        public let `type`: String?
        public let name: String?

        public init(accountId: String? = nil, names: [String]? = nil, type: String? = nil, name: String? = nil) {
            self.accountId = accountId
            self.names = names
            self.`type` = `type`
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case names = "Names"
            case `type` = "Type"
            case name = "Name"
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionRefusedCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimeoutCount", required: false, type: .integer), 
            AWSShapeMember(label: "UnknownHostCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode5XXCount", required: false, type: .integer), 
            AWSShapeMember(label: "OtherCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode4XXCount", required: false, type: .integer)
        ]
        public let connectionRefusedCount: Int32?
        public let timeoutCount: Int32?
        public let unknownHostCount: Int32?
        public let hTTPCode5XXCount: Int32?
        public let otherCount: Int32?
        public let hTTPCode4XXCount: Int32?

        public init(connectionRefusedCount: Int32? = nil, timeoutCount: Int32? = nil, unknownHostCount: Int32? = nil, hTTPCode5XXCount: Int32? = nil, otherCount: Int32? = nil, hTTPCode4XXCount: Int32? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
        }

        private enum CodingKeys: String, CodingKey {
            case connectionRefusedCount = "ConnectionRefusedCount"
            case timeoutCount = "TimeoutCount"
            case unknownHostCount = "UnknownHostCount"
            case hTTPCode5XXCount = "HTTPCode5XXCount"
            case otherCount = "OtherCount"
            case hTTPCode4XXCount = "HTTPCode4XXCount"
        }
    }

    public struct TelemetryRecord: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsRejectedCount", required: false, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "SegmentsReceivedCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsSentCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsSpilloverCount", required: false, type: .integer), 
            AWSShapeMember(label: "BackendConnectionErrors", required: false, type: .structure)
        ]
        public let segmentsRejectedCount: Int32?
        public let timestamp: Double?
        public let segmentsReceivedCount: Int32?
        public let segmentsSentCount: Int32?
        public let segmentsSpilloverCount: Int32?
        public let backendConnectionErrors: BackendConnectionErrors?

        public init(segmentsRejectedCount: Int32? = nil, timestamp: Double? = nil, segmentsReceivedCount: Int32? = nil, segmentsSentCount: Int32? = nil, segmentsSpilloverCount: Int32? = nil, backendConnectionErrors: BackendConnectionErrors? = nil) {
            self.segmentsRejectedCount = segmentsRejectedCount
            self.timestamp = timestamp
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.backendConnectionErrors = backendConnectionErrors
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsRejectedCount = "SegmentsRejectedCount"
            case timestamp = "Timestamp"
            case segmentsReceivedCount = "SegmentsReceivedCount"
            case segmentsSentCount = "SegmentsSentCount"
            case segmentsSpilloverCount = "SegmentsSpilloverCount"
            case backendConnectionErrors = "BackendConnectionErrors"
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceIds", required: true, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case traceIds = "TraceIds"
            case nextToken = "NextToken"
        }
    }

    public struct TraceSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IsPartial", required: false, type: .boolean), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "Http", required: false, type: .structure), 
            AWSShapeMember(label: "HasError", required: false, type: .boolean), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "HasThrottle", required: false, type: .boolean), 
            AWSShapeMember(label: "Users", required: false, type: .list), 
            AWSShapeMember(label: "Annotations", required: false, type: .map), 
            AWSShapeMember(label: "Duration", required: false, type: .double), 
            AWSShapeMember(label: "HasFault", required: false, type: .boolean), 
            AWSShapeMember(label: "ResponseTime", required: false, type: .double)
        ]
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// One or more of the segment documents has a 400 series error.
        public let hasError: Bool?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// One or more of the segment documents has a 500 series error.
        public let hasFault: Bool?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?

        public init(isPartial: Bool? = nil, serviceIds: [ServiceId]? = nil, http: Http? = nil, hasError: Bool? = nil, id: String? = nil, hasThrottle: Bool? = nil, users: [TraceUser]? = nil, annotations: [String: [ValueWithServiceIds]]? = nil, duration: Double? = nil, hasFault: Bool? = nil, responseTime: Double? = nil) {
            self.isPartial = isPartial
            self.serviceIds = serviceIds
            self.http = http
            self.hasError = hasError
            self.id = id
            self.hasThrottle = hasThrottle
            self.users = users
            self.annotations = annotations
            self.duration = duration
            self.hasFault = hasFault
            self.responseTime = responseTime
        }

        private enum CodingKeys: String, CodingKey {
            case isPartial = "IsPartial"
            case serviceIds = "ServiceIds"
            case http = "Http"
            case hasError = "HasError"
            case id = "Id"
            case hasThrottle = "HasThrottle"
            case users = "Users"
            case annotations = "Annotations"
            case duration = "Duration"
            case hasFault = "HasFault"
            case responseTime = "ResponseTime"
        }
    }

}