// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Xray {

    public struct BatchGetTracesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "Traces", required: false, type: .list), 
            AWSShapeProperty(label: "UnprocessedTraceIds", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let traces = dictionary["Traces"] as? [[String: Any]] {
                self.traces = try traces.map({ try Trace(dictionary: $0) })
            } else { 
                self.traces = nil
            }
            self.unprocessedTraceIds = dictionary["UnprocessedTraceIds"] as? [String]
        }
    }

    public struct EdgeStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeProperty(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeProperty(label: "OkCount", required: false, type: .long), 
            AWSShapeProperty(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeProperty(label: "TotalCount", required: false, type: .long)
        ]
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalResponseTime = dictionary["TotalResponseTime"] as? Double
            if let faultStatistics = dictionary["FaultStatistics"] as? [String: Any] { self.faultStatistics = try Xray.FaultStatistics(dictionary: faultStatistics) } else { self.faultStatistics = nil }
            self.okCount = dictionary["OkCount"] as? Int64
            if let errorStatistics = dictionary["ErrorStatistics"] as? [String: Any] { self.errorStatistics = try Xray.ErrorStatistics(dictionary: errorStatistics) } else { self.errorStatistics = nil }
            self.totalCount = dictionary["TotalCount"] as? Int64
        }
    }

    public struct Segment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Document", required: false, type: .string), 
            AWSShapeProperty(label: "Id", required: false, type: .string)
        ]
        /// The segment document
        public let document: String?
        /// The segment's ID.
        public let id: String?

        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.document = dictionary["Document"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public struct Alias: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Type", required: false, type: .string), 
            AWSShapeProperty(label: "Name", required: false, type: .string), 
            AWSShapeProperty(label: "Names", required: false, type: .list)
        ]
        /// The type of the alias.
        public let `type`: String?
        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?

        public init(type: String? = nil, name: String? = nil, names: [String]? = nil) {
            self.`type` = `type`
            self.name = name
            self.names = names
        }

        public init(dictionary: [String: Any]) throws {
            self.`type` = dictionary["Type"] as? String
            self.name = dictionary["Name"] as? String
            self.names = dictionary["Names"] as? [String]
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ServiceIds", required: false, type: .list), 
            AWSShapeProperty(label: "AnnotationValue", required: false, type: .structure)
        ]
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?

        public init(serviceIds: [ServiceId]? = nil, annotationValue: AnnotationValue? = nil) {
            self.serviceIds = serviceIds
            self.annotationValue = annotationValue
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            } else { 
                self.serviceIds = nil
            }
            if let annotationValue = dictionary["AnnotationValue"] as? [String: Any] { self.annotationValue = try Xray.AnnotationValue(dictionary: annotationValue) } else { self.annotationValue = nil }
        }
    }

    public struct HistogramEntry: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Value", required: false, type: .double), 
            AWSShapeProperty(label: "Count", required: false, type: .integer)
        ]
        /// The value of the entry.
        public let value: Double?
        /// The prevalence of the entry.
        public let count: Int32?

        public init(value: Double? = nil, count: Int32? = nil) {
            self.value = value
            self.count = count
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Double
            self.count = dictionary["Count"] as? Int32
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "ErrorCode", required: false, type: .string), 
            AWSShapeProperty(label: "Message", required: false, type: .string)
        ]
        /// The segment's ID.
        public let id: String?
        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(id: String? = nil, errorCode: String? = nil, message: String? = nil) {
            self.id = id
            self.errorCode = errorCode
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct GetTraceSummariesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TracesProcessedCount", required: false, type: .long), 
            AWSShapeProperty(label: "TraceSummaries", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "ApproximateTime", required: false, type: .timestamp)
        ]
        /// The number of traces that were processed to get this set of summaries.
        public let tracesProcessedCount: Int64?
        /// Trace IDs and metadata for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The start time of this page of results.
        public let approximateTime: String?

        public init(tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil, nextToken: String? = nil, approximateTime: String? = nil) {
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
            self.nextToken = nextToken
            self.approximateTime = approximateTime
        }

        public init(dictionary: [String: Any]) throws {
            self.tracesProcessedCount = dictionary["TracesProcessedCount"] as? Int64
            if let traceSummaries = dictionary["TraceSummaries"] as? [[String: Any]] {
                self.traceSummaries = try traceSummaries.map({ try TraceSummary(dictionary: $0) })
            } else { 
                self.traceSummaries = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.approximateTime = dictionary["ApproximateTime"] as? String
        }
    }

    public struct Edge: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeProperty(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeProperty(label: "Aliases", required: false, type: .list), 
            AWSShapeProperty(label: "ResponseTimeHistogram", required: false, type: .list)
        ]
        /// The start time of the first segment on the edge.
        public let startTime: String?
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?
        /// The end time of the last segment on the edge.
        public let endTime: String?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int32?
        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// A histogram that maps the spread of client response times on an edge.
        public let responseTimeHistogram: [HistogramEntry]?

        public init(startTime: String? = nil, summaryStatistics: EdgeStatistics? = nil, endTime: String? = nil, referenceId: Int32? = nil, aliases: [Alias]? = nil, responseTimeHistogram: [HistogramEntry]? = nil) {
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
            self.endTime = endTime
            self.referenceId = referenceId
            self.aliases = aliases
            self.responseTimeHistogram = responseTimeHistogram
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? String
            if let summaryStatistics = dictionary["SummaryStatistics"] as? [String: Any] { self.summaryStatistics = try Xray.EdgeStatistics(dictionary: summaryStatistics) } else { self.summaryStatistics = nil }
            self.endTime = dictionary["EndTime"] as? String
            self.referenceId = dictionary["ReferenceId"] as? Int32
            if let aliases = dictionary["Aliases"] as? [[String: Any]] {
                self.aliases = try aliases.map({ try Alias(dictionary: $0) })
            } else { 
                self.aliases = nil
            }
            if let responseTimeHistogram = dictionary["ResponseTimeHistogram"] as? [[String: Any]] {
                self.responseTimeHistogram = try responseTimeHistogram.map({ try HistogramEntry(dictionary: $0) })
            } else { 
                self.responseTimeHistogram = nil
            }
        }
    }

    public struct ErrorStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TotalCount", required: false, type: .long), 
            AWSShapeProperty(label: "OtherCount", required: false, type: .long), 
            AWSShapeProperty(label: "ThrottleCount", required: false, type: .long)
        ]
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil, throttleCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
            self.throttleCount = throttleCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalCount = dictionary["TotalCount"] as? Int64
            self.otherCount = dictionary["OtherCount"] as? Int64
            self.throttleCount = dictionary["ThrottleCount"] as? Int64
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "StartTime", required: true, type: .timestamp)
        ]
        /// The end of the time frame for which to generate a graph.
        public let endTime: String
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The start of the time frame for which to generate a graph.
        public let startTime: String

        public init(endTime: String, nextToken: String? = nil, startTime: String) {
            self.endTime = endTime
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public init(dictionary: [String: Any]) throws {
            guard let endTime = dictionary["EndTime"] as? String else { throw InitializableError.missingRequiredParam("EndTime") }
            self.endTime = endTime
            self.nextToken = dictionary["NextToken"] as? String
            guard let startTime = dictionary["StartTime"] as? String else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "UnprocessedTraceSegments", required: false, type: .list)
        ]
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        public init(dictionary: [String: Any]) throws {
            if let unprocessedTraceSegments = dictionary["UnprocessedTraceSegments"] as? [[String: Any]] {
                self.unprocessedTraceSegments = try unprocessedTraceSegments.map({ try UnprocessedTraceSegment(dictionary: $0) })
            } else { 
                self.unprocessedTraceSegments = nil
            }
        }
    }

    public struct AnnotationValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "BooleanValue", required: false, type: .boolean), 
            AWSShapeProperty(label: "StringValue", required: false, type: .string), 
            AWSShapeProperty(label: "NumberValue", required: false, type: .double)
        ]
        /// Value for a Boolean annotation.
        public let booleanValue: Bool?
        /// Value for a String annotation.
        public let stringValue: String?
        /// Value for a Number annotation.
        public let numberValue: Double?

        public init(booleanValue: Bool? = nil, stringValue: String? = nil, numberValue: Double? = nil) {
            self.booleanValue = booleanValue
            self.stringValue = stringValue
            self.numberValue = numberValue
        }

        public init(dictionary: [String: Any]) throws {
            self.booleanValue = dictionary["BooleanValue"] as? Bool
            self.stringValue = dictionary["StringValue"] as? String
            self.numberValue = dictionary["NumberValue"] as? Double
        }
    }

    public struct GetServiceGraphResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "Services", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// The start of the time frame for which the graph was generated.
        public let startTime: String?
        /// The end of the time frame for which the graph was generated.
        public let endTime: String?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(startTime: String? = nil, endTime: String? = nil, services: [Service]? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.services = services
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? String
            self.endTime = dictionary["EndTime"] as? String
            if let services = dictionary["Services"] as? [[String: Any]] {
                self.services = try services.map({ try Service(dictionary: $0) })
            } else { 
                self.services = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TraceUser: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ServiceIds", required: false, type: .list), 
            AWSShapeProperty(label: "UserName", required: false, type: .string)
        ]
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            } else { 
                self.serviceIds = nil
            }
            self.userName = dictionary["UserName"] as? String
        }
    }

    public struct FaultStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TotalCount", required: false, type: .long), 
            AWSShapeProperty(label: "OtherCount", required: false, type: .long)
        ]
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?

        public init(totalCount: Int64? = nil, otherCount: Int64? = nil) {
            self.totalCount = totalCount
            self.otherCount = otherCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalCount = dictionary["TotalCount"] as? Int64
            self.otherCount = dictionary["OtherCount"] as? Int64
        }
    }

    public struct Http: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ClientIp", required: false, type: .string), 
            AWSShapeProperty(label: "HttpURL", required: false, type: .string), 
            AWSShapeProperty(label: "HttpMethod", required: false, type: .string), 
            AWSShapeProperty(label: "HttpStatus", required: false, type: .integer), 
            AWSShapeProperty(label: "UserAgent", required: false, type: .string)
        ]
        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request URL.
        public let httpURL: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int32?
        /// The request's user agent string.
        public let userAgent: String?

        public init(clientIp: String? = nil, httpURL: String? = nil, httpMethod: String? = nil, httpStatus: Int32? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpURL = httpURL
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.userAgent = userAgent
        }

        public init(dictionary: [String: Any]) throws {
            self.clientIp = dictionary["ClientIp"] as? String
            self.httpURL = dictionary["HttpURL"] as? String
            self.httpMethod = dictionary["HttpMethod"] as? String
            self.httpStatus = dictionary["HttpStatus"] as? Int32
            self.userAgent = dictionary["UserAgent"] as? String
        }
    }

    public struct ServiceStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeProperty(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeProperty(label: "OkCount", required: false, type: .long), 
            AWSShapeProperty(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeProperty(label: "TotalCount", required: false, type: .long)
        ]
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.totalCount = totalCount
        }

        public init(dictionary: [String: Any]) throws {
            self.totalResponseTime = dictionary["TotalResponseTime"] as? Double
            if let faultStatistics = dictionary["FaultStatistics"] as? [String: Any] { self.faultStatistics = try Xray.FaultStatistics(dictionary: faultStatistics) } else { self.faultStatistics = nil }
            self.okCount = dictionary["OkCount"] as? Int64
            if let errorStatistics = dictionary["ErrorStatistics"] as? [String: Any] { self.errorStatistics = try Xray.ErrorStatistics(dictionary: errorStatistics) } else { self.errorStatistics = nil }
            self.totalCount = dictionary["TotalCount"] as? Int64
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TraceIds", required: true, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceIds = dictionary["TraceIds"] as? [String] else { throw InitializableError.missingRequiredParam("TraceIds") }
            self.traceIds = traceIds
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct GetTraceGraphResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Services", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// The services that have processed one of the specified requests.
        public let services: [Service]?
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(services: [Service]? = nil, nextToken: String? = nil) {
            self.services = services
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let services = dictionary["Services"] as? [[String: Any]] {
                self.services = try services.map({ try Service(dictionary: $0) })
            } else { 
                self.services = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct Trace: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Segments", required: false, type: .list), 
            AWSShapeProperty(label: "Duration", required: false, type: .double), 
            AWSShapeProperty(label: "Id", required: false, type: .string)
        ]
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?

        public init(segments: [Segment]? = nil, duration: Double? = nil, id: String? = nil) {
            self.segments = segments
            self.duration = duration
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let segments = dictionary["Segments"] as? [[String: Any]] {
                self.segments = try segments.map({ try Segment(dictionary: $0) })
            } else { 
                self.segments = nil
            }
            self.duration = dictionary["Duration"] as? Double
            self.id = dictionary["Id"] as? String
        }
    }

    public struct PutTraceSegmentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TraceSegmentDocuments", required: true, type: .list)
        ]
        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceSegmentDocuments = dictionary["TraceSegmentDocuments"] as? [String] else { throw InitializableError.missingRequiredParam("TraceSegmentDocuments") }
            self.traceSegmentDocuments = traceSegmentDocuments
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StartTime", required: true, type: .timestamp), 
            AWSShapeProperty(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeProperty(label: "FilterExpression", required: false, type: .string), 
            AWSShapeProperty(label: "Sampling", required: false, type: .boolean), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// The start of the time frame for which to retrieve traces.
        public let startTime: String
        /// The end of the time frame for which to retrieve traces.
        public let endTime: String
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?

        public init(startTime: String, endTime: String, filterExpression: String? = nil, sampling: Bool? = nil, nextToken: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.sampling = sampling
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let startTime = dictionary["StartTime"] as? String else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            guard let endTime = dictionary["EndTime"] as? String else { throw InitializableError.missingRequiredParam("EndTime") }
            self.endTime = endTime
            self.filterExpression = dictionary["FilterExpression"] as? String
            self.sampling = dictionary["Sampling"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EC2InstanceId", required: false, type: .string), 
            AWSShapeProperty(label: "Hostname", required: false, type: .string), 
            AWSShapeProperty(label: "TelemetryRecords", required: true, type: .list), 
            AWSShapeProperty(label: "ResourceARN", required: false, type: .string)
        ]
        public let eC2InstanceId: String?
        public let hostname: String?
        public let telemetryRecords: [TelemetryRecord]
        public let resourceARN: String?

        public init(eC2InstanceId: String? = nil, hostname: String? = nil, telemetryRecords: [TelemetryRecord], resourceARN: String? = nil) {
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
            self.telemetryRecords = telemetryRecords
            self.resourceARN = resourceARN
        }

        public init(dictionary: [String: Any]) throws {
            self.eC2InstanceId = dictionary["EC2InstanceId"] as? String
            self.hostname = dictionary["Hostname"] as? String
            guard let telemetryRecords = dictionary["TelemetryRecords"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TelemetryRecords") }
            self.telemetryRecords = try telemetryRecords.map({ try TelemetryRecord(dictionary: $0) })
            self.resourceARN = dictionary["ResourceARN"] as? String
        }
    }

    public struct Service: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "AccountId", required: false, type: .string), 
            AWSShapeProperty(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeProperty(label: "DurationHistogram", required: false, type: .list), 
            AWSShapeProperty(label: "State", required: false, type: .string), 
            AWSShapeProperty(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeProperty(label: "Edges", required: false, type: .list), 
            AWSShapeProperty(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeProperty(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "Root", required: false, type: .boolean), 
            AWSShapeProperty(label: "Name", required: false, type: .string), 
            AWSShapeProperty(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "Names", required: false, type: .list), 
            AWSShapeProperty(label: "Type", required: false, type: .string)
        ]
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// The service's state.
        public let state: String?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int32?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The start time of the first segment that the service generated.
        public let startTime: String?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The canonical name of the service.
        public let name: String?
        /// The end time of the last segment that the service generated.
        public let endTime: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public let `type`: String?

        public init(accountId: String? = nil, summaryStatistics: ServiceStatistics? = nil, durationHistogram: [HistogramEntry]? = nil, state: String? = nil, referenceId: Int32? = nil, edges: [Edge]? = nil, responseTimeHistogram: [HistogramEntry]? = nil, startTime: String? = nil, root: Bool? = nil, name: String? = nil, endTime: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.summaryStatistics = summaryStatistics
            self.durationHistogram = durationHistogram
            self.state = state
            self.referenceId = referenceId
            self.edges = edges
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.root = root
            self.name = name
            self.endTime = endTime
            self.names = names
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            self.accountId = dictionary["AccountId"] as? String
            if let summaryStatistics = dictionary["SummaryStatistics"] as? [String: Any] { self.summaryStatistics = try Xray.ServiceStatistics(dictionary: summaryStatistics) } else { self.summaryStatistics = nil }
            if let durationHistogram = dictionary["DurationHistogram"] as? [[String: Any]] {
                self.durationHistogram = try durationHistogram.map({ try HistogramEntry(dictionary: $0) })
            } else { 
                self.durationHistogram = nil
            }
            self.state = dictionary["State"] as? String
            self.referenceId = dictionary["ReferenceId"] as? Int32
            if let edges = dictionary["Edges"] as? [[String: Any]] {
                self.edges = try edges.map({ try Edge(dictionary: $0) })
            } else { 
                self.edges = nil
            }
            if let responseTimeHistogram = dictionary["ResponseTimeHistogram"] as? [[String: Any]] {
                self.responseTimeHistogram = try responseTimeHistogram.map({ try HistogramEntry(dictionary: $0) })
            } else { 
                self.responseTimeHistogram = nil
            }
            self.startTime = dictionary["StartTime"] as? String
            self.root = dictionary["Root"] as? Bool
            self.name = dictionary["Name"] as? String
            self.endTime = dictionary["EndTime"] as? String
            self.names = dictionary["Names"] as? [String]
            self.`type` = dictionary["Type"] as? String
        }
    }

    public struct ServiceId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "AccountId", required: false, type: .string), 
            AWSShapeProperty(label: "Names", required: false, type: .list), 
            AWSShapeProperty(label: "Type", required: false, type: .string), 
            AWSShapeProperty(label: "Name", required: false, type: .string)
        ]
        public let accountId: String?
        public let names: [String]?
        public let `type`: String?
        public let name: String?

        public init(accountId: String? = nil, names: [String]? = nil, type: String? = nil, name: String? = nil) {
            self.accountId = accountId
            self.names = names
            self.`type` = `type`
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.accountId = dictionary["AccountId"] as? String
            self.names = dictionary["Names"] as? [String]
            self.`type` = dictionary["Type"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ConnectionRefusedCount", required: false, type: .integer), 
            AWSShapeProperty(label: "TimeoutCount", required: false, type: .integer), 
            AWSShapeProperty(label: "UnknownHostCount", required: false, type: .integer), 
            AWSShapeProperty(label: "HTTPCode5XXCount", required: false, type: .integer), 
            AWSShapeProperty(label: "OtherCount", required: false, type: .integer), 
            AWSShapeProperty(label: "HTTPCode4XXCount", required: false, type: .integer)
        ]
        public let connectionRefusedCount: Int32?
        public let timeoutCount: Int32?
        public let unknownHostCount: Int32?
        public let hTTPCode5XXCount: Int32?
        public let otherCount: Int32?
        public let hTTPCode4XXCount: Int32?

        public init(connectionRefusedCount: Int32? = nil, timeoutCount: Int32? = nil, unknownHostCount: Int32? = nil, hTTPCode5XXCount: Int32? = nil, otherCount: Int32? = nil, hTTPCode4XXCount: Int32? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
        }

        public init(dictionary: [String: Any]) throws {
            self.connectionRefusedCount = dictionary["ConnectionRefusedCount"] as? Int32
            self.timeoutCount = dictionary["TimeoutCount"] as? Int32
            self.unknownHostCount = dictionary["UnknownHostCount"] as? Int32
            self.hTTPCode5XXCount = dictionary["HTTPCode5XXCount"] as? Int32
            self.otherCount = dictionary["OtherCount"] as? Int32
            self.hTTPCode4XXCount = dictionary["HTTPCode4XXCount"] as? Int32
        }
    }

    public struct TelemetryRecord: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentsRejectedCount", required: false, type: .integer), 
            AWSShapeProperty(label: "Timestamp", required: false, type: .timestamp), 
            AWSShapeProperty(label: "SegmentsReceivedCount", required: false, type: .integer), 
            AWSShapeProperty(label: "SegmentsSentCount", required: false, type: .integer), 
            AWSShapeProperty(label: "SegmentsSpilloverCount", required: false, type: .integer), 
            AWSShapeProperty(label: "BackendConnectionErrors", required: false, type: .structure)
        ]
        public let segmentsRejectedCount: Int32?
        public let timestamp: String?
        public let segmentsReceivedCount: Int32?
        public let segmentsSentCount: Int32?
        public let segmentsSpilloverCount: Int32?
        public let backendConnectionErrors: BackendConnectionErrors?

        public init(segmentsRejectedCount: Int32? = nil, timestamp: String? = nil, segmentsReceivedCount: Int32? = nil, segmentsSentCount: Int32? = nil, segmentsSpilloverCount: Int32? = nil, backendConnectionErrors: BackendConnectionErrors? = nil) {
            self.segmentsRejectedCount = segmentsRejectedCount
            self.timestamp = timestamp
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.backendConnectionErrors = backendConnectionErrors
        }

        public init(dictionary: [String: Any]) throws {
            self.segmentsRejectedCount = dictionary["SegmentsRejectedCount"] as? Int32
            self.timestamp = dictionary["Timestamp"] as? String
            self.segmentsReceivedCount = dictionary["SegmentsReceivedCount"] as? Int32
            self.segmentsSentCount = dictionary["SegmentsSentCount"] as? Int32
            self.segmentsSpilloverCount = dictionary["SegmentsSpilloverCount"] as? Int32
            if let backendConnectionErrors = dictionary["BackendConnectionErrors"] as? [String: Any] { self.backendConnectionErrors = try Xray.BackendConnectionErrors(dictionary: backendConnectionErrors) } else { self.backendConnectionErrors = nil }
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TraceIds", required: true, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]
        /// Pagination token. Not used.
        public let nextToken: String?

        public init(traceIds: [String], nextToken: String? = nil) {
            self.traceIds = traceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let traceIds = dictionary["TraceIds"] as? [String] else { throw InitializableError.missingRequiredParam("TraceIds") }
            self.traceIds = traceIds
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TraceSummary: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "IsPartial", required: false, type: .boolean), 
            AWSShapeProperty(label: "ServiceIds", required: false, type: .list), 
            AWSShapeProperty(label: "Http", required: false, type: .structure), 
            AWSShapeProperty(label: "HasError", required: false, type: .boolean), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "HasThrottle", required: false, type: .boolean), 
            AWSShapeProperty(label: "Users", required: false, type: .list), 
            AWSShapeProperty(label: "Annotations", required: false, type: .map), 
            AWSShapeProperty(label: "Duration", required: false, type: .double), 
            AWSShapeProperty(label: "HasFault", required: false, type: .boolean), 
            AWSShapeProperty(label: "ResponseTime", required: false, type: .double)
        ]
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// One or more of the segment documents has a 400 series error.
        public let hasError: Bool?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// One or more of the segment documents has a 500 series error.
        public let hasFault: Bool?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?

        public init(isPartial: Bool? = nil, serviceIds: [ServiceId]? = nil, http: Http? = nil, hasError: Bool? = nil, id: String? = nil, hasThrottle: Bool? = nil, users: [TraceUser]? = nil, annotations: [String: [ValueWithServiceIds]]? = nil, duration: Double? = nil, hasFault: Bool? = nil, responseTime: Double? = nil) {
            self.isPartial = isPartial
            self.serviceIds = serviceIds
            self.http = http
            self.hasError = hasError
            self.id = id
            self.hasThrottle = hasThrottle
            self.users = users
            self.annotations = annotations
            self.duration = duration
            self.hasFault = hasFault
            self.responseTime = responseTime
        }

        public init(dictionary: [String: Any]) throws {
            self.isPartial = dictionary["IsPartial"] as? Bool
            if let serviceIds = dictionary["ServiceIds"] as? [[String: Any]] {
                self.serviceIds = try serviceIds.map({ try ServiceId(dictionary: $0) })
            } else { 
                self.serviceIds = nil
            }
            if let http = dictionary["Http"] as? [String: Any] { self.http = try Xray.Http(dictionary: http) } else { self.http = nil }
            self.hasError = dictionary["HasError"] as? Bool
            self.id = dictionary["Id"] as? String
            self.hasThrottle = dictionary["HasThrottle"] as? Bool
            if let users = dictionary["Users"] as? [[String: Any]] {
                self.users = try users.map({ try TraceUser(dictionary: $0) })
            } else { 
                self.users = nil
            }
            if let annotations = dictionary["Annotations"] as? [String: Any] {
                var annotationsDict: [String: [ValueWithServiceIds]] = [:]
                for (key, value) in annotations {
                    guard let valueWithServiceIds = value as? [[String: Any]] else { throw InitializableError.convertingError }
                    let valueWithServiceIdsList: [ValueWithServiceIds] = try valueWithServiceIds.map { try ValueWithServiceIds(dictionary: $0) }
                    annotationsDict[key] = valueWithServiceIdsList
                }
                self.annotations = annotationsDict
            } else { 
                self.annotations = nil
            }
            self.duration = dictionary["Duration"] as? Double
            self.hasFault = dictionary["HasFault"] as? Bool
            self.responseTime = dictionary["ResponseTime"] as? Double
        }
    }

}