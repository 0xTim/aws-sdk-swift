// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension ECR {

    public struct GetLifecyclePolicyPreviewResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "previewResults", required: false, type: .list), 
            AWSShapeMember(label: "lifecyclePolicyText", required: false, type: .string), 
            AWSShapeMember(label: "summary", required: false, type: .structure), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The results of the lifecycle policy preview request.
        public let previewResults: [LifecyclePolicyPreviewResult]?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The list of images that is returned as a result of the action.
        public let summary: LifecyclePolicyPreviewSummary?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The status of the lifecycle policy preview request.
        public let status: LifecyclePolicyPreviewStatus?
        /// The nextToken value to include in a future GetLifecyclePolicyPreview request. When the results of a GetLifecyclePolicyPreview request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(previewResults: [LifecyclePolicyPreviewResult]? = nil, lifecyclePolicyText: String? = nil, summary: LifecyclePolicyPreviewSummary? = nil, repositoryName: String? = nil, registryId: String? = nil, status: LifecyclePolicyPreviewStatus? = nil, nextToken: String? = nil) {
            self.previewResults = previewResults
            self.lifecyclePolicyText = lifecyclePolicyText
            self.summary = summary
            self.repositoryName = repositoryName
            self.registryId = registryId
            self.status = status
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case previewResults = "previewResults"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case summary = "summary"
            case repositoryName = "repositoryName"
            case registryId = "registryId"
            case status = "status"
            case nextToken = "nextToken"
        }
    }

    public struct GetLifecyclePolicyPreviewRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "imageIds", required: false, type: .list), 
            AWSShapeMember(label: "filter", required: false, type: .structure), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The nextToken value returned from a previous paginated&#x2028; GetLifecyclePolicyPreviewRequest request where maxResults was used and the&#x2028; results exceeded the value of that parameter. Pagination continues from the end of the&#x2028; previous results that returned the nextToken value. This value is&#x2028; null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The list of imageIDs to be included.
        public let imageIds: [ImageIdentifier]?
        /// An optional parameter that filters results based on image tag status and all tags, if tagged.
        public let filter: LifecyclePolicyPreviewFilter?
        /// The name of the repository.
        public let repositoryName: String
        /// The maximum number of repository results returned by GetLifecyclePolicyPreviewRequest in&#x2028; paginated output. When this parameter is used, GetLifecyclePolicyPreviewRequest only returns&#x2028; maxResults results in a single page along with a nextToken&#x2028; response element. The remaining results of the initial request can be seen by sending&#x2028; another GetLifecyclePolicyPreviewRequest request with the returned nextToken&#x2028; value. This value can be between 1 and 100. If this&#x2028; parameter is not used, then GetLifecyclePolicyPreviewRequest returns up to&#x2028; 100 results and a nextToken value, if&#x2028; applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int32?

        public init(registryId: String? = nil, nextToken: String? = nil, imageIds: [ImageIdentifier]? = nil, filter: LifecyclePolicyPreviewFilter? = nil, repositoryName: String, maxResults: Int32? = nil) {
            self.registryId = registryId
            self.nextToken = nextToken
            self.imageIds = imageIds
            self.filter = filter
            self.repositoryName = repositoryName
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case nextToken = "nextToken"
            case imageIds = "imageIds"
            case filter = "filter"
            case repositoryName = "repositoryName"
            case maxResults = "maxResults"
        }
    }

    public struct LifecyclePolicyPreviewSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "expiringImageTotalCount", required: false, type: .integer)
        ]
        /// The number of expiring images.
        public let expiringImageTotalCount: Int32?

        public init(expiringImageTotalCount: Int32? = nil) {
            self.expiringImageTotalCount = expiringImageTotalCount
        }

        private enum CodingKeys: String, CodingKey {
            case expiringImageTotalCount = "expiringImageTotalCount"
        }
    }

    public struct CreateRepositoryRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The name to use for the repository. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app).
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryPolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyText", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The JSON repository policy that was deleted from the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImagesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "imageDetails", required: false, type: .list)
        ]
        /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of ImageDetail objects that contain data about the image.
        public let imageDetails: [ImageDetail]?

        public init(nextToken: String? = nil, imageDetails: [ImageDetail]? = nil) {
            self.nextToken = nextToken
            self.imageDetails = imageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case imageDetails = "imageDetails"
        }
    }

    public struct DeleteRepositoryRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "force", required: false, type: .boolean)
        ]
        /// The AWS account ID associated with the registry that contains the repository to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to delete.
        public let repositoryName: String
        ///  If a repository contains images, forces the deletion.
        public let force: Bool?

        public init(registryId: String? = nil, repositoryName: String, force: Bool? = nil) {
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.force = force
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case force = "force"
        }
    }

    public struct BatchDeleteImageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageIds", required: false, type: .list), 
            AWSShapeMember(label: "failures", required: false, type: .list)
        ]
        /// The image IDs of the deleted images.
        public let imageIds: [ImageIdentifier]?
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?

        public init(imageIds: [ImageIdentifier]? = nil, failures: [ImageFailure]? = nil) {
            self.imageIds = imageIds
            self.failures = failures
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds = "imageIds"
            case failures = "failures"
        }
    }

    public struct DescribeRepositoriesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "repositories", required: false, type: .list)
        ]
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// A list of repository objects corresponding to valid repositories.
        public let repositories: [Repository]?

        public init(nextToken: String? = nil, repositories: [Repository]? = nil) {
            self.nextToken = nextToken
            self.repositories = repositories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositories = "repositories"
        }
    }

    public struct StartLifecyclePolicyPreviewResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "lifecyclePolicyText", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The JSON repository policy text.
        public let lifecyclePolicyText: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The status of the lifecycle policy preview request.
        public let status: LifecyclePolicyPreviewStatus?

        public init(registryId: String? = nil, lifecyclePolicyText: String? = nil, repositoryName: String? = nil, status: LifecyclePolicyPreviewStatus? = nil) {
            self.registryId = registryId
            self.lifecyclePolicyText = lifecyclePolicyText
            self.repositoryName = repositoryName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case repositoryName = "repositoryName"
            case status = "status"
        }
    }

    public struct CompleteLayerUploadRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploadId", required: true, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "layerDigests", required: true, type: .list), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the image layer.
        public let uploadId: String
        /// The AWS account ID associated with the registry to which to upload layers. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The sha256 digest of the image layer.
        public let layerDigests: [String]
        /// The name of the repository to associate with the image layer.
        public let repositoryName: String

        public init(uploadId: String, registryId: String? = nil, layerDigests: [String], repositoryName: String) {
            self.uploadId = uploadId
            self.registryId = registryId
            self.layerDigests = layerDigests
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
            case registryId = "registryId"
            case layerDigests = "layerDigests"
            case repositoryName = "repositoryName"
        }
    }

    public struct StartLifecyclePolicyPreviewRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "lifecyclePolicyText", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The policy to be evaluated against. If you do not specify a policy, the current policy for the repository is used.
        public let lifecyclePolicyText: String?
        /// The name of the repository to be evaluated.
        public let repositoryName: String

        public init(registryId: String? = nil, lifecyclePolicyText: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.lifecyclePolicyText = lifecyclePolicyText
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case repositoryName = "repositoryName"
        }
    }

    public struct CompleteLayerUploadResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploadId", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "layerDigest", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The upload ID associated with the layer.
        public let uploadId: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(uploadId: String? = nil, registryId: String? = nil, layerDigest: String? = nil, repositoryName: String? = nil) {
            self.uploadId = uploadId
            self.registryId = registryId
            self.layerDigest = layerDigest
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
            case registryId = "registryId"
            case layerDigest = "layerDigest"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchGetImageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "images", required: false, type: .list), 
            AWSShapeMember(label: "failures", required: false, type: .list)
        ]
        /// A list of image objects corresponding to the image references in the request.
        public let images: [Image]?
        /// Any failures associated with the call.
        public let failures: [ImageFailure]?

        public init(images: [Image]? = nil, failures: [ImageFailure]? = nil) {
            self.images = images
            self.failures = failures
        }

        private enum CodingKeys: String, CodingKey {
            case images = "images"
            case failures = "failures"
        }
    }

    public struct ImageDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "imageTags", required: false, type: .list), 
            AWSShapeMember(label: "imageSizeInBytes", required: false, type: .long), 
            AWSShapeMember(label: "imagePushedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "imageDigest", required: false, type: .string)
        ]
        /// The AWS account ID associated with the registry to which this image belongs.
        public let registryId: String?
        /// The list of tags associated with this image.
        public let imageTags: [String]?
        /// The size, in bytes, of the image in the repository.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by DescribeImages. 
        public let imageSizeInBytes: Int64?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository. 
        public let imagePushedAt: TimeStamp?
        /// The name of the repository to which this image belongs.
        public let repositoryName: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?

        public init(registryId: String? = nil, imageTags: [String]? = nil, imageSizeInBytes: Int64? = nil, imagePushedAt: TimeStamp? = nil, repositoryName: String? = nil, imageDigest: String? = nil) {
            self.registryId = registryId
            self.imageTags = imageTags
            self.imageSizeInBytes = imageSizeInBytes
            self.imagePushedAt = imagePushedAt
            self.repositoryName = repositoryName
            self.imageDigest = imageDigest
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case imageTags = "imageTags"
            case imageSizeInBytes = "imageSizeInBytes"
            case imagePushedAt = "imagePushedAt"
            case repositoryName = "repositoryName"
            case imageDigest = "imageDigest"
        }
    }

    public struct GetRepositoryPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository with the policy to retrieve.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct UploadLayerPartRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploadId", required: true, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "partFirstByte", required: true, type: .long), 
            AWSShapeMember(label: "layerPartBlob", required: true, type: .blob), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "partLastByte", required: true, type: .long)
        ]
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the layer part upload.
        public let uploadId: String
        /// The AWS account ID associated with the registry to which you are uploading layer parts. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The integer value of the first byte of the layer part.
        public let partFirstByte: Int64
        /// The base64-encoded layer part payload.
        public let layerPartBlob: Data
        /// The name of the repository to which you are uploading layer parts.
        public let repositoryName: String
        /// The integer value of the last byte of the layer part.
        public let partLastByte: Int64

        public init(uploadId: String, registryId: String? = nil, partFirstByte: Int64, layerPartBlob: Data, repositoryName: String, partLastByte: Int64) {
            self.uploadId = uploadId
            self.registryId = registryId
            self.partFirstByte = partFirstByte
            self.layerPartBlob = layerPartBlob
            self.repositoryName = repositoryName
            self.partLastByte = partLastByte
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
            case registryId = "registryId"
            case partFirstByte = "partFirstByte"
            case layerPartBlob = "layerPartBlob"
            case repositoryName = "repositoryName"
            case partLastByte = "partLastByte"
        }
    }

    public enum LayerAvailability: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public struct BatchCheckLayerAvailabilityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "layers", required: false, type: .list), 
            AWSShapeMember(label: "failures", required: false, type: .list)
        ]
        /// A list of image layer objects corresponding to the image layer references in the request.
        public let layers: [Layer]?
        /// Any failures associated with the call.
        public let failures: [LayerFailure]?

        public init(layers: [Layer]? = nil, failures: [LayerFailure]? = nil) {
            self.layers = layers
            self.failures = failures
        }

        private enum CodingKeys: String, CodingKey {
            case layers = "layers"
            case failures = "failures"
        }
    }

    public struct DeleteRepositoryPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository policy to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the repository policy to delete.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct LifecyclePolicyPreviewResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageDigest", required: false, type: .string), 
            AWSShapeMember(label: "imageTags", required: false, type: .list), 
            AWSShapeMember(label: "imagePushedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "action", required: false, type: .structure), 
            AWSShapeMember(label: "appliedRulePriority", required: false, type: .integer)
        ]
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The list of tags associated with this image.
        public let imageTags: [String]?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public let imagePushedAt: TimeStamp?
        /// The type of action to be taken.
        public let action: LifecyclePolicyRuleAction?
        /// The priority of the applied rule.
        public let appliedRulePriority: Int32?

        public init(imageDigest: String? = nil, imageTags: [String]? = nil, imagePushedAt: TimeStamp? = nil, action: LifecyclePolicyRuleAction? = nil, appliedRulePriority: Int32? = nil) {
            self.imageDigest = imageDigest
            self.imageTags = imageTags
            self.imagePushedAt = imagePushedAt
            self.action = action
            self.appliedRulePriority = appliedRulePriority
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest = "imageDigest"
            case imageTags = "imageTags"
            case imagePushedAt = "imagePushedAt"
            case action = "action"
            case appliedRulePriority = "appliedRulePriority"
        }
    }

    public struct DescribeImagesFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tagStatus", required: false, type: .enum)
        ]
        /// The tag status with which to filter your DescribeImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public let tagStatus: TagStatus?

        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus = "tagStatus"
        }
    }

    public struct GetAuthorizationTokenResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "authorizationData", required: false, type: .list)
        ]
        /// A list of authorization token data objects that correspond to the registryIds values in the request.
        public let authorizationData: [AuthorizationData]?

        public init(authorizationData: [AuthorizationData]? = nil) {
            self.authorizationData = authorizationData
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationData = "authorizationData"
        }
    }

    public enum ImageActionType: String, CustomStringConvertible, Codable {
        case expire = "EXPIRE"
        public var description: String { return self.rawValue }
    }

    public struct PutLifecyclePolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "lifecyclePolicyText", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The JSON repository policy text.
        public let lifecyclePolicyText: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(registryId: String? = nil, lifecyclePolicyText: String? = nil, repositoryName: String? = nil) {
            self.registryId = registryId
            self.lifecyclePolicyText = lifecyclePolicyText
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case repositoryName = "repositoryName"
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "imageIds", required: false, type: .list), 
            AWSShapeMember(label: "filter", required: false, type: .structure), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// The AWS account ID associated with the registry that contains the repository in which to describe images. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
        public let nextToken: String?
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?
        /// The filter key and value with which to filter your DescribeImages results.
        public let filter: DescribeImagesFilter?
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public let repositoryName: String
        /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
        public let maxResults: Int32?

        public init(registryId: String? = nil, nextToken: String? = nil, imageIds: [ImageIdentifier]? = nil, filter: DescribeImagesFilter? = nil, repositoryName: String, maxResults: Int32? = nil) {
            self.registryId = registryId
            self.nextToken = nextToken
            self.imageIds = imageIds
            self.filter = filter
            self.repositoryName = repositoryName
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case nextToken = "nextToken"
            case imageIds = "imageIds"
            case filter = "filter"
            case repositoryName = "repositoryName"
            case maxResults = "maxResults"
        }
    }

    public struct UploadLayerPartResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploadId", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "lastByteReceived", required: false, type: .long)
        ]
        /// The upload ID associated with the request.
        public let uploadId: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The integer value of the last byte received in the request.
        public let lastByteReceived: Int64?

        public init(uploadId: String? = nil, registryId: String? = nil, repositoryName: String? = nil, lastByteReceived: Int64? = nil) {
            self.uploadId = uploadId
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.lastByteReceived = lastByteReceived
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case lastByteReceived = "lastByteReceived"
        }
    }

    public struct SetRepositoryPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "force", required: false, type: .boolean), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "policyText", required: true, type: .string)
        ]
        /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
        public let force: Bool?
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to receive the policy.
        public let repositoryName: String
        /// The JSON repository policy text to apply to the repository.
        public let policyText: String

        public init(force: Bool? = nil, registryId: String? = nil, repositoryName: String, policyText: String) {
            self.force = force
            self.registryId = registryId
            self.repositoryName = repositoryName
            self.policyText = policyText
        }

        private enum CodingKeys: String, CodingKey {
            case force = "force"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
            case policyText = "policyText"
        }
    }

    public struct LifecyclePolicyRuleAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]
        /// The type of action to be taken.
        public let `type`: ImageActionType?

        public init(type: ImageActionType? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct Layer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "layerAvailability", required: false, type: .enum), 
            AWSShapeMember(label: "layerDigest", required: false, type: .string), 
            AWSShapeMember(label: "mediaType", required: false, type: .string), 
            AWSShapeMember(label: "layerSize", required: false, type: .long)
        ]
        /// The availability status of the image layer.
        public let layerAvailability: LayerAvailability?
        /// The sha256 digest of the image layer.
        public let layerDigest: String?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public let mediaType: String?
        /// The size, in bytes, of the image layer.
        public let layerSize: Int64?

        public init(layerAvailability: LayerAvailability? = nil, layerDigest: String? = nil, mediaType: String? = nil, layerSize: Int64? = nil) {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.mediaType = mediaType
            self.layerSize = layerSize
        }

        private enum CodingKeys: String, CodingKey {
            case layerAvailability = "layerAvailability"
            case layerDigest = "layerDigest"
            case mediaType = "mediaType"
            case layerSize = "layerSize"
        }
    }

    public struct Image: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageManifest", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "imageId", required: false, type: .structure), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The image manifest associated with the image.
        public let imageManifest: String?
        /// The AWS account ID associated with the registry containing the image.
        public let registryId: String?
        /// An object containing the image tag and image digest associated with an image.
        public let imageId: ImageIdentifier?
        /// The name of the repository associated with the image.
        public let repositoryName: String?

        public init(imageManifest: String? = nil, registryId: String? = nil, imageId: ImageIdentifier? = nil, repositoryName: String? = nil) {
            self.imageManifest = imageManifest
            self.registryId = registryId
            self.imageId = imageId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageManifest = "imageManifest"
            case registryId = "registryId"
            case imageId = "imageId"
            case repositoryName = "repositoryName"
        }
    }

    public struct LifecyclePolicyPreviewFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tagStatus", required: false, type: .enum)
        ]
        /// The tag status of the image.
        public let tagStatus: TagStatus?

        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus = "tagStatus"
        }
    }

    public enum ImageFailureCode: String, CustomStringConvertible, Codable {
        case invalidimagedigest = "InvalidImageDigest"
        case invalidimagetag = "InvalidImageTag"
        case imagetagdoesnotmatchdigest = "ImageTagDoesNotMatchDigest"
        case imagenotfound = "ImageNotFound"
        case missingdigestandtag = "MissingDigestAndTag"
        public var description: String { return self.rawValue }
    }

    public struct GetRepositoryPolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyText", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The JSON repository policy text associated with the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct InitiateLayerUploadRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry to which you intend to upload layers. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository to which you intend to upload layers.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct AuthorizationData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "expiresAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "proxyEndpoint", required: false, type: .string), 
            AWSShapeMember(label: "authorizationToken", required: false, type: .string)
        ]
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public let expiresAt: TimeStamp?
        /// The registry URL to use for this authorization token in a docker login command. The Amazon ECR registry URL format is https://aws_account_id.dkr.ecr.region.amazonaws.com. For example, https://012345678910.dkr.ecr.us-east-1.amazonaws.com.. 
        public let proxyEndpoint: String?
        /// A base64-encoded string that contains authorization data for the specified Amazon ECR registry. When the string is decoded, it is presented in the format user:password for private registry authentication using docker login.
        public let authorizationToken: String?

        public init(expiresAt: TimeStamp? = nil, proxyEndpoint: String? = nil, authorizationToken: String? = nil) {
            self.expiresAt = expiresAt
            self.proxyEndpoint = proxyEndpoint
            self.authorizationToken = authorizationToken
        }

        private enum CodingKeys: String, CodingKey {
            case expiresAt = "expiresAt"
            case proxyEndpoint = "proxyEndpoint"
            case authorizationToken = "authorizationToken"
        }
    }

    public struct BatchDeleteImageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageIds", required: true, type: .list), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The AWS account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The repository that contains the image to delete.
        public let repositoryName: String

        public init(imageIds: [ImageIdentifier], registryId: String? = nil, repositoryName: String) {
            self.imageIds = imageIds
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageIds = "imageIds"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetLifecyclePolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "lifecyclePolicyText", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "lastEvaluatedAt", required: false, type: .timestamp)
        ]
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The time stamp of the last time that the lifecycle policy was run.
        public let lastEvaluatedAt: TimeStamp?

        public init(registryId: String? = nil, lifecyclePolicyText: String? = nil, repositoryName: String? = nil, lastEvaluatedAt: TimeStamp? = nil) {
            self.registryId = registryId
            self.lifecyclePolicyText = lifecyclePolicyText
            self.repositoryName = repositoryName
            self.lastEvaluatedAt = lastEvaluatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case repositoryName = "repositoryName"
            case lastEvaluatedAt = "lastEvaluatedAt"
        }
    }

    public struct PutImageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "image", required: false, type: .structure)
        ]
        /// Details of the image uploaded.
        public let image: Image?

        public init(image: Image? = nil) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image = "image"
        }
    }

    public struct BatchCheckLayerAvailabilityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "layerDigests", required: true, type: .list), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The digests of the image layers to check.
        public let layerDigests: [String]
        /// The AWS account ID associated with the registry that contains the image layers to check. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layers to check.
        public let repositoryName: String

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigests = "layerDigests"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchGetImageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "acceptedMediaTypes", required: false, type: .list), 
            AWSShapeMember(label: "imageIds", required: true, type: .list), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the images to describe. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The accepted media types for the request. Valid values: application/vnd.docker.distribution.manifest.v1+json | application/vnd.docker.distribution.manifest.v2+json | application/vnd.oci.image.manifest.v1+json 
        public let acceptedMediaTypes: [String]?
        /// A list of image ID references that correspond to images to describe. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public let imageIds: [ImageIdentifier]
        /// The repository that contains the images to describe.
        public let repositoryName: String

        public init(registryId: String? = nil, acceptedMediaTypes: [String]? = nil, imageIds: [ImageIdentifier], repositoryName: String) {
            self.registryId = registryId
            self.acceptedMediaTypes = acceptedMediaTypes
            self.imageIds = imageIds
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case acceptedMediaTypes = "acceptedMediaTypes"
            case imageIds = "imageIds"
            case repositoryName = "repositoryName"
        }
    }

    public struct ImageIdentifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageDigest", required: false, type: .string), 
            AWSShapeMember(label: "imageTag", required: false, type: .string)
        ]
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The tag used for the image.
        public let imageTag: String?

        public init(imageDigest: String? = nil, imageTag: String? = nil) {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }

        private enum CodingKeys: String, CodingKey {
            case imageDigest = "imageDigest"
            case imageTag = "imageTag"
        }
    }

    public struct GetDownloadUrlForLayerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "layerDigest", required: true, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The digest of the image layer to download.
        public let layerDigest: String
        /// The AWS account ID associated with the registry that contains the image layer to download. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository that is associated with the image layer to download.
        public let repositoryName: String

        public init(layerDigest: String, registryId: String? = nil, repositoryName: String) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest = "layerDigest"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public enum LayerFailureCode: String, CustomStringConvertible, Codable {
        case invalidlayerdigest = "InvalidLayerDigest"
        case missinglayerdigest = "MissingLayerDigest"
        public var description: String { return self.rawValue }
    }

    public struct PutLifecyclePolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "lifecyclePolicyText", required: true, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository. If you do&#x2028; not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The JSON repository policy text to apply to the repository.
        public let lifecyclePolicyText: String
        /// The name of the repository to receive the policy.
        public let repositoryName: String

        public init(registryId: String? = nil, lifecyclePolicyText: String, repositoryName: String) {
            self.registryId = registryId
            self.lifecyclePolicyText = lifecyclePolicyText
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]
        /// The repository that was deleted.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public enum TagStatus: String, CustomStringConvertible, Codable {
        case tagged = "TAGGED"
        case untagged = "UNTAGGED"
        public var description: String { return self.rawValue }
    }

    public struct LayerFailure: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "layerDigest", required: false, type: .string), 
            AWSShapeMember(label: "failureCode", required: false, type: .enum), 
            AWSShapeMember(label: "failureReason", required: false, type: .string)
        ]
        /// The layer digest associated with the failure.
        public let layerDigest: String?
        /// The failure code associated with the failure.
        public let failureCode: LayerFailureCode?
        /// The reason for the failure.
        public let failureReason: String?

        public init(layerDigest: String? = nil, failureCode: LayerFailureCode? = nil, failureReason: String? = nil) {
            self.layerDigest = layerDigest
            self.failureCode = failureCode
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest = "layerDigest"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
        }
    }

    public struct ListImagesFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tagStatus", required: false, type: .enum)
        ]
        /// The tag status with which to filter your ListImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public let tagStatus: TagStatus?

        public init(tagStatus: TagStatus? = nil) {
            self.tagStatus = tagStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tagStatus = "tagStatus"
        }
    }

    public struct GetAuthorizationTokenRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryIds", required: false, type: .list)
        ]
        /// A list of AWS account IDs that are associated with the registries for which to get authorization tokens. If you do not specify a registry, the default registry is assumed.
        public let registryIds: [String]?

        public init(registryIds: [String]? = nil) {
            self.registryIds = registryIds
        }

        private enum CodingKeys: String, CodingKey {
            case registryIds = "registryIds"
        }
    }

    public struct GetLifecyclePolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The name of the repository.
        public let repositoryName: String

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct ListImagesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "filter", required: false, type: .structure), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// The AWS account ID associated with the registry that contains the repository in which to list images. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The nextToken value returned from a previous paginated ListImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes. 
        public let nextToken: String?
        /// The filter key and value with which to filter your ListImages results.
        public let filter: ListImagesFilter?
        /// The repository with image IDs to be listed.
        public let repositoryName: String
        /// The maximum number of image results returned by ListImages in paginated output. When this parameter is used, ListImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListImages request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListImages returns up to 100 results and a nextToken value, if applicable.
        public let maxResults: Int32?

        public init(registryId: String? = nil, nextToken: String? = nil, filter: ListImagesFilter? = nil, repositoryName: String, maxResults: Int32? = nil) {
            self.registryId = registryId
            self.nextToken = nextToken
            self.filter = filter
            self.repositoryName = repositoryName
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case nextToken = "nextToken"
            case filter = "filter"
            case repositoryName = "repositoryName"
            case maxResults = "maxResults"
        }
    }

    public struct SetRepositoryPolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyText", required: false, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The JSON repository policy text applied to the repository.
        public let policyText: String?
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The repository name associated with the request.
        public let repositoryName: String?

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case policyText = "policyText"
            case registryId = "registryId"
            case repositoryName = "repositoryName"
        }
    }

    public struct PutImageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageManifest", required: true, type: .string), 
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "imageTag", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The image manifest corresponding to the image to be uploaded.
        public let imageManifest: String
        /// The AWS account ID associated with the registry that contains the repository in which to put the image. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or OCI formats.
        public let imageTag: String?
        /// The name of the repository in which to put the image.
        public let repositoryName: String

        public init(imageManifest: String, registryId: String? = nil, imageTag: String? = nil, repositoryName: String) {
            self.imageManifest = imageManifest
            self.registryId = registryId
            self.imageTag = imageTag
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case imageManifest = "imageManifest"
            case registryId = "registryId"
            case imageTag = "imageTag"
            case repositoryName = "repositoryName"
        }
    }

    public struct Repository: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryArn", required: false, type: .string), 
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "repositoryUri", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The AWS account ID associated with the registry that contains the repository.
        public let registryId: String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public let repositoryArn: String?
        /// The date and time, in JavaScript date format, when the repository was created.
        public let createdAt: TimeStamp?
        /// The URI for the repository. You can use this URI for Docker push or pull operations.
        public let repositoryUri: String?
        /// The name of the repository.
        public let repositoryName: String?

        public init(registryId: String? = nil, repositoryArn: String? = nil, createdAt: TimeStamp? = nil, repositoryUri: String? = nil, repositoryName: String? = nil) {
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.createdAt = createdAt
            self.repositoryUri = repositoryUri
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case repositoryArn = "repositoryArn"
            case createdAt = "createdAt"
            case repositoryUri = "repositoryUri"
            case repositoryName = "repositoryName"
        }
    }

    public struct ImageFailure: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imageId", required: false, type: .structure), 
            AWSShapeMember(label: "failureCode", required: false, type: .enum), 
            AWSShapeMember(label: "failureReason", required: false, type: .string)
        ]
        /// The image ID associated with the failure.
        public let imageId: ImageIdentifier?
        /// The code associated with the failure.
        public let failureCode: ImageFailureCode?
        /// The reason for the failure.
        public let failureReason: String?

        public init(imageId: ImageIdentifier? = nil, failureCode: ImageFailureCode? = nil, failureReason: String? = nil) {
            self.imageId = imageId
            self.failureCode = failureCode
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case imageId = "imageId"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
        }
    }

    public struct DeleteLifecyclePolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "lifecyclePolicyText", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "lastEvaluatedAt", required: false, type: .timestamp)
        ]
        /// The registry ID associated with the request.
        public let registryId: String?
        /// The JSON lifecycle policy text.
        public let lifecyclePolicyText: String?
        /// The repository name associated with the request.
        public let repositoryName: String?
        /// The time stamp of the last time that the lifecycle policy was run.
        public let lastEvaluatedAt: TimeStamp?

        public init(registryId: String? = nil, lifecyclePolicyText: String? = nil, repositoryName: String? = nil, lastEvaluatedAt: TimeStamp? = nil) {
            self.registryId = registryId
            self.lifecyclePolicyText = lifecyclePolicyText
            self.repositoryName = repositoryName
            self.lastEvaluatedAt = lastEvaluatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case lifecyclePolicyText = "lifecyclePolicyText"
            case repositoryName = "repositoryName"
            case lastEvaluatedAt = "lastEvaluatedAt"
        }
    }

    public struct InitiateLayerUploadResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "uploadId", required: false, type: .string), 
            AWSShapeMember(label: "partSize", required: false, type: .long)
        ]
        /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
        public let uploadId: String?
        /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
        public let partSize: Int64?

        public init(uploadId: String? = nil, partSize: Int64? = nil) {
            self.uploadId = uploadId
            self.partSize = partSize
        }

        private enum CodingKeys: String, CodingKey {
            case uploadId = "uploadId"
            case partSize = "partSize"
        }
    }

    public struct CreateRepositoryResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "repository", required: false, type: .structure)
        ]
        /// The repository that was created.
        public let repository: Repository?

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        private enum CodingKeys: String, CodingKey {
            case repository = "repository"
        }
    }

    public enum LifecyclePolicyPreviewStatus: String, CustomStringConvertible, Codable {
        case inProgress = "IN_PROGRESS"
        case complete = "COMPLETE"
        case expired = "EXPIRED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct GetDownloadUrlForLayerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "layerDigest", required: false, type: .string), 
            AWSShapeMember(label: "downloadUrl", required: false, type: .string)
        ]
        /// The digest of the image layer to download.
        public let layerDigest: String?
        /// The pre-signed Amazon S3 download URL for the requested layer.
        public let downloadUrl: String?

        public init(layerDigest: String? = nil, downloadUrl: String? = nil) {
            self.layerDigest = layerDigest
            self.downloadUrl = downloadUrl
        }

        private enum CodingKeys: String, CodingKey {
            case layerDigest = "layerDigest"
            case downloadUrl = "downloadUrl"
        }
    }

    public struct ListImagesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "imageIds", required: false, type: .list)
        ]
        /// The nextToken value to include in a future ListImages request. When the results of a ListImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of image IDs for the requested repository.
        public let imageIds: [ImageIdentifier]?

        public init(nextToken: String? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.nextToken = nextToken
            self.imageIds = imageIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case imageIds = "imageIds"
        }
    }

    public struct DescribeRepositoriesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "registryId", required: false, type: .string), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "repositoryNames", required: false, type: .list), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer)
        ]
        /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default registry is assumed.
        public let registryId: String?
        /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify repositories with repositoryNames.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes. 
        public let nextToken: String?
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public let repositoryNames: [String]?
        /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify repositories with repositoryNames.
        public let maxResults: Int32?

        public init(registryId: String? = nil, nextToken: String? = nil, repositoryNames: [String]? = nil, maxResults: Int32? = nil) {
            self.registryId = registryId
            self.nextToken = nextToken
            self.repositoryNames = repositoryNames
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "registryId"
            case nextToken = "nextToken"
            case repositoryNames = "repositoryNames"
            case maxResults = "maxResults"
        }
    }

}