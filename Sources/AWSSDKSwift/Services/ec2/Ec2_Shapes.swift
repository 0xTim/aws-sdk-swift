// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Ec2 {

    public struct DescribeVpcClassicLinkResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ClassicLink status of one or more VPCs.
        public var vpcs: [VpcClassicLink]? = nil

        public init() {}

        public init(vpcs: [VpcClassicLink]? = nil) {
            self.vpcs = vpcs
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcs = dictionary["Vpcs"] as? [[String: Any]] {
                self.vpcs = try vpcs.map({ try VpcClassicLink(dictionary: $0) })
            }
        }
    }

    public struct GetConsoleScreenshotRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// When set to true, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.
        public var wakeUp: Bool? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(wakeUp: Bool? = nil, instanceId: String, dryRun: Bool? = nil) {
            self.wakeUp = wakeUp
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.wakeUp = dictionary["WakeUp"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeIamInstanceProfileAssociationsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more IAM instance profile associations.
        public var associationIds: [String]? = nil
        /// One or more filters.    instance-id - The ID of the instance.    state - The state of the association (associating | associated | disassociating | disassociated).  
        public var filters: [Filter]? = nil
        /// The token to request the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(associationIds: [String]? = nil, filters: [Filter]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.associationIds = associationIds
            self.filters = filters
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let associationIds = dictionary["AssociationIds"] as? [String] {
                self.associationIds = associationIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeInstanceAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// The instance attribute. Note: The enaSupport attribute is not supported at this time.
        public var attribute: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, instanceId: String, attribute: String) {
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct BlobAttributeValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var value: Data? = nil

        public init() {}

        public init(value: Data? = nil) {
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Data
        }
    }

    public struct ModifyVolumeAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Indicates whether the volume should be auto-enabled for I/O operations.
        public var autoEnableIO: AttributeBooleanValue? = nil
        /// The ID of the volume.
        public var volumeId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, autoEnableIO: AttributeBooleanValue? = nil, volumeId: String) {
            self.dryRun = dryRun
            self.autoEnableIO = autoEnableIO
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let autoEnableIO = dictionary["AutoEnableIO"] as? [String: Any] { self.autoEnableIO = try Ec2.AttributeBooleanValue(dictionary: autoEnableIO) }
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public struct InternetGatewayAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// The current state of the attachment.
        public var state: String? = nil

        public init() {}

        public init(vpcId: String? = nil, state: String? = nil) {
            self.vpcId = vpcId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            self.state = dictionary["State"] as? String
        }
    }

    public struct DescribeScheduledInstanceAvailabilityResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Information about the available Scheduled Instances.
        public var scheduledInstanceAvailabilitySet: [ScheduledInstanceAvailability]? = nil

        public init() {}

        public init(nextToken: String? = nil, scheduledInstanceAvailabilitySet: [ScheduledInstanceAvailability]? = nil) {
            self.nextToken = nextToken
            self.scheduledInstanceAvailabilitySet = scheduledInstanceAvailabilitySet
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let scheduledInstanceAvailabilitySet = dictionary["ScheduledInstanceAvailabilitySet"] as? [[String: Any]] {
                self.scheduledInstanceAvailabilitySet = try scheduledInstanceAvailabilitySet.map({ try ScheduledInstanceAvailability(dictionary: $0) })
            }
        }
    }

    public struct DescribeAddressesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more Elastic IP addresses.
        public var addresses: [Address]? = nil

        public init() {}

        public init(addresses: [Address]? = nil) {
            self.addresses = addresses
        }

        public init(dictionary: [String: Any]) throws {
            if let addresses = dictionary["Addresses"] as? [[String: Any]] {
                self.addresses = try addresses.map({ try Address(dictionary: $0) })
            }
        }
    }

    public struct DescribeNatGatewaysResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the NAT gateways.
        public var natGateways: [NatGateway]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(natGateways: [NatGateway]? = nil, nextToken: String? = nil) {
            self.natGateways = natGateways
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let natGateways = dictionary["NatGateways"] as? [[String: Any]] {
                self.natGateways = try natGateways.map({ try NatGateway(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CreateEgressOnlyInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC for which to create the egress-only Internet gateway.
        public var vpcId: String = ""
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        public var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, clientToken: String? = nil, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.clientToken = clientToken
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.clientToken = dictionary["ClientToken"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ModifyVpcAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" will succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.
        public var enableDnsSupport: AttributeBooleanValue? = nil
        /// Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.
        public var enableDnsHostnames: AttributeBooleanValue? = nil

        public init() {}

        public init(vpcId: String, enableDnsSupport: AttributeBooleanValue? = nil, enableDnsHostnames: AttributeBooleanValue? = nil) {
            self.vpcId = vpcId
            self.enableDnsSupport = enableDnsSupport
            self.enableDnsHostnames = enableDnsHostnames
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            if let enableDnsSupport = dictionary["EnableDnsSupport"] as? [String: Any] { self.enableDnsSupport = try Ec2.AttributeBooleanValue(dictionary: enableDnsSupport) }
            if let enableDnsHostnames = dictionary["EnableDnsHostnames"] as? [String: Any] { self.enableDnsHostnames = try Ec2.AttributeBooleanValue(dictionary: enableDnsHostnames) }
        }
    }

    public struct CreateVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID of the owner of the peer VPC. Default: Your AWS account ID
        public var peerOwnerId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the requester VPC.
        public var vpcId: String? = nil
        /// The ID of the VPC with which you are creating the VPC peering connection.
        public var peerVpcId: String? = nil

        public init() {}

        public init(peerOwnerId: String? = nil, dryRun: Bool? = nil, vpcId: String? = nil, peerVpcId: String? = nil) {
            self.peerOwnerId = peerOwnerId
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.peerVpcId = peerVpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.peerOwnerId = dictionary["PeerOwnerId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.vpcId = dictionary["VpcId"] as? String
            self.peerVpcId = dictionary["PeerVpcId"] as? String
        }
    }

    public struct Host: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide. 
        public var clientToken: String? = nil
        /// Whether auto-placement is on or off.
        public var autoPlacement: String? = nil
        /// The ID of the Dedicated Host.
        public var hostId: String? = nil
        /// The Dedicated Host's state.
        public var state: String? = nil
        /// The number of new instances that can be launched onto the Dedicated Host.
        public var availableCapacity: AvailableCapacity? = nil
        /// The reservation ID of the Dedicated Host. This returns a null response if the Dedicated Host doesn't have an associated reservation.
        public var hostReservationId: String? = nil
        /// The IDs and instance type that are currently running on the Dedicated Host.
        public var instances: [HostInstance]? = nil
        /// The hardware specifications of the Dedicated Host.
        public var hostProperties: HostProperties? = nil
        /// The Availability Zone of the Dedicated Host.
        public var availabilityZone: String? = nil

        public init() {}

        public init(clientToken: String? = nil, autoPlacement: String? = nil, hostId: String? = nil, state: String? = nil, availableCapacity: AvailableCapacity? = nil, hostReservationId: String? = nil, instances: [HostInstance]? = nil, hostProperties: HostProperties? = nil, availabilityZone: String? = nil) {
            self.clientToken = clientToken
            self.autoPlacement = autoPlacement
            self.hostId = hostId
            self.state = state
            self.availableCapacity = availableCapacity
            self.hostReservationId = hostReservationId
            self.instances = instances
            self.hostProperties = hostProperties
            self.availabilityZone = availabilityZone
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.autoPlacement = dictionary["AutoPlacement"] as? String
            self.hostId = dictionary["HostId"] as? String
            self.state = dictionary["State"] as? String
            if let availableCapacity = dictionary["AvailableCapacity"] as? [String: Any] { self.availableCapacity = try Ec2.AvailableCapacity(dictionary: availableCapacity) }
            self.hostReservationId = dictionary["HostReservationId"] as? String
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try HostInstance(dictionary: $0) })
            }
            if let hostProperties = dictionary["HostProperties"] as? [String: Any] { self.hostProperties = try Ec2.HostProperties(dictionary: hostProperties) }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
        }
    }

    public struct TargetReservationValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The configuration of the Convertible Reserved Instances that make up the exchange.
        public var targetConfiguration: TargetConfiguration? = nil
        /// The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.
        public var reservationValue: ReservationValue? = nil

        public init() {}

        public init(targetConfiguration: TargetConfiguration? = nil, reservationValue: ReservationValue? = nil) {
            self.targetConfiguration = targetConfiguration
            self.reservationValue = reservationValue
        }

        public init(dictionary: [String: Any]) throws {
            if let targetConfiguration = dictionary["TargetConfiguration"] as? [String: Any] { self.targetConfiguration = try Ec2.TargetConfiguration(dictionary: targetConfiguration) }
            if let reservationValue = dictionary["ReservationValue"] as? [String: Any] { self.reservationValue = try Ec2.ReservationValue(dictionary: reservationValue) }
        }
    }

    public struct ImportKeyPairResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The key pair name you provided.
        public var keyName: String? = nil
        /// The MD5 public key fingerprint as specified in section 4 of RFC 4716.
        public var keyFingerprint: String? = nil

        public init() {}

        public init(keyName: String? = nil, keyFingerprint: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? String
            self.keyFingerprint = dictionary["KeyFingerprint"] as? String
        }
    }

    public struct DescribeSnapshotsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The NextToken value to include in a future DescribeSnapshots request. When the results of a DescribeSnapshots request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Information about the snapshots.
        public var snapshots: [Snapshot]? = nil

        public init() {}

        public init(nextToken: String? = nil, snapshots: [Snapshot]? = nil) {
            self.nextToken = nextToken
            self.snapshots = snapshots
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let snapshots = dictionary["Snapshots"] as? [[String: Any]] {
                self.snapshots = try snapshots.map({ try Snapshot(dictionary: $0) })
            }
        }
    }

    public struct DescribeInstanceStatusRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    availability-zone - The Availability Zone of the instance.    event.code - The code for the scheduled event (instance-reboot | system-reboot | system-maintenance | instance-retirement | instance-stop).    event.description - A description of the event.    event.not-after - The latest end time for the scheduled event (for example, 2014-09-15T17:15:20.000Z).    event.not-before - The earliest start time for the scheduled event (for example, 2014-09-15T17:15:20.000Z).    instance-state-code - The code for the instance state, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).    instance-state-name - The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).    instance-status.reachability - Filters on instance status where the name is reachability (passed | failed | initializing | insufficient-data).    instance-status.status - The status of the instance (ok | impaired | initializing | insufficient-data | not-applicable).    system-status.reachability - Filters on system status where the name is reachability (passed | failed | initializing | insufficient-data).    system-status.status - The system status of the instance (ok | impaired | initializing | insufficient-data | not-applicable).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// When true, includes the health status for all instances. When false, includes the health status for running instances only. Default: false 
        public var includeAllInstances: Bool? = nil
        /// One or more instance IDs. Default: Describes all your instances. Constraints: Maximum 100 explicitly specified instance IDs.
        public var instanceIds: [String]? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, includeAllInstances: Bool? = nil, instanceIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.includeAllInstances = includeAllInstances
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.includeAllInstances = dictionary["IncludeAllInstances"] as? Bool
            if let instanceIds = dictionary["InstanceIds"] as? [String] {
                self.instanceIds = instanceIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct VolumeStatusItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The details of the operation.
        public var actions: [VolumeStatusAction]? = nil
        /// The volume status.
        public var volumeStatus: VolumeStatusInfo? = nil
        /// A list of events associated with the volume.
        public var events: [VolumeStatusEvent]? = nil
        /// The Availability Zone of the volume.
        public var availabilityZone: String? = nil
        /// The volume ID.
        public var volumeId: String? = nil

        public init() {}

        public init(actions: [VolumeStatusAction]? = nil, volumeStatus: VolumeStatusInfo? = nil, events: [VolumeStatusEvent]? = nil, availabilityZone: String? = nil, volumeId: String? = nil) {
            self.actions = actions
            self.volumeStatus = volumeStatus
            self.events = events
            self.availabilityZone = availabilityZone
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            if let actions = dictionary["Actions"] as? [[String: Any]] {
                self.actions = try actions.map({ try VolumeStatusAction(dictionary: $0) })
            }
            if let volumeStatus = dictionary["VolumeStatus"] as? [String: Any] { self.volumeStatus = try Ec2.VolumeStatusInfo(dictionary: volumeStatus) }
            if let events = dictionary["Events"] as? [[String: Any]] {
                self.events = try events.map({ try VolumeStatusEvent(dictionary: $0) })
            }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct CreateRouteTableResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the route table.
        public var routeTable: RouteTable? = nil

        public init() {}

        public init(routeTable: RouteTable? = nil) {
            self.routeTable = routeTable
        }

        public init(dictionary: [String: Any]) throws {
            if let routeTable = dictionary["RouteTable"] as? [String: Any] { self.routeTable = try Ec2.RouteTable(dictionary: routeTable) }
        }
    }

    public struct EnableVpcClassicLinkRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct InstanceNetworkInterface: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The MAC address.
        public var macAddress: String? = nil
        /// Indicates whether to validate network traffic to or from this network interface.
        public var sourceDestCheck: Bool? = nil
        /// The private DNS name.
        public var privateDnsName: String? = nil
        /// The ID of the AWS account that created the network interface.
        public var ownerId: String? = nil
        /// The network interface attachment.
        public var attachment: InstanceNetworkInterfaceAttachment? = nil
        /// The description.
        public var description: String? = nil
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: String? = nil
        /// The status of the network interface.
        public var status: String? = nil
        /// One or more private IPv4 addresses associated with the network interface.
        public var privateIpAddresses: [InstancePrivateIpAddress]? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// One or more IPv6 addresses associated with the network interface.
        public var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// One or more security groups.
        public var groups: [GroupIdentifier]? = nil
        /// The association information for an Elastic IPv4 associated with the network interface.
        public var association: InstanceNetworkInterfaceAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, networkInterfaceId: String? = nil, macAddress: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, ownerId: String? = nil, attachment: InstanceNetworkInterfaceAttachment? = nil, description: String? = nil, privateIpAddress: String? = nil, status: String? = nil, privateIpAddresses: [InstancePrivateIpAddress]? = nil, vpcId: String? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, groups: [GroupIdentifier]? = nil, association: InstanceNetworkInterfaceAssociation? = nil) {
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.macAddress = macAddress
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.ownerId = ownerId
            self.attachment = attachment
            self.description = description
            self.privateIpAddress = privateIpAddress
            self.status = status
            self.privateIpAddresses = privateIpAddresses
            self.vpcId = vpcId
            self.ipv6Addresses = ipv6Addresses
            self.groups = groups
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.macAddress = dictionary["MacAddress"] as? String
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? Bool
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.InstanceNetworkInterfaceAttachment(dictionary: attachment) }
            self.description = dictionary["Description"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.status = dictionary["Status"] as? String
            if let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [[String: Any]] {
                self.privateIpAddresses = try privateIpAddresses.map({ try InstancePrivateIpAddress(dictionary: $0) })
            }
            self.vpcId = dictionary["VpcId"] as? String
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [[String: Any]] {
                self.ipv6Addresses = try ipv6Addresses.map({ try InstanceIpv6Address(dictionary: $0) })
            }
            if let groups = dictionary["Groups"] as? [[String: Any]] {
                self.groups = try groups.map({ try GroupIdentifier(dictionary: $0) })
            }
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.InstanceNetworkInterfaceAssociation(dictionary: association) }
        }
    }

    public struct CreateNetworkInterfaceResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the network interface.
        public var networkInterface: NetworkInterface? = nil

        public init() {}

        public init(networkInterface: NetworkInterface? = nil) {
            self.networkInterface = networkInterface
        }

        public init(dictionary: [String: Any]) throws {
            if let networkInterface = dictionary["NetworkInterface"] as? [String: Any] { self.networkInterface = try Ec2.NetworkInterface(dictionary: networkInterface) }
        }
    }

    public struct ResetInstanceAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// The attribute to reset.  You can only reset the following attributes: kernel | ramdisk | sourceDestCheck. To change an instance attribute, use ModifyInstanceAttribute. 
        public var attribute: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, instanceId: String, attribute: String) {
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct Monitoring: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
        public var state: String? = nil

        public init() {}

        public init(state: String? = nil) {
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.state = dictionary["State"] as? String
        }
    }

    public struct RequestSpotLaunchSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instance.
        public var subnetId: String? = nil
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var userData: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        public var ebsOptimized: Bool? = nil
        /// The ID of the kernel.
        public var kernelId: String? = nil
        public var securityGroupIds: [String]? = nil
        public var monitoring: RunInstancesMonitoringEnabled? = nil
        /// The instance type.
        public var instanceType: String? = nil
        public var securityGroups: [String]? = nil
        /// The name of the key pair.
        public var keyName: String? = nil
        /// Deprecated.
        public var addressingType: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// The ID of the AMI.
        public var imageId: String? = nil
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        public var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The placement information for the instance.
        public var placement: SpotPlacement? = nil
        /// The ID of the RAM disk.
        public var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, securityGroupIds: [String]? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, instanceType: String? = nil, securityGroups: [String]? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            if let securityGroupIds = dictionary["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = securityGroupIds
            }
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.RunInstancesMonitoringEnabled(dictionary: monitoring) }
            self.instanceType = dictionary["InstanceType"] as? String
            if let securityGroups = dictionary["SecurityGroups"] as? [String] {
                self.securityGroups = securityGroups
            }
            self.keyName = dictionary["KeyName"] as? String
            self.addressingType = dictionary["AddressingType"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) }
            self.imageId = dictionary["ImageId"] as? String
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try InstanceNetworkInterfaceSpecification(dictionary: $0) })
            }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.SpotPlacement(dictionary: placement) }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct AssociateVpcCidrBlockRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
        public var amazonProvidedIpv6CidrBlock: Bool? = nil

        public init() {}

        public init(vpcId: String, amazonProvidedIpv6CidrBlock: Bool? = nil) {
            self.vpcId = vpcId
            self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.amazonProvidedIpv6CidrBlock = dictionary["AmazonProvidedIpv6CidrBlock"] as? Bool
        }
    }

    public struct ImageDiskContainer: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The S3 bucket for the disk image.
        public var userBucket: UserBucket? = nil
        /// The format of the disk image being imported. Valid values: RAW | VHD | VMDK | OVA 
        public var format: String? = nil
        /// The ID of the EBS snapshot to be used for importing the snapshot.
        public var snapshotId: String? = nil
        /// The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)
        public var url: String? = nil
        /// The block device mapping for the disk.
        public var deviceName: String? = nil
        /// The description of the disk image.
        public var description: String? = nil

        public init() {}

        public init(userBucket: UserBucket? = nil, format: String? = nil, snapshotId: String? = nil, url: String? = nil, deviceName: String? = nil, description: String? = nil) {
            self.userBucket = userBucket
            self.format = format
            self.snapshotId = snapshotId
            self.url = url
            self.deviceName = deviceName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucket(dictionary: userBucket) }
            self.format = dictionary["Format"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.url = dictionary["Url"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct PurchaseReservedInstancesOfferingRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Reserved Instance offering to purchase.
        public var reservedInstancesOfferingId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The number of Reserved Instances to purchase.
        public var instanceCount: Int32 = 0
        /// Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.
        public var limitPrice: ReservedInstanceLimitPrice? = nil

        public init() {}

        public init(reservedInstancesOfferingId: String, dryRun: Bool? = nil, instanceCount: Int32, limitPrice: ReservedInstanceLimitPrice? = nil) {
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.dryRun = dryRun
            self.instanceCount = instanceCount
            self.limitPrice = limitPrice
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstancesOfferingId = dictionary["ReservedInstancesOfferingId"] as? String else { throw InitializableError.missingRequiredParam("ReservedInstancesOfferingId") }
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceCount = dictionary["InstanceCount"] as? Int32 else { throw InitializableError.missingRequiredParam("InstanceCount") }
            self.instanceCount = instanceCount
            if let limitPrice = dictionary["LimitPrice"] as? [String: Any] { self.limitPrice = try Ec2.ReservedInstanceLimitPrice(dictionary: limitPrice) }
        }
    }

    public struct ReservedInstances: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The recurring charge tag assigned to the resource.
        public var recurringCharges: [RecurringCharge]? = nil
        /// Any tags assigned to the resource.
        public var tags: [Tag]? = nil
        /// The usage price of the Reserved Instance, per hour.
        public var usagePrice: Float? = nil
        /// The state of the Reserved Instance purchase.
        public var state: String? = nil
        /// The tenancy of the instance.
        public var instanceTenancy: String? = nil
        /// The instance type on which the Reserved Instance can be used.
        public var instanceType: String? = nil
        /// The Reserved Instance offering type.
        public var offeringType: String? = nil
        /// The Reserved Instance product platform description.
        public var productDescription: String? = nil
        /// The offering class of the Reserved Instance.
        public var offeringClass: String? = nil
        /// The Availability Zone in which the Reserved Instance can be used.
        public var availabilityZone: String? = nil
        /// The date and time the Reserved Instance started.
        public var start: Date? = nil
        /// The time when the Reserved Instance expires.
        public var end: Date? = nil
        /// The ID of the Reserved Instance.
        public var reservedInstancesId: String? = nil
        /// The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The number of reservations purchased.
        public var instanceCount: Int32? = nil
        /// The duration of the Reserved Instance, in seconds.
        public var duration: Int64? = nil
        /// The scope of the Reserved Instance.
        public var scope: String? = nil
        /// The purchase price of the Reserved Instance.
        public var fixedPrice: Float? = nil

        public init() {}

        public init(recurringCharges: [RecurringCharge]? = nil, tags: [Tag]? = nil, usagePrice: Float? = nil, state: String? = nil, instanceTenancy: String? = nil, instanceType: String? = nil, offeringType: String? = nil, productDescription: String? = nil, offeringClass: String? = nil, availabilityZone: String? = nil, start: Date? = nil, end: Date? = nil, reservedInstancesId: String? = nil, currencyCode: String? = nil, instanceCount: Int32? = nil, duration: Int64? = nil, scope: String? = nil, fixedPrice: Float? = nil) {
            self.recurringCharges = recurringCharges
            self.tags = tags
            self.usagePrice = usagePrice
            self.state = state
            self.instanceTenancy = instanceTenancy
            self.instanceType = instanceType
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.offeringClass = offeringClass
            self.availabilityZone = availabilityZone
            self.start = start
            self.end = end
            self.reservedInstancesId = reservedInstancesId
            self.currencyCode = currencyCode
            self.instanceCount = instanceCount
            self.duration = duration
            self.scope = scope
            self.fixedPrice = fixedPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let recurringCharges = dictionary["RecurringCharges"] as? [[String: Any]] {
                self.recurringCharges = try recurringCharges.map({ try RecurringCharge(dictionary: $0) })
            }
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.usagePrice = dictionary["UsagePrice"] as? Float
            self.state = dictionary["State"] as? String
            self.instanceTenancy = dictionary["InstanceTenancy"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.offeringType = dictionary["OfferingType"] as? String
            self.productDescription = dictionary["ProductDescription"] as? String
            self.offeringClass = dictionary["OfferingClass"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.start = dictionary["Start"] as? Date
            self.end = dictionary["End"] as? Date
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.duration = dictionary["Duration"] as? Int64
            self.scope = dictionary["Scope"] as? String
            self.fixedPrice = dictionary["FixedPrice"] as? Float
        }
    }

    public struct NetworkInterfaceIpv6Address: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 address.
        public var ipv6Address: String? = nil

        public init() {}

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6Address = dictionary["Ipv6Address"] as? String
        }
    }

    public struct DescribeCustomerGatewaysRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more customer gateway IDs. Default: Describes all your customer gateways.
        public var customerGatewayIds: [String]? = nil
        /// One or more filters.    bgp-asn - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).    customer-gateway-id - The ID of the customer gateway.    ip-address - The IP address of the customer gateway's Internet-routable external interface.    state - The state of the customer gateway (pending | available | deleting | deleted).    type - The type of customer gateway. Currently, the only supported type is ipsec.1.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(customerGatewayIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.customerGatewayIds = customerGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let customerGatewayIds = dictionary["CustomerGatewayIds"] as? [String] {
                self.customerGatewayIds = customerGatewayIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct NetworkInterface: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The MAC address.
        public var macAddress: String? = nil
        /// Indicates whether traffic to or from the instance is validated.
        public var sourceDestCheck: Bool? = nil
        /// The private DNS name.
        public var privateDnsName: String? = nil
        /// The network interface attachment.
        public var attachment: NetworkInterfaceAttachment? = nil
        /// The type of interface.
        public var interfaceType: String? = nil
        /// Any tags assigned to the network interface.
        public var tagSet: [Tag]? = nil
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: String? = nil
        /// The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).
        public var requesterId: String? = nil
        /// A description.
        public var description: String? = nil
        /// The AWS account ID of the owner of the network interface.
        public var ownerId: String? = nil
        /// The private IPv4 addresses associated with the network interface.
        public var privateIpAddresses: [NetworkInterfacePrivateIpAddress]? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// The Availability Zone.
        public var availabilityZone: String? = nil
        /// The status of the network interface.
        public var status: String? = nil
        /// Indicates whether the network interface is being managed by AWS.
        public var requesterManaged: Bool? = nil
        /// The IPv6 addresses associated with the network interface.
        public var ipv6Addresses: [NetworkInterfaceIpv6Address]? = nil
        /// Any security groups for the network interface.
        public var groups: [GroupIdentifier]? = nil
        /// The association information for an Elastic IP address (IPv4) associated with the network interface.
        public var association: NetworkInterfaceAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, networkInterfaceId: String? = nil, macAddress: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, attachment: NetworkInterfaceAttachment? = nil, interfaceType: String? = nil, tagSet: [Tag]? = nil, privateIpAddress: String? = nil, requesterId: String? = nil, description: String? = nil, ownerId: String? = nil, privateIpAddresses: [NetworkInterfacePrivateIpAddress]? = nil, vpcId: String? = nil, availabilityZone: String? = nil, status: String? = nil, requesterManaged: Bool? = nil, ipv6Addresses: [NetworkInterfaceIpv6Address]? = nil, groups: [GroupIdentifier]? = nil, association: NetworkInterfaceAssociation? = nil) {
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.macAddress = macAddress
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.attachment = attachment
            self.interfaceType = interfaceType
            self.tagSet = tagSet
            self.privateIpAddress = privateIpAddress
            self.requesterId = requesterId
            self.description = description
            self.ownerId = ownerId
            self.privateIpAddresses = privateIpAddresses
            self.vpcId = vpcId
            self.availabilityZone = availabilityZone
            self.status = status
            self.requesterManaged = requesterManaged
            self.ipv6Addresses = ipv6Addresses
            self.groups = groups
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.macAddress = dictionary["MacAddress"] as? String
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? Bool
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.NetworkInterfaceAttachment(dictionary: attachment) }
            self.interfaceType = dictionary["InterfaceType"] as? String
            if let tagSet = dictionary["TagSet"] as? [[String: Any]] {
                self.tagSet = try tagSet.map({ try Tag(dictionary: $0) })
            }
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.requesterId = dictionary["RequesterId"] as? String
            self.description = dictionary["Description"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [[String: Any]] {
                self.privateIpAddresses = try privateIpAddresses.map({ try NetworkInterfacePrivateIpAddress(dictionary: $0) })
            }
            self.vpcId = dictionary["VpcId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.status = dictionary["Status"] as? String
            self.requesterManaged = dictionary["RequesterManaged"] as? Bool
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [[String: Any]] {
                self.ipv6Addresses = try ipv6Addresses.map({ try NetworkInterfaceIpv6Address(dictionary: $0) })
            }
            if let groups = dictionary["Groups"] as? [[String: Any]] {
                self.groups = try groups.map({ try GroupIdentifier(dictionary: $0) })
            }
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.NetworkInterfaceAssociation(dictionary: association) }
        }
    }

    public struct Subnet: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether instances launched in this subnet receive a public IPv4 address.
        public var mapPublicIpOnLaunch: Bool? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// Indicates whether this is the default subnet for the Availability Zone.
        public var defaultForAz: Bool? = nil
        /// The ID of the VPC the subnet is in.
        public var vpcId: String? = nil
        /// The current state of the subnet.
        public var state: String? = nil
        /// Any tags assigned to the subnet.
        public var tags: [Tag]? = nil
        /// Indicates whether a network interface created in this subnet (including a network interface created by RunInstances) receives an IPv6 address.
        public var assignIpv6AddressOnCreation: Bool? = nil
        /// Information about the IPv6 CIDR blocks associated with the subnet.
        public var ipv6CidrBlockAssociationSet: [SubnetIpv6CidrBlockAssociation]? = nil
        /// The number of unused private IPv4 addresses in the subnet. Note that the IPv4 addresses for any stopped instances are considered unavailable.
        public var availableIpAddressCount: Int32? = nil
        /// The Availability Zone of the subnet.
        public var availabilityZone: String? = nil
        /// The IPv4 CIDR block assigned to the subnet.
        public var cidrBlock: String? = nil

        public init() {}

        public init(mapPublicIpOnLaunch: Bool? = nil, subnetId: String? = nil, defaultForAz: Bool? = nil, vpcId: String? = nil, state: String? = nil, tags: [Tag]? = nil, assignIpv6AddressOnCreation: Bool? = nil, ipv6CidrBlockAssociationSet: [SubnetIpv6CidrBlockAssociation]? = nil, availableIpAddressCount: Int32? = nil, availabilityZone: String? = nil, cidrBlock: String? = nil) {
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.subnetId = subnetId
            self.defaultForAz = defaultForAz
            self.vpcId = vpcId
            self.state = state
            self.tags = tags
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.availableIpAddressCount = availableIpAddressCount
            self.availabilityZone = availabilityZone
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.mapPublicIpOnLaunch = dictionary["MapPublicIpOnLaunch"] as? Bool
            self.subnetId = dictionary["SubnetId"] as? String
            self.defaultForAz = dictionary["DefaultForAz"] as? Bool
            self.vpcId = dictionary["VpcId"] as? String
            self.state = dictionary["State"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.assignIpv6AddressOnCreation = dictionary["AssignIpv6AddressOnCreation"] as? Bool
            if let ipv6CidrBlockAssociationSet = dictionary["Ipv6CidrBlockAssociationSet"] as? [[String: Any]] {
                self.ipv6CidrBlockAssociationSet = try ipv6CidrBlockAssociationSet.map({ try SubnetIpv6CidrBlockAssociation(dictionary: $0) })
            }
            self.availableIpAddressCount = dictionary["AvailableIpAddressCount"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.cidrBlock = dictionary["CidrBlock"] as? String
        }
    }

    public struct CancelSpotInstanceRequestsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Spot instance requests.
        public var cancelledSpotInstanceRequests: [CancelledSpotInstanceRequest]? = nil

        public init() {}

        public init(cancelledSpotInstanceRequests: [CancelledSpotInstanceRequest]? = nil) {
            self.cancelledSpotInstanceRequests = cancelledSpotInstanceRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let cancelledSpotInstanceRequests = dictionary["CancelledSpotInstanceRequests"] as? [[String: Any]] {
                self.cancelledSpotInstanceRequests = try cancelledSpotInstanceRequests.map({ try CancelledSpotInstanceRequest(dictionary: $0) })
            }
        }
    }

    public struct EnableVolumeIORequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the volume.
        public var volumeId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(volumeId: String, dryRun: Bool? = nil) {
            self.volumeId = volumeId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct AssociateSubnetCidrBlockResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// Information about the IPv6 CIDR block association.
        public var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil) {
            self.subnetId = subnetId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.SubnetIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) }
        }
    }

    public struct EventInformation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The event. The following are the error events.    iamFleetRoleInvalid - The Spot fleet did not have the required permissions either to launch or terminate an instance.    launchSpecTemporarilyBlacklisted - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.    spotFleetRequestConfigurationInvalid - The configuration is not valid. For more information, see the description of the event.    spotInstanceCountLimitExceeded - You've reached the limit on the number of Spot instances that you can launch.   The following are the fleetRequestChange events.    active - The Spot fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot instances.    cancelled - The Spot fleet is canceled and has no running Spot instances. The Spot fleet will be deleted two days after its instances were terminated.    cancelled_running - The Spot fleet is canceled and will not launch additional Spot instances, but its existing Spot instances continue to run until they are interrupted or terminated.    cancelled_terminating - The Spot fleet is canceled and its Spot instances are terminating.    expired - The Spot fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with TerminateInstancesWithExpiration set.    modify_in_progress - A request to modify the Spot fleet request was accepted and is in progress.    modify_successful - The Spot fleet request was modified.    price_update - The bid price for a launch configuration was adjusted because it was too high. This change is permanent.    submitted - The Spot fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot instances.   The following are the instanceChange events.    launched - A bid was fulfilled and a new instance was launched.    terminated - An instance was terminated by the user.  
        public var eventSubType: String? = nil
        /// The ID of the instance. This information is available only for instanceChange events.
        public var instanceId: String? = nil
        /// The description of the event.
        public var eventDescription: String? = nil

        public init() {}

        public init(eventSubType: String? = nil, instanceId: String? = nil, eventDescription: String? = nil) {
            self.eventSubType = eventSubType
            self.instanceId = instanceId
            self.eventDescription = eventDescription
        }

        public init(dictionary: [String: Any]) throws {
            self.eventSubType = dictionary["EventSubType"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.eventDescription = dictionary["EventDescription"] as? String
        }
    }

    public struct DescribeSubnetsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more subnet IDs. Default: Describes all your subnets.
        public var subnetIds: [String]? = nil
        /// One or more filters.    availabilityZone - The Availability Zone for the subnet. You can also use availability-zone as the filter name.    available-ip-address-count - The number of IPv4 addresses in the subnet that are available.    cidrBlock - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use cidr or cidr-block as the filter names.    defaultForAz - Indicates whether this is the default subnet for the Availability Zone. You can also use default-for-az as the filter name.    ipv6-cidr-block-association.ipv6-cidr-block - An IPv6 CIDR block associated with the subnet.    ipv6-cidr-block-association.association-id - An association ID for an IPv6 CIDR block associated with the subnet.    ipv6-cidr-block-association.state - The state of an IPv6 CIDR block associated with the subnet.    state - The state of the subnet (pending | available).    subnet-id - The ID of the subnet.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the subnet.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(subnetIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.subnetIds = subnetIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let subnetIds = dictionary["SubnetIds"] as? [String] {
                self.subnetIds = subnetIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeTagsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return..
        public var nextToken: String? = nil
        /// A list of tags.
        public var tags: [TagDescription]? = nil

        public init() {}

        public init(nextToken: String? = nil, tags: [TagDescription]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try TagDescription(dictionary: $0) })
            }
        }
    }

    public struct AcceptReservedInstancesExchangeQuoteResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the successful exchange.
        public var exchangeId: String? = nil

        public init() {}

        public init(exchangeId: String? = nil) {
            self.exchangeId = exchangeId
        }

        public init(dictionary: [String: Any]) throws {
            self.exchangeId = dictionary["ExchangeId"] as? String
        }
    }

    public struct DescribeNatGatewaysRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    nat-gateway-id - The ID of the NAT gateway.    state - The state of the NAT gateway (pending | failed | available | deleting | deleted).    subnet-id - The ID of the subnet in which the NAT gateway resides.    vpc-id - The ID of the VPC in which the NAT gateway resides.  
        public var filter: [Filter]? = nil
        /// One or more NAT gateway IDs.
        public var natGatewayIds: [String]? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value specified is greater than 1000, we return only 1000 items.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filter: [Filter]? = nil, natGatewayIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.natGatewayIds = natGatewayIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [[String: Any]] {
                self.filter = try filter.map({ try Filter(dictionary: $0) })
            }
            if let natGatewayIds = dictionary["NatGatewayIds"] as? [String] {
                self.natGatewayIds = natGatewayIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct NetworkInterfacePrivateIpAddress: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The private IPv4 address.
        public var privateIpAddress: String? = nil
        /// The private DNS name.
        public var privateDnsName: String? = nil
        /// Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.
        public var primary: Bool? = nil
        /// The association information for an Elastic IP address (IPv4) associated with the network interface.
        public var association: NetworkInterfaceAssociation? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, privateDnsName: String? = nil, primary: Bool? = nil, association: NetworkInterfaceAssociation? = nil) {
            self.privateIpAddress = privateIpAddress
            self.privateDnsName = privateDnsName
            self.primary = primary
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.primary = dictionary["Primary"] as? Bool
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.NetworkInterfaceAssociation(dictionary: association) }
        }
    }

    public struct DescribeNetworkAclsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more network ACLs.
        public var networkAcls: [NetworkAcl]? = nil

        public init() {}

        public init(networkAcls: [NetworkAcl]? = nil) {
            self.networkAcls = networkAcls
        }

        public init(dictionary: [String: Any]) throws {
            if let networkAcls = dictionary["NetworkAcls"] as? [[String: Any]] {
                self.networkAcls = try networkAcls.map({ try NetworkAcl(dictionary: $0) })
            }
        }
    }

    public struct ReservedInstancesListing: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the Reserved Instance listing.
        public var status: String? = nil
        /// The price of the Reserved Instance listing.
        public var priceSchedules: [PriceSchedule]? = nil
        /// The ID of the Reserved Instance listing.
        public var reservedInstancesListingId: String? = nil
        /// A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see Ensuring Idempotency.
        public var clientToken: String? = nil
        /// Any tags assigned to the resource.
        public var tags: [Tag]? = nil
        /// The last modified timestamp of the listing.
        public var updateDate: Date? = nil
        /// The ID of the Reserved Instance.
        public var reservedInstancesId: String? = nil
        /// The time the listing was created.
        public var createDate: Date? = nil
        /// The reason for the current status of the Reserved Instance listing. The response can be blank.
        public var statusMessage: String? = nil
        /// The number of instances in this state.
        public var instanceCounts: [InstanceCount]? = nil

        public init() {}

        public init(status: String? = nil, priceSchedules: [PriceSchedule]? = nil, reservedInstancesListingId: String? = nil, clientToken: String? = nil, tags: [Tag]? = nil, updateDate: Date? = nil, reservedInstancesId: String? = nil, createDate: Date? = nil, statusMessage: String? = nil, instanceCounts: [InstanceCount]? = nil) {
            self.status = status
            self.priceSchedules = priceSchedules
            self.reservedInstancesListingId = reservedInstancesListingId
            self.clientToken = clientToken
            self.tags = tags
            self.updateDate = updateDate
            self.reservedInstancesId = reservedInstancesId
            self.createDate = createDate
            self.statusMessage = statusMessage
            self.instanceCounts = instanceCounts
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            if let priceSchedules = dictionary["PriceSchedules"] as? [[String: Any]] {
                self.priceSchedules = try priceSchedules.map({ try PriceSchedule(dictionary: $0) })
            }
            self.reservedInstancesListingId = dictionary["ReservedInstancesListingId"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.updateDate = dictionary["UpdateDate"] as? Date
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            self.createDate = dictionary["CreateDate"] as? Date
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let instanceCounts = dictionary["InstanceCounts"] as? [[String: Any]] {
                self.instanceCounts = try instanceCounts.map({ try InstanceCount(dictionary: $0) })
            }
        }
    }

    public struct DeleteNetworkAclRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the network ACL.
        public var networkAclId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, networkAclId: String) {
            self.dryRun = dryRun
            self.networkAclId = networkAclId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
        }
    }

    public struct AllocateHostsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID. Default: Enabled
        public var autoPlacement: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide. 
        public var clientToken: String? = nil
        /// Specify the instance type that you want your Dedicated Hosts to be configured for. When you specify the instance type, that is the only instance type that you can launch onto that host.
        public var instanceType: String = ""
        /// The Availability Zone for the Dedicated Hosts.
        public var availabilityZone: String = ""
        /// The number of Dedicated Hosts you want to allocate to your account with these parameters.
        public var quantity: Int32 = 0

        public init() {}

        public init(autoPlacement: String? = nil, clientToken: String? = nil, instanceType: String, availabilityZone: String, quantity: Int32) {
            self.autoPlacement = autoPlacement
            self.clientToken = clientToken
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.quantity = quantity
        }

        public init(dictionary: [String: Any]) throws {
            self.autoPlacement = dictionary["AutoPlacement"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            guard let instanceType = dictionary["InstanceType"] as? String else { throw InitializableError.missingRequiredParam("InstanceType") }
            self.instanceType = instanceType
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            guard let quantity = dictionary["Quantity"] as? Int32 else { throw InitializableError.missingRequiredParam("Quantity") }
            self.quantity = quantity
        }
    }

    public struct DescribeVpcEndpointServicesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value is greater than 1000, we return only 1000 items.
        public var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct UnassignIpv6AddressesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 addresses to unassign from the network interface.
        public var ipv6Addresses: [String] = []
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""

        public init() {}

        public init(ipv6Addresses: [String], networkInterfaceId: String) {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let ipv6Addresses = dictionary["Ipv6Addresses"] as? [String] else { throw InitializableError.missingRequiredParam("Ipv6Addresses") }
            self.ipv6Addresses = ipv6Addresses
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
        }
    }

    public struct BundleInstanceResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the bundle task.
        public var bundleTask: BundleTask? = nil

        public init() {}

        public init(bundleTask: BundleTask? = nil) {
            self.bundleTask = bundleTask
        }

        public init(dictionary: [String: Any]) throws {
            if let bundleTask = dictionary["BundleTask"] as? [String: Any] { self.bundleTask = try Ec2.BundleTask(dictionary: bundleTask) }
        }
    }

    public struct DeletePlacementGroupRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The name of the placement group.
        public var groupName: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, groupName: String) {
            self.dryRun = dryRun
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let groupName = dictionary["GroupName"] as? String else { throw InitializableError.missingRequiredParam("GroupName") }
            self.groupName = groupName
        }
    }

    public struct PrefixListId: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the prefix.
        public var prefixListId: String? = nil

        public init() {}

        public init(prefixListId: String? = nil) {
            self.prefixListId = prefixListId
        }

        public init(dictionary: [String: Any]) throws {
            self.prefixListId = dictionary["PrefixListId"] as? String
        }
    }

    public struct PeeringConnectionOptionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.
        public var allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil
        /// If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        public var allowDnsResolutionFromRemoteVpc: Bool? = nil
        /// If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.
        public var allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil

        public init() {}

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

        public init(dictionary: [String: Any]) throws {
            self.allowEgressFromLocalVpcToRemoteClassicLink = dictionary["AllowEgressFromLocalVpcToRemoteClassicLink"] as? Bool
            self.allowDnsResolutionFromRemoteVpc = dictionary["AllowDnsResolutionFromRemoteVpc"] as? Bool
            self.allowEgressFromLocalClassicLinkToRemoteVpc = dictionary["AllowEgressFromLocalClassicLinkToRemoteVpc"] as? Bool
        }
    }

    public struct AccountAttributeValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The value of the attribute.
        public var attributeValue: String? = nil

        public init() {}

        public init(attributeValue: String? = nil) {
            self.attributeValue = attributeValue
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeValue = dictionary["AttributeValue"] as? String
        }
    }

    public struct PurchaseScheduledInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more purchase requests.
        public var purchaseRequests: [PurchaseRequest] = []
        /// Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see Ensuring Idempotency.
        public var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(purchaseRequests: [PurchaseRequest], clientToken: String? = nil, dryRun: Bool? = nil) {
            self.purchaseRequests = purchaseRequests
            self.clientToken = clientToken
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let purchaseRequests = dictionary["PurchaseRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("PurchaseRequests") }
            self.purchaseRequests = try purchaseRequests.map({ try PurchaseRequest(dictionary: $0) })
            self.clientToken = dictionary["ClientToken"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeHostReservationOfferingsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// This is the maximum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.
        public var maxDuration: Int32? = nil
        /// This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.
        public var minDuration: Int32? = nil
        /// One or more filters.    instance-family - The instance family of the offering (e.g., m4).    payment-option - The payment option (NoUpfront | PartialUpfront | AllUpfront).  
        public var filter: [Filter]? = nil
        /// The token to use to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The ID of the reservation offering.
        public var offeringId: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error.
        public var maxResults: Int32? = nil

        public init() {}

        public init(maxDuration: Int32? = nil, minDuration: Int32? = nil, filter: [Filter]? = nil, nextToken: String? = nil, offeringId: String? = nil, maxResults: Int32? = nil) {
            self.maxDuration = maxDuration
            self.minDuration = minDuration
            self.filter = filter
            self.nextToken = nextToken
            self.offeringId = offeringId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.maxDuration = dictionary["MaxDuration"] as? Int32
            self.minDuration = dictionary["MinDuration"] as? Int32
            if let filter = dictionary["Filter"] as? [[String: Any]] {
                self.filter = try filter.map({ try Filter(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.offeringId = dictionary["OfferingId"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct StopInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more stopped instances.
        public var stoppingInstances: [InstanceStateChange]? = nil

        public init() {}

        public init(stoppingInstances: [InstanceStateChange]? = nil) {
            self.stoppingInstances = stoppingInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let stoppingInstances = dictionary["StoppingInstances"] as? [[String: Any]] {
                self.stoppingInstances = try stoppingInstances.map({ try InstanceStateChange(dictionary: $0) })
            }
        }
    }

    public struct DescribeScheduledInstanceAvailabilityRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time period for the first schedule to start.
        public var firstSlotStartTimeRange: SlotDateTimeRangeRequest = SlotDateTimeRangeRequest()
        /// The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.
        public var minSlotDurationInHours: Int32? = nil
        /// The maximum available duration, in hours. This value must be greater than MinSlotDurationInHours and less than 1,720.
        public var maxSlotDurationInHours: Int32? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    availability-zone - The Availability Zone (for example, us-west-2a).    instance-type - The instance type (for example, c4.large).    network-platform - The network platform (EC2-Classic or EC2-VPC).    platform - The platform (Linux/UNIX or Windows).  
        public var filters: [Filter]? = nil
        /// The token for the next set of results.
        public var nextToken: String? = nil
        /// The schedule recurrence.
        public var recurrence: ScheduledInstanceRecurrenceRequest = ScheduledInstanceRecurrenceRequest()
        /// The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(firstSlotStartTimeRange: SlotDateTimeRangeRequest, minSlotDurationInHours: Int32? = nil, maxSlotDurationInHours: Int32? = nil, dryRun: Bool? = nil, filters: [Filter]? = nil, nextToken: String? = nil, recurrence: ScheduledInstanceRecurrenceRequest, maxResults: Int32? = nil) {
            self.firstSlotStartTimeRange = firstSlotStartTimeRange
            self.minSlotDurationInHours = minSlotDurationInHours
            self.maxSlotDurationInHours = maxSlotDurationInHours
            self.dryRun = dryRun
            self.filters = filters
            self.nextToken = nextToken
            self.recurrence = recurrence
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let firstSlotStartTimeRange = dictionary["FirstSlotStartTimeRange"] as? [String: Any] else { throw InitializableError.missingRequiredParam("FirstSlotStartTimeRange") }
            self.firstSlotStartTimeRange = try Ec2.SlotDateTimeRangeRequest(dictionary: firstSlotStartTimeRange)
            self.minSlotDurationInHours = dictionary["MinSlotDurationInHours"] as? Int32
            self.maxSlotDurationInHours = dictionary["MaxSlotDurationInHours"] as? Int32
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            guard let recurrence = dictionary["Recurrence"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Recurrence") }
            self.recurrence = try Ec2.ScheduledInstanceRecurrenceRequest(dictionary: recurrence)
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ReservedInstancesModificationResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.
        public var reservedInstancesId: String? = nil
        /// The target Reserved Instances configurations supplied as part of the modification request.
        public var targetConfiguration: ReservedInstancesConfiguration? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil, targetConfiguration: ReservedInstancesConfiguration? = nil) {
            self.reservedInstancesId = reservedInstancesId
            self.targetConfiguration = targetConfiguration
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            if let targetConfiguration = dictionary["TargetConfiguration"] as? [String: Any] { self.targetConfiguration = try Ec2.ReservedInstancesConfiguration(dictionary: targetConfiguration) }
        }
    }

    public struct EnableVpcClassicLinkDnsSupportResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ImportVolumeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The disk image.
        public var image: DiskImageDetail = DiskImageDetail()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The volume size.
        public var volume: VolumeDetail = VolumeDetail()
        /// The Availability Zone for the resulting EBS volume.
        public var availabilityZone: String = ""
        /// A description of the volume.
        public var description: String? = nil

        public init() {}

        public init(image: DiskImageDetail, dryRun: Bool? = nil, volume: VolumeDetail, availabilityZone: String, description: String? = nil) {
            self.image = image
            self.dryRun = dryRun
            self.volume = volume
            self.availabilityZone = availabilityZone
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Ec2.DiskImageDetail(dictionary: image)
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let volume = dictionary["Volume"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volume") }
            self.volume = try Ec2.VolumeDetail(dictionary: volume)
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeAddressesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-Classic] One or more Elastic IP addresses. Default: Describes all your Elastic IP addresses.
        public var publicIps: [String]? = nil
        /// [EC2-VPC] One or more allocation IDs. Default: Describes all your Elastic IP addresses.
        public var allocationIds: [String]? = nil
        /// One or more filters. Filter names and values are case-sensitive.    allocation-id - [EC2-VPC] The allocation ID for the address.    association-id - [EC2-VPC] The association ID for the address.    domain - Indicates whether the address is for use in EC2-Classic (standard) or in a VPC (vpc).    instance-id - The ID of the instance the address is associated with, if any.    network-interface-id - [EC2-VPC] The ID of the network interface that the address is associated with, if any.    network-interface-owner-id - The AWS account ID of the owner.    private-ip-address - [EC2-VPC] The private IP address associated with the Elastic IP address.    public-ip - The Elastic IP address.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(publicIps: [String]? = nil, allocationIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.publicIps = publicIps
            self.allocationIds = allocationIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let publicIps = dictionary["PublicIps"] as? [String] {
                self.publicIps = publicIps
            }
            if let allocationIds = dictionary["AllocationIds"] as? [String] {
                self.allocationIds = allocationIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct Ipv6CidrBlock: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 CIDR block.
        public var ipv6CidrBlock: String? = nil

        public init() {}

        public init(ipv6CidrBlock: String? = nil) {
            self.ipv6CidrBlock = ipv6CidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
        }
    }

    public struct SecurityGroup: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-VPC] One or more outbound rules associated with the security group.
        public var ipPermissionsEgress: [IpPermission]? = nil
        /// The name of the security group.
        public var groupName: String? = nil
        /// [EC2-VPC] The ID of the VPC for the security group.
        public var vpcId: String? = nil
        /// One or more inbound rules associated with the security group.
        public var ipPermissions: [IpPermission]? = nil
        /// Any tags assigned to the security group.
        public var tags: [Tag]? = nil
        /// The AWS account ID of the owner of the security group.
        public var ownerId: String? = nil
        /// The ID of the security group.
        public var groupId: String? = nil
        /// A description of the security group.
        public var description: String? = nil

        public init() {}

        public init(ipPermissionsEgress: [IpPermission]? = nil, groupName: String? = nil, vpcId: String? = nil, ipPermissions: [IpPermission]? = nil, tags: [Tag]? = nil, ownerId: String? = nil, groupId: String? = nil, description: String? = nil) {
            self.ipPermissionsEgress = ipPermissionsEgress
            self.groupName = groupName
            self.vpcId = vpcId
            self.ipPermissions = ipPermissions
            self.tags = tags
            self.ownerId = ownerId
            self.groupId = groupId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let ipPermissionsEgress = dictionary["IpPermissionsEgress"] as? [[String: Any]] {
                self.ipPermissionsEgress = try ipPermissionsEgress.map({ try IpPermission(dictionary: $0) })
            }
            self.groupName = dictionary["GroupName"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [[String: Any]] {
                self.ipPermissions = try ipPermissions.map({ try IpPermission(dictionary: $0) })
            }
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.ownerId = dictionary["OwnerId"] as? String
            self.groupId = dictionary["GroupId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeAccountAttributesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more account attributes.
        public var accountAttributes: [AccountAttribute]? = nil

        public init() {}

        public init(accountAttributes: [AccountAttribute]? = nil) {
            self.accountAttributes = accountAttributes
        }

        public init(dictionary: [String: Any]) throws {
            if let accountAttributes = dictionary["AccountAttributes"] as? [[String: Any]] {
                self.accountAttributes = try accountAttributes.map({ try AccountAttribute(dictionary: $0) })
            }
        }
    }

    public struct ReplaceRouteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [IPv4 traffic only] The ID of a NAT gateway.
        public var natGatewayId: String? = nil
        /// The ID of a network interface.
        public var networkInterfaceId: String? = nil
        /// The ID of a NAT instance in your VPC.
        public var instanceId: String? = nil
        /// The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.
        public var destinationIpv6CidrBlock: String? = nil
        /// The ID of a VPC peering connection.
        public var vpcPeeringConnectionId: String? = nil
        /// The ID of the route table.
        public var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// [IPv6 traffic only] The ID of an egress-only Internet gateway.
        public var egressOnlyInternetGatewayId: String? = nil
        /// The ID of an Internet gateway or virtual private gateway.
        public var gatewayId: String? = nil
        /// The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.
        public var destinationCidrBlock: String? = nil

        public init() {}

        public init(natGatewayId: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, destinationIpv6CidrBlock: String? = nil, vpcPeeringConnectionId: String? = nil, routeTableId: String, dryRun: Bool? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            self.gatewayId = dictionary["GatewayId"] as? String
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
        }
    }

    public struct CreateRouteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [IPv4 traffic only] The ID of a NAT gateway.
        public var natGatewayId: String? = nil
        /// The ID of a network interface.
        public var networkInterfaceId: String? = nil
        /// The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        public var instanceId: String? = nil
        /// The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.
        public var destinationIpv6CidrBlock: String? = nil
        /// The ID of a VPC peering connection.
        public var vpcPeeringConnectionId: String? = nil
        /// The ID of the route table for the route.
        public var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// [IPv6 traffic only] The ID of an egress-only Internet gateway.
        public var egressOnlyInternetGatewayId: String? = nil
        /// The ID of an Internet gateway or virtual private gateway attached to your VPC.
        public var gatewayId: String? = nil
        /// The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.
        public var destinationCidrBlock: String? = nil

        public init() {}

        public init(natGatewayId: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, destinationIpv6CidrBlock: String? = nil, vpcPeeringConnectionId: String? = nil, routeTableId: String, dryRun: Bool? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            self.gatewayId = dictionary["GatewayId"] as? String
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
        }
    }

    public struct DeleteVpnConnectionRouteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPN connection.
        public var vpnConnectionId: String = ""
        /// The CIDR block associated with the local subnet of the customer network.
        public var destinationCidrBlock: String = ""

        public init() {}

        public init(vpnConnectionId: String, destinationCidrBlock: String) {
            self.vpnConnectionId = vpnConnectionId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpnConnectionId = dictionary["VpnConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpnConnectionId") }
            self.vpnConnectionId = vpnConnectionId
            guard let destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String else { throw InitializableError.missingRequiredParam("DestinationCidrBlock") }
            self.destinationCidrBlock = destinationCidrBlock
        }
    }

    public struct KeyPairInfo: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the key pair.
        public var keyName: String? = nil
        /// If you used CreateKeyPair to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used ImportKeyPair to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.
        public var keyFingerprint: String? = nil

        public init() {}

        public init(keyName: String? = nil, keyFingerprint: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? String
            self.keyFingerprint = dictionary["KeyFingerprint"] as? String
        }
    }

    public struct VolumeAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time stamp when the attachment initiated.
        public var attachTime: Date? = nil
        /// Indicates whether the EBS volume is deleted on instance termination.
        public var deleteOnTermination: Bool? = nil
        /// The device name.
        public var device: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The ID of the volume.
        public var volumeId: String? = nil
        /// The attachment state of the volume.
        public var state: String? = nil

        public init() {}

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, device: String? = nil, instanceId: String? = nil, volumeId: String? = nil, state: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.device = device
            self.instanceId = instanceId
            self.volumeId = volumeId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.device = dictionary["Device"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
            self.state = dictionary["State"] as? String
        }
    }

    public struct ImportSnapshotTask: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A description of the import snapshot task.
        public var description: String? = nil
        /// Describes an import snapshot task.
        public var snapshotTaskDetail: SnapshotTaskDetail? = nil
        /// The ID of the import snapshot task.
        public var importTaskId: String? = nil

        public init() {}

        public init(description: String? = nil, snapshotTaskDetail: SnapshotTaskDetail? = nil, importTaskId: String? = nil) {
            self.description = description
            self.snapshotTaskDetail = snapshotTaskDetail
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            if let snapshotTaskDetail = dictionary["SnapshotTaskDetail"] as? [String: Any] { self.snapshotTaskDetail = try Ec2.SnapshotTaskDetail(dictionary: snapshotTaskDetail) }
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct CreateNatGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The subnet in which to create the NAT gateway.
        public var subnetId: String = ""
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency. Constraint: Maximum 64 ASCII characters.
        public var clientToken: String? = nil
        /// The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.
        public var allocationId: String = ""

        public init() {}

        public init(subnetId: String, clientToken: String? = nil, allocationId: String) {
            self.subnetId = subnetId
            self.clientToken = clientToken
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            self.clientToken = dictionary["ClientToken"] as? String
            guard let allocationId = dictionary["AllocationId"] as? String else { throw InitializableError.missingRequiredParam("AllocationId") }
            self.allocationId = allocationId
        }
    }

    public struct AttachVpnGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the attachment.
        public var vpcAttachment: VpcAttachment? = nil

        public init() {}

        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcAttachment = dictionary["VpcAttachment"] as? [String: Any] { self.vpcAttachment = try Ec2.VpcAttachment(dictionary: vpcAttachment) }
        }
    }

    public struct RequestSpotInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360). The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates. Note that you can't specify an Availability Zone group or a launch group if you specify a duration.
        public var blockDurationMinutes: Int32? = nil
        /// The user-specified name for a logical grouping of bids. When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active. If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group. Default: Instances are launched in any available Availability Zone.
        public var availabilityZoneGroup: String? = nil
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        public var clientToken: String? = nil
        public var launchSpecification: RequestSpotLaunchSpecification? = nil
        /// The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled. Default: The request is effective indefinitely.
        public var validFrom: Date? = nil
        /// The maximum hourly price (bid) for any Spot instance launched to fulfill the request.
        public var spotPrice: String = ""
        /// The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. Default: The request is effective indefinitely.
        public var validUntil: Date? = nil
        /// The Spot instance request type. Default: one-time 
        public var type: String? = nil
        /// The maximum number of Spot instances to launch. Default: 1
        public var instanceCount: Int32? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The instance launch group. Launch groups are Spot instances that launch together and terminate together. Default: Instances are launched and terminated individually
        public var launchGroup: String? = nil

        public init() {}

        public init(blockDurationMinutes: Int32? = nil, availabilityZoneGroup: String? = nil, clientToken: String? = nil, launchSpecification: RequestSpotLaunchSpecification? = nil, validFrom: Date? = nil, spotPrice: String, validUntil: Date? = nil, type: String? = nil, instanceCount: Int32? = nil, dryRun: Bool? = nil, launchGroup: String? = nil) {
            self.blockDurationMinutes = blockDurationMinutes
            self.availabilityZoneGroup = availabilityZoneGroup
            self.clientToken = clientToken
            self.launchSpecification = launchSpecification
            self.validFrom = validFrom
            self.spotPrice = spotPrice
            self.validUntil = validUntil
            self.type = type
            self.instanceCount = instanceCount
            self.dryRun = dryRun
            self.launchGroup = launchGroup
        }

        public init(dictionary: [String: Any]) throws {
            self.blockDurationMinutes = dictionary["BlockDurationMinutes"] as? Int32
            self.availabilityZoneGroup = dictionary["AvailabilityZoneGroup"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            if let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] { self.launchSpecification = try Ec2.RequestSpotLaunchSpecification(dictionary: launchSpecification) }
            self.validFrom = dictionary["ValidFrom"] as? Date
            guard let spotPrice = dictionary["SpotPrice"] as? String else { throw InitializableError.missingRequiredParam("SpotPrice") }
            self.spotPrice = spotPrice
            self.validUntil = dictionary["ValidUntil"] as? Date
            self.type = dictionary["Type"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.dryRun = dictionary["DryRun"] as? Bool
            self.launchGroup = dictionary["LaunchGroup"] as? String
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    architecture - The image architecture (i386 | x86_64).    block-device-mapping.delete-on-termination - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.    block-device-mapping.device-name - The device name for the EBS volume (for example, /dev/sdh).    block-device-mapping.snapshot-id - The ID of the snapshot used for the EBS volume.    block-device-mapping.volume-size - The volume size of the EBS volume, in GiB.    block-device-mapping.volume-type - The volume type of the EBS volume (gp2 | io1 | st1 | sc1 | standard).    description - The description of the image (provided during image creation).    ena-support - A Boolean that indicates whether enhanced networking with ENA is enabled.    hypervisor - The hypervisor type (ovm | xen).    image-id - The ID of the image.    image-type - The image type (machine | kernel | ramdisk).    is-public - A Boolean that indicates whether the image is public.    kernel-id - The kernel ID.    manifest-location - The location of the image manifest.    name - The name of the AMI (provided during image creation).    owner-alias - String value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.    owner-id - The AWS account ID of the image owner.    platform - The platform. To only list Windows-based AMIs, use windows.    product-code - The product code.    product-code.type - The type of the product code (devpay | marketplace).    ramdisk-id - The RAM disk ID.    root-device-name - The name of the root device volume (for example, /dev/sda1).    root-device-type - The type of the root device volume (ebs | instance-store).    state - The state of the image (available | pending | failed).    state-reason-code - The reason code for the state change.    state-reason-message - The message for the state change.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    virtualization-type - The virtualization type (paravirtual | hvm).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Scopes the images by users with explicit launch permissions. Specify an AWS account ID, self (the sender of the request), or all (public AMIs).
        public var executableUsers: [String]? = nil
        /// One or more image IDs. Default: Describes all images available to you.
        public var imageIds: [String]? = nil
        /// Filters the images by the owner. Specify an AWS account ID, self (owner is the sender of the request), or an AWS owner alias (valid values are amazon | aws-marketplace | microsoft). Omitting this option returns all images for which you have launch permissions, regardless of ownership.
        public var owners: [String]? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, executableUsers: [String]? = nil, imageIds: [String]? = nil, owners: [String]? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.executableUsers = executableUsers
            self.imageIds = imageIds
            self.owners = owners
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let executableUsers = dictionary["ExecutableUsers"] as? [String] {
                self.executableUsers = executableUsers
            }
            if let imageIds = dictionary["ImageIds"] as? [String] {
                self.imageIds = imageIds
            }
            if let owners = dictionary["Owners"] as? [String] {
                self.owners = owners
            }
        }
    }

    public struct HostOffering: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upfront price of the offering. Does not apply to No Upfront offerings.
        public var upfrontPrice: String? = nil
        /// The available payment option.
        public var paymentOption: String? = nil
        /// The ID of the offering.
        public var offeringId: String? = nil
        /// The hourly price of the offering.
        public var hourlyPrice: String? = nil
        /// The currency of the offering.
        public var currencyCode: String? = nil
        /// The duration of the offering (in seconds).
        public var duration: Int32? = nil
        /// The instance family of the offering.
        public var instanceFamily: String? = nil

        public init() {}

        public init(upfrontPrice: String? = nil, paymentOption: String? = nil, offeringId: String? = nil, hourlyPrice: String? = nil, currencyCode: String? = nil, duration: Int32? = nil, instanceFamily: String? = nil) {
            self.upfrontPrice = upfrontPrice
            self.paymentOption = paymentOption
            self.offeringId = offeringId
            self.hourlyPrice = hourlyPrice
            self.currencyCode = currencyCode
            self.duration = duration
            self.instanceFamily = instanceFamily
        }

        public init(dictionary: [String: Any]) throws {
            self.upfrontPrice = dictionary["UpfrontPrice"] as? String
            self.paymentOption = dictionary["PaymentOption"] as? String
            self.offeringId = dictionary["OfferingId"] as? String
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.duration = dictionary["Duration"] as? Int32
            self.instanceFamily = dictionary["InstanceFamily"] as? String
        }
    }

    public struct InstanceNetworkInterfaceSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a RunInstances request, you must provide the device index.
        public var deviceIndex: Int32? = nil
        /// The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.
        public var subnetId: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The description of the network interface. Applies only if creating a network interface when launching an instance.
        public var description: String? = nil
        /// The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        public var privateIpAddress: String? = nil
        /// The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        public var secondaryPrivateIpAddressCount: Int32? = nil
        /// One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        public var privateIpAddresses: [PrivateIpAddressSpecification]? = nil
        /// A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        public var ipv6AddressCount: Int32? = nil
        /// One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        public var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// If set to true, the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance.
        public var deleteOnTermination: Bool? = nil
        /// Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
        public var associatePublicIpAddress: Bool? = nil
        /// The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        public var groups: [String]? = nil

        public init() {}

        public init(deviceIndex: Int32? = nil, subnetId: String? = nil, networkInterfaceId: String? = nil, description: String? = nil, privateIpAddress: String? = nil, secondaryPrivateIpAddressCount: Int32? = nil, privateIpAddresses: [PrivateIpAddressSpecification]? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, deleteOnTermination: Bool? = nil, associatePublicIpAddress: Bool? = nil, groups: [String]? = nil) {
            self.deviceIndex = deviceIndex
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.description = description
            self.privateIpAddress = privateIpAddress
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.privateIpAddresses = privateIpAddresses
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.deleteOnTermination = deleteOnTermination
            self.associatePublicIpAddress = associatePublicIpAddress
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.description = dictionary["Description"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            if let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [[String: Any]] {
                self.privateIpAddresses = try privateIpAddresses.map({ try PrivateIpAddressSpecification(dictionary: $0) })
            }
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [[String: Any]] {
                self.ipv6Addresses = try ipv6Addresses.map({ try InstanceIpv6Address(dictionary: $0) })
            }
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.associatePublicIpAddress = dictionary["AssociatePublicIpAddress"] as? Bool
            if let groups = dictionary["Groups"] as? [String] {
                self.groups = groups
            }
        }
    }

    public struct DeleteRouteTableRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the route table.
        public var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(routeTableId: String, dryRun: Bool? = nil) {
            self.routeTableId = routeTableId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct NatGatewayAddress: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the network interface associated with the NAT gateway.
        public var networkInterfaceId: String? = nil
        /// The Elastic IP address associated with the NAT gateway.
        public var publicIp: String? = nil
        /// The private IP address associated with the Elastic IP address.
        public var privateIp: String? = nil
        /// The allocation ID of the Elastic IP address that's associated with the NAT gateway.
        public var allocationId: String? = nil

        public init() {}

        public init(networkInterfaceId: String? = nil, publicIp: String? = nil, privateIp: String? = nil, allocationId: String? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.publicIp = publicIp
            self.privateIp = privateIp
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
            self.privateIp = dictionary["PrivateIp"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
        }
    }

    public struct DescribeNetworkInterfaceAttributeResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The description of the network interface.
        public var description: AttributeValue? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The attachment (if any) of the network interface.
        public var attachment: NetworkInterfaceAttachment? = nil
        /// The security groups associated with the network interface.
        public var groups: [GroupIdentifier]? = nil
        /// Indicates whether source/destination checking is enabled.
        public var sourceDestCheck: AttributeBooleanValue? = nil

        public init() {}

        public init(description: AttributeValue? = nil, networkInterfaceId: String? = nil, attachment: NetworkInterfaceAttachment? = nil, groups: [GroupIdentifier]? = nil, sourceDestCheck: AttributeBooleanValue? = nil) {
            self.description = description
            self.networkInterfaceId = networkInterfaceId
            self.attachment = attachment
            self.groups = groups
            self.sourceDestCheck = sourceDestCheck
        }

        public init(dictionary: [String: Any]) throws {
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) }
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.NetworkInterfaceAttachment(dictionary: attachment) }
            if let groups = dictionary["Groups"] as? [[String: Any]] {
                self.groups = try groups.map({ try GroupIdentifier(dictionary: $0) })
            }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) }
        }
    }

    public struct ModifyVpcEndpointResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ImportSnapshotRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Token to enable idempotency for VM import requests.
        public var clientToken: String? = nil
        /// The name of the role to use when not using the default role, 'vmimport'.
        public var roleName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The client-specific data.
        public var clientData: ClientData? = nil
        /// Information about the disk container.
        public var diskContainer: SnapshotDiskContainer? = nil
        /// The description string for the import snapshot task.
        public var description: String? = nil

        public init() {}

        public init(clientToken: String? = nil, roleName: String? = nil, dryRun: Bool? = nil, clientData: ClientData? = nil, diskContainer: SnapshotDiskContainer? = nil, description: String? = nil) {
            self.clientToken = clientToken
            self.roleName = roleName
            self.dryRun = dryRun
            self.clientData = clientData
            self.diskContainer = diskContainer
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.roleName = dictionary["RoleName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            if let clientData = dictionary["ClientData"] as? [String: Any] { self.clientData = try Ec2.ClientData(dictionary: clientData) }
            if let diskContainer = dictionary["DiskContainer"] as? [String: Any] { self.diskContainer = try Ec2.SnapshotDiskContainer(dictionary: diskContainer) }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateVpcRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The tenancy options for instances launched into the VPC. For default, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For dedicated, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of dedicated or host into a dedicated tenancy VPC.   Important: The host value cannot be used with this parameter. Use the default or dedicated values only. Default: default 
        public var instanceTenancy: String? = nil
        /// Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.
        public var amazonProvidedIpv6CidrBlock: Bool? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The IPv4 network range for the VPC, in CIDR notation. For example, 10.0.0.0/16.
        public var cidrBlock: String = ""

        public init() {}

        public init(instanceTenancy: String? = nil, amazonProvidedIpv6CidrBlock: Bool? = nil, dryRun: Bool? = nil, cidrBlock: String) {
            self.instanceTenancy = instanceTenancy
            self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
            self.dryRun = dryRun
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceTenancy = dictionary["InstanceTenancy"] as? String
            self.amazonProvidedIpv6CidrBlock = dictionary["AmazonProvidedIpv6CidrBlock"] as? Bool
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let cidrBlock = dictionary["CidrBlock"] as? String else { throw InitializableError.missingRequiredParam("CidrBlock") }
            self.cidrBlock = cidrBlock
        }
    }

    public struct CreateRouteTableRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVpcsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more VPCs.
        public var vpcs: [Vpc]? = nil

        public init() {}

        public init(vpcs: [Vpc]? = nil) {
            self.vpcs = vpcs
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcs = dictionary["Vpcs"] as? [[String: Any]] {
                self.vpcs = try vpcs.map({ try Vpc(dictionary: $0) })
            }
        }
    }

    public struct ImportInstanceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The disk image.
        public var diskImages: [DiskImage]? = nil
        /// The instance operating system.
        public var platform: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The launch specification.
        public var launchSpecification: ImportInstanceLaunchSpecification? = nil
        /// A description for the instance being imported.
        public var description: String? = nil

        public init() {}

        public init(diskImages: [DiskImage]? = nil, platform: String, dryRun: Bool? = nil, launchSpecification: ImportInstanceLaunchSpecification? = nil, description: String? = nil) {
            self.diskImages = diskImages
            self.platform = platform
            self.dryRun = dryRun
            self.launchSpecification = launchSpecification
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let diskImages = dictionary["DiskImages"] as? [[String: Any]] {
                self.diskImages = try diskImages.map({ try DiskImage(dictionary: $0) })
            }
            guard let platform = dictionary["Platform"] as? String else { throw InitializableError.missingRequiredParam("Platform") }
            self.platform = platform
            self.dryRun = dictionary["DryRun"] as? Bool
            if let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] { self.launchSpecification = try Ec2.ImportInstanceLaunchSpecification(dictionary: launchSpecification) }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateVpcEndpointRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        public var clientToken: String? = nil
        /// The AWS service name, in the form com.amazonaws.region.service . To get a list of available services, use the DescribeVpcEndpointServices request.
        public var serviceName: String = ""
        /// The ID of the VPC in which the endpoint will be used.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.
        public var policyDocument: String? = nil
        /// One or more route table IDs.
        public var routeTableIds: [String]? = nil

        public init() {}

        public init(clientToken: String? = nil, serviceName: String, vpcId: String, dryRun: Bool? = nil, policyDocument: String? = nil, routeTableIds: [String]? = nil) {
            self.clientToken = clientToken
            self.serviceName = serviceName
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.policyDocument = policyDocument
            self.routeTableIds = routeTableIds
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            guard let serviceName = dictionary["ServiceName"] as? String else { throw InitializableError.missingRequiredParam("ServiceName") }
            self.serviceName = serviceName
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.policyDocument = dictionary["PolicyDocument"] as? String
            if let routeTableIds = dictionary["RouteTableIds"] as? [String] {
                self.routeTableIds = routeTableIds
            }
        }
    }

    public struct MovingAddressStatus: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.
        public var moveStatus: String? = nil
        /// The Elastic IP address.
        public var publicIp: String? = nil

        public init() {}

        public init(moveStatus: String? = nil, publicIp: String? = nil) {
            self.moveStatus = moveStatus
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.moveStatus = dictionary["MoveStatus"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct DeregisterImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the AMI.
        public var imageId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, imageId: String) {
            self.dryRun = dryRun
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct DeleteSnapshotRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the EBS snapshot.
        public var snapshotId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(snapshotId: String, dryRun: Bool? = nil) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeReservedInstancesOfferingsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum duration (in seconds) to filter when searching for offerings. Default: 94608000 (3 years)
        public var maxDuration: Int64? = nil
        /// The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of dedicated is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances). Default: default 
        public var instanceTenancy: String? = nil
        /// One or more Reserved Instances offering IDs.
        public var reservedInstancesOfferingIds: [String]? = nil
        /// One or more filters.    availability-zone - The Availability Zone where the Reserved Instance can be used.    duration - The duration of the Reserved Instance (for example, one year or three years), in seconds (31536000 | 94608000).    fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).    instance-type - The instance type that is covered by the reservation.    marketplace - Set to true to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.    product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web |  Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC))     reserved-instances-offering-id - The Reserved Instances offering ID.    scope - The scope of the Reserved Instance (Availability Zone or Region).    usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The instance type that the reservation will cover (for example, m1.small). For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide.
        public var instanceType: String? = nil
        /// The Availability Zone in which the Reserved Instance can be used.
        public var availabilityZone: String? = nil
        /// The Reserved Instance product platform description. Instances that include (Amazon VPC) in the description are for use with Amazon VPC.
        public var productDescription: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. The maximum is 100. Default: 100
        public var maxResults: Int32? = nil
        /// The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type. 
        public var offeringType: String? = nil
        /// The offering class of the Reserved Instance. Can be standard or convertible.
        public var offeringClass: String? = nil
        /// Include Reserved Instance Marketplace offerings in the response.
        public var includeMarketplace: Bool? = nil
        /// The minimum duration (in seconds) to filter when searching for offerings. Default: 2592000 (1 month)
        public var minDuration: Int64? = nil
        /// The maximum number of instances to filter when searching for offerings. Default: 20
        public var maxInstanceCount: Int32? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil

        public init() {}

        public init(maxDuration: Int64? = nil, instanceTenancy: String? = nil, reservedInstancesOfferingIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, instanceType: String? = nil, availabilityZone: String? = nil, productDescription: String? = nil, maxResults: Int32? = nil, offeringType: String? = nil, offeringClass: String? = nil, includeMarketplace: Bool? = nil, minDuration: Int64? = nil, maxInstanceCount: Int32? = nil, nextToken: String? = nil) {
            self.maxDuration = maxDuration
            self.instanceTenancy = instanceTenancy
            self.reservedInstancesOfferingIds = reservedInstancesOfferingIds
            self.filters = filters
            self.dryRun = dryRun
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.productDescription = productDescription
            self.maxResults = maxResults
            self.offeringType = offeringType
            self.offeringClass = offeringClass
            self.includeMarketplace = includeMarketplace
            self.minDuration = minDuration
            self.maxInstanceCount = maxInstanceCount
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.maxDuration = dictionary["MaxDuration"] as? Int64
            self.instanceTenancy = dictionary["InstanceTenancy"] as? String
            if let reservedInstancesOfferingIds = dictionary["ReservedInstancesOfferingIds"] as? [String] {
                self.reservedInstancesOfferingIds = reservedInstancesOfferingIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.instanceType = dictionary["InstanceType"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.productDescription = dictionary["ProductDescription"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.offeringType = dictionary["OfferingType"] as? String
            self.offeringClass = dictionary["OfferingClass"] as? String
            self.includeMarketplace = dictionary["IncludeMarketplace"] as? Bool
            self.minDuration = dictionary["MinDuration"] as? Int64
            self.maxInstanceCount = dictionary["MaxInstanceCount"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CancelledSpotInstanceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Spot instance request.
        public var spotInstanceRequestId: String? = nil
        /// The state of the Spot instance request.
        public var state: String? = nil

        public init() {}

        public init(spotInstanceRequestId: String? = nil, state: String? = nil) {
            self.spotInstanceRequestId = spotInstanceRequestId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
            self.state = dictionary["State"] as? String
        }
    }

    public struct ModifyImageAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more product codes. After you add a product code to an AMI, it can't be removed. This is only valid when modifying the productCodes attribute.
        public var productCodes: [String]? = nil
        /// A description for the AMI.
        public var description: AttributeValue? = nil
        /// One or more AWS account IDs. This is only valid when modifying the launchPermission attribute.
        public var userIds: [String]? = nil
        /// The ID of the AMI.
        public var imageId: String = ""
        /// One or more user groups. This is only valid when modifying the launchPermission attribute.
        public var userGroups: [String]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The name of the attribute to modify.
        public var attribute: String? = nil
        /// The value of the attribute being modified. This is only valid when modifying the description attribute.
        public var value: String? = nil
        /// A launch permission modification.
        public var launchPermission: LaunchPermissionModifications? = nil
        /// The operation type.
        public var operationType: String? = nil

        public init() {}

        public init(productCodes: [String]? = nil, description: AttributeValue? = nil, userIds: [String]? = nil, imageId: String, userGroups: [String]? = nil, dryRun: Bool? = nil, attribute: String? = nil, value: String? = nil, launchPermission: LaunchPermissionModifications? = nil, operationType: String? = nil) {
            self.productCodes = productCodes
            self.description = description
            self.userIds = userIds
            self.imageId = imageId
            self.userGroups = userGroups
            self.dryRun = dryRun
            self.attribute = attribute
            self.value = value
            self.launchPermission = launchPermission
            self.operationType = operationType
        }

        public init(dictionary: [String: Any]) throws {
            if let productCodes = dictionary["ProductCodes"] as? [String] {
                self.productCodes = productCodes
            }
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) }
            if let userIds = dictionary["UserIds"] as? [String] {
                self.userIds = userIds
            }
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
            if let userGroups = dictionary["UserGroups"] as? [String] {
                self.userGroups = userGroups
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.attribute = dictionary["Attribute"] as? String
            self.value = dictionary["Value"] as? String
            if let launchPermission = dictionary["LaunchPermission"] as? [String: Any] { self.launchPermission = try Ec2.LaunchPermissionModifications(dictionary: launchPermission) }
            self.operationType = dictionary["OperationType"] as? String
        }
    }

    public struct SubnetIpv6CidrBlockAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the state of the CIDR block.
        public var ipv6CidrBlockState: SubnetCidrBlockState? = nil
        /// The IPv6 CIDR block.
        public var ipv6CidrBlock: String? = nil
        /// The association ID for the CIDR block.
        public var associationId: String? = nil

        public init() {}

        public init(ipv6CidrBlockState: SubnetCidrBlockState? = nil, ipv6CidrBlock: String? = nil, associationId: String? = nil) {
            self.ipv6CidrBlockState = ipv6CidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            if let ipv6CidrBlockState = dictionary["Ipv6CidrBlockState"] as? [String: Any] { self.ipv6CidrBlockState = try Ec2.SubnetCidrBlockState(dictionary: ipv6CidrBlockState) }
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct CreateDhcpOptionsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A set of DHCP options.
        public var dhcpOptions: DhcpOptions? = nil

        public init() {}

        public init(dhcpOptions: DhcpOptions? = nil) {
            self.dhcpOptions = dhcpOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let dhcpOptions = dictionary["DhcpOptions"] as? [String: Any] { self.dhcpOptions = try Ec2.DhcpOptions(dictionary: dhcpOptions) }
        }
    }

    public struct InstanceNetworkInterfaceAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The public DNS name.
        public var publicDnsName: String? = nil
        /// The ID of the owner of the Elastic IP address.
        public var ipOwnerId: String? = nil
        /// The public IP address or Elastic IP address bound to the network interface.
        public var publicIp: String? = nil

        public init() {}

        public init(publicDnsName: String? = nil, ipOwnerId: String? = nil, publicIp: String? = nil) {
            self.publicDnsName = publicDnsName
            self.ipOwnerId = ipOwnerId
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.publicDnsName = dictionary["PublicDnsName"] as? String
            self.ipOwnerId = dictionary["IpOwnerId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct EbsInstanceBlockDevice: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time stamp when the attachment initiated.
        public var attachTime: Date? = nil
        /// Indicates whether the volume is deleted on instance termination.
        public var deleteOnTermination: Bool? = nil
        /// The attachment state.
        public var status: String? = nil
        /// The ID of the EBS volume.
        public var volumeId: String? = nil

        public init() {}

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, status: String? = nil, volumeId: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.status = status
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.status = dictionary["Status"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct CancelImportTaskRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The reason for canceling the task.
        public var cancelReason: String? = nil
        /// The ID of the import image or import snapshot task to be canceled.
        public var importTaskId: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, cancelReason: String? = nil, importTaskId: String? = nil) {
            self.dryRun = dryRun
            self.cancelReason = cancelReason
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.cancelReason = dictionary["CancelReason"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct ReservedInstanceReservationValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Convertible Reserved Instance that you are exchanging.
        public var reservedInstanceId: String? = nil
        /// The total value of the Convertible Reserved Instance that you are exchanging.
        public var reservationValue: ReservationValue? = nil

        public init() {}

        public init(reservedInstanceId: String? = nil, reservationValue: ReservationValue? = nil) {
            self.reservedInstanceId = reservedInstanceId
            self.reservationValue = reservationValue
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstanceId = dictionary["ReservedInstanceId"] as? String
            if let reservationValue = dictionary["ReservationValue"] as? [String: Any] { self.reservationValue = try Ec2.ReservationValue(dictionary: reservationValue) }
        }
    }

    public struct CreateFlowLogsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the flow logs.
        public var flowLogIds: [String]? = nil
        /// Information about the flow logs that could not be created successfully.
        public var unsuccessful: [UnsuccessfulItem]? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        public var clientToken: String? = nil

        public init() {}

        public init(flowLogIds: [String]? = nil, unsuccessful: [UnsuccessfulItem]? = nil, clientToken: String? = nil) {
            self.flowLogIds = flowLogIds
            self.unsuccessful = unsuccessful
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            if let flowLogIds = dictionary["FlowLogIds"] as? [String] {
                self.flowLogIds = flowLogIds
            }
            if let unsuccessful = dictionary["Unsuccessful"] as? [[String: Any]] {
                self.unsuccessful = try unsuccessful.map({ try UnsuccessfulItem(dictionary: $0) })
            }
            self.clientToken = dictionary["ClientToken"] as? String
        }
    }

    public struct StopInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more instance IDs.
        public var instanceIds: [String] = []
        /// Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances. Default: false 
        public var force: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil, instanceIds: [String], force: Bool? = nil) {
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.force = force
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
            self.force = dictionary["Force"] as? Bool
        }
    }

    public struct AvailabilityZone: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the Availability Zone.
        public var zoneName: String? = nil
        /// The state of the Availability Zone.
        public var state: String? = nil
        /// Any messages about the Availability Zone.
        public var messages: [AvailabilityZoneMessage]? = nil
        /// The name of the region.
        public var regionName: String? = nil

        public init() {}

        public init(zoneName: String? = nil, state: String? = nil, messages: [AvailabilityZoneMessage]? = nil, regionName: String? = nil) {
            self.zoneName = zoneName
            self.state = state
            self.messages = messages
            self.regionName = regionName
        }

        public init(dictionary: [String: Any]) throws {
            self.zoneName = dictionary["ZoneName"] as? String
            self.state = dictionary["State"] as? String
            if let messages = dictionary["Messages"] as? [[String: Any]] {
                self.messages = try messages.map({ try AvailabilityZoneMessage(dictionary: $0) })
            }
            self.regionName = dictionary["RegionName"] as? String
        }
    }

    public struct VolumeStatusDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the volume status.
        public var name: String? = nil
        /// The intended status of the volume status.
        public var status: String? = nil

        public init() {}

        public init(name: String? = nil, status: String? = nil) {
            self.name = name
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.status = dictionary["Status"] as? String
        }
    }

    public struct DisassociateIamInstanceProfileResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the IAM instance profile association.
        public var iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil

        public init() {}

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

        public init(dictionary: [String: Any]) throws {
            if let iamInstanceProfileAssociation = dictionary["IamInstanceProfileAssociation"] as? [String: Any] { self.iamInstanceProfileAssociation = try Ec2.IamInstanceProfileAssociation(dictionary: iamInstanceProfileAssociation) }
        }
    }

    public struct DescribeReservedInstancesModificationsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// One or more filters.    client-token - The idempotency token for the modification request.    create-date - The time when the modification request was created.    effective-date - The time when the modification becomes effective.    modification-result.reserved-instances-id - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is fulfilled.    modification-result.target-configuration.availability-zone - The Availability Zone for the new Reserved Instances.    modification-result.target-configuration.instance-count  - The number of new Reserved Instances.    modification-result.target-configuration.instance-type - The instance type of the new Reserved Instances.    modification-result.target-configuration.platform - The network platform of the new Reserved Instances (EC2-Classic | EC2-VPC).    reserved-instances-id - The ID of the Reserved Instances modified.    reserved-instances-modification-id - The ID of the modification request.    status - The status of the Reserved Instances modification request (processing | fulfilled | failed).    status-message - The reason for the status.    update-date - The time when the modification request was last updated.  
        public var filters: [Filter]? = nil
        /// IDs for the submitted modification request.
        public var reservedInstancesModificationIds: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, filters: [Filter]? = nil, reservedInstancesModificationIds: [String]? = nil) {
            self.nextToken = nextToken
            self.filters = filters
            self.reservedInstancesModificationIds = reservedInstancesModificationIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let reservedInstancesModificationIds = dictionary["ReservedInstancesModificationIds"] as? [String] {
                self.reservedInstancesModificationIds = reservedInstancesModificationIds
            }
        }
    }

    public struct SpotInstanceStateFault: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The reason code for the Spot instance state change.
        public var code: String? = nil
        /// The message for the Spot instance state change.
        public var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DescribeImagesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more images.
        public var images: [Image]? = nil

        public init() {}

        public init(images: [Image]? = nil) {
            self.images = images
        }

        public init(dictionary: [String: Any]) throws {
            if let images = dictionary["Images"] as? [[String: Any]] {
                self.images = try images.map({ try Image(dictionary: $0) })
            }
        }
    }

    public struct ScheduledInstancesPlacement: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Availability Zone.
        public var availabilityZone: String? = nil
        /// The name of the placement group.
        public var groupName: String? = nil

        public init() {}

        public init(availabilityZone: String? = nil, groupName: String? = nil) {
            self.availabilityZone = availabilityZone
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct CancelSpotFleetRequestsSuccessItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current state of the Spot fleet request.
        public var currentSpotFleetRequestState: String = ""
        /// The previous state of the Spot fleet request.
        public var previousSpotFleetRequestState: String = ""
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""

        public init() {}

        public init(currentSpotFleetRequestState: String, previousSpotFleetRequestState: String, spotFleetRequestId: String) {
            self.currentSpotFleetRequestState = currentSpotFleetRequestState
            self.previousSpotFleetRequestState = previousSpotFleetRequestState
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let currentSpotFleetRequestState = dictionary["CurrentSpotFleetRequestState"] as? String else { throw InitializableError.missingRequiredParam("CurrentSpotFleetRequestState") }
            self.currentSpotFleetRequestState = currentSpotFleetRequestState
            guard let previousSpotFleetRequestState = dictionary["PreviousSpotFleetRequestState"] as? String else { throw InitializableError.missingRequiredParam("PreviousSpotFleetRequestState") }
            self.previousSpotFleetRequestState = previousSpotFleetRequestState
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct AuthorizeSecurityGroupIngressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-Classic] The AWS account number for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.
        public var sourceSecurityGroupOwnerId: String? = nil
        /// [EC2-Classic, default VPC] The name of the security group.
        public var groupName: String? = nil
        /// A set of IP permissions. Can be used to specify multiple rules in a single command.
        public var ipPermissions: [IpPermission]? = nil
        /// The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.
        public var cidrIp: String? = nil
        /// [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.
        public var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use -1 to specify all codes.
        public var toPort: Int32? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use -1 to specify all types.
        public var fromPort: Int32? = nil
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). (VPC only) Use -1 to specify all protocols. If you specify -1, or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For tcp, udp, and icmp, you must specify a port range. For protocol 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.
        public var ipProtocol: String? = nil
        /// The ID of the security group. Required for a nondefault VPC.
        public var groupId: String? = nil

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, groupName: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, toPort: Int32? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, groupId: String? = nil) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.toPort = toPort
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            self.groupName = dictionary["GroupName"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [[String: Any]] {
                self.ipPermissions = try ipPermissions.map({ try IpPermission(dictionary: $0) })
            }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.toPort = dictionary["ToPort"] as? Int32
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.groupId = dictionary["GroupId"] as? String
        }
    }

    public struct PortRange: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The first port in the range.
        public var from: Int32? = nil
        /// The last port in the range.
        public var to: Int32? = nil

        public init() {}

        public init(from: Int32? = nil, to: Int32? = nil) {
            self.from = from
            self.to = to
        }

        public init(dictionary: [String: Any]) throws {
            self.from = dictionary["From"] as? Int32
            self.to = dictionary["To"] as? Int32
        }
    }

    public struct InstanceState: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current state of the instance.
        public var name: String? = nil
        /// The low byte represents the state. The high byte is an opaque internal value and should be ignored.    0 : pending     16 : running     32 : shutting-down     48 : terminated     64 : stopping     80 : stopped   
        public var code: Int32? = nil

        public init() {}

        public init(name: String? = nil, code: Int32? = nil) {
            self.name = name
            self.code = code
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.code = dictionary["Code"] as? Int32
        }
    }

    public struct InstancePrivateIpAddress: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The private IPv4 address of the network interface.
        public var privateIpAddress: String? = nil
        /// The private IPv4 DNS name.
        public var privateDnsName: String? = nil
        /// Indicates whether this IPv4 address is the primary private IP address of the network interface.
        public var primary: Bool? = nil
        /// The association information for an Elastic IP address for the network interface.
        public var association: InstanceNetworkInterfaceAssociation? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, privateDnsName: String? = nil, primary: Bool? = nil, association: InstanceNetworkInterfaceAssociation? = nil) {
            self.privateIpAddress = privateIpAddress
            self.privateDnsName = privateDnsName
            self.primary = primary
            self.association = association
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.primary = dictionary["Primary"] as? Bool
            if let association = dictionary["Association"] as? [String: Any] { self.association = try Ec2.InstanceNetworkInterfaceAssociation(dictionary: association) }
        }
    }

    public struct HostProperties: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of sockets on the Dedicated Host.
        public var sockets: Int32? = nil
        /// The instance type size that the Dedicated Host supports (for example, m3.medium).
        public var instanceType: String? = nil
        /// The number of vCPUs on the Dedicated Host.
        public var totalVCpus: Int32? = nil
        /// The number of cores on the Dedicated Host.
        public var cores: Int32? = nil

        public init() {}

        public init(sockets: Int32? = nil, instanceType: String? = nil, totalVCpus: Int32? = nil, cores: Int32? = nil) {
            self.sockets = sockets
            self.instanceType = instanceType
            self.totalVCpus = totalVCpus
            self.cores = cores
        }

        public init(dictionary: [String: Any]) throws {
            self.sockets = dictionary["Sockets"] as? Int32
            self.instanceType = dictionary["InstanceType"] as? String
            self.totalVCpus = dictionary["TotalVCpus"] as? Int32
            self.cores = dictionary["Cores"] as? Int32
        }
    }

    public struct UnassignPrivateIpAddressesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.
        public var privateIpAddresses: [String] = []

        public init() {}

        public init(networkInterfaceId: String, privateIpAddresses: [String]) {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
        }

        public init(dictionary: [String: Any]) throws {
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            guard let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [String] else { throw InitializableError.missingRequiredParam("PrivateIpAddresses") }
            self.privateIpAddresses = privateIpAddresses
        }
    }

    public struct SecurityGroupReference: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC with the referencing security group.
        public var referencingVpcId: String = ""
        /// The ID of your security group.
        public var groupId: String = ""
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(referencingVpcId: String, groupId: String, vpcPeeringConnectionId: String? = nil) {
            self.referencingVpcId = referencingVpcId
            self.groupId = groupId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let referencingVpcId = dictionary["ReferencingVpcId"] as? String else { throw InitializableError.missingRequiredParam("ReferencingVpcId") }
            self.referencingVpcId = referencingVpcId
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct PriceSchedule: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current price schedule, as determined by the term remaining for the Reserved Instance in the listing. A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.
        public var active: Bool? = nil
        /// The currency for transacting the Reserved Instance resale. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.
        public var term: Int64? = nil
        /// The fixed price for the term.
        public var price: Double? = nil

        public init() {}

        public init(active: Bool? = nil, currencyCode: String? = nil, term: Int64? = nil, price: Double? = nil) {
            self.active = active
            self.currencyCode = currencyCode
            self.term = term
            self.price = price
        }

        public init(dictionary: [String: Any]) throws {
            self.active = dictionary["Active"] as? Bool
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.term = dictionary["Term"] as? Int64
            self.price = dictionary["Price"] as? Double
        }
    }

    public struct DescribePrefixListsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more prefix list IDs.
        public var prefixListIds: [String]? = nil
        /// One or more filters.    prefix-list-id: The ID of a prefix list.    prefix-list-name: The name of a prefix list.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value specified is greater than 1000, we return only 1000 items.
        public var maxResults: Int32? = nil

        public init() {}

        public init(prefixListIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.prefixListIds = prefixListIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let prefixListIds = dictionary["PrefixListIds"] as? [String] {
                self.prefixListIds = prefixListIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DiskImage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the disk image.
        public var image: DiskImageDetail? = nil
        /// Information about the volume.
        public var volume: VolumeDetail? = nil
        /// A description of the disk image.
        public var description: String? = nil

        public init() {}

        public init(image: DiskImageDetail? = nil, volume: VolumeDetail? = nil, description: String? = nil) {
            self.image = image
            self.volume = volume
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let image = dictionary["Image"] as? [String: Any] { self.image = try Ec2.DiskImageDetail(dictionary: image) }
            if let volume = dictionary["Volume"] as? [String: Any] { self.volume = try Ec2.VolumeDetail(dictionary: volume) }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeRouteTablesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more route table IDs. Default: Describes all your route tables.
        public var routeTableIds: [String]? = nil
        /// One or more filters.    association.route-table-association-id - The ID of an association ID for the route table.    association.route-table-id - The ID of the route table involved in the association.    association.subnet-id - The ID of the subnet involved in the association.    association.main - Indicates whether the route table is the main route table for the VPC (true | false).    route-table-id - The ID of the route table.    route.destination-cidr-block - The IPv4 CIDR range specified in a route in the table.    route.destination-ipv6-cidr-block - The IPv6 CIDR range specified in a route in the route table.    route.destination-prefix-list-id - The ID (prefix) of the AWS service specified in a route in the table.    route.egress-only-internet-gateway-id - The ID of an egress-only Internet gateway specified in a route in the route table.    route.gateway-id - The ID of a gateway specified in a route in the table.    route.instance-id - The ID of an instance specified in a route in the table.    route.nat-gateway-id - The ID of a NAT gateway.    route.origin - Describes how the route was created. CreateRouteTable indicates that the route was automatically created when the route table was created; CreateRoute indicates that the route was manually added to the route table; EnableVgwRoutePropagation indicates that the route was propagated by route propagation.    route.state - The state of a route in the route table (active | blackhole). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).    route.vpc-peering-connection-id - The ID of a VPC peering connection specified in a route in the table.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the route table.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(routeTableIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.routeTableIds = routeTableIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let routeTableIds = dictionary["RouteTableIds"] as? [String] {
                self.routeTableIds = routeTableIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeInternetGatewaysResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more Internet gateways.
        public var internetGateways: [InternetGateway]? = nil

        public init() {}

        public init(internetGateways: [InternetGateway]? = nil) {
            self.internetGateways = internetGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let internetGateways = dictionary["InternetGateways"] as? [[String: Any]] {
                self.internetGateways = try internetGateways.map({ try InternetGateway(dictionary: $0) })
            }
        }
    }

    public struct InstanceNetworkInterfaceAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time stamp when the attachment initiated.
        public var attachTime: Date? = nil
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Bool? = nil
        /// The index of the device on the instance for the network interface attachment.
        public var deviceIndex: Int32? = nil
        /// The ID of the network interface attachment.
        public var attachmentId: String? = nil
        /// The attachment state.
        public var status: String? = nil

        public init() {}

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, deviceIndex: Int32? = nil, attachmentId: String? = nil, status: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.attachmentId = attachmentId
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.attachmentId = dictionary["AttachmentId"] as? String
            self.status = dictionary["Status"] as? String
        }
    }

    public struct DisassociateVpcCidrBlockRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The association ID for the CIDR block.
        public var associationId: String = ""

        public init() {}

        public init(associationId: String) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct DescribeVpcPeeringConnectionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    accepter-vpc-info.cidr-block - The IPv4 CIDR block of the peer VPC.    accepter-vpc-info.owner-id - The AWS account ID of the owner of the peer VPC.    accepter-vpc-info.vpc-id - The ID of the peer VPC.    expiration-time - The expiration date and time for the VPC peering connection.    requester-vpc-info.cidr-block - The IPv4 CIDR block of the requester's VPC.    requester-vpc-info.owner-id - The AWS account ID of the owner of the requester VPC.    requester-vpc-info.vpc-id - The ID of the requester VPC.    status-code - The status of the VPC peering connection (pending-acceptance | failed | expired | provisioning | active | deleted | rejected).    status-message - A message that provides more information about the status of the VPC peering connection, if applicable.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-peering-connection-id - The ID of the VPC peering connection.  
        public var filters: [Filter]? = nil
        /// One or more VPC peering connection IDs. Default: Describes all your VPC peering connections.
        public var vpcPeeringConnectionIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, vpcPeeringConnectionIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcPeeringConnectionIds = vpcPeeringConnectionIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let vpcPeeringConnectionIds = dictionary["VpcPeeringConnectionIds"] as? [String] {
                self.vpcPeeringConnectionIds = vpcPeeringConnectionIds
            }
        }
    }

    public struct DetachClassicLinkVpcRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC to which the instance is linked.
        public var vpcId: String = ""
        /// The ID of the instance to unlink from the VPC.
        public var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, instanceId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReservationValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The hourly rate of the reservation.
        public var hourlyPrice: String? = nil
        /// The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).
        public var remainingTotalValue: String? = nil
        /// The remaining upfront cost of the reservation.
        public var remainingUpfrontValue: String? = nil

        public init() {}

        public init(hourlyPrice: String? = nil, remainingTotalValue: String? = nil, remainingUpfrontValue: String? = nil) {
            self.hourlyPrice = hourlyPrice
            self.remainingTotalValue = remainingTotalValue
            self.remainingUpfrontValue = remainingUpfrontValue
        }

        public init(dictionary: [String: Any]) throws {
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.remainingTotalValue = dictionary["RemainingTotalValue"] as? String
            self.remainingUpfrontValue = dictionary["RemainingUpfrontValue"] as? String
        }
    }

    public struct DetachClassicLinkVpcResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct S3Storage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.
        public var bucket: String? = nil
        /// The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in Best Practices for Managing AWS Access Keys.
        public var aWSAccessKeyId: String? = nil
        /// The signature of the JSON document.
        public var uploadPolicySignature: String? = nil
        /// The beginning of the file name of the AMI.
        public var prefix: String? = nil
        /// An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.
        public var uploadPolicy: Data? = nil

        public init() {}

        public init(bucket: String? = nil, aWSAccessKeyId: String? = nil, uploadPolicySignature: String? = nil, prefix: String? = nil, uploadPolicy: Data? = nil) {
            self.bucket = bucket
            self.aWSAccessKeyId = aWSAccessKeyId
            self.uploadPolicySignature = uploadPolicySignature
            self.prefix = prefix
            self.uploadPolicy = uploadPolicy
        }

        public init(dictionary: [String: Any]) throws {
            self.bucket = dictionary["Bucket"] as? String
            self.aWSAccessKeyId = dictionary["AWSAccessKeyId"] as? String
            self.uploadPolicySignature = dictionary["UploadPolicySignature"] as? String
            self.prefix = dictionary["Prefix"] as? String
            self.uploadPolicy = dictionary["UploadPolicy"] as? Data
        }
    }

    public struct DescribeInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Zero or more reservations.
        public var reservations: [Reservation]? = nil

        public init() {}

        public init(nextToken: String? = nil, reservations: [Reservation]? = nil) {
            self.nextToken = nextToken
            self.reservations = reservations
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let reservations = dictionary["Reservations"] as? [[String: Any]] {
                self.reservations = try reservations.map({ try Reservation(dictionary: $0) })
            }
        }
    }

    public struct DescribeReservedInstancesListingsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Reserved Instance IDs.
        public var reservedInstancesId: String? = nil
        /// One or more Reserved Instance listing IDs.
        public var reservedInstancesListingId: String? = nil
        /// One or more filters.    reserved-instances-id - The ID of the Reserved Instances.    reserved-instances-listing-id - The ID of the Reserved Instances listing.    status - The status of the Reserved Instance listing (pending | active | cancelled | closed).    status-message - The reason for the status.  
        public var filters: [Filter]? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil, reservedInstancesListingId: String? = nil, filters: [Filter]? = nil) {
            self.reservedInstancesId = reservedInstancesId
            self.reservedInstancesListingId = reservedInstancesListingId
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
            self.reservedInstancesListingId = dictionary["ReservedInstancesListingId"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct CancelBundleTaskRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the bundle task.
        public var bundleId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(bundleId: String, dryRun: Bool? = nil) {
            self.bundleId = bundleId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let bundleId = dictionary["BundleId"] as? String else { throw InitializableError.missingRequiredParam("BundleId") }
            self.bundleId = bundleId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DeleteCustomerGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the customer gateway.
        public var customerGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(customerGatewayId: String, dryRun: Bool? = nil) {
            self.customerGatewayId = customerGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let customerGatewayId = dictionary["CustomerGatewayId"] as? String else { throw InitializableError.missingRequiredParam("CustomerGatewayId") }
            self.customerGatewayId = customerGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeHostsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the Dedicated Hosts.
        public var hosts: [Host]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(hosts: [Host]? = nil, nextToken: String? = nil) {
            self.hosts = hosts
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let hosts = dictionary["Hosts"] as? [[String: Any]] {
                self.hosts = try hosts.map({ try Host(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct PurchaseHostReservationResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Describes the details of the purchase.
        public var purchase: [Purchase]? = nil
        /// The total amount that will be charged to your account when you purchase the reservation.
        public var totalUpfrontPrice: String? = nil
        /// The currency in which the totalUpfrontPrice and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide 
        public var clientToken: String? = nil
        /// The total hourly price of the reservation calculated per hour.
        public var totalHourlyPrice: String? = nil

        public init() {}

        public init(purchase: [Purchase]? = nil, totalUpfrontPrice: String? = nil, currencyCode: String? = nil, clientToken: String? = nil, totalHourlyPrice: String? = nil) {
            self.purchase = purchase
            self.totalUpfrontPrice = totalUpfrontPrice
            self.currencyCode = currencyCode
            self.clientToken = clientToken
            self.totalHourlyPrice = totalHourlyPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let purchase = dictionary["Purchase"] as? [[String: Any]] {
                self.purchase = try purchase.map({ try Purchase(dictionary: $0) })
            }
            self.totalUpfrontPrice = dictionary["TotalUpfrontPrice"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            self.totalHourlyPrice = dictionary["TotalHourlyPrice"] as? String
        }
    }

    public struct DeleteEgressOnlyInternetGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var returnCode: Bool? = nil

        public init() {}

        public init(returnCode: Bool? = nil) {
            self.returnCode = returnCode
        }

        public init(dictionary: [String: Any]) throws {
            self.returnCode = dictionary["ReturnCode"] as? Bool
        }
    }

    public struct DeleteVolumeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the volume.
        public var volumeId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(volumeId: String, dryRun: Bool? = nil) {
            self.volumeId = volumeId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct TargetConfiguration: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Convertible Reserved Instance offering.
        public var offeringId: String? = nil
        /// The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request
        public var instanceCount: Int32? = nil

        public init() {}

        public init(offeringId: String? = nil, instanceCount: Int32? = nil) {
            self.offeringId = offeringId
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            self.offeringId = dictionary["OfferingId"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
        }
    }

    public struct CreateCustomerGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the customer gateway.
        public var customerGateway: CustomerGateway? = nil

        public init() {}

        public init(customerGateway: CustomerGateway? = nil) {
            self.customerGateway = customerGateway
        }

        public init(dictionary: [String: Any]) throws {
            if let customerGateway = dictionary["CustomerGateway"] as? [String: Any] { self.customerGateway = try Ec2.CustomerGateway(dictionary: customerGateway) }
        }
    }

    public struct DescribeBundleTasksResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more bundle tasks.
        public var bundleTasks: [BundleTask]? = nil

        public init() {}

        public init(bundleTasks: [BundleTask]? = nil) {
            self.bundleTasks = bundleTasks
        }

        public init(dictionary: [String: Any]) throws {
            if let bundleTasks = dictionary["BundleTasks"] as? [[String: Any]] {
                self.bundleTasks = try bundleTasks.map({ try BundleTask(dictionary: $0) })
            }
        }
    }

    public struct GetReservedInstancesExchangeQuoteResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The new end date of the reservation term.
        public var outputReservedInstancesWillExpireAt: Date? = nil
        /// The cost associated with the Reserved Instance.
        public var targetConfigurationValueRollup: ReservationValue? = nil
        /// If true, the exchange is valid. If false, the exchange cannot be completed.
        public var isValidExchange: Bool? = nil
        /// The cost associated with the Reserved Instance.
        public var reservedInstanceValueRollup: ReservationValue? = nil
        /// The configuration of your Convertible Reserved Instances.
        public var reservedInstanceValueSet: [ReservedInstanceReservationValue]? = nil
        /// The total true upfront charge for the exchange.
        public var paymentDue: String? = nil
        /// The currency of the transaction.
        public var currencyCode: String? = nil
        /// The values of the target Convertible Reserved Instances.
        public var targetConfigurationValueSet: [TargetReservationValue]? = nil
        /// Describes the reason why the exchange cannot be completed.
        public var validationFailureReason: String? = nil

        public init() {}

        public init(outputReservedInstancesWillExpireAt: Date? = nil, targetConfigurationValueRollup: ReservationValue? = nil, isValidExchange: Bool? = nil, reservedInstanceValueRollup: ReservationValue? = nil, reservedInstanceValueSet: [ReservedInstanceReservationValue]? = nil, paymentDue: String? = nil, currencyCode: String? = nil, targetConfigurationValueSet: [TargetReservationValue]? = nil, validationFailureReason: String? = nil) {
            self.outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAt
            self.targetConfigurationValueRollup = targetConfigurationValueRollup
            self.isValidExchange = isValidExchange
            self.reservedInstanceValueRollup = reservedInstanceValueRollup
            self.reservedInstanceValueSet = reservedInstanceValueSet
            self.paymentDue = paymentDue
            self.currencyCode = currencyCode
            self.targetConfigurationValueSet = targetConfigurationValueSet
            self.validationFailureReason = validationFailureReason
        }

        public init(dictionary: [String: Any]) throws {
            self.outputReservedInstancesWillExpireAt = dictionary["OutputReservedInstancesWillExpireAt"] as? Date
            if let targetConfigurationValueRollup = dictionary["TargetConfigurationValueRollup"] as? [String: Any] { self.targetConfigurationValueRollup = try Ec2.ReservationValue(dictionary: targetConfigurationValueRollup) }
            self.isValidExchange = dictionary["IsValidExchange"] as? Bool
            if let reservedInstanceValueRollup = dictionary["ReservedInstanceValueRollup"] as? [String: Any] { self.reservedInstanceValueRollup = try Ec2.ReservationValue(dictionary: reservedInstanceValueRollup) }
            if let reservedInstanceValueSet = dictionary["ReservedInstanceValueSet"] as? [[String: Any]] {
                self.reservedInstanceValueSet = try reservedInstanceValueSet.map({ try ReservedInstanceReservationValue(dictionary: $0) })
            }
            self.paymentDue = dictionary["PaymentDue"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            if let targetConfigurationValueSet = dictionary["TargetConfigurationValueSet"] as? [[String: Any]] {
                self.targetConfigurationValueSet = try targetConfigurationValueSet.map({ try TargetReservationValue(dictionary: $0) })
            }
            self.validationFailureReason = dictionary["ValidationFailureReason"] as? String
        }
    }

    public struct InstanceExportDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the resource being exported.
        public var instanceId: String? = nil
        /// The target virtualization environment.
        public var targetEnvironment: String? = nil

        public init() {}

        public init(instanceId: String? = nil, targetEnvironment: String? = nil) {
            self.instanceId = instanceId
            self.targetEnvironment = targetEnvironment
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
            self.targetEnvironment = dictionary["TargetEnvironment"] as? String
        }
    }

    public struct NetworkAcl: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether this is the default network ACL for the VPC.
        public var isDefault: Bool? = nil
        /// One or more entries (rules) in the network ACL.
        public var entries: [NetworkAclEntry]? = nil
        /// The ID of the network ACL.
        public var networkAclId: String? = nil
        /// The ID of the VPC for the network ACL.
        public var vpcId: String? = nil
        /// Any tags assigned to the network ACL.
        public var tags: [Tag]? = nil
        /// Any associations between the network ACL and one or more subnets
        public var associations: [NetworkAclAssociation]? = nil

        public init() {}

        public init(isDefault: Bool? = nil, entries: [NetworkAclEntry]? = nil, networkAclId: String? = nil, vpcId: String? = nil, tags: [Tag]? = nil, associations: [NetworkAclAssociation]? = nil) {
            self.isDefault = isDefault
            self.entries = entries
            self.networkAclId = networkAclId
            self.vpcId = vpcId
            self.tags = tags
            self.associations = associations
        }

        public init(dictionary: [String: Any]) throws {
            self.isDefault = dictionary["IsDefault"] as? Bool
            if let entries = dictionary["Entries"] as? [[String: Any]] {
                self.entries = try entries.map({ try NetworkAclEntry(dictionary: $0) })
            }
            self.networkAclId = dictionary["NetworkAclId"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            if let associations = dictionary["Associations"] as? [[String: Any]] {
                self.associations = try associations.map({ try NetworkAclAssociation(dictionary: $0) })
            }
        }
    }

    public struct RevokeSecurityGroupIngressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.
        public var sourceSecurityGroupOwnerId: String? = nil
        /// [EC2-Classic, default VPC] The name of the security group.
        public var groupName: String? = nil
        /// A set of IP permissions. You can't specify a source security group and a CIDR IP address range.
        public var ipPermissions: [IpPermission]? = nil
        /// The CIDR IP address range. You can't specify this parameter when specifying a source security group.
        public var cidrIp: String? = nil
        /// [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.
        public var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use -1 to specify all ICMP codes for the ICMP type.
        public var toPort: Int32? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use -1 to specify all ICMP types.
        public var fromPort: Int32? = nil
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). Use -1 to specify all.
        public var ipProtocol: String? = nil
        /// The ID of the security group. Required for a security group in a nondefault VPC.
        public var groupId: String? = nil

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, groupName: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, toPort: Int32? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, groupId: String? = nil) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.toPort = toPort
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            self.groupName = dictionary["GroupName"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [[String: Any]] {
                self.ipPermissions = try ipPermissions.map({ try IpPermission(dictionary: $0) })
            }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.toPort = dictionary["ToPort"] as? Int32
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.groupId = dictionary["GroupId"] as? String
        }
    }

    public struct DescribeKeyPairsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more key pairs.
        public var keyPairs: [KeyPairInfo]? = nil

        public init() {}

        public init(keyPairs: [KeyPairInfo]? = nil) {
            self.keyPairs = keyPairs
        }

        public init(dictionary: [String: Any]) throws {
            if let keyPairs = dictionary["KeyPairs"] as? [[String: Any]] {
                self.keyPairs = try keyPairs.map({ try KeyPairInfo(dictionary: $0) })
            }
        }
    }

    public struct ScheduledInstancesPrivateIpAddressConfig: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.
        public var primary: Bool? = nil
        /// The IPv4 address.
        public var privateIpAddress: String? = nil

        public init() {}

        public init(primary: Bool? = nil, privateIpAddress: String? = nil) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.primary = dictionary["Primary"] as? Bool
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
        }
    }

    public struct CancelReservedInstancesListingResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Reserved Instance listing.
        public var reservedInstancesListings: [ReservedInstancesListing]? = nil

        public init() {}

        public init(reservedInstancesListings: [ReservedInstancesListing]? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesListings = dictionary["ReservedInstancesListings"] as? [[String: Any]] {
                self.reservedInstancesListings = try reservedInstancesListings.map({ try ReservedInstancesListing(dictionary: $0) })
            }
        }
    }

    public struct AcceptReservedInstancesExchangeQuoteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the Convertible Reserved Instances to exchange for other Convertible Reserved Instances of the same or higher value.
        public var reservedInstanceIds: [String] = []
        /// The configurations of the Convertible Reserved Instance offerings that you are purchasing in this exchange.
        public var targetConfigurations: [TargetConfigurationRequest]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(reservedInstanceIds: [String], targetConfigurations: [TargetConfigurationRequest]? = nil, dryRun: Bool? = nil) {
            self.reservedInstanceIds = reservedInstanceIds
            self.targetConfigurations = targetConfigurations
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstanceIds = dictionary["ReservedInstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("ReservedInstanceIds") }
            self.reservedInstanceIds = reservedInstanceIds
            if let targetConfigurations = dictionary["TargetConfigurations"] as? [[String: Any]] {
                self.targetConfigurations = try targetConfigurations.map({ try TargetConfigurationRequest(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct BundleInstanceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the instance to bundle. Type: String Default: None Required: Yes
        public var instanceId: String = ""
        /// The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.
        public var storage: Storage = Storage()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, storage: Storage, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.storage = storage
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let storage = dictionary["Storage"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Storage") }
            self.storage = try Ec2.Storage(dictionary: storage)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVolumesModificationsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Token for pagination, null if there are no more results 
        public var nextToken: String? = nil
        /// A list of returned VolumeModification objects.
        public var volumesModifications: [VolumeModification]? = nil

        public init() {}

        public init(nextToken: String? = nil, volumesModifications: [VolumeModification]? = nil) {
            self.nextToken = nextToken
            self.volumesModifications = volumesModifications
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let volumesModifications = dictionary["VolumesModifications"] as? [[String: Any]] {
                self.volumesModifications = try volumesModifications.map({ try VolumeModification(dictionary: $0) })
            }
        }
    }

    public struct DescribeVpcClassicLinkRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    is-classic-link-enabled - Whether the VPC is enabled for ClassicLink (true | false).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public var filters: [Filter]? = nil
        /// One or more VPCs for which you want to describe the ClassicLink status.
        public var vpcIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, vpcIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcIds = vpcIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let vpcIds = dictionary["VpcIds"] as? [String] {
                self.vpcIds = vpcIds
            }
        }
    }

    public struct DescribeVolumeAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the volume.
        public var volumeId: String = ""
        /// The instance attribute.
        public var attribute: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, volumeId: String, attribute: String? = nil) {
            self.dryRun = dryRun
            self.volumeId = volumeId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.attribute = dictionary["Attribute"] as? String
        }
    }

    public struct GetPasswordDataRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Windows instance.
        public var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReportInstanceStatusRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time at which the reported instance health state began.
        public var startTime: Date? = nil
        /// The status of all instances listed.
        public var status: String = ""
        /// The time at which the reported instance health state ended.
        public var endTime: Date? = nil
        /// One or more instances.
        public var instances: [String] = []
        /// One or more reason codes that describes the health state of your instance.    instance-stuck-in-state: My instance is stuck in a state.    unresponsive: My instance is unresponsive.    not-accepting-credentials: My instance is not accepting my credentials.    password-not-available: A password is not available for my instance.    performance-network: My instance is experiencing performance problems which I believe are network related.    performance-instance-store: My instance is experiencing performance problems which I believe are related to the instance stores.    performance-ebs-volume: My instance is experiencing performance problems which I believe are related to an EBS volume.    performance-other: My instance is experiencing performance problems.    other: [explain using the description parameter]  
        public var reasonCodes: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Descriptive text about the health state of your instance.
        public var description: String? = nil

        public init() {}

        public init(startTime: Date? = nil, status: String, endTime: Date? = nil, instances: [String], reasonCodes: [String], dryRun: Bool? = nil, description: String? = nil) {
            self.startTime = startTime
            self.status = status
            self.endTime = endTime
            self.instances = instances
            self.reasonCodes = reasonCodes
            self.dryRun = dryRun
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            guard let status = dictionary["Status"] as? String else { throw InitializableError.missingRequiredParam("Status") }
            self.status = status
            self.endTime = dictionary["EndTime"] as? Date
            guard let instances = dictionary["Instances"] as? [String] else { throw InitializableError.missingRequiredParam("Instances") }
            self.instances = instances
            guard let reasonCodes = dictionary["ReasonCodes"] as? [String] else { throw InitializableError.missingRequiredParam("ReasonCodes") }
            self.reasonCodes = reasonCodes
            self.dryRun = dictionary["DryRun"] as? Bool
            self.description = dictionary["Description"] as? String
        }
    }

    public struct AllocateHostsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the allocated Dedicated Host. This is used when you want to launch an instance onto a specific host.
        public var hostIds: [String]? = nil

        public init() {}

        public init(hostIds: [String]? = nil) {
            self.hostIds = hostIds
        }

        public init(dictionary: [String: Any]) throws {
            if let hostIds = dictionary["HostIds"] as? [String] {
                self.hostIds = hostIds
            }
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        public var value: String? = nil
        /// The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws: 
        public var key: String? = nil

        public init() {}

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct DescribeRegionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The names of one or more regions.
        public var regionNames: [String]? = nil
        /// One or more filters.    endpoint - The endpoint of the region (for example, ec2.us-east-1.amazonaws.com).    region-name - The name of the region (for example, us-east-1).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(regionNames: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.regionNames = regionNames
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let regionNames = dictionary["RegionNames"] as? [String] {
                self.regionNames = regionNames
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct TagDescription: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The tag key.
        public var key: String? = nil
        /// The ID of the resource. For example, ami-1a2b3c4d.
        public var resourceId: String? = nil
        /// The tag value.
        public var value: String? = nil
        /// The resource type.
        public var resourceType: String? = nil

        public init() {}

        public init(key: String? = nil, resourceId: String? = nil, value: String? = nil, resourceType: String? = nil) {
            self.key = key
            self.resourceId = resourceId
            self.value = value
            self.resourceType = resourceType
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            self.resourceId = dictionary["ResourceId"] as? String
            self.value = dictionary["Value"] as? String
            self.resourceType = dictionary["ResourceType"] as? String
        }
    }

    public struct ProvisionedBandwidth: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public var provisioned: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public var status: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public var requestTime: Date? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public var provisionTime: Date? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public var requested: String? = nil

        public init() {}

        public init(provisioned: String? = nil, status: String? = nil, requestTime: Date? = nil, provisionTime: Date? = nil, requested: String? = nil) {
            self.provisioned = provisioned
            self.status = status
            self.requestTime = requestTime
            self.provisionTime = provisionTime
            self.requested = requested
        }

        public init(dictionary: [String: Any]) throws {
            self.provisioned = dictionary["Provisioned"] as? String
            self.status = dictionary["Status"] as? String
            self.requestTime = dictionary["RequestTime"] as? Date
            self.provisionTime = dictionary["ProvisionTime"] as? Date
            self.requested = dictionary["Requested"] as? String
        }
    }

    public struct DescribeSnapshotAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the EBS snapshot.
        public var snapshotId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The snapshot attribute you would like to view.
        public var attribute: String = ""

        public init() {}

        public init(snapshotId: String, dryRun: Bool? = nil, attribute: String) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct DescribeSpotDatafeedSubscriptionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeSnapshotAttributeResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of permissions for creating volumes from the snapshot.
        public var createVolumePermissions: [CreateVolumePermission]? = nil
        /// A list of product codes.
        public var productCodes: [ProductCode]? = nil
        /// The ID of the EBS snapshot.
        public var snapshotId: String? = nil

        public init() {}

        public init(createVolumePermissions: [CreateVolumePermission]? = nil, productCodes: [ProductCode]? = nil, snapshotId: String? = nil) {
            self.createVolumePermissions = createVolumePermissions
            self.productCodes = productCodes
            self.snapshotId = snapshotId
        }

        public init(dictionary: [String: Any]) throws {
            if let createVolumePermissions = dictionary["CreateVolumePermissions"] as? [[String: Any]] {
                self.createVolumePermissions = try createVolumePermissions.map({ try CreateVolumePermission(dictionary: $0) })
            }
            if let productCodes = dictionary["ProductCodes"] as? [[String: Any]] {
                self.productCodes = try productCodes.map({ try ProductCode(dictionary: $0) })
            }
            self.snapshotId = dictionary["SnapshotId"] as? String
        }
    }

    public struct RecurringCharge: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The frequency of the recurring charge.
        public var frequency: String? = nil
        /// The amount of the recurring charge.
        public var amount: Double? = nil

        public init() {}

        public init(frequency: String? = nil, amount: Double? = nil) {
            self.frequency = frequency
            self.amount = amount
        }

        public init(dictionary: [String: Any]) throws {
            self.frequency = dictionary["Frequency"] as? String
            self.amount = dictionary["Amount"] as? Double
        }
    }

    public struct DeleteVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpcPeeringConnectionId") }
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

    public struct DescribeAvailabilityZonesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The names of one or more Availability Zones.
        public var zoneNames: [String]? = nil
        /// One or more filters.    message - Information about the Availability Zone.    region-name - The name of the region for the Availability Zone (for example, us-east-1).    state - The state of the Availability Zone (available | information | impaired | unavailable).    zone-name - The name of the Availability Zone (for example, us-east-1a).  
        public var filters: [Filter]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, zoneNames: [String]? = nil, filters: [Filter]? = nil) {
            self.dryRun = dryRun
            self.zoneNames = zoneNames
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let zoneNames = dictionary["ZoneNames"] as? [String] {
                self.zoneNames = zoneNames
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct AssociateRouteTableResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The route table association ID (needed to disassociate the route table).
        public var associationId: String? = nil

        public init() {}

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct IcmpTypeCode: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ICMP type. A value of -1 means all types.
        public var type: Int32? = nil
        /// The ICMP code. A value of -1 means all codes for the specified ICMP type.
        public var code: Int32? = nil

        public init() {}

        public init(type: Int32? = nil, code: Int32? = nil) {
            self.type = type
            self.code = code
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["Type"] as? Int32
            self.code = dictionary["Code"] as? Int32
        }
    }

    public struct DeleteFlowLogsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more flow log IDs.
        public var flowLogIds: [String] = []

        public init() {}

        public init(flowLogIds: [String]) {
            self.flowLogIds = flowLogIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let flowLogIds = dictionary["FlowLogIds"] as? [String] else { throw InitializableError.missingRequiredParam("FlowLogIds") }
            self.flowLogIds = flowLogIds
        }
    }

    public struct DescribeVpnConnectionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more VPN connection IDs. Default: Describes your VPN connections.
        public var vpnConnectionIds: [String]? = nil
        /// One or more filters.    customer-gateway-configuration - The configuration information for the customer gateway.    customer-gateway-id - The ID of a customer gateway associated with the VPN connection.    state - The state of the VPN connection (pending | available | deleting | deleted).    option.static-routes-only - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).    route.destination-cidr-block - The destination CIDR block. This corresponds to the subnet used in a customer data center.    bgp-asn - The BGP Autonomous System Number (ASN) associated with a BGP device.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of VPN connection. Currently the only supported type is ipsec.1.    vpn-connection-id - The ID of the VPN connection.    vpn-gateway-id - The ID of a virtual private gateway associated with the VPN connection.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpnConnectionIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.vpnConnectionIds = vpnConnectionIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnConnectionIds = dictionary["VpnConnectionIds"] as? [String] {
                self.vpnConnectionIds = vpnConnectionIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReservedInstanceLimitPrice: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The currency in which the limitPrice amount is specified. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).
        public var amount: Double? = nil

        public init() {}

        public init(currencyCode: String? = nil, amount: Double? = nil) {
            self.currencyCode = currencyCode
            self.amount = amount
        }

        public init(dictionary: [String: Any]) throws {
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.amount = dictionary["Amount"] as? Double
        }
    }

    public struct NewDhcpConfiguration: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var key: String? = nil
        public var values: [String]? = nil

        public init() {}

        public init(key: String? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            if let values = dictionary["Values"] as? [String] {
                self.values = values
            }
        }
    }

    public struct NetworkAclEntry: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv4 network range to allow or deny, in CIDR notation.
        public var cidrBlock: String? = nil
        /// ICMP protocol: The ICMP type and code.
        public var icmpTypeCode: IcmpTypeCode? = nil
        /// The rule number for the entry. ACL entries are processed in ascending order by rule number.
        public var ruleNumber: Int32? = nil
        /// The protocol. A value of -1 means all protocols.
        public var `protocol`: String? = nil
        /// Indicates whether to allow or deny the traffic that matches the rule.
        public var ruleAction: String? = nil
        /// Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).
        public var egress: Bool? = nil
        /// The IPv6 network range to allow or deny, in CIDR notation.
        public var ipv6CidrBlock: String? = nil
        /// TCP or UDP protocols: The range of ports the rule applies to.
        public var portRange: PortRange? = nil

        public init() {}

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32? = nil, protocol: String? = nil, ruleAction: String? = nil, egress: Bool? = nil, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrBlock = dictionary["CidrBlock"] as? String
            if let icmpTypeCode = dictionary["IcmpTypeCode"] as? [String: Any] { self.icmpTypeCode = try Ec2.IcmpTypeCode(dictionary: icmpTypeCode) }
            self.ruleNumber = dictionary["RuleNumber"] as? Int32
            self.`protocol` = dictionary["Protocol"] as? String
            self.ruleAction = dictionary["RuleAction"] as? String
            self.egress = dictionary["Egress"] as? Bool
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            if let portRange = dictionary["PortRange"] as? [String: Any] { self.portRange = try Ec2.PortRange(dictionary: portRange) }
        }
    }

    public struct Vpc: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the VPC is the default VPC.
        public var isDefault: Bool? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// The current state of the VPC.
        public var state: String? = nil
        /// Any tags assigned to the VPC.
        public var tags: [Tag]? = nil
        /// The ID of the set of DHCP options you've associated with the VPC (or default if the default options are associated with the VPC).
        public var dhcpOptionsId: String? = nil
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        public var ipv6CidrBlockAssociationSet: [VpcIpv6CidrBlockAssociation]? = nil
        /// The allowed tenancy of instances launched into the VPC.
        public var instanceTenancy: String? = nil
        /// The IPv4 CIDR block for the VPC.
        public var cidrBlock: String? = nil

        public init() {}

        public init(isDefault: Bool? = nil, vpcId: String? = nil, state: String? = nil, tags: [Tag]? = nil, dhcpOptionsId: String? = nil, ipv6CidrBlockAssociationSet: [VpcIpv6CidrBlockAssociation]? = nil, instanceTenancy: String? = nil, cidrBlock: String? = nil) {
            self.isDefault = isDefault
            self.vpcId = vpcId
            self.state = state
            self.tags = tags
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.instanceTenancy = instanceTenancy
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.isDefault = dictionary["IsDefault"] as? Bool
            self.vpcId = dictionary["VpcId"] as? String
            self.state = dictionary["State"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.dhcpOptionsId = dictionary["DhcpOptionsId"] as? String
            if let ipv6CidrBlockAssociationSet = dictionary["Ipv6CidrBlockAssociationSet"] as? [[String: Any]] {
                self.ipv6CidrBlockAssociationSet = try ipv6CidrBlockAssociationSet.map({ try VpcIpv6CidrBlockAssociation(dictionary: $0) })
            }
            self.instanceTenancy = dictionary["InstanceTenancy"] as? String
            self.cidrBlock = dictionary["CidrBlock"] as? String
        }
    }

    public struct AvailabilityZoneMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The message about the Availability Zone.
        public var message: String? = nil

        public init() {}

        public init(message: String? = nil) {
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DescribeStaleSecurityGroupsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.
        public var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, vpcId: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct RestoreAddressToClassicRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The Elastic IP address.
        public var publicIp: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, publicIp: String) {
            self.dryRun = dryRun
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let publicIp = dictionary["PublicIp"] as? String else { throw InitializableError.missingRequiredParam("PublicIp") }
            self.publicIp = publicIp
        }
    }

    public struct RouteTable: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The routes in the route table.
        public var routes: [Route]? = nil
        /// Any virtual private gateway (VGW) propagating routes.
        public var propagatingVgws: [PropagatingVgw]? = nil
        /// The ID of the route table.
        public var routeTableId: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// Any tags assigned to the route table.
        public var tags: [Tag]? = nil
        /// The associations between the route table and one or more subnets.
        public var associations: [RouteTableAssociation]? = nil

        public init() {}

        public init(routes: [Route]? = nil, propagatingVgws: [PropagatingVgw]? = nil, routeTableId: String? = nil, vpcId: String? = nil, tags: [Tag]? = nil, associations: [RouteTableAssociation]? = nil) {
            self.routes = routes
            self.propagatingVgws = propagatingVgws
            self.routeTableId = routeTableId
            self.vpcId = vpcId
            self.tags = tags
            self.associations = associations
        }

        public init(dictionary: [String: Any]) throws {
            if let routes = dictionary["Routes"] as? [[String: Any]] {
                self.routes = try routes.map({ try Route(dictionary: $0) })
            }
            if let propagatingVgws = dictionary["PropagatingVgws"] as? [[String: Any]] {
                self.propagatingVgws = try propagatingVgws.map({ try PropagatingVgw(dictionary: $0) })
            }
            self.routeTableId = dictionary["RouteTableId"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            if let associations = dictionary["Associations"] as? [[String: Any]] {
                self.associations = try associations.map({ try RouteTableAssociation(dictionary: $0) })
            }
        }
    }

    public struct VolumeStatusEvent: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The earliest start time of the event.
        public var notBefore: Date? = nil
        /// The type of this event.
        public var eventType: String? = nil
        /// The latest end time of the event.
        public var notAfter: Date? = nil
        /// The ID of this event.
        public var eventId: String? = nil
        /// A description of the event.
        public var description: String? = nil

        public init() {}

        public init(notBefore: Date? = nil, eventType: String? = nil, notAfter: Date? = nil, eventId: String? = nil, description: String? = nil) {
            self.notBefore = notBefore
            self.eventType = eventType
            self.notAfter = notAfter
            self.eventId = eventId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.notBefore = dictionary["NotBefore"] as? Date
            self.eventType = dictionary["EventType"] as? String
            self.notAfter = dictionary["NotAfter"] as? Date
            self.eventId = dictionary["EventId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ModifyVpcEndpointRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more route tables IDs to associate with the endpoint.
        public var addRouteTableIds: [String]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the endpoint.
        public var vpcEndpointId: String = ""
        /// A policy document to attach to the endpoint. The policy must be in valid JSON format.
        public var policyDocument: String? = nil
        /// Specify true to reset the policy document to the default policy. The default policy allows access to the service.
        public var resetPolicy: Bool? = nil
        /// One or more route table IDs to disassociate from the endpoint.
        public var removeRouteTableIds: [String]? = nil

        public init() {}

        public init(addRouteTableIds: [String]? = nil, dryRun: Bool? = nil, vpcEndpointId: String, policyDocument: String? = nil, resetPolicy: Bool? = nil, removeRouteTableIds: [String]? = nil) {
            self.addRouteTableIds = addRouteTableIds
            self.dryRun = dryRun
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = policyDocument
            self.resetPolicy = resetPolicy
            self.removeRouteTableIds = removeRouteTableIds
        }

        public init(dictionary: [String: Any]) throws {
            if let addRouteTableIds = dictionary["AddRouteTableIds"] as? [String] {
                self.addRouteTableIds = addRouteTableIds
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcEndpointId = dictionary["VpcEndpointId"] as? String else { throw InitializableError.missingRequiredParam("VpcEndpointId") }
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = dictionary["PolicyDocument"] as? String
            self.resetPolicy = dictionary["ResetPolicy"] as? Bool
            if let removeRouteTableIds = dictionary["RemoveRouteTableIds"] as? [String] {
                self.removeRouteTableIds = removeRouteTableIds
            }
        }
    }

    public struct VpcClassicLink: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// Any tags assigned to the VPC.
        public var tags: [Tag]? = nil
        /// Indicates whether the VPC is enabled for ClassicLink.
        public var classicLinkEnabled: Bool? = nil

        public init() {}

        public init(vpcId: String? = nil, tags: [Tag]? = nil, classicLinkEnabled: Bool? = nil) {
            self.vpcId = vpcId
            self.tags = tags
            self.classicLinkEnabled = classicLinkEnabled
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.classicLinkEnabled = dictionary["ClassicLinkEnabled"] as? Bool
        }
    }

    public struct DisassociateIamInstanceProfileRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the IAM instance profile association.
        public var associationId: String = ""

        public init() {}

        public init(associationId: String) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct DescribeHostReservationOfferingsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the offerings.
        public var offeringSet: [HostOffering]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(offeringSet: [HostOffering]? = nil, nextToken: String? = nil) {
            self.offeringSet = offeringSet
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let offeringSet = dictionary["OfferingSet"] as? [[String: Any]] {
                self.offeringSet = try offeringSet.map({ try HostOffering(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct VpcCidrBlockState: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The state of the CIDR block.
        public var state: String? = nil
        /// A message about the status of the CIDR block, if applicable.
        public var statusMessage: String? = nil

        public init() {}

        public init(state: String? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.state = dictionary["State"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct NetworkAclAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// The ID of the association between a network ACL and a subnet.
        public var networkAclAssociationId: String? = nil
        /// The ID of the network ACL.
        public var networkAclId: String? = nil

        public init() {}

        public init(subnetId: String? = nil, networkAclAssociationId: String? = nil, networkAclId: String? = nil) {
            self.subnetId = subnetId
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkAclAssociationId = dictionary["NetworkAclAssociationId"] as? String
            self.networkAclId = dictionary["NetworkAclId"] as? String
        }
    }

    public struct DeleteNatGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the NAT gateway.
        public var natGatewayId: String = ""

        public init() {}

        public init(natGatewayId: String) {
            self.natGatewayId = natGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let natGatewayId = dictionary["NatGatewayId"] as? String else { throw InitializableError.missingRequiredParam("NatGatewayId") }
            self.natGatewayId = natGatewayId
        }
    }

    public struct PurchaseScheduledInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the Scheduled Instances.
        public var scheduledInstanceSet: [ScheduledInstance]? = nil

        public init() {}

        public init(scheduledInstanceSet: [ScheduledInstance]? = nil) {
            self.scheduledInstanceSet = scheduledInstanceSet
        }

        public init(dictionary: [String: Any]) throws {
            if let scheduledInstanceSet = dictionary["ScheduledInstanceSet"] as? [[String: Any]] {
                self.scheduledInstanceSet = try scheduledInstanceSet.map({ try ScheduledInstance(dictionary: $0) })
            }
        }
    }

    public struct DescribeVolumeStatusResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// A list of volumes.
        public var volumeStatuses: [VolumeStatusItem]? = nil

        public init() {}

        public init(nextToken: String? = nil, volumeStatuses: [VolumeStatusItem]? = nil) {
            self.nextToken = nextToken
            self.volumeStatuses = volumeStatuses
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let volumeStatuses = dictionary["VolumeStatuses"] as? [[String: Any]] {
                self.volumeStatuses = try volumeStatuses.map({ try VolumeStatusItem(dictionary: $0) })
            }
        }
    }

    public struct AvailableCapacity: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The total number of instances that the Dedicated Host supports.
        public var availableInstanceCapacity: [InstanceCapacity]? = nil
        /// The number of vCPUs available on the Dedicated Host.
        public var availableVCpus: Int32? = nil

        public init() {}

        public init(availableInstanceCapacity: [InstanceCapacity]? = nil, availableVCpus: Int32? = nil) {
            self.availableInstanceCapacity = availableInstanceCapacity
            self.availableVCpus = availableVCpus
        }

        public init(dictionary: [String: Any]) throws {
            if let availableInstanceCapacity = dictionary["AvailableInstanceCapacity"] as? [[String: Any]] {
                self.availableInstanceCapacity = try availableInstanceCapacity.map({ try InstanceCapacity(dictionary: $0) })
            }
            self.availableVCpus = dictionary["AvailableVCpus"] as? Int32
        }
    }

    public struct SpotPrice: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date and time the request was created, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var timestamp: Date? = nil
        /// The instance type. Note that T2 and HS1 instance types are not supported.
        public var instanceType: String? = nil
        /// The Availability Zone.
        public var availabilityZone: String? = nil
        /// The maximum price (bid) that you are willing to pay for a Spot instance.
        public var spotPrice: String? = nil
        /// A general description of the AMI.
        public var productDescription: String? = nil

        public init() {}

        public init(timestamp: Date? = nil, instanceType: String? = nil, availabilityZone: String? = nil, spotPrice: String? = nil, productDescription: String? = nil) {
            self.timestamp = timestamp
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.spotPrice = spotPrice
            self.productDescription = productDescription
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.instanceType = dictionary["InstanceType"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.spotPrice = dictionary["SpotPrice"] as? String
            self.productDescription = dictionary["ProductDescription"] as? String
        }
    }

    public struct ReservedInstancesConfiguration: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.
        public var platform: String? = nil
        /// The number of modified Reserved Instances.
        public var instanceCount: Int32? = nil
        /// The instance type for the modified Reserved Instances.
        public var instanceType: String? = nil
        /// The Availability Zone for the modified Reserved Instances.
        public var availabilityZone: String? = nil
        /// Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.
        public var scope: String? = nil

        public init() {}

        public init(platform: String? = nil, instanceCount: Int32? = nil, instanceType: String? = nil, availabilityZone: String? = nil, scope: String? = nil) {
            self.platform = platform
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.scope = scope
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.instanceType = dictionary["InstanceType"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.scope = dictionary["Scope"] as? String
        }
    }

    public struct CreatePlacementGroupRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The placement strategy.
        public var strategy: String = ""
        /// A name for the placement group. Constraints: Up to 255 ASCII characters
        public var groupName: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, strategy: String, groupName: String) {
            self.dryRun = dryRun
            self.strategy = strategy
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let strategy = dictionary["Strategy"] as? String else { throw InitializableError.missingRequiredParam("Strategy") }
            self.strategy = strategy
            guard let groupName = dictionary["GroupName"] as? String else { throw InitializableError.missingRequiredParam("GroupName") }
            self.groupName = groupName
        }
    }

    public struct DescribeSecurityGroupReferencesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more security group IDs in your account.
        public var groupId: [String] = []
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(groupId: [String], dryRun: Bool? = nil) {
            self.groupId = groupId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let groupId = dictionary["GroupId"] as? [String] else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVolumesModificationsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more volume IDs for which in-progress modifications will be described.
        public var volumeIds: [String]? = nil
        /// One or more filters. Supported filters: volume-id, modification-state, target-size, target-iops, target-volume-type, original-size, original-iops, original-volume-type, start-time. 
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The nextToken value returned by a previous paginated request.
        public var nextToken: String? = nil
        /// The maximum number of results (up to a limit of 500) to be returned in a paginated request.
        public var maxResults: Int32? = nil

        public init() {}

        public init(volumeIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeIds = dictionary["VolumeIds"] as? [String] {
                self.volumeIds = volumeIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ImageAttribute: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more block device mapping entries.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// One or more product codes.
        public var productCodes: [ProductCode]? = nil
        /// One or more launch permissions.
        public var launchPermissions: [LaunchPermission]? = nil
        /// Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public var sriovNetSupport: AttributeValue? = nil
        /// The kernel ID.
        public var kernelId: AttributeValue? = nil
        /// The ID of the AMI.
        public var imageId: String? = nil
        /// The RAM disk ID.
        public var ramdiskId: AttributeValue? = nil
        /// A description for the AMI.
        public var description: AttributeValue? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, productCodes: [ProductCode]? = nil, launchPermissions: [LaunchPermission]? = nil, sriovNetSupport: AttributeValue? = nil, kernelId: AttributeValue? = nil, imageId: String? = nil, ramdiskId: AttributeValue? = nil, description: AttributeValue? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.productCodes = productCodes
            self.launchPermissions = launchPermissions
            self.sriovNetSupport = sriovNetSupport
            self.kernelId = kernelId
            self.imageId = imageId
            self.ramdiskId = ramdiskId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            if let productCodes = dictionary["ProductCodes"] as? [[String: Any]] {
                self.productCodes = try productCodes.map({ try ProductCode(dictionary: $0) })
            }
            if let launchPermissions = dictionary["LaunchPermissions"] as? [[String: Any]] {
                self.launchPermissions = try launchPermissions.map({ try LaunchPermission(dictionary: $0) })
            }
            if let sriovNetSupport = dictionary["SriovNetSupport"] as? [String: Any] { self.sriovNetSupport = try Ec2.AttributeValue(dictionary: sriovNetSupport) }
            if let kernelId = dictionary["KernelId"] as? [String: Any] { self.kernelId = try Ec2.AttributeValue(dictionary: kernelId) }
            self.imageId = dictionary["ImageId"] as? String
            if let ramdiskId = dictionary["RamdiskId"] as? [String: Any] { self.ramdiskId = try Ec2.AttributeValue(dictionary: ramdiskId) }
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) }
        }
    }

    public struct CreateInstanceExportTaskRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The target virtualization environment.
        public var targetEnvironment: String? = nil
        /// The format and location for an instance export task.
        public var exportToS3Task: ExportToS3TaskSpecification? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// A description for the conversion task or the resource being exported. The maximum length is 255 bytes.
        public var description: String? = nil

        public init() {}

        public init(targetEnvironment: String? = nil, exportToS3Task: ExportToS3TaskSpecification? = nil, instanceId: String, description: String? = nil) {
            self.targetEnvironment = targetEnvironment
            self.exportToS3Task = exportToS3Task
            self.instanceId = instanceId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.targetEnvironment = dictionary["TargetEnvironment"] as? String
            if let exportToS3Task = dictionary["ExportToS3Task"] as? [String: Any] { self.exportToS3Task = try Ec2.ExportToS3TaskSpecification(dictionary: exportToS3Task) }
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateFlowLogsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of traffic to log.
        public var trafficType: String = ""
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        public var clientToken: String? = nil
        /// One or more subnet, network interface, or VPC IDs. Constraints: Maximum of 1000 resources
        public var resourceIds: [String] = []
        /// The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group.
        public var deliverLogsPermissionArn: String = ""
        /// The type of resource on which to create the flow log.
        public var resourceType: String = ""
        /// The name of the CloudWatch log group.
        public var logGroupName: String = ""

        public init() {}

        public init(trafficType: String, clientToken: String? = nil, resourceIds: [String], deliverLogsPermissionArn: String, resourceType: String, logGroupName: String) {
            self.trafficType = trafficType
            self.clientToken = clientToken
            self.resourceIds = resourceIds
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            self.resourceType = resourceType
            self.logGroupName = logGroupName
        }

        public init(dictionary: [String: Any]) throws {
            guard let trafficType = dictionary["TrafficType"] as? String else { throw InitializableError.missingRequiredParam("TrafficType") }
            self.trafficType = trafficType
            self.clientToken = dictionary["ClientToken"] as? String
            guard let resourceIds = dictionary["ResourceIds"] as? [String] else { throw InitializableError.missingRequiredParam("ResourceIds") }
            self.resourceIds = resourceIds
            guard let deliverLogsPermissionArn = dictionary["DeliverLogsPermissionArn"] as? String else { throw InitializableError.missingRequiredParam("DeliverLogsPermissionArn") }
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            guard let resourceType = dictionary["ResourceType"] as? String else { throw InitializableError.missingRequiredParam("ResourceType") }
            self.resourceType = resourceType
            guard let logGroupName = dictionary["LogGroupName"] as? String else { throw InitializableError.missingRequiredParam("LogGroupName") }
            self.logGroupName = logGroupName
        }
    }

    public struct ImportImageTask: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The license type of the virtual machine.
        public var licenseType: String? = nil
        /// A brief status for the import image task.
        public var status: String? = nil
        /// The description string for the import image task.
        public var platform: String? = nil
        /// The percentage of progress of the import image task.
        public var progress: String? = nil
        /// The target hypervisor for the import task. Valid values: xen 
        public var hypervisor: String? = nil
        /// The architecture of the virtual machine. Valid values: i386 | x86_64 
        public var architecture: String? = nil
        /// The ID of the Amazon Machine Image (AMI) of the imported virtual machine.
        public var imageId: String? = nil
        /// The ID of the import image task.
        public var importTaskId: String? = nil
        /// A descriptive status message for the import image task.
        public var statusMessage: String? = nil
        /// Information about the snapshots.
        public var snapshotDetails: [SnapshotDetail]? = nil
        /// A description of the import task.
        public var description: String? = nil

        public init() {}

        public init(licenseType: String? = nil, status: String? = nil, platform: String? = nil, progress: String? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, importTaskId: String? = nil, statusMessage: String? = nil, snapshotDetails: [SnapshotDetail]? = nil, description: String? = nil) {
            self.licenseType = licenseType
            self.status = status
            self.platform = platform
            self.progress = progress
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.importTaskId = importTaskId
            self.statusMessage = statusMessage
            self.snapshotDetails = snapshotDetails
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.licenseType = dictionary["LicenseType"] as? String
            self.status = dictionary["Status"] as? String
            self.platform = dictionary["Platform"] as? String
            self.progress = dictionary["Progress"] as? String
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.imageId = dictionary["ImageId"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let snapshotDetails = dictionary["SnapshotDetails"] as? [[String: Any]] {
                self.snapshotDetails = try snapshotDetails.map({ try SnapshotDetail(dictionary: $0) })
            }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVolumesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the volumes.
        public var volumes: [Volume]? = nil
        /// The NextToken value to include in a future DescribeVolumes request. When the results of a DescribeVolumes request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(volumes: [Volume]? = nil, nextToken: String? = nil) {
            self.volumes = volumes
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let volumes = dictionary["Volumes"] as? [[String: Any]] {
                self.volumes = try volumes.map({ try Volume(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct ModifyInstancePlacementRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The new affinity setting for the instance.
        public var affinity: String? = nil
        /// The ID of the Dedicated Host that the instance will have affinity with.
        public var hostId: String? = nil
        /// The ID of the instance that you are modifying.
        public var instanceId: String = ""
        /// The tenancy of the instance that you are modifying.
        public var tenancy: String? = nil

        public init() {}

        public init(affinity: String? = nil, hostId: String? = nil, instanceId: String, tenancy: String? = nil) {
            self.affinity = affinity
            self.hostId = hostId
            self.instanceId = instanceId
            self.tenancy = tenancy
        }

        public init(dictionary: [String: Any]) throws {
            self.affinity = dictionary["Affinity"] as? String
            self.hostId = dictionary["HostId"] as? String
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.tenancy = dictionary["Tenancy"] as? String
        }
    }

    public struct ScheduledInstancesLaunchSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more block device mapping entries.
        public var blockDeviceMappings: [ScheduledInstancesBlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instances.
        public var subnetId: String? = nil
        /// The base64-encoded MIME user data.
        public var userData: String? = nil
        /// Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false 
        public var ebsOptimized: Bool? = nil
        /// The ID of the kernel.
        public var kernelId: String? = nil
        /// The IDs of one or more security groups.
        public var securityGroupIds: [String]? = nil
        /// Enable or disable monitoring for the instances.
        public var monitoring: ScheduledInstancesMonitoring? = nil
        /// The instance type.
        public var instanceType: String? = nil
        /// The name of the key pair.
        public var keyName: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil
        /// The ID of the Amazon Machine Image (AMI).
        public var imageId: String = ""
        /// One or more network interfaces.
        public var networkInterfaces: [ScheduledInstancesNetworkInterface]? = nil
        /// The placement information.
        public var placement: ScheduledInstancesPlacement? = nil
        /// The ID of the RAM disk.
        public var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [ScheduledInstancesBlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, securityGroupIds: [String]? = nil, monitoring: ScheduledInstancesMonitoring? = nil, instanceType: String? = nil, keyName: String? = nil, iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil, imageId: String, networkInterfaces: [ScheduledInstancesNetworkInterface]? = nil, placement: ScheduledInstancesPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.keyName = keyName
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try ScheduledInstancesBlockDeviceMapping(dictionary: $0) })
            }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            if let securityGroupIds = dictionary["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = securityGroupIds
            }
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.ScheduledInstancesMonitoring(dictionary: monitoring) }
            self.instanceType = dictionary["InstanceType"] as? String
            self.keyName = dictionary["KeyName"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.ScheduledInstancesIamInstanceProfile(dictionary: iamInstanceProfile) }
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try ScheduledInstancesNetworkInterface(dictionary: $0) })
            }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.ScheduledInstancesPlacement(dictionary: placement) }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct DisableVpcClassicLinkRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct MoveAddressToVpcResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the move of the IP address.
        public var status: String? = nil
        /// The allocation ID for the Elastic IP address.
        public var allocationId: String? = nil

        public init() {}

        public init(status: String? = nil, allocationId: String? = nil) {
            self.status = status
            self.allocationId = allocationId
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
        }
    }

    public struct DeleteVpnConnectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPN connection.
        public var vpnConnectionId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpnConnectionId: String, dryRun: Bool? = nil) {
            self.vpnConnectionId = vpnConnectionId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpnConnectionId = dictionary["VpnConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpnConnectionId") }
            self.vpnConnectionId = vpnConnectionId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateVolumePermission: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.
        public var userId: String? = nil
        /// The specific group that is to be added or removed from a volume's list of create volume permissions.
        public var group: String? = nil

        public init() {}

        public init(userId: String? = nil, group: String? = nil) {
            self.userId = userId
            self.group = group
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            self.group = dictionary["Group"] as? String
        }
    }

    public struct CustomerGateway: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the customer gateway.
        public var customerGatewayId: String? = nil
        /// The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).
        public var bgpAsn: String? = nil
        /// The type of VPN connection the customer gateway supports (ipsec.1).
        public var type: String? = nil
        /// Any tags assigned to the customer gateway.
        public var tags: [Tag]? = nil
        /// The current state of the customer gateway (pending | available | deleting | deleted).
        public var state: String? = nil
        /// The Internet-routable IP address of the customer gateway's outside interface.
        public var ipAddress: String? = nil

        public init() {}

        public init(customerGatewayId: String? = nil, bgpAsn: String? = nil, type: String? = nil, tags: [Tag]? = nil, state: String? = nil, ipAddress: String? = nil) {
            self.customerGatewayId = customerGatewayId
            self.bgpAsn = bgpAsn
            self.type = type
            self.tags = tags
            self.state = state
            self.ipAddress = ipAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.customerGatewayId = dictionary["CustomerGatewayId"] as? String
            self.bgpAsn = dictionary["BgpAsn"] as? String
            self.type = dictionary["Type"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.state = dictionary["State"] as? String
            self.ipAddress = dictionary["IpAddress"] as? String
        }
    }

    public struct DescribeAccountAttributesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more account attribute names.
        public var attributeNames: [String]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(attributeNames: [String]? = nil, dryRun: Bool? = nil) {
            self.attributeNames = attributeNames
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeNames = dictionary["AttributeNames"] as? [String] {
                self.attributeNames = attributeNames
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of VPN connection this virtual private gateway supports.
        public var type: String = ""
        /// The Availability Zone for the virtual private gateway.
        public var availabilityZone: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(type: String, availabilityZone: String? = nil, dryRun: Bool? = nil) {
            self.type = type
            self.availabilityZone = availabilityZone
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let type = dictionary["Type"] as? String else { throw InitializableError.missingRequiredParam("Type") }
            self.type = type
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DeleteSpotDatafeedSubscriptionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct Route: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the egress-only Internet gateway.
        public var egressOnlyInternetGatewayId: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The ID of a NAT gateway.
        public var natGatewayId: String? = nil
        /// Describes how the route was created.    CreateRouteTable - The route was automatically created when the route table was created.    CreateRoute - The route was manually added to the route table.    EnableVgwRoutePropagation - The route was propagated by route propagation.  
        public var origin: String? = nil
        /// The state of the route. The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).
        public var state: String? = nil
        /// The IPv6 CIDR block used for the destination match.
        public var destinationIpv6CidrBlock: String? = nil
        /// The prefix of the AWS service.
        public var destinationPrefixListId: String? = nil
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String? = nil
        /// The ID of a NAT instance in your VPC.
        public var instanceId: String? = nil
        /// The AWS account ID of the owner of the instance.
        public var instanceOwnerId: String? = nil
        /// The ID of a gateway attached to your VPC.
        public var gatewayId: String? = nil
        /// The IPv4 CIDR block used for the destination match.
        public var destinationCidrBlock: String? = nil

        public init() {}

        public init(egressOnlyInternetGatewayId: String? = nil, networkInterfaceId: String? = nil, natGatewayId: String? = nil, origin: String? = nil, state: String? = nil, destinationIpv6CidrBlock: String? = nil, destinationPrefixListId: String? = nil, vpcPeeringConnectionId: String? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.natGatewayId = natGatewayId
            self.origin = origin
            self.state = state
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.origin = dictionary["Origin"] as? String
            self.state = dictionary["State"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
            self.destinationPrefixListId = dictionary["DestinationPrefixListId"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.instanceOwnerId = dictionary["InstanceOwnerId"] as? String
            self.gatewayId = dictionary["GatewayId"] as? String
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
        }
    }

    public struct CancelSpotFleetRequestsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the Spot fleet requests that are successfully canceled.
        public var successfulFleetRequests: [CancelSpotFleetRequestsSuccessItem]? = nil
        /// Information about the Spot fleet requests that are not successfully canceled.
        public var unsuccessfulFleetRequests: [CancelSpotFleetRequestsErrorItem]? = nil

        public init() {}

        public init(successfulFleetRequests: [CancelSpotFleetRequestsSuccessItem]? = nil, unsuccessfulFleetRequests: [CancelSpotFleetRequestsErrorItem]? = nil) {
            self.successfulFleetRequests = successfulFleetRequests
            self.unsuccessfulFleetRequests = unsuccessfulFleetRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let successfulFleetRequests = dictionary["SuccessfulFleetRequests"] as? [[String: Any]] {
                self.successfulFleetRequests = try successfulFleetRequests.map({ try CancelSpotFleetRequestsSuccessItem(dictionary: $0) })
            }
            if let unsuccessfulFleetRequests = dictionary["UnsuccessfulFleetRequests"] as? [[String: Any]] {
                self.unsuccessfulFleetRequests = try unsuccessfulFleetRequests.map({ try CancelSpotFleetRequestsErrorItem(dictionary: $0) })
            }
        }
    }

    public struct DeleteSecurityGroupRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the security group. Required for a nondefault VPC.
        public var groupId: String? = nil
        /// [EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.
        public var groupName: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, groupId: String? = nil, groupName: String? = nil) {
            self.dryRun = dryRun
            self.groupId = groupId
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.groupId = dictionary["GroupId"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct CreateVpcResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPC.
        public var vpc: Vpc? = nil

        public init() {}

        public init(vpc: Vpc? = nil) {
            self.vpc = vpc
        }

        public init(dictionary: [String: Any]) throws {
            if let vpc = dictionary["Vpc"] as? [String: Any] { self.vpc = try Ec2.Vpc(dictionary: vpc) }
        }
    }

    public struct DescribeInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    affinity - The affinity setting for an instance running on a Dedicated Host (default | host).    architecture - The instance architecture (i386 | x86_64).    association.public-ip - The address of the Elastic IP address (IPv4) bound to the network interface.    association.ip-owner-id - The owner of the Elastic IP address (IPv4) associated with the network interface.    association.allocation-id - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.    association.association-id - The association ID returned when the network interface was associated with an IPv4 address.    availability-zone - The Availability Zone of the instance.    block-device-mapping.attach-time - The attach time for an EBS volume mapped to the instance, for example, 2010-09-15T17:15:20.000Z.    block-device-mapping.delete-on-termination - A Boolean that indicates whether the EBS volume is deleted on instance termination.    block-device-mapping.device-name - The device name for the EBS volume (for example, /dev/sdh or xvdh).    block-device-mapping.status - The status for the EBS volume (attaching | attached | detaching | detached).    block-device-mapping.volume-id - The volume ID of the EBS volume.    client-token - The idempotency token you provided when you launched the instance.    dns-name - The public DNS name of the instance.    group-id - The ID of the security group for the instance. EC2-Classic only.    group-name - The name of the security group for the instance. EC2-Classic only.    host-id - The ID of the Dedicated Host on which the instance is running, if applicable.    hypervisor - The hypervisor type of the instance (ovm | xen).    iam-instance-profile.arn - The instance profile associated with the instance. Specified as an ARN.    image-id - The ID of the image used to launch the instance.    instance-id - The ID of the instance.    instance-lifecycle - Indicates whether this is a Spot Instance or a Scheduled Instance (spot | scheduled).    instance-state-code - The state of the instance, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).    instance-state-name - The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).    instance-type - The type of instance (for example, t2.micro).    instance.group-id - The ID of the security group for the instance.     instance.group-name - The name of the security group for the instance.     ip-address - The public IPv4 address of the instance.    kernel-id - The kernel ID.    key-name - The name of the key pair used when the instance was launched.    launch-index - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on).     launch-time - The time when the instance was launched.    monitoring-state - Indicates whether detailed monitoring is enabled (disabled | enabled).    network-interface.addresses.private-ip-address - The private IPv4 address associated with the network interface.    network-interface.addresses.primary - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.    network-interface.addresses.association.public-ip - The ID of the association of an Elastic IP address (IPv4) with a network interface.    network-interface.addresses.association.ip-owner-id - The owner ID of the private IPv4 address associated with the network interface.    network-interface.attachment.attachment-id - The ID of the interface attachment.    network-interface.attachment.instance-id - The ID of the instance to which the network interface is attached.    network-interface.attachment.instance-owner-id - The owner ID of the instance to which the network interface is attached.    network-interface.attachment.device-index - The device index to which the network interface is attached.    network-interface.attachment.status - The status of the attachment (attaching | attached | detaching | detached).    network-interface.attachment.attach-time - The time that the network interface was attached to an instance.    network-interface.attachment.delete-on-termination - Specifies whether the attachment is deleted when an instance is terminated.    network-interface.availability-zone - The Availability Zone for the network interface.    network-interface.description - The description of the network interface.    network-interface.group-id - The ID of a security group associated with the network interface.    network-interface.group-name - The name of a security group associated with the network interface.    network-interface.ipv6-addresses.ipv6-address - The IPv6 address associated with the network interface.    network-interface.mac-address - The MAC address of the network interface.    network-interface.network-interface-id - The ID of the network interface.    network-interface.owner-id - The ID of the owner of the network interface.    network-interface.private-dns-name - The private DNS name of the network interface.    network-interface.requester-id - The requester ID for the network interface.    network-interface.requester-managed - Indicates whether the network interface is being managed by AWS.    network-interface.status - The status of the network interface (available) | in-use).    network-interface.source-dest-check - Whether the network interface performs source/destination checking. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the network interface to perform network address translation (NAT) in your VPC.    network-interface.subnet-id - The ID of the subnet for the network interface.    network-interface.vpc-id - The ID of the VPC for the network interface.    owner-id - The AWS account ID of the instance owner.    placement-group-name - The name of the placement group for the instance.    platform - The platform. Use windows if you have Windows instances; otherwise, leave blank.    private-dns-name - The private IPv4 DNS name of the instance.    private-ip-address - The private IPv4 address of the instance.    product-code - The product code associated with the AMI used to launch the instance.    product-code.type - The type of product code (devpay | marketplace).    ramdisk-id - The RAM disk ID.    reason - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.    requester-id - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).    reservation-id - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you'll get one reservation ID. If you launch ten instances using the same launch request, you'll also get one reservation ID.    root-device-name - The name of the root device for the instance (for example, /dev/sda1 or /dev/xvda).    root-device-type - The type of root device that the instance uses (ebs | instance-store).    source-dest-check - Indicates whether the instance performs source/destination checking. A value of true means that checking is enabled, and false means checking is disabled. The value must be false for the instance to perform network address translation (NAT) in your VPC.     spot-instance-request-id - The ID of the Spot instance request.    state-reason-code - The reason code for the state change.    state-reason-message - A message that describes the state change.    subnet-id - The ID of the subnet for the instance.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    tenancy - The tenancy of an instance (dedicated | default | host).    virtualization-type - The virtualization type of the instance (paravirtual | hvm).    vpc-id - The ID of the VPC that the instance is running in.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more instance IDs. Default: Describes all your instances.
        public var instanceIds: [String]? = nil
        /// The token to request the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter or tag filters in the same call.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, instanceIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceIds = dictionary["InstanceIds"] as? [String] {
                self.instanceIds = instanceIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeScheduledInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Information about the Scheduled Instances.
        public var scheduledInstanceSet: [ScheduledInstance]? = nil

        public init() {}

        public init(nextToken: String? = nil, scheduledInstanceSet: [ScheduledInstance]? = nil) {
            self.nextToken = nextToken
            self.scheduledInstanceSet = scheduledInstanceSet
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let scheduledInstanceSet = dictionary["ScheduledInstanceSet"] as? [[String: Any]] {
                self.scheduledInstanceSet = try scheduledInstanceSet.map({ try ScheduledInstance(dictionary: $0) })
            }
        }
    }

    public struct DeleteNetworkAclEntryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the network ACL.
        public var networkAclId: String = ""
        /// The rule number of the entry to delete.
        public var ruleNumber: Int32 = 0
        /// Indicates whether the rule is an egress rule.
        public var egress: Bool = false
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(networkAclId: String, ruleNumber: Int32, egress: Bool, dryRun: Bool? = nil) {
            self.networkAclId = networkAclId
            self.ruleNumber = ruleNumber
            self.egress = egress
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
            guard let ruleNumber = dictionary["RuleNumber"] as? Int32 else { throw InitializableError.missingRequiredParam("RuleNumber") }
            self.ruleNumber = ruleNumber
            guard let egress = dictionary["Egress"] as? Bool else { throw InitializableError.missingRequiredParam("Egress") }
            self.egress = egress
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ResetSnapshotAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the snapshot.
        public var snapshotId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.
        public var attribute: String = ""

        public init() {}

        public init(snapshotId: String, dryRun: Bool? = nil, attribute: String) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct VpnGateway: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Any VPCs attached to the virtual private gateway.
        public var vpcAttachments: [VpcAttachment]? = nil
        /// The ID of the virtual private gateway.
        public var vpnGatewayId: String? = nil
        /// The type of VPN connection the virtual private gateway supports.
        public var type: String? = nil
        /// The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.
        public var availabilityZone: String? = nil
        /// Any tags assigned to the virtual private gateway.
        public var tags: [Tag]? = nil
        /// The current state of the virtual private gateway.
        public var state: String? = nil

        public init() {}

        public init(vpcAttachments: [VpcAttachment]? = nil, vpnGatewayId: String? = nil, type: String? = nil, availabilityZone: String? = nil, tags: [Tag]? = nil, state: String? = nil) {
            self.vpcAttachments = vpcAttachments
            self.vpnGatewayId = vpnGatewayId
            self.type = type
            self.availabilityZone = availabilityZone
            self.tags = tags
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcAttachments = dictionary["VpcAttachments"] as? [[String: Any]] {
                self.vpcAttachments = try vpcAttachments.map({ try VpcAttachment(dictionary: $0) })
            }
            self.vpnGatewayId = dictionary["VpnGatewayId"] as? String
            self.type = dictionary["Type"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.state = dictionary["State"] as? String
        }
    }

    public struct CancelSpotFleetRequestsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Indicates whether to terminate instances for a Spot fleet request if it is canceled successfully.
        public var terminateInstances: Bool = false
        /// The IDs of the Spot fleet requests.
        public var spotFleetRequestIds: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, terminateInstances: Bool, spotFleetRequestIds: [String]) {
            self.dryRun = dryRun
            self.terminateInstances = terminateInstances
            self.spotFleetRequestIds = spotFleetRequestIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let terminateInstances = dictionary["TerminateInstances"] as? Bool else { throw InitializableError.missingRequiredParam("TerminateInstances") }
            self.terminateInstances = terminateInstances
            guard let spotFleetRequestIds = dictionary["SpotFleetRequestIds"] as? [String] else { throw InitializableError.missingRequiredParam("SpotFleetRequestIds") }
            self.spotFleetRequestIds = spotFleetRequestIds
        }
    }

    public struct DescribeVolumeStatusRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more volume IDs. Default: Describes all your volumes.
        public var volumeIds: [String]? = nil
        /// One or more filters.    action.code - The action code for the event (for example, enable-volume-io).    action.description - A description of the action.    action.event-id - The event ID associated with the action.    availability-zone - The Availability Zone of the instance.    event.description - A description of the event.    event.event-id - The event ID.    event.event-type - The event type (for io-enabled: passed | failed; for io-performance: io-performance:degraded | io-performance:severely-degraded | io-performance:stalled).    event.not-after - The latest end time for the event.    event.not-before - The earliest start time for the event.    volume-status.details-name - The cause for volume-status.status (io-enabled | io-performance).    volume-status.details-status - The status of volume-status.details-name (for io-enabled: passed | failed; for io-performance: normal | degraded | severely-degraded | stalled).    volume-status.status - The status of the volume (ok | impaired | warning | insufficient-data).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The NextToken value to include in a future DescribeVolumeStatus request. When the results of the request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The maximum number of volume results returned by DescribeVolumeStatus in paginated output. When this parameter is used, the request only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then DescribeVolumeStatus returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.
        public var maxResults: Int32? = nil

        public init() {}

        public init(volumeIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeIds = dictionary["VolumeIds"] as? [String] {
                self.volumeIds = volumeIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeSecurityGroupsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more security group IDs. Required for security groups in a nondefault VPC. Default: Describes all your security groups.
        public var groupIds: [String]? = nil
        /// One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.    description - The description of the security group.    egress.ip-permission.prefix-list-id - The ID (prefix) of the AWS service to which the security group allows access.    group-id - The ID of the security group.     group-name - The name of the security group.    ip-permission.cidr - An IPv4 CIDR range that has been granted permission in a security group rule.    ip-permission.from-port - The start of port range for the TCP and UDP protocols, or an ICMP type number.    ip-permission.group-id - The ID of a security group that has been granted permission.    ip-permission.group-name - The name of a security group that has been granted permission.    ip-permission.ipv6-cidr - An IPv6 CIDR range that has been granted permission in a security group rule.    ip-permission.protocol - The IP protocol for the permission (tcp | udp | icmp or a protocol number).    ip-permission.to-port - The end of port range for the TCP and UDP protocols, or an ICMP code.    ip-permission.user-id - The ID of an AWS account that has been granted permission.    owner-id - The AWS account ID of the owner of the security group.    tag-key - The key of a tag assigned to the security group.    tag-value - The value of a tag assigned to the security group.    vpc-id - The ID of the VPC specified when the security group was created.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// [EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the group-name filter to describe security groups by name. Default: Describes all your security groups.
        public var groupNames: [String]? = nil

        public init() {}

        public init(groupIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, groupNames: [String]? = nil) {
            self.groupIds = groupIds
            self.filters = filters
            self.dryRun = dryRun
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            if let groupIds = dictionary["GroupIds"] as? [String] {
                self.groupIds = groupIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let groupNames = dictionary["GroupNames"] as? [String] {
                self.groupNames = groupNames
            }
        }
    }

    public struct Snapshot: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the DescribeSnapshots API operation.
        public var stateMessage: String? = nil
        /// The snapshot state.
        public var state: String? = nil
        /// The ID of the volume that was used to create the snapshot. Snapshots created by the CopySnapshot action have an arbitrary volume ID that should not be used for any purpose.
        public var volumeId: String? = nil
        /// Indicates whether the snapshot is encrypted.
        public var encrypted: Bool? = nil
        /// Any tags assigned to the snapshot.
        public var tags: [Tag]? = nil
        /// The AWS account ID of the EBS snapshot owner.
        public var ownerId: String? = nil
        /// The description for the snapshot.
        public var description: String? = nil
        /// The time stamp when the snapshot was initiated.
        public var startTime: Date? = nil
        /// The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the DescribeSnapshots API operation.
        public var dataEncryptionKeyId: String? = nil
        /// The progress of the snapshot, as a percentage.
        public var progress: String? = nil
        /// The ID of the snapshot. Each snapshot receives a unique identifier when it is created.
        public var snapshotId: String? = nil
        /// The size of the volume, in GiB.
        public var volumeSize: Int32? = nil
        ///  Value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. 
        public var ownerAlias: String? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.
        public var kmsKeyId: String? = nil

        public init() {}

        public init(stateMessage: String? = nil, state: String? = nil, volumeId: String? = nil, encrypted: Bool? = nil, tags: [Tag]? = nil, ownerId: String? = nil, description: String? = nil, startTime: Date? = nil, dataEncryptionKeyId: String? = nil, progress: String? = nil, snapshotId: String? = nil, volumeSize: Int32? = nil, ownerAlias: String? = nil, kmsKeyId: String? = nil) {
            self.stateMessage = stateMessage
            self.state = state
            self.volumeId = volumeId
            self.encrypted = encrypted
            self.tags = tags
            self.ownerId = ownerId
            self.description = description
            self.startTime = startTime
            self.dataEncryptionKeyId = dataEncryptionKeyId
            self.progress = progress
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.ownerAlias = ownerAlias
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            self.stateMessage = dictionary["StateMessage"] as? String
            self.state = dictionary["State"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
            self.encrypted = dictionary["Encrypted"] as? Bool
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.ownerId = dictionary["OwnerId"] as? String
            self.description = dictionary["Description"] as? String
            self.startTime = dictionary["StartTime"] as? Date
            self.dataEncryptionKeyId = dictionary["DataEncryptionKeyId"] as? String
            self.progress = dictionary["Progress"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.ownerAlias = dictionary["OwnerAlias"] as? String
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct DescribeVpcsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    cidr - The IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, /28).    dhcp-options-id - The ID of a set of DHCP options.    ipv6-cidr-block-association.ipv6-cidr-block - An IPv6 CIDR block associated with the VPC.    ipv6-cidr-block-association.association-id - The association ID for an IPv6 CIDR block associated with the VPC.    ipv6-cidr-block-association.state - The state of an IPv6 CIDR block associated with the VPC.    isDefault - Indicates whether the VPC is the default VPC.    state - The state of the VPC (pending | available).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC.  
        public var filters: [Filter]? = nil
        /// One or more VPC IDs. Default: Describes all your VPCs.
        public var vpcIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, vpcIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcIds = vpcIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let vpcIds = dictionary["VpcIds"] as? [String] {
                self.vpcIds = vpcIds
            }
        }
    }

    public struct DescribeIdFormatResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the ID format for the resource.
        public var statuses: [IdFormat]? = nil

        public init() {}

        public init(statuses: [IdFormat]? = nil) {
            self.statuses = statuses
        }

        public init(dictionary: [String: Any]) throws {
            if let statuses = dictionary["Statuses"] as? [[String: Any]] {
                self.statuses = try statuses.map({ try IdFormat(dictionary: $0) })
            }
        }
    }

    public struct RegisterImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The billing product codes.
        public var billingProducts: [String]? = nil
        /// One or more block device mapping entries.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI. There is no way to disable sriovNetSupport at this time. This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.
        public var sriovNetSupport: String? = nil
        /// The name of the root device (for example, /dev/sda1, or /dev/xvda).
        public var rootDeviceName: String? = nil
        /// The full path to your AMI manifest in Amazon S3 storage.
        public var imageLocation: String? = nil
        /// The ID of the kernel.
        public var kernelId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A description for your AMI.
        public var description: String? = nil
        /// A name for your AMI. Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)
        public var name: String = ""
        /// The architecture of the AMI. Default: For Amazon EBS-backed AMIs, i386. For instance store-backed AMIs, the architecture specified in the manifest file.
        public var architecture: String? = nil
        /// Set to true to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI. This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.
        public var enaSupport: Bool? = nil
        /// The type of virtualization. Default: paravirtual 
        public var virtualizationType: String? = nil
        /// The ID of the RAM disk.
        public var ramdiskId: String? = nil

        public init() {}

        public init(billingProducts: [String]? = nil, blockDeviceMappings: [BlockDeviceMapping]? = nil, sriovNetSupport: String? = nil, rootDeviceName: String? = nil, imageLocation: String? = nil, kernelId: String? = nil, dryRun: Bool? = nil, description: String? = nil, name: String, architecture: String? = nil, enaSupport: Bool? = nil, virtualizationType: String? = nil, ramdiskId: String? = nil) {
            self.billingProducts = billingProducts
            self.blockDeviceMappings = blockDeviceMappings
            self.sriovNetSupport = sriovNetSupport
            self.rootDeviceName = rootDeviceName
            self.imageLocation = imageLocation
            self.kernelId = kernelId
            self.dryRun = dryRun
            self.description = description
            self.name = name
            self.architecture = architecture
            self.enaSupport = enaSupport
            self.virtualizationType = virtualizationType
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let billingProducts = dictionary["BillingProducts"] as? [String] {
                self.billingProducts = billingProducts
            }
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.sriovNetSupport = dictionary["SriovNetSupport"] as? String
            self.rootDeviceName = dictionary["RootDeviceName"] as? String
            self.imageLocation = dictionary["ImageLocation"] as? String
            self.kernelId = dictionary["KernelId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.description = dictionary["Description"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.architecture = dictionary["Architecture"] as? String
            self.enaSupport = dictionary["EnaSupport"] as? Bool
            self.virtualizationType = dictionary["VirtualizationType"] as? String
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct DescribeMovingAddressesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Elastic IP addresses.
        public var publicIps: [String]? = nil
        /// One or more filters.    moving-status - The status of the Elastic IP address (MovingToVpc | RestoringToClassic).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token to use to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value outside of this range, an error is returned. Default: If no value is provided, the default is 1000.
        public var maxResults: Int32? = nil

        public init() {}

        public init(publicIps: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.publicIps = publicIps
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let publicIps = dictionary["PublicIps"] as? [String] {
                self.publicIps = publicIps
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct MonitorInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The monitoring information.
        public var instanceMonitorings: [InstanceMonitoring]? = nil

        public init() {}

        public init(instanceMonitorings: [InstanceMonitoring]? = nil) {
            self.instanceMonitorings = instanceMonitorings
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceMonitorings = dictionary["InstanceMonitorings"] as? [[String: Any]] {
                self.instanceMonitorings = try instanceMonitorings.map({ try InstanceMonitoring(dictionary: $0) })
            }
        }
    }

    public struct AssignIpv6AddressesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 addresses assigned to the network interface.
        public var assignedIpv6Addresses: [String]? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil

        public init() {}

        public init(assignedIpv6Addresses: [String]? = nil, networkInterfaceId: String? = nil) {
            self.assignedIpv6Addresses = assignedIpv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            if let assignedIpv6Addresses = dictionary["AssignedIpv6Addresses"] as? [String] {
                self.assignedIpv6Addresses = assignedIpv6Addresses
            }
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
        }
    }

    public struct AssignPrivateIpAddressesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.
        public var allowReassignment: Bool? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.
        public var secondaryPrivateIpAddressCount: Int32? = nil
        /// One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses. If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.
        public var privateIpAddresses: [String]? = nil

        public init() {}

        public init(allowReassignment: Bool? = nil, networkInterfaceId: String, secondaryPrivateIpAddressCount: Int32? = nil, privateIpAddresses: [String]? = nil) {
            self.allowReassignment = allowReassignment
            self.networkInterfaceId = networkInterfaceId
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.privateIpAddresses = privateIpAddresses
        }

        public init(dictionary: [String: Any]) throws {
            self.allowReassignment = dictionary["AllowReassignment"] as? Bool
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            if let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [String] {
                self.privateIpAddresses = privateIpAddresses
            }
        }
    }

    public struct RunInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to false after launch, use ModifyInstanceAttribute. Alternatively, if you set InstanceInitiatedShutdownBehavior to terminate, you can terminate the instance by running the shutdown command from the instance. Default: false 
        public var disableApiTermination: Bool? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see Ensuring Idempotency. Constraints: Maximum 64 ASCII characters
        public var clientToken: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false 
        public var ebsOptimized: Bool? = nil
        /// The ID of the kernel.  We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see  PV-GRUB in the Amazon Elastic Compute Cloud User Guide. 
        public var kernelId: String? = nil
        /// [EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        public var ipv6AddressCount: Int32? = nil
        /// The instance type. For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide. Default: m1.small 
        public var instanceType: String? = nil
        /// [EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
        public var privateIpAddress: String? = nil
        /// The name of the key pair. You can create a key pair using CreateKeyPair or ImportKeyPair.  If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in. 
        public var keyName: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: stop 
        public var instanceInitiatedShutdownBehavior: String? = nil
        /// [EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        public var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances. Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see How many instances can I run in Amazon EC2 in the Amazon EC2 General FAQ.
        public var minCount: Int32 = 0
        /// The ID of the RAM disk.  We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see  PV-GRUB in the Amazon Elastic Compute Cloud User Guide. 
        public var ramdiskId: String? = nil
        /// The block device mapping.  Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action. 
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// [EC2-VPC] The ID of the subnet to launch the instance into.
        public var subnetId: String? = nil
        /// The user data to make available to the instance. For more information, see Running Commands on Your Linux Instance at Launch (Linux) and Adding User Data (Windows). If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var userData: String? = nil
        /// One or more security group IDs. You can create a security group using CreateSecurityGroup. Default: Amazon EC2 uses the default security group.
        public var securityGroupIds: [String]? = nil
        /// The monitoring for the instance.
        public var monitoring: RunInstancesMonitoringEnabled? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// [EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead. Default: Amazon EC2 uses the default security group.
        public var securityGroups: [String]? = nil
        /// The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above MinCount. Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see How many instances can I run in Amazon EC2 in the Amazon EC2 FAQ.
        public var maxCount: Int32 = 0
        /// Reserved.
        public var additionalInfo: String? = nil
        /// The placement for the instance.
        public var placement: Placement? = nil
        /// One or more network interfaces.
        public var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The ID of the AMI, which you can get by calling DescribeImages.
        public var imageId: String = ""

        public init() {}

        public init(disableApiTermination: Bool? = nil, clientToken: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, ipv6AddressCount: Int32? = nil, instanceType: String? = nil, privateIpAddress: String? = nil, keyName: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, instanceInitiatedShutdownBehavior: String? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, minCount: Int32, ramdiskId: String? = nil, blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, securityGroupIds: [String]? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, dryRun: Bool? = nil, securityGroups: [String]? = nil, maxCount: Int32, additionalInfo: String? = nil, placement: Placement? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, imageId: String) {
            self.disableApiTermination = disableApiTermination
            self.clientToken = clientToken
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.ipv6AddressCount = ipv6AddressCount
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.keyName = keyName
            self.iamInstanceProfile = iamInstanceProfile
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.ipv6Addresses = ipv6Addresses
            self.minCount = minCount
            self.ramdiskId = ramdiskId
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.dryRun = dryRun
            self.securityGroups = securityGroups
            self.maxCount = maxCount
            self.additionalInfo = additionalInfo
            self.placement = placement
            self.networkInterfaces = networkInterfaces
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.disableApiTermination = dictionary["DisableApiTermination"] as? Bool
            self.clientToken = dictionary["ClientToken"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            self.instanceType = dictionary["InstanceType"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.keyName = dictionary["KeyName"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) }
            self.instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? String
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [[String: Any]] {
                self.ipv6Addresses = try ipv6Addresses.map({ try InstanceIpv6Address(dictionary: $0) })
            }
            guard let minCount = dictionary["MinCount"] as? Int32 else { throw InitializableError.missingRequiredParam("MinCount") }
            self.minCount = minCount
            self.ramdiskId = dictionary["RamdiskId"] as? String
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            if let securityGroupIds = dictionary["SecurityGroupIds"] as? [String] {
                self.securityGroupIds = securityGroupIds
            }
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.RunInstancesMonitoringEnabled(dictionary: monitoring) }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let securityGroups = dictionary["SecurityGroups"] as? [String] {
                self.securityGroups = securityGroups
            }
            guard let maxCount = dictionary["MaxCount"] as? Int32 else { throw InitializableError.missingRequiredParam("MaxCount") }
            self.maxCount = maxCount
            self.additionalInfo = dictionary["AdditionalInfo"] as? String
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.Placement(dictionary: placement) }
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try InstanceNetworkInterfaceSpecification(dictionary: $0) })
            }
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct SpotInstanceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Availability Zone in which the bid is launched.
        public var launchedAvailabilityZone: String? = nil
        /// The ID of the Spot instance request.
        public var spotInstanceRequestId: String? = nil
        /// The state of the Spot instance request. Spot bid status information can help you track your Spot instance requests. For more information, see Spot Bid Status in the Amazon Elastic Compute Cloud User Guide.
        public var state: String? = nil
        /// The maximum hourly price (bid) for the Spot instance launched to fulfill the request.
        public var spotPrice: String? = nil
        /// Any tags assigned to the resource.
        public var tags: [Tag]? = nil
        /// The end date of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached.
        public var validUntil: Date? = nil
        /// The fault codes for the Spot instance request, if any.
        public var fault: SpotInstanceStateFault? = nil
        /// The product description associated with the Spot instance.
        public var productDescription: String? = nil
        /// The Availability Zone group. If you specify the same Availability Zone group for all Spot instance requests, all Spot instances are launched in the same Availability Zone.
        public var availabilityZoneGroup: String? = nil
        /// The status code and status message describing the Spot instance request.
        public var status: SpotInstanceStatus? = nil
        /// The start date of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). The request becomes active at this date and time.
        public var validFrom: Date? = nil
        /// The instance ID, if an instance has been launched to fulfill the Spot instance request.
        public var instanceId: String? = nil
        /// If you specified a duration and your Spot instance request was fulfilled, this is the fixed hourly price in effect for the Spot instance while it runs.
        public var actualBlockHourlyPrice: String? = nil
        /// The duration for the Spot instance, in minutes.
        public var blockDurationMinutes: Int32? = nil
        /// Additional information for launching instances.
        public var launchSpecification: LaunchSpecification? = nil
        /// The Spot instance request type.
        public var type: String? = nil
        /// The instance launch group. Launch groups are Spot instances that launch together and terminate together.
        public var launchGroup: String? = nil
        /// The date and time when the Spot instance request was created, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var createTime: Date? = nil

        public init() {}

        public init(launchedAvailabilityZone: String? = nil, spotInstanceRequestId: String? = nil, state: String? = nil, spotPrice: String? = nil, tags: [Tag]? = nil, validUntil: Date? = nil, fault: SpotInstanceStateFault? = nil, productDescription: String? = nil, availabilityZoneGroup: String? = nil, status: SpotInstanceStatus? = nil, validFrom: Date? = nil, instanceId: String? = nil, actualBlockHourlyPrice: String? = nil, blockDurationMinutes: Int32? = nil, launchSpecification: LaunchSpecification? = nil, type: String? = nil, launchGroup: String? = nil, createTime: Date? = nil) {
            self.launchedAvailabilityZone = launchedAvailabilityZone
            self.spotInstanceRequestId = spotInstanceRequestId
            self.state = state
            self.spotPrice = spotPrice
            self.tags = tags
            self.validUntil = validUntil
            self.fault = fault
            self.productDescription = productDescription
            self.availabilityZoneGroup = availabilityZoneGroup
            self.status = status
            self.validFrom = validFrom
            self.instanceId = instanceId
            self.actualBlockHourlyPrice = actualBlockHourlyPrice
            self.blockDurationMinutes = blockDurationMinutes
            self.launchSpecification = launchSpecification
            self.type = type
            self.launchGroup = launchGroup
            self.createTime = createTime
        }

        public init(dictionary: [String: Any]) throws {
            self.launchedAvailabilityZone = dictionary["LaunchedAvailabilityZone"] as? String
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
            self.state = dictionary["State"] as? String
            self.spotPrice = dictionary["SpotPrice"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.validUntil = dictionary["ValidUntil"] as? Date
            if let fault = dictionary["Fault"] as? [String: Any] { self.fault = try Ec2.SpotInstanceStateFault(dictionary: fault) }
            self.productDescription = dictionary["ProductDescription"] as? String
            self.availabilityZoneGroup = dictionary["AvailabilityZoneGroup"] as? String
            if let status = dictionary["Status"] as? [String: Any] { self.status = try Ec2.SpotInstanceStatus(dictionary: status) }
            self.validFrom = dictionary["ValidFrom"] as? Date
            self.instanceId = dictionary["InstanceId"] as? String
            self.actualBlockHourlyPrice = dictionary["ActualBlockHourlyPrice"] as? String
            self.blockDurationMinutes = dictionary["BlockDurationMinutes"] as? Int32
            if let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] { self.launchSpecification = try Ec2.LaunchSpecification(dictionary: launchSpecification) }
            self.type = dictionary["Type"] as? String
            self.launchGroup = dictionary["LaunchGroup"] as? String
            self.createTime = dictionary["CreateTime"] as? Date
        }
    }

    public struct RebootInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more instance IDs.
        public var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct VpcPeeringConnectionStateReason: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the VPC peering connection.
        public var code: String? = nil
        /// A message that provides more information about the status, if applicable.
        public var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct ScheduledInstance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The platform (Linux/UNIX or Windows).
        public var platform: String? = nil
        /// The time that the previous schedule ended or will end.
        public var previousSlotEndTime: Date? = nil
        /// The total number of hours for a single instance for the entire term.
        public var totalScheduledInstanceHours: Int32? = nil
        /// The date when the Scheduled Instance was purchased.
        public var createDate: Date? = nil
        /// The hourly price for a single instance.
        public var hourlyPrice: String? = nil
        /// The instance type.
        public var instanceType: String? = nil
        /// The number of hours in the schedule.
        public var slotDurationInHours: Int32? = nil
        /// The Scheduled Instance ID.
        public var scheduledInstanceId: String? = nil
        /// The Availability Zone.
        public var availabilityZone: String? = nil
        /// The start date for the Scheduled Instance.
        public var termStartDate: Date? = nil
        /// The end date for the Scheduled Instance.
        public var termEndDate: Date? = nil
        /// The time for the next schedule to start.
        public var nextSlotStartTime: Date? = nil
        /// The number of instances.
        public var instanceCount: Int32? = nil
        /// The network platform (EC2-Classic or EC2-VPC).
        public var networkPlatform: String? = nil
        /// The schedule recurrence.
        public var recurrence: ScheduledInstanceRecurrence? = nil

        public init() {}

        public init(platform: String? = nil, previousSlotEndTime: Date? = nil, totalScheduledInstanceHours: Int32? = nil, createDate: Date? = nil, hourlyPrice: String? = nil, instanceType: String? = nil, slotDurationInHours: Int32? = nil, scheduledInstanceId: String? = nil, availabilityZone: String? = nil, termStartDate: Date? = nil, termEndDate: Date? = nil, nextSlotStartTime: Date? = nil, instanceCount: Int32? = nil, networkPlatform: String? = nil, recurrence: ScheduledInstanceRecurrence? = nil) {
            self.platform = platform
            self.previousSlotEndTime = previousSlotEndTime
            self.totalScheduledInstanceHours = totalScheduledInstanceHours
            self.createDate = createDate
            self.hourlyPrice = hourlyPrice
            self.instanceType = instanceType
            self.slotDurationInHours = slotDurationInHours
            self.scheduledInstanceId = scheduledInstanceId
            self.availabilityZone = availabilityZone
            self.termStartDate = termStartDate
            self.termEndDate = termEndDate
            self.nextSlotStartTime = nextSlotStartTime
            self.instanceCount = instanceCount
            self.networkPlatform = networkPlatform
            self.recurrence = recurrence
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            self.previousSlotEndTime = dictionary["PreviousSlotEndTime"] as? Date
            self.totalScheduledInstanceHours = dictionary["TotalScheduledInstanceHours"] as? Int32
            self.createDate = dictionary["CreateDate"] as? Date
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.slotDurationInHours = dictionary["SlotDurationInHours"] as? Int32
            self.scheduledInstanceId = dictionary["ScheduledInstanceId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.termStartDate = dictionary["TermStartDate"] as? Date
            self.termEndDate = dictionary["TermEndDate"] as? Date
            self.nextSlotStartTime = dictionary["NextSlotStartTime"] as? Date
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            self.networkPlatform = dictionary["NetworkPlatform"] as? String
            if let recurrence = dictionary["Recurrence"] as? [String: Any] { self.recurrence = try Ec2.ScheduledInstanceRecurrence(dictionary: recurrence) }
        }
    }

    public struct DescribeSpotFleetInstancesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""
        /// The running instances. Note that this list is refreshed periodically and might be out of date.
        public var activeInstances: [ActiveInstance] = []

        public init() {}

        public init(nextToken: String? = nil, spotFleetRequestId: String, activeInstances: [ActiveInstance]) {
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.activeInstances = activeInstances
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            guard let activeInstances = dictionary["ActiveInstances"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("ActiveInstances") }
            self.activeInstances = try activeInstances.map({ try ActiveInstance(dictionary: $0) })
        }
    }

    public struct ProductCode: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of product code.
        public var productCodeType: String? = nil
        /// The product code.
        public var productCodeId: String? = nil

        public init() {}

        public init(productCodeType: String? = nil, productCodeId: String? = nil) {
            self.productCodeType = productCodeType
            self.productCodeId = productCodeId
        }

        public init(dictionary: [String: Any]) throws {
            self.productCodeType = dictionary["ProductCodeType"] as? String
            self.productCodeId = dictionary["ProductCodeId"] as? String
        }
    }

    public struct InstanceStatusEvent: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The event code.
        public var code: String? = nil
        /// The earliest scheduled start time for the event.
        public var notBefore: Date? = nil
        /// The latest scheduled end time for the event.
        public var notAfter: Date? = nil
        /// A description of the event. After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].
        public var description: String? = nil

        public init() {}

        public init(code: String? = nil, notBefore: Date? = nil, notAfter: Date? = nil, description: String? = nil) {
            self.code = code
            self.notBefore = notBefore
            self.notAfter = notAfter
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.notBefore = dictionary["NotBefore"] as? Date
            self.notAfter = dictionary["NotAfter"] as? Date
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVolumeAttributeResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of product codes.
        public var productCodes: [ProductCode]? = nil
        /// The ID of the volume.
        public var volumeId: String? = nil
        /// The state of autoEnableIO attribute.
        public var autoEnableIO: AttributeBooleanValue? = nil

        public init() {}

        public init(productCodes: [ProductCode]? = nil, volumeId: String? = nil, autoEnableIO: AttributeBooleanValue? = nil) {
            self.productCodes = productCodes
            self.volumeId = volumeId
            self.autoEnableIO = autoEnableIO
        }

        public init(dictionary: [String: Any]) throws {
            if let productCodes = dictionary["ProductCodes"] as? [[String: Any]] {
                self.productCodes = try productCodes.map({ try ProductCode(dictionary: $0) })
            }
            self.volumeId = dictionary["VolumeId"] as? String
            if let autoEnableIO = dictionary["AutoEnableIO"] as? [String: Any] { self.autoEnableIO = try Ec2.AttributeBooleanValue(dictionary: autoEnableIO) }
        }
    }

    public struct DeleteNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(networkInterfaceId: String, dryRun: Bool? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct SpotDatafeedSubscription: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon S3 bucket where the Spot instance data feed is located.
        public var bucket: String? = nil
        /// The AWS account ID of the account.
        public var ownerId: String? = nil
        /// The state of the Spot instance data feed subscription.
        public var state: String? = nil
        /// The fault codes for the Spot instance request, if any.
        public var fault: SpotInstanceStateFault? = nil
        /// The prefix that is prepended to data feed files.
        public var prefix: String? = nil

        public init() {}

        public init(bucket: String? = nil, ownerId: String? = nil, state: String? = nil, fault: SpotInstanceStateFault? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.ownerId = ownerId
            self.state = state
            self.fault = fault
            self.prefix = prefix
        }

        public init(dictionary: [String: Any]) throws {
            self.bucket = dictionary["Bucket"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            self.state = dictionary["State"] as? String
            if let fault = dictionary["Fault"] as? [String: Any] { self.fault = try Ec2.SpotInstanceStateFault(dictionary: fault) }
            self.prefix = dictionary["Prefix"] as? String
        }
    }

    public struct ImportImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the disk containers.
        public var diskContainers: [ImageDiskContainer]? = nil
        /// The operating system of the virtual machine. Valid values: Windows | Linux 
        public var platform: String? = nil
        /// The token to enable idempotency for VM import requests.
        public var clientToken: String? = nil
        /// The license type to be used for the Amazon Machine Image (AMI) after importing.  Note: You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see Prerequisites in the VM Import/Export User Guide. Valid values: AWS | BYOL 
        public var licenseType: String? = nil
        /// The target hypervisor platform. Valid values: xen 
        public var hypervisor: String? = nil
        /// The architecture of the virtual machine. Valid values: i386 | x86_64 
        public var architecture: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The name of the role to use when not using the default role, 'vmimport'.
        public var roleName: String? = nil
        /// The client-specific data.
        public var clientData: ClientData? = nil
        /// A description string for the import image task.
        public var description: String? = nil

        public init() {}

        public init(diskContainers: [ImageDiskContainer]? = nil, platform: String? = nil, clientToken: String? = nil, licenseType: String? = nil, hypervisor: String? = nil, architecture: String? = nil, dryRun: Bool? = nil, roleName: String? = nil, clientData: ClientData? = nil, description: String? = nil) {
            self.diskContainers = diskContainers
            self.platform = platform
            self.clientToken = clientToken
            self.licenseType = licenseType
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.dryRun = dryRun
            self.roleName = roleName
            self.clientData = clientData
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let diskContainers = dictionary["DiskContainers"] as? [[String: Any]] {
                self.diskContainers = try diskContainers.map({ try ImageDiskContainer(dictionary: $0) })
            }
            self.platform = dictionary["Platform"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            self.licenseType = dictionary["LicenseType"] as? String
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.roleName = dictionary["RoleName"] as? String
            if let clientData = dictionary["ClientData"] as? [String: Any] { self.clientData = try Ec2.ClientData(dictionary: clientData) }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ImportInstanceVolumeDetailItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the import of this particular disk image.
        public var status: String = ""
        /// The number of bytes converted so far.
        public var bytesConverted: Int64 = 0
        /// The volume.
        public var volume: DiskImageVolumeDescription = DiskImageVolumeDescription()
        /// The image.
        public var image: DiskImageDescription = DiskImageDescription()
        /// The status information or errors related to the disk image.
        public var statusMessage: String? = nil
        /// The Availability Zone where the resulting instance will reside.
        public var availabilityZone: String = ""
        /// A description of the task.
        public var description: String? = nil

        public init() {}

        public init(status: String, bytesConverted: Int64, volume: DiskImageVolumeDescription, image: DiskImageDescription, statusMessage: String? = nil, availabilityZone: String, description: String? = nil) {
            self.status = status
            self.bytesConverted = bytesConverted
            self.volume = volume
            self.image = image
            self.statusMessage = statusMessage
            self.availabilityZone = availabilityZone
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let status = dictionary["Status"] as? String else { throw InitializableError.missingRequiredParam("Status") }
            self.status = status
            guard let bytesConverted = dictionary["BytesConverted"] as? Int64 else { throw InitializableError.missingRequiredParam("BytesConverted") }
            self.bytesConverted = bytesConverted
            guard let volume = dictionary["Volume"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volume") }
            self.volume = try Ec2.DiskImageVolumeDescription(dictionary: volume)
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Ec2.DiskImageDescription(dictionary: image)
            self.statusMessage = dictionary["StatusMessage"] as? String
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.description = dictionary["Description"] as? String
        }
    }

    public struct UnsuccessfulItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the resource.
        public var resourceId: String? = nil
        /// Information about the error.
        public var error: UnsuccessfulItemError = UnsuccessfulItemError()

        public init() {}

        public init(resourceId: String? = nil, error: UnsuccessfulItemError) {
            self.resourceId = resourceId
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.resourceId = dictionary["ResourceId"] as? String
            guard let error = dictionary["Error"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Error") }
            self.error = try Ec2.UnsuccessfulItemError(dictionary: error)
        }
    }

    public struct DescribeIamInstanceProfileAssociationsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Information about one or more IAM instance profile associations.
        public var iamInstanceProfileAssociations: [IamInstanceProfileAssociation]? = nil

        public init() {}

        public init(nextToken: String? = nil, iamInstanceProfileAssociations: [IamInstanceProfileAssociation]? = nil) {
            self.nextToken = nextToken
            self.iamInstanceProfileAssociations = iamInstanceProfileAssociations
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let iamInstanceProfileAssociations = dictionary["IamInstanceProfileAssociations"] as? [[String: Any]] {
                self.iamInstanceProfileAssociations = try iamInstanceProfileAssociations.map({ try IamInstanceProfileAssociation(dictionary: $0) })
            }
        }
    }

    public struct ModifySpotFleetRequestResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Is true if the request succeeds, and an error otherwise.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct Volume: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.
        public var volumeType: String? = nil
        /// The volume state.
        public var state: String? = nil
        /// The ID of the volume.
        public var volumeId: String? = nil
        /// Any tags assigned to the volume.
        public var tags: [Tag]? = nil
        /// The snapshot from which the volume was created, if applicable.
        public var snapshotId: String? = nil
        /// The size of the volume, in GiBs.
        public var size: Int32? = nil
        /// Indicates whether the volume will be encrypted.
        public var encrypted: Bool? = nil
        /// The time stamp when volume creation was initiated.
        public var createTime: Date? = nil
        /// The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information on General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        public var iops: Int32? = nil
        /// The Availability Zone for the volume.
        public var availabilityZone: String? = nil
        /// Information about the volume attachments.
        public var attachments: [VolumeAttachment]? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.
        public var kmsKeyId: String? = nil

        public init() {}

        public init(volumeType: String? = nil, state: String? = nil, volumeId: String? = nil, tags: [Tag]? = nil, snapshotId: String? = nil, size: Int32? = nil, encrypted: Bool? = nil, createTime: Date? = nil, iops: Int32? = nil, availabilityZone: String? = nil, attachments: [VolumeAttachment]? = nil, kmsKeyId: String? = nil) {
            self.volumeType = volumeType
            self.state = state
            self.volumeId = volumeId
            self.tags = tags
            self.snapshotId = snapshotId
            self.size = size
            self.encrypted = encrypted
            self.createTime = createTime
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.attachments = attachments
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            self.volumeType = dictionary["VolumeType"] as? String
            self.state = dictionary["State"] as? String
            self.volumeId = dictionary["VolumeId"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.size = dictionary["Size"] as? Int32
            self.encrypted = dictionary["Encrypted"] as? Bool
            self.createTime = dictionary["CreateTime"] as? Date
            self.iops = dictionary["Iops"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            if let attachments = dictionary["Attachments"] as? [[String: Any]] {
                self.attachments = try attachments.map({ try VolumeAttachment(dictionary: $0) })
            }
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct PurchaseHostReservationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The currency in which the totalUpfrontPrice, LimitPrice, and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        public var clientToken: String? = nil
        /// The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request will fail. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is USD. For example, to indicate a limit price of USD 100, specify 100.00.
        public var limitPrice: String? = nil
        /// The ID of the offering.
        public var offeringId: String = ""
        /// The ID/s of the Dedicated Host/s that the reservation will be associated with.
        public var hostIdSet: [String] = []

        public init() {}

        public init(currencyCode: String? = nil, clientToken: String? = nil, limitPrice: String? = nil, offeringId: String, hostIdSet: [String]) {
            self.currencyCode = currencyCode
            self.clientToken = clientToken
            self.limitPrice = limitPrice
            self.offeringId = offeringId
            self.hostIdSet = hostIdSet
        }

        public init(dictionary: [String: Any]) throws {
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            self.limitPrice = dictionary["LimitPrice"] as? String
            guard let offeringId = dictionary["OfferingId"] as? String else { throw InitializableError.missingRequiredParam("OfferingId") }
            self.offeringId = offeringId
            guard let hostIdSet = dictionary["HostIdSet"] as? [String] else { throw InitializableError.missingRequiredParam("HostIdSet") }
            self.hostIdSet = hostIdSet
        }
    }

    public struct SubnetCidrBlockState: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The state of a CIDR block.
        public var state: String? = nil
        /// A message about the status of the CIDR block, if applicable.
        public var statusMessage: String? = nil

        public init() {}

        public init(state: String? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.state = dictionary["State"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct InstanceAttribute: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The block device mapping of the instance.
        public var blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil
        /// If the value is true, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.
        public var disableApiTermination: AttributeBooleanValue? = nil
        /// The user data.
        public var userData: AttributeValue? = nil
        /// Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public var sriovNetSupport: AttributeValue? = nil
        /// The name of the root device (for example, /dev/sda1 or /dev/xvda).
        public var rootDeviceName: AttributeValue? = nil
        /// Indicates whether the instance is optimized for EBS I/O.
        public var ebsOptimized: AttributeBooleanValue? = nil
        /// Indicates whether source/destination checking is enabled. A value of true means checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.
        public var sourceDestCheck: AttributeBooleanValue? = nil
        /// The kernel ID.
        public var kernelId: AttributeValue? = nil
        /// The instance type.
        public var instanceType: AttributeValue? = nil
        /// A list of product codes.
        public var productCodes: [ProductCode]? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// Indicates whether enhanced networking with ENA is enabled.
        public var enaSupport: AttributeBooleanValue? = nil
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        public var instanceInitiatedShutdownBehavior: AttributeValue? = nil
        /// The RAM disk ID.
        public var ramdiskId: AttributeValue? = nil
        /// The security groups associated with the instance.
        public var groups: [GroupIdentifier]? = nil

        public init() {}

        public init(blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, disableApiTermination: AttributeBooleanValue? = nil, userData: AttributeValue? = nil, sriovNetSupport: AttributeValue? = nil, rootDeviceName: AttributeValue? = nil, ebsOptimized: AttributeBooleanValue? = nil, sourceDestCheck: AttributeBooleanValue? = nil, kernelId: AttributeValue? = nil, instanceType: AttributeValue? = nil, productCodes: [ProductCode]? = nil, instanceId: String? = nil, enaSupport: AttributeBooleanValue? = nil, instanceInitiatedShutdownBehavior: AttributeValue? = nil, ramdiskId: AttributeValue? = nil, groups: [GroupIdentifier]? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.disableApiTermination = disableApiTermination
            self.userData = userData
            self.sriovNetSupport = sriovNetSupport
            self.rootDeviceName = rootDeviceName
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.kernelId = kernelId
            self.instanceType = instanceType
            self.productCodes = productCodes
            self.instanceId = instanceId
            self.enaSupport = enaSupport
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.ramdiskId = ramdiskId
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try InstanceBlockDeviceMapping(dictionary: $0) })
            }
            if let disableApiTermination = dictionary["DisableApiTermination"] as? [String: Any] { self.disableApiTermination = try Ec2.AttributeBooleanValue(dictionary: disableApiTermination) }
            if let userData = dictionary["UserData"] as? [String: Any] { self.userData = try Ec2.AttributeValue(dictionary: userData) }
            if let sriovNetSupport = dictionary["SriovNetSupport"] as? [String: Any] { self.sriovNetSupport = try Ec2.AttributeValue(dictionary: sriovNetSupport) }
            if let rootDeviceName = dictionary["RootDeviceName"] as? [String: Any] { self.rootDeviceName = try Ec2.AttributeValue(dictionary: rootDeviceName) }
            if let ebsOptimized = dictionary["EbsOptimized"] as? [String: Any] { self.ebsOptimized = try Ec2.AttributeBooleanValue(dictionary: ebsOptimized) }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) }
            if let kernelId = dictionary["KernelId"] as? [String: Any] { self.kernelId = try Ec2.AttributeValue(dictionary: kernelId) }
            if let instanceType = dictionary["InstanceType"] as? [String: Any] { self.instanceType = try Ec2.AttributeValue(dictionary: instanceType) }
            if let productCodes = dictionary["ProductCodes"] as? [[String: Any]] {
                self.productCodes = try productCodes.map({ try ProductCode(dictionary: $0) })
            }
            self.instanceId = dictionary["InstanceId"] as? String
            if let enaSupport = dictionary["EnaSupport"] as? [String: Any] { self.enaSupport = try Ec2.AttributeBooleanValue(dictionary: enaSupport) }
            if let instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? [String: Any] { self.instanceInitiatedShutdownBehavior = try Ec2.AttributeValue(dictionary: instanceInitiatedShutdownBehavior) }
            if let ramdiskId = dictionary["RamdiskId"] as? [String: Any] { self.ramdiskId = try Ec2.AttributeValue(dictionary: ramdiskId) }
            if let groups = dictionary["Groups"] as? [[String: Any]] {
                self.groups = try groups.map({ try GroupIdentifier(dictionary: $0) })
            }
        }
    }

    public struct DescribeConversionTasksResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the conversion tasks.
        public var conversionTasks: [ConversionTask]? = nil

        public init() {}

        public init(conversionTasks: [ConversionTask]? = nil) {
            self.conversionTasks = conversionTasks
        }

        public init(dictionary: [String: Any]) throws {
            if let conversionTasks = dictionary["ConversionTasks"] as? [[String: Any]] {
                self.conversionTasks = try conversionTasks.map({ try ConversionTask(dictionary: $0) })
            }
        }
    }

    public struct ModifySnapshotAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The account ID to modify for the snapshot.
        public var userIds: [String]? = nil
        /// The ID of the snapshot.
        public var snapshotId: String = ""
        /// A JSON representation of the snapshot attribute modification.
        public var createVolumePermission: CreateVolumePermissionModifications? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The snapshot attribute to modify.  Only volume creation permissions may be modified at the customer level. 
        public var attribute: String? = nil
        /// The type of operation to perform to the attribute.
        public var operationType: String? = nil
        /// The group to modify for the snapshot.
        public var groupNames: [String]? = nil

        public init() {}

        public init(userIds: [String]? = nil, snapshotId: String, createVolumePermission: CreateVolumePermissionModifications? = nil, dryRun: Bool? = nil, attribute: String? = nil, operationType: String? = nil, groupNames: [String]? = nil) {
            self.userIds = userIds
            self.snapshotId = snapshotId
            self.createVolumePermission = createVolumePermission
            self.dryRun = dryRun
            self.attribute = attribute
            self.operationType = operationType
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            if let userIds = dictionary["UserIds"] as? [String] {
                self.userIds = userIds
            }
            guard let snapshotId = dictionary["SnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SnapshotId") }
            self.snapshotId = snapshotId
            if let createVolumePermission = dictionary["CreateVolumePermission"] as? [String: Any] { self.createVolumePermission = try Ec2.CreateVolumePermissionModifications(dictionary: createVolumePermission) }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.attribute = dictionary["Attribute"] as? String
            self.operationType = dictionary["OperationType"] as? String
            if let groupNames = dictionary["GroupNames"] as? [String] {
                self.groupNames = groupNames
            }
        }
    }

    public struct AttachClassicLinkVpcResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ModifySpotFleetRequestRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The size of the fleet.
        public var targetCapacity: Int32? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""
        /// Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.
        public var excessCapacityTerminationPolicy: String? = nil

        public init() {}

        public init(targetCapacity: Int32? = nil, spotFleetRequestId: String, excessCapacityTerminationPolicy: String? = nil) {
            self.targetCapacity = targetCapacity
            self.spotFleetRequestId = spotFleetRequestId
            self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        }

        public init(dictionary: [String: Any]) throws {
            self.targetCapacity = dictionary["TargetCapacity"] as? Int32
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            self.excessCapacityTerminationPolicy = dictionary["ExcessCapacityTerminationPolicy"] as? String
        }
    }

    public struct HostReservation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upfront price of the reservation.
        public var upfrontPrice: String? = nil
        /// The state of the reservation.
        public var state: String? = nil
        /// The payment option selected for this reservation.
        public var paymentOption: String? = nil
        /// The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.
        public var offeringId: String? = nil
        /// The number of Dedicated Hosts the reservation is associated with.
        public var count: Int32? = nil
        /// The ID of the reservation that specifies the associated Dedicated Hosts.
        public var hostReservationId: String? = nil
        /// The hourly price of the reservation.
        public var hourlyPrice: String? = nil
        /// The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.
        public var instanceFamily: String? = nil
        /// The date and time that the reservation started.
        public var start: Date? = nil
        /// The date and time that the reservation ends.
        public var end: Date? = nil
        /// The IDs of the Dedicated Hosts associated with the reservation.
        public var hostIdSet: [String]? = nil
        /// The currency in which the upfrontPrice and hourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The length of the reservation's term, specified in seconds. Can be 31536000 (1 year) | 94608000 (3 years).
        public var duration: Int32? = nil

        public init() {}

        public init(upfrontPrice: String? = nil, state: String? = nil, paymentOption: String? = nil, offeringId: String? = nil, count: Int32? = nil, hostReservationId: String? = nil, hourlyPrice: String? = nil, instanceFamily: String? = nil, start: Date? = nil, end: Date? = nil, hostIdSet: [String]? = nil, currencyCode: String? = nil, duration: Int32? = nil) {
            self.upfrontPrice = upfrontPrice
            self.state = state
            self.paymentOption = paymentOption
            self.offeringId = offeringId
            self.count = count
            self.hostReservationId = hostReservationId
            self.hourlyPrice = hourlyPrice
            self.instanceFamily = instanceFamily
            self.start = start
            self.end = end
            self.hostIdSet = hostIdSet
            self.currencyCode = currencyCode
            self.duration = duration
        }

        public init(dictionary: [String: Any]) throws {
            self.upfrontPrice = dictionary["UpfrontPrice"] as? String
            self.state = dictionary["State"] as? String
            self.paymentOption = dictionary["PaymentOption"] as? String
            self.offeringId = dictionary["OfferingId"] as? String
            self.count = dictionary["Count"] as? Int32
            self.hostReservationId = dictionary["HostReservationId"] as? String
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.instanceFamily = dictionary["InstanceFamily"] as? String
            self.start = dictionary["Start"] as? Date
            self.end = dictionary["End"] as? Date
            if let hostIdSet = dictionary["HostIdSet"] as? [String] {
                self.hostIdSet = hostIdSet
            }
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.duration = dictionary["Duration"] as? Int32
        }
    }

    public struct CreateReservedInstancesListingResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the Standard Reserved Instance listing.
        public var reservedInstancesListings: [ReservedInstancesListing]? = nil

        public init() {}

        public init(reservedInstancesListings: [ReservedInstancesListing]? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesListings = dictionary["ReservedInstancesListings"] as? [[String: Any]] {
                self.reservedInstancesListings = try reservedInstancesListings.map({ try ReservedInstancesListing(dictionary: $0) })
            }
        }
    }

    public struct DescribeHostsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    instance-type - The instance type size that the Dedicated Host is configured to support.    auto-placement - Whether auto-placement is enabled or disabled (on | off).    host-reservation-id - The ID of the reservation assigned to this host.    client-token - The idempotency token you provided when you launched the instance    state- The allocation state of the Dedicated Host (available | under-assessment | permanent-failure | released | released-permanent-failure).    availability-zone - The Availability Zone of the host.  
        public var filter: [Filter]? = nil
        /// The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.
        public var hostIds: [String]? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error. You cannot specify this parameter and the host IDs parameter in the same request.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filter: [Filter]? = nil, hostIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.hostIds = hostIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [[String: Any]] {
                self.filter = try filter.map({ try Filter(dictionary: $0) })
            }
            if let hostIds = dictionary["HostIds"] as? [String] {
                self.hostIds = hostIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct AllocateAddressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Set to vpc to allocate the address for use with instances in a VPC. Default: The address is for use with instances in EC2-Classic.
        public var domain: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(domain: String? = nil, dryRun: Bool? = nil) {
            self.domain = domain
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.domain = dictionary["Domain"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeBundleTasksRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    bundle-id - The ID of the bundle task.    error-code - If the task failed, the error code returned.    error-message - If the task failed, the error message returned.    instance-id - The ID of the instance.    progress - The level of task completion, as a percentage (for example, 20%).    s3-bucket - The Amazon S3 bucket to store the AMI.    s3-prefix - The beginning of the AMI name.    start-time - The time the task started (for example, 2013-09-15T17:15:20.000Z).    state - The state of the task (pending | waiting-for-shutdown | bundling | storing | cancelling | complete | failed).    update-time - The time of the most recent update for the task.  
        public var filters: [Filter]? = nil
        /// One or more bundle task IDs. Default: Describes all your bundle tasks.
        public var bundleIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, bundleIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.bundleIds = bundleIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let bundleIds = dictionary["BundleIds"] as? [String] {
                self.bundleIds = bundleIds
            }
        }
    }

    public struct RunScheduledInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the newly launched instances.
        public var instanceIdSet: [String]? = nil

        public init() {}

        public init(instanceIdSet: [String]? = nil) {
            self.instanceIdSet = instanceIdSet
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceIdSet = dictionary["InstanceIdSet"] as? [String] {
                self.instanceIdSet = instanceIdSet
            }
        }
    }

    public struct DescribeVpcEndpointServicesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of supported AWS services.
        public var serviceNames: [String]? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public var nextToken: String? = nil

        public init() {}

        public init(serviceNames: [String]? = nil, nextToken: String? = nil) {
            self.serviceNames = serviceNames
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let serviceNames = dictionary["ServiceNames"] as? [String] {
                self.serviceNames = serviceNames
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct AssociateVpcCidrBlockResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// Information about the IPv6 CIDR block association.
        public var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(vpcId: String? = nil, ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil) {
            self.vpcId = vpcId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.VpcIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) }
        }
    }

    public struct UserData: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var data: String? = nil

        public init() {}

        public init(data: String? = nil) {
            self.data = data
        }

        public init(dictionary: [String: Any]) throws {
            self.data = dictionary["Data"] as? String
        }
    }

    public struct AssociateAddressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
        public var privateIpAddress: String? = nil
        /// [EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.
        public var networkInterfaceId: String? = nil
        /// The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        public var instanceId: String? = nil
        /// [EC2-VPC] The allocation ID. This is required for EC2-VPC.
        public var allocationId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The Elastic IP address. This is required for EC2-Classic.
        public var publicIp: String? = nil
        /// [EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.
        public var allowReassociation: Bool? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, allocationId: String? = nil, dryRun: Bool? = nil, publicIp: String? = nil, allowReassociation: Bool? = nil) {
            self.privateIpAddress = privateIpAddress
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.allocationId = allocationId
            self.dryRun = dryRun
            self.publicIp = publicIp
            self.allowReassociation = allowReassociation
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.publicIp = dictionary["PublicIp"] as? String
            self.allowReassociation = dictionary["AllowReassociation"] as? Bool
        }
    }

    public struct DisassociateSubnetCidrBlockRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The association ID for the CIDR block.
        public var associationId: String = ""

        public init() {}

        public init(associationId: String) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct DeleteEgressOnlyInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the egress-only Internet gateway.
        public var egressOnlyInternetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(egressOnlyInternetGatewayId: String, dryRun: Bool? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("EgressOnlyInternetGatewayId") }
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct AuthorizeSecurityGroupEgressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account number for a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public var sourceSecurityGroupOwnerId: String? = nil
        /// A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.
        public var ipPermissions: [IpPermission]? = nil
        /// The CIDR IPv4 address range. We recommend that you specify the CIDR range in a set of IP permissions instead.
        public var cidrIp: String? = nil
        /// The name of a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public var fromPort: Int32? = nil
        /// The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.
        public var ipProtocol: String? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public var toPort: Int32? = nil
        /// The ID of the security group.
        public var groupId: String = ""

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, toPort: Int32? = nil, groupId: String) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.toPort = toPort
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [[String: Any]] {
                self.ipPermissions = try ipPermissions.map({ try IpPermission(dictionary: $0) })
            }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.toPort = dictionary["ToPort"] as? Int32
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
        }
    }

    public struct FlowLog: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the flow log group.
        public var logGroupName: String? = nil
        /// The status of the flow log (ACTIVE).
        public var flowLogStatus: String? = nil
        /// The flow log ID.
        public var flowLogId: String? = nil
        /// The date and time the flow log was created.
        public var creationTime: Date? = nil
        /// The type of traffic captured for the flow log.
        public var trafficType: String? = nil
        /// The ARN of the IAM role that posts logs to CloudWatch Logs.
        public var deliverLogsPermissionArn: String? = nil
        /// The ID of the resource on which the flow log was created.
        public var resourceId: String? = nil
        /// The status of the logs delivery (SUCCESS | FAILED).
        public var deliverLogsStatus: String? = nil
        /// Information about the error that occurred. Rate limited indicates that CloudWatch logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of CloudWatch Logs log groups that you can create. Access error indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. Unknown error indicates an internal error.
        public var deliverLogsErrorMessage: String? = nil

        public init() {}

        public init(logGroupName: String? = nil, flowLogStatus: String? = nil, flowLogId: String? = nil, creationTime: Date? = nil, trafficType: String? = nil, deliverLogsPermissionArn: String? = nil, resourceId: String? = nil, deliverLogsStatus: String? = nil, deliverLogsErrorMessage: String? = nil) {
            self.logGroupName = logGroupName
            self.flowLogStatus = flowLogStatus
            self.flowLogId = flowLogId
            self.creationTime = creationTime
            self.trafficType = trafficType
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            self.resourceId = resourceId
            self.deliverLogsStatus = deliverLogsStatus
            self.deliverLogsErrorMessage = deliverLogsErrorMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.logGroupName = dictionary["LogGroupName"] as? String
            self.flowLogStatus = dictionary["FlowLogStatus"] as? String
            self.flowLogId = dictionary["FlowLogId"] as? String
            self.creationTime = dictionary["CreationTime"] as? Date
            self.trafficType = dictionary["TrafficType"] as? String
            self.deliverLogsPermissionArn = dictionary["DeliverLogsPermissionArn"] as? String
            self.resourceId = dictionary["ResourceId"] as? String
            self.deliverLogsStatus = dictionary["DeliverLogsStatus"] as? String
            self.deliverLogsErrorMessage = dictionary["DeliverLogsErrorMessage"] as? String
        }
    }

    public struct CreateVpcEndpointResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        public var clientToken: String? = nil
        /// Information about the endpoint.
        public var vpcEndpoint: VpcEndpoint? = nil

        public init() {}

        public init(clientToken: String? = nil, vpcEndpoint: VpcEndpoint? = nil) {
            self.clientToken = clientToken
            self.vpcEndpoint = vpcEndpoint
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let vpcEndpoint = dictionary["VpcEndpoint"] as? [String: Any] { self.vpcEndpoint = try Ec2.VpcEndpoint(dictionary: vpcEndpoint) }
        }
    }

    public struct AttachNetworkInterfaceResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the network interface attachment.
        public var attachmentId: String? = nil

        public init() {}

        public init(attachmentId: String? = nil) {
            self.attachmentId = attachmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.attachmentId = dictionary["AttachmentId"] as? String
        }
    }

    public struct DescribeVpcEndpointsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public var nextToken: String? = nil
        /// Information about the endpoints.
        public var vpcEndpoints: [VpcEndpoint]? = nil

        public init() {}

        public init(nextToken: String? = nil, vpcEndpoints: [VpcEndpoint]? = nil) {
            self.nextToken = nextToken
            self.vpcEndpoints = vpcEndpoints
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let vpcEndpoints = dictionary["VpcEndpoints"] as? [[String: Any]] {
                self.vpcEndpoints = try vpcEndpoints.map({ try VpcEndpoint(dictionary: $0) })
            }
        }
    }

    public struct CreateKeyPairRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A unique name for the key pair. Constraints: Up to 255 ASCII characters
        public var keyName: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(keyName: String, dryRun: Bool? = nil) {
            self.keyName = keyName
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let keyName = dictionary["KeyName"] as? String else { throw InitializableError.missingRequiredParam("KeyName") }
            self.keyName = keyName
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct StaleSecurityGroup: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the stale inbound rules in the security group.
        public var staleIpPermissions: [StaleIpPermission]? = nil
        /// Information about the stale outbound rules in the security group.
        public var staleIpPermissionsEgress: [StaleIpPermission]? = nil
        /// The name of the security group.
        public var groupName: String? = nil
        /// The ID of the VPC for the security group.
        public var vpcId: String? = nil
        /// The ID of the security group.
        public var groupId: String = ""
        /// The description of the security group.
        public var description: String? = nil

        public init() {}

        public init(staleIpPermissions: [StaleIpPermission]? = nil, staleIpPermissionsEgress: [StaleIpPermission]? = nil, groupName: String? = nil, vpcId: String? = nil, groupId: String, description: String? = nil) {
            self.staleIpPermissions = staleIpPermissions
            self.staleIpPermissionsEgress = staleIpPermissionsEgress
            self.groupName = groupName
            self.vpcId = vpcId
            self.groupId = groupId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let staleIpPermissions = dictionary["StaleIpPermissions"] as? [[String: Any]] {
                self.staleIpPermissions = try staleIpPermissions.map({ try StaleIpPermission(dictionary: $0) })
            }
            if let staleIpPermissionsEgress = dictionary["StaleIpPermissionsEgress"] as? [[String: Any]] {
                self.staleIpPermissionsEgress = try staleIpPermissionsEgress.map({ try StaleIpPermission(dictionary: $0) })
            }
            self.groupName = dictionary["GroupName"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct ConfirmProductInstanceResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.
        public var ownerId: String? = nil
        /// The return value of the request. Returns true if the specified product code is owned by the requester and associated with the specified instance.
        public var `return`: Bool? = nil

        public init() {}

        public init(ownerId: String? = nil, return: Bool? = nil) {
            self.ownerId = ownerId
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.ownerId = dictionary["OwnerId"] as? String
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct ImportKeyPairRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A unique name for the key pair.
        public var keyName: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.
        public var publicKeyMaterial: Data = Data()

        public init() {}

        public init(keyName: String, dryRun: Bool? = nil, publicKeyMaterial: Data) {
            self.keyName = keyName
            self.dryRun = dryRun
            self.publicKeyMaterial = publicKeyMaterial
        }

        public init(dictionary: [String: Any]) throws {
            guard let keyName = dictionary["KeyName"] as? String else { throw InitializableError.missingRequiredParam("KeyName") }
            self.keyName = keyName
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let publicKeyMaterial = dictionary["PublicKeyMaterial"] as? Data else { throw InitializableError.missingRequiredParam("PublicKeyMaterial") }
            self.publicKeyMaterial = publicKeyMaterial
        }
    }

    public struct RunInstancesMonitoringEnabled: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
        public var enabled: Bool = false

        public init() {}

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            guard let enabled = dictionary["Enabled"] as? Bool else { throw InitializableError.missingRequiredParam("Enabled") }
            self.enabled = enabled
        }
    }

    public struct GetPasswordDataResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time the data was last updated.
        public var timestamp: Date? = nil
        /// The password of the instance.
        public var passwordData: String? = nil
        /// The ID of the Windows instance.
        public var instanceId: String? = nil

        public init() {}

        public init(timestamp: Date? = nil, passwordData: String? = nil, instanceId: String? = nil) {
            self.timestamp = timestamp
            self.passwordData = passwordData
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.passwordData = dictionary["PasswordData"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct IdFormat: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.
        public var deadline: Date? = nil
        /// The type of resource.
        public var resource: String? = nil
        /// Indicates whether longer IDs (17-character IDs) are enabled for the resource.
        public var useLongIds: Bool? = nil

        public init() {}

        public init(deadline: Date? = nil, resource: String? = nil, useLongIds: Bool? = nil) {
            self.deadline = deadline
            self.resource = resource
            self.useLongIds = useLongIds
        }

        public init(dictionary: [String: Any]) throws {
            self.deadline = dictionary["Deadline"] as? Date
            self.resource = dictionary["Resource"] as? String
            self.useLongIds = dictionary["UseLongIds"] as? Bool
        }
    }

    public struct DescribeClassicLinkInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    group-id - The ID of a VPC security group that's associated with the instance.    instance-id - The ID of the instance.    tag:key=value - The key/value combination of a tag assigned to the resource.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC that the instance is linked to.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more instance IDs. Must be instances linked to a VPC through ClassicLink.
        public var instanceIds: [String]? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request. Constraint: If the value is greater than 1000, we return only 1000 items.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, instanceIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceIds = dictionary["InstanceIds"] as? [String] {
                self.instanceIds = instanceIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct RunScheduledInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see Ensuring Idempotency.
        public var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.
        public var launchSpecification: ScheduledInstancesLaunchSpecification = ScheduledInstancesLaunchSpecification()
        /// The number of instances. Default: 1
        public var instanceCount: Int32? = nil
        /// The Scheduled Instance ID.
        public var scheduledInstanceId: String = ""

        public init() {}

        public init(clientToken: String? = nil, dryRun: Bool? = nil, launchSpecification: ScheduledInstancesLaunchSpecification, instanceCount: Int32? = nil, scheduledInstanceId: String) {
            self.clientToken = clientToken
            self.dryRun = dryRun
            self.launchSpecification = launchSpecification
            self.instanceCount = instanceCount
            self.scheduledInstanceId = scheduledInstanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let launchSpecification = dictionary["LaunchSpecification"] as? [String: Any] else { throw InitializableError.missingRequiredParam("LaunchSpecification") }
            self.launchSpecification = try Ec2.ScheduledInstancesLaunchSpecification(dictionary: launchSpecification)
            self.instanceCount = dictionary["InstanceCount"] as? Int32
            guard let scheduledInstanceId = dictionary["ScheduledInstanceId"] as? String else { throw InitializableError.missingRequiredParam("ScheduledInstanceId") }
            self.scheduledInstanceId = scheduledInstanceId
        }
    }

    public struct BlockDeviceMapping: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Suppresses the specified device included in the block device mapping of the AMI.
        public var noDevice: String? = nil
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        public var virtualName: String? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public var deviceName: String? = nil
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        public var ebs: EbsBlockDevice? = nil

        public init() {}

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsBlockDevice? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.EbsBlockDevice(dictionary: ebs) }
        }
    }

    public struct ReplaceIamInstanceProfileAssociationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfileSpecification = IamInstanceProfileSpecification()
        /// The ID of the existing IAM instance profile association.
        public var associationId: String = ""

        public init() {}

        public init(iamInstanceProfile: IamInstanceProfileSpecification, associationId: String) {
            self.iamInstanceProfile = iamInstanceProfile
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IamInstanceProfile") }
            self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile)
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct ScheduledInstancesIpv6Address: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 address.
        public var ipv6Address: String? = nil

        public init() {}

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6Address = dictionary["Ipv6Address"] as? String
        }
    }

    public struct DescribeSpotFleetRequestHistoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The starting date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var startTime: Date = Date()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The type of events to describe. By default, all events are described.
        public var eventType: String? = nil
        /// The token for the next set of results.
        public var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(startTime: Date, dryRun: Bool? = nil, eventType: String? = nil, nextToken: String? = nil, spotFleetRequestId: String, maxResults: Int32? = nil) {
            self.startTime = startTime
            self.dryRun = dryRun
            self.eventType = eventType
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            self.dryRun = dictionary["DryRun"] as? Bool
            self.eventType = dictionary["EventType"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ScheduledInstanceAvailability: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The platform (Linux/UNIX or Windows).
        public var platform: String? = nil
        /// The total number of hours for a single instance for the entire term.
        public var totalScheduledInstanceHours: Int32? = nil
        /// The minimum term. The only possible value is 365 days.
        public var minTermDurationInDays: Int32? = nil
        /// The maximum term. The only possible value is 365 days.
        public var maxTermDurationInDays: Int32? = nil
        /// The hourly price for a single instance.
        public var hourlyPrice: String? = nil
        /// The instance type. You can specify one of the C3, C4, M4, or R3 instance types.
        public var instanceType: String? = nil
        /// The number of hours in the schedule.
        public var slotDurationInHours: Int32? = nil
        /// The Availability Zone.
        public var availabilityZone: String? = nil
        /// The number of available instances.
        public var availableInstanceCount: Int32? = nil
        /// The time period for the first schedule to start.
        public var firstSlotStartTime: Date? = nil
        /// The network platform (EC2-Classic or EC2-VPC).
        public var networkPlatform: String? = nil
        /// The purchase token. This token expires in two hours.
        public var purchaseToken: String? = nil
        /// The schedule recurrence.
        public var recurrence: ScheduledInstanceRecurrence? = nil

        public init() {}

        public init(platform: String? = nil, totalScheduledInstanceHours: Int32? = nil, minTermDurationInDays: Int32? = nil, maxTermDurationInDays: Int32? = nil, hourlyPrice: String? = nil, instanceType: String? = nil, slotDurationInHours: Int32? = nil, availabilityZone: String? = nil, availableInstanceCount: Int32? = nil, firstSlotStartTime: Date? = nil, networkPlatform: String? = nil, purchaseToken: String? = nil, recurrence: ScheduledInstanceRecurrence? = nil) {
            self.platform = platform
            self.totalScheduledInstanceHours = totalScheduledInstanceHours
            self.minTermDurationInDays = minTermDurationInDays
            self.maxTermDurationInDays = maxTermDurationInDays
            self.hourlyPrice = hourlyPrice
            self.instanceType = instanceType
            self.slotDurationInHours = slotDurationInHours
            self.availabilityZone = availabilityZone
            self.availableInstanceCount = availableInstanceCount
            self.firstSlotStartTime = firstSlotStartTime
            self.networkPlatform = networkPlatform
            self.purchaseToken = purchaseToken
            self.recurrence = recurrence
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            self.totalScheduledInstanceHours = dictionary["TotalScheduledInstanceHours"] as? Int32
            self.minTermDurationInDays = dictionary["MinTermDurationInDays"] as? Int32
            self.maxTermDurationInDays = dictionary["MaxTermDurationInDays"] as? Int32
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.slotDurationInHours = dictionary["SlotDurationInHours"] as? Int32
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.availableInstanceCount = dictionary["AvailableInstanceCount"] as? Int32
            self.firstSlotStartTime = dictionary["FirstSlotStartTime"] as? Date
            self.networkPlatform = dictionary["NetworkPlatform"] as? String
            self.purchaseToken = dictionary["PurchaseToken"] as? String
            if let recurrence = dictionary["Recurrence"] as? [String: Any] { self.recurrence = try Ec2.ScheduledInstanceRecurrence(dictionary: recurrence) }
        }
    }

    public struct VolumeDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The size of the volume, in GiB.
        public var size: Int64 = 0

        public init() {}

        public init(size: Int64) {
            self.size = size
        }

        public init(dictionary: [String: Any]) throws {
            guard let size = dictionary["Size"] as? Int64 else { throw InitializableError.missingRequiredParam("Size") }
            self.size = size
        }
    }

    public struct ReleaseHostsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the Dedicated Hosts you want to release.
        public var hostIds: [String] = []

        public init() {}

        public init(hostIds: [String]) {
            self.hostIds = hostIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let hostIds = dictionary["HostIds"] as? [String] else { throw InitializableError.missingRequiredParam("HostIds") }
            self.hostIds = hostIds
        }
    }

    public struct InstanceStatusDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of instance status.
        public var name: String? = nil
        /// The status.
        public var status: String? = nil
        /// The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.
        public var impairedSince: Date? = nil

        public init() {}

        public init(name: String? = nil, status: String? = nil, impairedSince: Date? = nil) {
            self.name = name
            self.status = status
            self.impairedSince = impairedSince
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.status = dictionary["Status"] as? String
            self.impairedSince = dictionary["ImpairedSince"] as? Date
        }
    }

    public struct StartInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more instance IDs.
        public var instanceIds: [String] = []
        /// Reserved.
        public var additionalInfo: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, instanceIds: [String], additionalInfo: String? = nil) {
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.additionalInfo = additionalInfo
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
            self.additionalInfo = dictionary["AdditionalInfo"] as? String
        }
    }

    public struct SlotStartTimeRangeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The earliest date and time, in UTC, for the Scheduled Instance to start.
        public var earliestTime: Date? = nil
        /// The latest date and time, in UTC, for the Scheduled Instance to start.
        public var latestTime: Date? = nil

        public init() {}

        public init(earliestTime: Date? = nil, latestTime: Date? = nil) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

        public init(dictionary: [String: Any]) throws {
            self.earliestTime = dictionary["EarliestTime"] as? Date
            self.latestTime = dictionary["LatestTime"] as? Date
        }
    }

    public struct CreateRouteResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct DescribeReservedInstancesListingsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the Reserved Instance listing.
        public var reservedInstancesListings: [ReservedInstancesListing]? = nil

        public init() {}

        public init(reservedInstancesListings: [ReservedInstancesListing]? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesListings = dictionary["ReservedInstancesListings"] as? [[String: Any]] {
                self.reservedInstancesListings = try reservedInstancesListings.map({ try ReservedInstancesListing(dictionary: $0) })
            }
        }
    }

    public struct GetHostReservationPurchasePreviewResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The purchase information of the Dedicated Host Reservation and the Dedicated Hosts associated with it.
        public var purchase: [Purchase]? = nil
        /// The potential total upfront price. This is billed immediately.
        public var totalUpfrontPrice: String? = nil
        /// The currency in which the totalUpfrontPrice and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The potential total hourly price of the reservation per hour.
        public var totalHourlyPrice: String? = nil

        public init() {}

        public init(purchase: [Purchase]? = nil, totalUpfrontPrice: String? = nil, currencyCode: String? = nil, totalHourlyPrice: String? = nil) {
            self.purchase = purchase
            self.totalUpfrontPrice = totalUpfrontPrice
            self.currencyCode = currencyCode
            self.totalHourlyPrice = totalHourlyPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let purchase = dictionary["Purchase"] as? [[String: Any]] {
                self.purchase = try purchase.map({ try Purchase(dictionary: $0) })
            }
            self.totalUpfrontPrice = dictionary["TotalUpfrontPrice"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.totalHourlyPrice = dictionary["TotalHourlyPrice"] as? String
        }
    }

    public struct ExportTask: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the instance to export.
        public var instanceExportDetails: InstanceExportDetails? = nil
        /// The ID of the export task.
        public var exportTaskId: String? = nil
        /// Information about the export task.
        public var exportToS3Task: ExportToS3Task? = nil
        /// The state of the export task.
        public var state: String? = nil
        /// The status message related to the export task.
        public var statusMessage: String? = nil
        /// A description of the resource being exported.
        public var description: String? = nil

        public init() {}

        public init(instanceExportDetails: InstanceExportDetails? = nil, exportTaskId: String? = nil, exportToS3Task: ExportToS3Task? = nil, state: String? = nil, statusMessage: String? = nil, description: String? = nil) {
            self.instanceExportDetails = instanceExportDetails
            self.exportTaskId = exportTaskId
            self.exportToS3Task = exportToS3Task
            self.state = state
            self.statusMessage = statusMessage
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceExportDetails = dictionary["InstanceExportDetails"] as? [String: Any] { self.instanceExportDetails = try Ec2.InstanceExportDetails(dictionary: instanceExportDetails) }
            self.exportTaskId = dictionary["ExportTaskId"] as? String
            if let exportToS3Task = dictionary["ExportToS3Task"] as? [String: Any] { self.exportToS3Task = try Ec2.ExportToS3Task(dictionary: exportToS3Task) }
            self.state = dictionary["State"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateSpotDatafeedSubscriptionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon S3 bucket in which to store the Spot instance data feed.
        public var bucket: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A prefix for the data feed file names.
        public var prefix: String? = nil

        public init() {}

        public init(bucket: String, dryRun: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.dryRun = dryRun
            self.prefix = prefix
        }

        public init(dictionary: [String: Any]) throws {
            guard let bucket = dictionary["Bucket"] as? String else { throw InitializableError.missingRequiredParam("Bucket") }
            self.bucket = bucket
            self.dryRun = dictionary["DryRun"] as? Bool
            self.prefix = dictionary["Prefix"] as? String
        }
    }

    public struct DescribeScheduledInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time period for the first schedule to start.
        public var slotStartTimeRange: SlotStartTimeRangeRequest? = nil
        /// The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil
        /// One or more filters.    availability-zone - The Availability Zone (for example, us-west-2a).    instance-type - The instance type (for example, c4.large).    network-platform - The network platform (EC2-Classic or EC2-VPC).    platform - The platform (Linux/UNIX or Windows).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token for the next set of results.
        public var nextToken: String? = nil
        /// One or more Scheduled Instance IDs.
        public var scheduledInstanceIds: [String]? = nil

        public init() {}

        public init(slotStartTimeRange: SlotStartTimeRangeRequest? = nil, maxResults: Int32? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, scheduledInstanceIds: [String]? = nil) {
            self.slotStartTimeRange = slotStartTimeRange
            self.maxResults = maxResults
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.scheduledInstanceIds = scheduledInstanceIds
        }

        public init(dictionary: [String: Any]) throws {
            if let slotStartTimeRange = dictionary["SlotStartTimeRange"] as? [String: Any] { self.slotStartTimeRange = try Ec2.SlotStartTimeRangeRequest(dictionary: slotStartTimeRange) }
            self.maxResults = dictionary["MaxResults"] as? Int32
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            if let scheduledInstanceIds = dictionary["ScheduledInstanceIds"] as? [String] {
                self.scheduledInstanceIds = scheduledInstanceIds
            }
        }
    }

    public struct DeleteSubnetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(subnetId: String, dryRun: Bool? = nil) {
            self.subnetId = subnetId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct EbsInstanceBlockDeviceSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the volume is deleted on instance termination.
        public var deleteOnTermination: Bool? = nil
        /// The ID of the EBS volume.
        public var volumeId: String? = nil

        public init() {}

        public init(deleteOnTermination: Bool? = nil, volumeId: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.volumeId = dictionary["VolumeId"] as? String
        }
    }

    public struct NetworkInterfaceAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The device index of the network interface attachment on the instance.
        public var deviceIndex: Int32? = nil
        /// The attachment state.
        public var status: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The timestamp indicating when the attachment initiated.
        public var attachTime: Date? = nil
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Bool? = nil
        /// The ID of the network interface attachment.
        public var attachmentId: String? = nil
        /// The AWS account ID of the owner of the instance.
        public var instanceOwnerId: String? = nil

        public init() {}

        public init(deviceIndex: Int32? = nil, status: String? = nil, instanceId: String? = nil, attachTime: Date? = nil, deleteOnTermination: Bool? = nil, attachmentId: String? = nil, instanceOwnerId: String? = nil) {
            self.deviceIndex = deviceIndex
            self.status = status
            self.instanceId = instanceId
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.attachmentId = attachmentId
            self.instanceOwnerId = instanceOwnerId
        }

        public init(dictionary: [String: Any]) throws {
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.status = dictionary["Status"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.attachTime = dictionary["AttachTime"] as? Date
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.attachmentId = dictionary["AttachmentId"] as? String
            self.instanceOwnerId = dictionary["InstanceOwnerId"] as? String
        }
    }

    public struct DescribePrefixListsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public var nextToken: String? = nil
        /// All available prefix lists.
        public var prefixLists: [PrefixList]? = nil

        public init() {}

        public init(nextToken: String? = nil, prefixLists: [PrefixList]? = nil) {
            self.nextToken = nextToken
            self.prefixLists = prefixLists
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let prefixLists = dictionary["PrefixLists"] as? [[String: Any]] {
                self.prefixLists = try prefixLists.map({ try PrefixList(dictionary: $0) })
            }
        }
    }

    public struct ReplaceRouteTableAssociationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the new route table to associate with the subnet.
        public var routeTableId: String = ""
        /// The association ID.
        public var associationId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, routeTableId: String, associationId: String) {
            self.dryRun = dryRun
            self.routeTableId = routeTableId
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct InstanceStatusSummary: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The system instance health or application instance health.
        public var details: [InstanceStatusDetails]? = nil
        /// The status.
        public var status: String? = nil

        public init() {}

        public init(details: [InstanceStatusDetails]? = nil, status: String? = nil) {
            self.details = details
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let details = dictionary["Details"] as? [[String: Any]] {
                self.details = try details.map({ try InstanceStatusDetails(dictionary: $0) })
            }
            self.status = dictionary["Status"] as? String
        }
    }

    public struct UnsuccessfulItemError: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The error code.
        public var code: String = ""
        /// The error message accompanying the error code.
        public var message: String = ""

        public init() {}

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            guard let code = dictionary["Code"] as? String else { throw InitializableError.missingRequiredParam("Code") }
            self.code = code
            guard let message = dictionary["Message"] as? String else { throw InitializableError.missingRequiredParam("Message") }
            self.message = message
        }
    }

    public struct RestoreAddressToClassicResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The move status for the IP address.
        public var status: String? = nil
        /// The Elastic IP address.
        public var publicIp: String? = nil

        public init() {}

        public init(status: String? = nil, publicIp: String? = nil) {
            self.status = status
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct CopyImageResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the new AMI.
        public var imageId: String? = nil

        public init() {}

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct DescribeSecurityGroupReferencesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPCs with the referencing security groups.
        public var securityGroupReferenceSet: [SecurityGroupReference]? = nil

        public init() {}

        public init(securityGroupReferenceSet: [SecurityGroupReference]? = nil) {
            self.securityGroupReferenceSet = securityGroupReferenceSet
        }

        public init(dictionary: [String: Any]) throws {
            if let securityGroupReferenceSet = dictionary["SecurityGroupReferenceSet"] as? [[String: Any]] {
                self.securityGroupReferenceSet = try securityGroupReferenceSet.map({ try SecurityGroupReference(dictionary: $0) })
            }
        }
    }

    public struct LaunchPermission: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID.
        public var userId: String? = nil
        /// The name of the group.
        public var group: String? = nil

        public init() {}

        public init(userId: String? = nil, group: String? = nil) {
            self.userId = userId
            self.group = group
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            self.group = dictionary["Group"] as? String
        }
    }

    public struct ImportImageResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The license type of the virtual machine.
        public var licenseType: String? = nil
        /// A brief status of the task.
        public var status: String? = nil
        /// The operating system of the virtual machine.
        public var platform: String? = nil
        /// The progress of the task.
        public var progress: String? = nil
        /// The target hypervisor of the import task.
        public var hypervisor: String? = nil
        /// The architecture of the virtual machine.
        public var architecture: String? = nil
        /// The ID of the Amazon Machine Image (AMI) created by the import task.
        public var imageId: String? = nil
        /// The task ID of the import image task.
        public var importTaskId: String? = nil
        /// A detailed status message of the import task.
        public var statusMessage: String? = nil
        /// Information about the snapshots.
        public var snapshotDetails: [SnapshotDetail]? = nil
        /// A description of the import task.
        public var description: String? = nil

        public init() {}

        public init(licenseType: String? = nil, status: String? = nil, platform: String? = nil, progress: String? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, importTaskId: String? = nil, statusMessage: String? = nil, snapshotDetails: [SnapshotDetail]? = nil, description: String? = nil) {
            self.licenseType = licenseType
            self.status = status
            self.platform = platform
            self.progress = progress
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.importTaskId = importTaskId
            self.statusMessage = statusMessage
            self.snapshotDetails = snapshotDetails
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.licenseType = dictionary["LicenseType"] as? String
            self.status = dictionary["Status"] as? String
            self.platform = dictionary["Platform"] as? String
            self.progress = dictionary["Progress"] as? String
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.imageId = dictionary["ImageId"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let snapshotDetails = dictionary["SnapshotDetails"] as? [[String: Any]] {
                self.snapshotDetails = try snapshotDetails.map({ try SnapshotDetail(dictionary: $0) })
            }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVpcPeeringConnectionsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPC peering connections.
        public var vpcPeeringConnections: [VpcPeeringConnection]? = nil

        public init() {}

        public init(vpcPeeringConnections: [VpcPeeringConnection]? = nil) {
            self.vpcPeeringConnections = vpcPeeringConnections
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcPeeringConnections = dictionary["VpcPeeringConnections"] as? [[String: Any]] {
                self.vpcPeeringConnections = try vpcPeeringConnections.map({ try VpcPeeringConnection(dictionary: $0) })
            }
        }
    }

    public struct DiskImageDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The disk image format.
        public var format: String = ""
        /// A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the Authenticating REST Requests topic in the Amazon Simple Storage Service Developer Guide. For information about the import manifest referenced by this API action, see VM Import Manifest.
        public var importManifestUrl: String = ""
        /// The size of the disk image, in GiB.
        public var bytes: Int64 = 0

        public init() {}

        public init(format: String, importManifestUrl: String, bytes: Int64) {
            self.format = format
            self.importManifestUrl = importManifestUrl
            self.bytes = bytes
        }

        public init(dictionary: [String: Any]) throws {
            guard let format = dictionary["Format"] as? String else { throw InitializableError.missingRequiredParam("Format") }
            self.format = format
            guard let importManifestUrl = dictionary["ImportManifestUrl"] as? String else { throw InitializableError.missingRequiredParam("ImportManifestUrl") }
            self.importManifestUrl = importManifestUrl
            guard let bytes = dictionary["Bytes"] as? Int64 else { throw InitializableError.missingRequiredParam("Bytes") }
            self.bytes = bytes
        }
    }

    public struct PrefixList: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the prefix.
        public var prefixListId: String? = nil
        /// The IP address range of the AWS service.
        public var cidrs: [String]? = nil
        /// The name of the prefix.
        public var prefixListName: String? = nil

        public init() {}

        public init(prefixListId: String? = nil, cidrs: [String]? = nil, prefixListName: String? = nil) {
            self.prefixListId = prefixListId
            self.cidrs = cidrs
            self.prefixListName = prefixListName
        }

        public init(dictionary: [String: Any]) throws {
            self.prefixListId = dictionary["PrefixListId"] as? String
            if let cidrs = dictionary["Cidrs"] as? [String] {
                self.cidrs = cidrs
            }
            self.prefixListName = dictionary["PrefixListName"] as? String
        }
    }

    public struct ModifyIdFormatRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of resource: instance | reservation | snapshot | volume 
        public var resource: String = ""
        /// Indicate whether the resource should use longer IDs (17-character IDs).
        public var useLongIds: Bool = false

        public init() {}

        public init(resource: String, useLongIds: Bool) {
            self.resource = resource
            self.useLongIds = useLongIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let resource = dictionary["Resource"] as? String else { throw InitializableError.missingRequiredParam("Resource") }
            self.resource = resource
            guard let useLongIds = dictionary["UseLongIds"] as? Bool else { throw InitializableError.missingRequiredParam("UseLongIds") }
            self.useLongIds = useLongIds
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    key - The tag key.    resource-id - The resource ID.    resource-type - The resource type (customer-gateway | dhcp-options | image | instance | internet-gateway | network-acl | network-interface | reserved-instances | route-table | security-group | snapshot | spot-instances-request | subnet | volume | vpc | vpn-connection | vpn-gateway).    value - The tag value.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BundleTask: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time this task started.
        public var startTime: Date? = nil
        /// If the task fails, a description of the error.
        public var bundleTaskError: BundleTaskError? = nil
        /// The level of task completion, as a percent (for example, 20%).
        public var progress: String? = nil
        /// The ID of the instance associated with this bundle task.
        public var instanceId: String? = nil
        /// The state of the task.
        public var state: String? = nil
        /// The time of the most recent update for the task.
        public var updateTime: Date? = nil
        /// The Amazon S3 storage locations.
        public var storage: Storage? = nil
        /// The ID of the bundle task.
        public var bundleId: String? = nil

        public init() {}

        public init(startTime: Date? = nil, bundleTaskError: BundleTaskError? = nil, progress: String? = nil, instanceId: String? = nil, state: String? = nil, updateTime: Date? = nil, storage: Storage? = nil, bundleId: String? = nil) {
            self.startTime = startTime
            self.bundleTaskError = bundleTaskError
            self.progress = progress
            self.instanceId = instanceId
            self.state = state
            self.updateTime = updateTime
            self.storage = storage
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            if let bundleTaskError = dictionary["BundleTaskError"] as? [String: Any] { self.bundleTaskError = try Ec2.BundleTaskError(dictionary: bundleTaskError) }
            self.progress = dictionary["Progress"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.state = dictionary["State"] as? String
            self.updateTime = dictionary["UpdateTime"] as? Date
            if let storage = dictionary["Storage"] as? [String: Any] { self.storage = try Ec2.Storage(dictionary: storage) }
            self.bundleId = dictionary["BundleId"] as? String
        }
    }

    public struct DetachNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the attachment.
        public var attachmentId: String = ""
        /// Specifies whether to force a detachment.
        public var force: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil, attachmentId: String, force: Bool? = nil) {
            self.dryRun = dryRun
            self.attachmentId = attachmentId
            self.force = force
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let attachmentId = dictionary["AttachmentId"] as? String else { throw InitializableError.missingRequiredParam("AttachmentId") }
            self.attachmentId = attachmentId
            self.force = dictionary["Force"] as? Bool
        }
    }

    public struct DescribeRegionsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more regions.
        public var regions: [Region]? = nil

        public init() {}

        public init(regions: [Region]? = nil) {
            self.regions = regions
        }

        public init(dictionary: [String: Any]) throws {
            if let regions = dictionary["Regions"] as? [[String: Any]] {
                self.regions = try regions.map({ try Region(dictionary: $0) })
            }
        }
    }

    public struct GetConsoleOutputRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateVpnConnectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the VPN connection requires static routes. If you are creating a VPN connection for a device that does not support BGP, you must specify true. Default: false 
        public var options: VpnConnectionOptionsSpecification? = nil
        /// The ID of the customer gateway.
        public var customerGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The type of VPN connection (ipsec.1).
        public var type: String = ""
        /// The ID of the virtual private gateway.
        public var vpnGatewayId: String = ""

        public init() {}

        public init(options: VpnConnectionOptionsSpecification? = nil, customerGatewayId: String, dryRun: Bool? = nil, type: String, vpnGatewayId: String) {
            self.options = options
            self.customerGatewayId = customerGatewayId
            self.dryRun = dryRun
            self.type = type
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            if let options = dictionary["Options"] as? [String: Any] { self.options = try Ec2.VpnConnectionOptionsSpecification(dictionary: options) }
            guard let customerGatewayId = dictionary["CustomerGatewayId"] as? String else { throw InitializableError.missingRequiredParam("CustomerGatewayId") }
            self.customerGatewayId = customerGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let type = dictionary["Type"] as? String else { throw InitializableError.missingRequiredParam("Type") }
            self.type = type
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct DescribeSpotPriceHistoryResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The historical Spot prices.
        public var spotPriceHistory: [SpotPrice]? = nil

        public init() {}

        public init(nextToken: String? = nil, spotPriceHistory: [SpotPrice]? = nil) {
            self.nextToken = nextToken
            self.spotPriceHistory = spotPriceHistory
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let spotPriceHistory = dictionary["SpotPriceHistory"] as? [[String: Any]] {
                self.spotPriceHistory = try spotPriceHistory.map({ try SpotPrice(dictionary: $0) })
            }
        }
    }

    public struct CreateSecurityGroupResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the security group.
        public var groupId: String? = nil

        public init() {}

        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.groupId = dictionary["GroupId"] as? String
        }
    }

    public struct CreateNatGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
        public var clientToken: String? = nil
        /// Information about the NAT gateway.
        public var natGateway: NatGateway? = nil

        public init() {}

        public init(clientToken: String? = nil, natGateway: NatGateway? = nil) {
            self.clientToken = clientToken
            self.natGateway = natGateway
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let natGateway = dictionary["NatGateway"] as? [String: Any] { self.natGateway = try Ec2.NatGateway(dictionary: natGateway) }
        }
    }

    public struct SpotPlacement: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Availability Zone. [Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        public var availabilityZone: String? = nil
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for Spot instances.
        public var tenancy: String? = nil
        /// The name of the placement group (for cluster instances).
        public var groupName: String? = nil

        public init() {}

        public init(availabilityZone: String? = nil, tenancy: String? = nil, groupName: String? = nil) {
            self.availabilityZone = availabilityZone
            self.tenancy = tenancy
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.tenancy = dictionary["Tenancy"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct Instance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The idempotency token you provided when you launched the instance, if applicable.
        public var clientToken: String? = nil
        /// The root device name (for example, /dev/sda1 or /dev/xvda).
        public var rootDeviceName: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
        public var ebsOptimized: Bool? = nil
        /// Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the instance to perform NAT. For more information, see NAT Instances in the Amazon Virtual Private Cloud User Guide.
        public var sourceDestCheck: Bool? = nil
        /// The kernel associated with this instance, if applicable.
        public var kernelId: String? = nil
        /// (IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the running state.  [EC2-VPC] The Amazon-provided DNS server will resolve Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.
        public var privateDnsName: String? = nil
        /// The instance type.
        public var instanceType: String? = nil
        /// The private IPv4 address assigned to the instance.
        public var privateIpAddress: String? = nil
        /// The product codes attached to this instance, if applicable.
        public var productCodes: [ProductCode]? = nil
        /// The name of the key pair, if this instance was launched with an associated key pair.
        public var keyName: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The IAM instance profile associated with the instance, if applicable.
        public var iamInstanceProfile: IamInstanceProfile? = nil
        /// (IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the running state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.
        public var publicDnsName: String? = nil
        /// [EC2-VPC] The ID of the VPC in which the instance is running.
        public var vpcId: String? = nil
        /// The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.
        public var rootDeviceType: String? = nil
        /// The RAM disk associated with this instance, if applicable.
        public var ramdiskId: String? = nil
        /// Indicates whether this is a Spot instance or a Scheduled Instance.
        public var instanceLifecycle: String? = nil
        /// Any block device mapping entries for the instance.
        public var blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil
        /// [EC2-VPC] The ID of the subnet in which the instance is running.
        public var subnetId: String? = nil
        /// Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public var sriovNetSupport: String? = nil
        /// The value is Windows for Windows instances; otherwise blank.
        public var platform: String? = nil
        /// If the request is a Spot instance request, the ID of the request.
        public var spotInstanceRequestId: String? = nil
        /// Any tags assigned to the instance.
        public var tags: [Tag]? = nil
        /// The time the instance was launched.
        public var launchTime: Date? = nil
        /// The current state of the instance.
        public var state: InstanceState? = nil
        /// The public IPv4 address assigned to the instance, if applicable.
        public var publicIpAddress: String? = nil
        /// The monitoring for the instance.
        public var monitoring: Monitoring? = nil
        /// The reason for the most recent state transition. This might be an empty string.
        public var stateTransitionReason: String? = nil
        /// The reason for the most recent state transition.
        public var stateReason: StateReason? = nil
        /// One or more security groups for the instance.
        public var securityGroups: [GroupIdentifier]? = nil
        /// The hypervisor type of the instance.
        public var hypervisor: String? = nil
        /// The architecture of the image.
        public var architecture: String? = nil
        /// The ID of the AMI used to launch the instance.
        public var imageId: String? = nil
        /// Specifies whether enhanced networking with ENA is enabled.
        public var enaSupport: Bool? = nil
        /// [EC2-VPC] One or more network interfaces for the instance.
        public var networkInterfaces: [InstanceNetworkInterface]? = nil
        /// The AMI launch index, which can be used to find this instance in the launch group.
        public var amiLaunchIndex: Int32? = nil
        /// The location where the instance launched, if applicable.
        public var placement: Placement? = nil
        /// The virtualization type of the instance.
        public var virtualizationType: String? = nil

        public init() {}

        public init(clientToken: String? = nil, rootDeviceName: String? = nil, ebsOptimized: Bool? = nil, sourceDestCheck: Bool? = nil, kernelId: String? = nil, privateDnsName: String? = nil, instanceType: String? = nil, privateIpAddress: String? = nil, productCodes: [ProductCode]? = nil, keyName: String? = nil, instanceId: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil, publicDnsName: String? = nil, vpcId: String? = nil, rootDeviceType: String? = nil, ramdiskId: String? = nil, instanceLifecycle: String? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, subnetId: String? = nil, sriovNetSupport: String? = nil, platform: String? = nil, spotInstanceRequestId: String? = nil, tags: [Tag]? = nil, launchTime: Date? = nil, state: InstanceState? = nil, publicIpAddress: String? = nil, monitoring: Monitoring? = nil, stateTransitionReason: String? = nil, stateReason: StateReason? = nil, securityGroups: [GroupIdentifier]? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, enaSupport: Bool? = nil, networkInterfaces: [InstanceNetworkInterface]? = nil, amiLaunchIndex: Int32? = nil, placement: Placement? = nil, virtualizationType: String? = nil) {
            self.clientToken = clientToken
            self.rootDeviceName = rootDeviceName
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.kernelId = kernelId
            self.privateDnsName = privateDnsName
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.productCodes = productCodes
            self.keyName = keyName
            self.instanceId = instanceId
            self.iamInstanceProfile = iamInstanceProfile
            self.publicDnsName = publicDnsName
            self.vpcId = vpcId
            self.rootDeviceType = rootDeviceType
            self.ramdiskId = ramdiskId
            self.instanceLifecycle = instanceLifecycle
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.sriovNetSupport = sriovNetSupport
            self.platform = platform
            self.spotInstanceRequestId = spotInstanceRequestId
            self.tags = tags
            self.launchTime = launchTime
            self.state = state
            self.publicIpAddress = publicIpAddress
            self.monitoring = monitoring
            self.stateTransitionReason = stateTransitionReason
            self.stateReason = stateReason
            self.securityGroups = securityGroups
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.enaSupport = enaSupport
            self.networkInterfaces = networkInterfaces
            self.amiLaunchIndex = amiLaunchIndex
            self.placement = placement
            self.virtualizationType = virtualizationType
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            self.rootDeviceName = dictionary["RootDeviceName"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            self.privateDnsName = dictionary["PrivateDnsName"] as? String
            self.instanceType = dictionary["InstanceType"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            if let productCodes = dictionary["ProductCodes"] as? [[String: Any]] {
                self.productCodes = try productCodes.map({ try ProductCode(dictionary: $0) })
            }
            self.keyName = dictionary["KeyName"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfile(dictionary: iamInstanceProfile) }
            self.publicDnsName = dictionary["PublicDnsName"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            self.rootDeviceType = dictionary["RootDeviceType"] as? String
            self.ramdiskId = dictionary["RamdiskId"] as? String
            self.instanceLifecycle = dictionary["InstanceLifecycle"] as? String
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try InstanceBlockDeviceMapping(dictionary: $0) })
            }
            self.subnetId = dictionary["SubnetId"] as? String
            self.sriovNetSupport = dictionary["SriovNetSupport"] as? String
            self.platform = dictionary["Platform"] as? String
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.launchTime = dictionary["LaunchTime"] as? Date
            if let state = dictionary["State"] as? [String: Any] { self.state = try Ec2.InstanceState(dictionary: state) }
            self.publicIpAddress = dictionary["PublicIpAddress"] as? String
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.Monitoring(dictionary: monitoring) }
            self.stateTransitionReason = dictionary["StateTransitionReason"] as? String
            if let stateReason = dictionary["StateReason"] as? [String: Any] { self.stateReason = try Ec2.StateReason(dictionary: stateReason) }
            if let securityGroups = dictionary["SecurityGroups"] as? [[String: Any]] {
                self.securityGroups = try securityGroups.map({ try GroupIdentifier(dictionary: $0) })
            }
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.imageId = dictionary["ImageId"] as? String
            self.enaSupport = dictionary["EnaSupport"] as? Bool
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try InstanceNetworkInterface(dictionary: $0) })
            }
            self.amiLaunchIndex = dictionary["AmiLaunchIndex"] as? Int32
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.Placement(dictionary: placement) }
            self.virtualizationType = dictionary["VirtualizationType"] as? String
        }
    }

    public struct AttachVolumeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The device name to expose to the instance (for example, /dev/sdh or xvdh).
        public var device: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        public var volumeId: String = ""

        public init() {}

        public init(device: String, dryRun: Bool? = nil, instanceId: String, volumeId: String) {
            self.device = device
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.volumeId = volumeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let device = dictionary["Device"] as? String else { throw InitializableError.missingRequiredParam("Device") }
            self.device = device
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
        }
    }

    public struct DisableVpcClassicLinkResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct AcceptVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String? = nil) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct DescribeFlowLogsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.    deliver-log-status - The status of the logs delivery (SUCCESS | FAILED).    flow-log-id - The ID of the flow log.    log-group-name - The name of the log group.    resource-id - The ID of the VPC, subnet, or network interface.    traffic-type - The type of traffic (ACCEPT | REJECT | ALL)  
        public var filter: [Filter]? = nil
        /// One or more flow log IDs.
        public var flowLogIds: [String]? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filter: [Filter]? = nil, flowLogIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.flowLogIds = flowLogIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["Filter"] as? [[String: Any]] {
                self.filter = try filter.map({ try Filter(dictionary: $0) })
            }
            if let flowLogIds = dictionary["FlowLogIds"] as? [String] {
                self.flowLogIds = flowLogIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct HostInstance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The instance type size (for example, m3.medium) of the running instance.
        public var instanceType: String? = nil
        /// the IDs of instances that are running on the Dedicated Host.
        public var instanceId: String? = nil

        public init() {}

        public init(instanceType: String? = nil, instanceId: String? = nil) {
            self.instanceType = instanceType
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceType = dictionary["InstanceType"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct DescribeSpotDatafeedSubscriptionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Spot instance data feed subscription.
        public var spotDatafeedSubscription: SpotDatafeedSubscription? = nil

        public init() {}

        public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
            self.spotDatafeedSubscription = spotDatafeedSubscription
        }

        public init(dictionary: [String: Any]) throws {
            if let spotDatafeedSubscription = dictionary["SpotDatafeedSubscription"] as? [String: Any] { self.spotDatafeedSubscription = try Ec2.SpotDatafeedSubscription(dictionary: spotDatafeedSubscription) }
        }
    }

    public struct SpotFleetMonitoring: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Enables monitoring for the instance. Default: false 
        public var enabled: Bool? = nil

        public init() {}

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.enabled = dictionary["Enabled"] as? Bool
        }
    }

    public struct Storage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An Amazon S3 storage location.
        public var s3: S3Storage? = nil

        public init() {}

        public init(s3: S3Storage? = nil) {
            self.s3 = s3
        }

        public init(dictionary: [String: Any]) throws {
            if let s3 = dictionary["S3"] as? [String: Any] { self.s3 = try Ec2.S3Storage(dictionary: s3) }
        }
    }

    public struct ImportInstanceLaunchSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-VPC] An available IP address from the IP address range of the subnet.
        public var privateIpAddress: String? = nil
        /// [EC2-VPC] The ID of the subnet in which to launch the instance.
        public var subnetId: String? = nil
        /// The user data to make available to the instance. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var userData: UserData? = nil
        /// One or more security group IDs.
        public var groupIds: [String]? = nil
        /// The architecture of the instance.
        public var architecture: String? = nil
        /// Reserved.
        public var additionalInfo: String? = nil
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        public var instanceInitiatedShutdownBehavior: String? = nil
        /// The placement information for the instance.
        public var placement: Placement? = nil
        /// Indicates whether monitoring is enabled.
        public var monitoring: Bool? = nil
        /// The instance type. For more information about the instance types that you can import, see Instance Types in the VM Import/Export User Guide.
        public var instanceType: String? = nil
        /// One or more security group names.
        public var groupNames: [String]? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, subnetId: String? = nil, userData: UserData? = nil, groupIds: [String]? = nil, architecture: String? = nil, additionalInfo: String? = nil, instanceInitiatedShutdownBehavior: String? = nil, placement: Placement? = nil, monitoring: Bool? = nil, instanceType: String? = nil, groupNames: [String]? = nil) {
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
            self.userData = userData
            self.groupIds = groupIds
            self.architecture = architecture
            self.additionalInfo = additionalInfo
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.placement = placement
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.subnetId = dictionary["SubnetId"] as? String
            if let userData = dictionary["UserData"] as? [String: Any] { self.userData = try Ec2.UserData(dictionary: userData) }
            if let groupIds = dictionary["GroupIds"] as? [String] {
                self.groupIds = groupIds
            }
            self.architecture = dictionary["Architecture"] as? String
            self.additionalInfo = dictionary["AdditionalInfo"] as? String
            self.instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? String
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.Placement(dictionary: placement) }
            self.monitoring = dictionary["Monitoring"] as? Bool
            self.instanceType = dictionary["InstanceType"] as? String
            if let groupNames = dictionary["GroupNames"] as? [String] {
                self.groupNames = groupNames
            }
        }
    }

    public struct SpotInstanceStatus: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The description for the status code.
        public var message: String? = nil
        /// The status code. For a list of status codes, see Spot Bid Status Codes in the Amazon Elastic Compute Cloud User Guide.
        public var code: String? = nil
        /// The date and time of the most recent status update, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var updateTime: Date? = nil

        public init() {}

        public init(message: String? = nil, code: String? = nil, updateTime: Date? = nil) {
            self.message = message
            self.code = code
            self.updateTime = updateTime
        }

        public init(dictionary: [String: Any]) throws {
            self.message = dictionary["Message"] as? String
            self.code = dictionary["Code"] as? String
            self.updateTime = dictionary["UpdateTime"] as? Date
        }
    }

    public struct InstanceIpv6Address: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 address.
        public var ipv6Address: String? = nil

        public init() {}

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6Address = dictionary["Ipv6Address"] as? String
        }
    }

    public struct StaleIpPermission: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.
        public var prefixListIds: [String]? = nil
        /// One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.
        public var userIdGroupPairs: [UserIdGroupPair]? = nil
        /// One or more IP ranges. Not applicable for stale security group rules.
        public var ipRanges: [String]? = nil
        /// The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of -1 indicates all ICMP types. 
        public var fromPort: Int32? = nil
        /// The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of -1 indicates all ICMP types. 
        public var toPort: Int32? = nil
        /// The IP protocol name (for tcp, udp, and icmp) or number (see Protocol Numbers).
        public var ipProtocol: String? = nil

        public init() {}

        public init(prefixListIds: [String]? = nil, userIdGroupPairs: [UserIdGroupPair]? = nil, ipRanges: [String]? = nil, fromPort: Int32? = nil, toPort: Int32? = nil, ipProtocol: String? = nil) {
            self.prefixListIds = prefixListIds
            self.userIdGroupPairs = userIdGroupPairs
            self.ipRanges = ipRanges
            self.fromPort = fromPort
            self.toPort = toPort
            self.ipProtocol = ipProtocol
        }

        public init(dictionary: [String: Any]) throws {
            if let prefixListIds = dictionary["PrefixListIds"] as? [String] {
                self.prefixListIds = prefixListIds
            }
            if let userIdGroupPairs = dictionary["UserIdGroupPairs"] as? [[String: Any]] {
                self.userIdGroupPairs = try userIdGroupPairs.map({ try UserIdGroupPair(dictionary: $0) })
            }
            if let ipRanges = dictionary["IpRanges"] as? [String] {
                self.ipRanges = ipRanges
            }
            self.fromPort = dictionary["FromPort"] as? Int32
            self.toPort = dictionary["ToPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
        }
    }

    public struct IamInstanceProfile: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: String? = nil
        /// The ID of the instance profile.
        public var id: String? = nil

        public init() {}

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.arn = dictionary["Arn"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public struct DescribeSecurityGroupsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more security groups.
        public var securityGroups: [SecurityGroup]? = nil

        public init() {}

        public init(securityGroups: [SecurityGroup]? = nil) {
            self.securityGroups = securityGroups
        }

        public init(dictionary: [String: Any]) throws {
            if let securityGroups = dictionary["SecurityGroups"] as? [[String: Any]] {
                self.securityGroups = try securityGroups.map({ try SecurityGroup(dictionary: $0) })
            }
        }
    }

    public struct Purchase: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upfront price of the reservation.
        public var upfrontPrice: String? = nil
        /// The IDs of the Dedicated Hosts associated with the reservation.
        public var hostIdSet: [String]? = nil
        /// The payment option for the reservation.
        public var paymentOption: String? = nil
        /// The hourly price of the reservation per hour.
        public var hourlyPrice: String? = nil
        /// The currency in which the UpfrontPrice and HourlyPrice amounts are specified. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The ID of the reservation.
        public var hostReservationId: String? = nil
        /// The duration of the reservation's term in seconds.
        public var duration: Int32? = nil
        /// The instance family on the Dedicated Host that the reservation can be associated with.
        public var instanceFamily: String? = nil

        public init() {}

        public init(upfrontPrice: String? = nil, hostIdSet: [String]? = nil, paymentOption: String? = nil, hourlyPrice: String? = nil, currencyCode: String? = nil, hostReservationId: String? = nil, duration: Int32? = nil, instanceFamily: String? = nil) {
            self.upfrontPrice = upfrontPrice
            self.hostIdSet = hostIdSet
            self.paymentOption = paymentOption
            self.hourlyPrice = hourlyPrice
            self.currencyCode = currencyCode
            self.hostReservationId = hostReservationId
            self.duration = duration
            self.instanceFamily = instanceFamily
        }

        public init(dictionary: [String: Any]) throws {
            self.upfrontPrice = dictionary["UpfrontPrice"] as? String
            if let hostIdSet = dictionary["HostIdSet"] as? [String] {
                self.hostIdSet = hostIdSet
            }
            self.paymentOption = dictionary["PaymentOption"] as? String
            self.hourlyPrice = dictionary["HourlyPrice"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.hostReservationId = dictionary["HostReservationId"] as? String
            self.duration = dictionary["Duration"] as? Int32
            self.instanceFamily = dictionary["InstanceFamily"] as? String
        }
    }

    public struct RequestSpotFleetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The configuration for the Spot fleet request.
        public var spotFleetRequestConfig: SpotFleetRequestConfigData = SpotFleetRequestConfigData()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(spotFleetRequestConfig: SpotFleetRequestConfigData, dryRun: Bool? = nil) {
            self.spotFleetRequestConfig = spotFleetRequestConfig
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestConfig = dictionary["SpotFleetRequestConfig"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotFleetRequestConfig") }
            self.spotFleetRequestConfig = try Ec2.SpotFleetRequestConfigData(dictionary: spotFleetRequestConfig)
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ReservedInstancesOffering: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The recurring charge tag assigned to the resource.
        public var recurringCharges: [RecurringCharge]? = nil
        /// The usage price of the Reserved Instance, per hour.
        public var usagePrice: Float? = nil
        /// The tenancy of the instance.
        public var instanceTenancy: String? = nil
        /// The pricing details of the Reserved Instance offering.
        public var pricingDetails: [PricingDetail]? = nil
        /// The instance type on which the Reserved Instance can be used.
        public var instanceType: String? = nil
        /// The Reserved Instance offering type.
        public var offeringType: String? = nil
        /// The Reserved Instance product platform description.
        public var productDescription: String? = nil
        /// Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is true.
        public var marketplace: Bool? = nil
        /// The Availability Zone in which the Reserved Instance can be used.
        public var availabilityZone: String? = nil
        /// If convertible it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If standard, it is not possible to perform an exchange.
        public var offeringClass: String? = nil
        /// The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The ID of the Reserved Instance offering. This is the offering ID used in GetReservedInstancesExchangeQuote to confirm that an exchange can be made.
        public var reservedInstancesOfferingId: String? = nil
        /// The duration of the Reserved Instance, in seconds.
        public var duration: Int64? = nil
        /// Whether the Reserved Instance is applied to instances in a region or an Availability Zone.
        public var scope: String? = nil
        /// The purchase price of the Reserved Instance.
        public var fixedPrice: Float? = nil

        public init() {}

        public init(recurringCharges: [RecurringCharge]? = nil, usagePrice: Float? = nil, instanceTenancy: String? = nil, pricingDetails: [PricingDetail]? = nil, instanceType: String? = nil, offeringType: String? = nil, productDescription: String? = nil, marketplace: Bool? = nil, availabilityZone: String? = nil, offeringClass: String? = nil, currencyCode: String? = nil, reservedInstancesOfferingId: String? = nil, duration: Int64? = nil, scope: String? = nil, fixedPrice: Float? = nil) {
            self.recurringCharges = recurringCharges
            self.usagePrice = usagePrice
            self.instanceTenancy = instanceTenancy
            self.pricingDetails = pricingDetails
            self.instanceType = instanceType
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.marketplace = marketplace
            self.availabilityZone = availabilityZone
            self.offeringClass = offeringClass
            self.currencyCode = currencyCode
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.duration = duration
            self.scope = scope
            self.fixedPrice = fixedPrice
        }

        public init(dictionary: [String: Any]) throws {
            if let recurringCharges = dictionary["RecurringCharges"] as? [[String: Any]] {
                self.recurringCharges = try recurringCharges.map({ try RecurringCharge(dictionary: $0) })
            }
            self.usagePrice = dictionary["UsagePrice"] as? Float
            self.instanceTenancy = dictionary["InstanceTenancy"] as? String
            if let pricingDetails = dictionary["PricingDetails"] as? [[String: Any]] {
                self.pricingDetails = try pricingDetails.map({ try PricingDetail(dictionary: $0) })
            }
            self.instanceType = dictionary["InstanceType"] as? String
            self.offeringType = dictionary["OfferingType"] as? String
            self.productDescription = dictionary["ProductDescription"] as? String
            self.marketplace = dictionary["Marketplace"] as? Bool
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.offeringClass = dictionary["OfferingClass"] as? String
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.reservedInstancesOfferingId = dictionary["ReservedInstancesOfferingId"] as? String
            self.duration = dictionary["Duration"] as? Int64
            self.scope = dictionary["Scope"] as? String
            self.fixedPrice = dictionary["FixedPrice"] as? Float
        }
    }

    public struct InstanceCount: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The states of the listed Reserved Instances.
        public var state: String? = nil
        /// The number of listed Reserved Instances in the state specified by the state.
        public var instanceCount: Int32? = nil

        public init() {}

        public init(state: String? = nil, instanceCount: Int32? = nil) {
            self.state = state
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            self.state = dictionary["State"] as? String
            self.instanceCount = dictionary["InstanceCount"] as? Int32
        }
    }

    public struct DescribeNetworkInterfacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more network interface IDs. Default: Describes all your network interfaces.
        public var networkInterfaceIds: [String]? = nil
        /// One or more filters.    addresses.private-ip-address - The private IPv4 addresses associated with the network interface.    addresses.primary - Whether the private IPv4 address is the primary IP address associated with the network interface.     addresses.association.public-ip - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).    addresses.association.owner-id - The owner ID of the addresses associated with the network interface.    association.association-id - The association ID returned when the network interface was associated with an IPv4 address.    association.allocation-id - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.    association.ip-owner-id - The owner of the Elastic IP address (IPv4) associated with the network interface.    association.public-ip - The address of the Elastic IP address (IPv4) bound to the network interface.    association.public-dns-name - The public DNS name for the network interface (IPv4).    attachment.attachment-id - The ID of the interface attachment.    attachment.attach.time - The time that the network interface was attached to an instance.    attachment.delete-on-termination - Indicates whether the attachment is deleted when an instance is terminated.    attachment.device-index - The device index to which the network interface is attached.    attachment.instance-id - The ID of the instance to which the network interface is attached.    attachment.instance-owner-id - The owner ID of the instance to which the network interface is attached.    attachment.nat-gateway-id - The ID of the NAT gateway to which the network interface is attached.    attachment.status - The status of the attachment (attaching | attached | detaching | detached).    availability-zone - The Availability Zone of the network interface.    description - The description of the network interface.    group-id - The ID of a security group associated with the network interface.    group-name - The name of a security group associated with the network interface.    ipv6-addresses.ipv6-address - An IPv6 address associated with the network interface.    mac-address - The MAC address of the network interface.    network-interface-id - The ID of the network interface.    owner-id - The AWS account ID of the network interface owner.    private-ip-address - The private IPv4 address or addresses of the network interface.    private-dns-name - The private DNS name of the network interface (IPv4).    requester-id - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).    requester-managed - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).    source-desk-check - Indicates whether the network interface performs source/destination checking. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the network interface to perform network address translation (NAT) in your VPC.     status - The status of the network interface. If the network interface is not attached to an instance, the status is available; if a network interface is attached to an instance the status is in-use.    subnet-id - The ID of the subnet for the network interface.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the network interface.  
        public var filters: [Filter]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkInterfaceIds: [String]? = nil, filters: [Filter]? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceIds = networkInterfaceIds
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let networkInterfaceIds = dictionary["NetworkInterfaceIds"] as? [String] {
                self.networkInterfaceIds = networkInterfaceIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct CreateNetworkAclResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the network ACL.
        public var networkAcl: NetworkAcl? = nil

        public init() {}

        public init(networkAcl: NetworkAcl? = nil) {
            self.networkAcl = networkAcl
        }

        public init(dictionary: [String: Any]) throws {
            if let networkAcl = dictionary["NetworkAcl"] as? [String: Any] { self.networkAcl = try Ec2.NetworkAcl(dictionary: networkAcl) }
        }
    }

    public struct InstanceBlockDeviceMapping: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        public var ebs: EbsInstanceBlockDevice? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public var deviceName: String? = nil

        public init() {}

        public init(ebs: EbsInstanceBlockDevice? = nil, deviceName: String? = nil) {
            self.ebs = ebs
            self.deviceName = deviceName
        }

        public init(dictionary: [String: Any]) throws {
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.EbsInstanceBlockDevice(dictionary: ebs) }
            self.deviceName = dictionary["DeviceName"] as? String
        }
    }

    public struct VolumeStatusAction: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The code identifying the operation, for example, enable-volume-io.
        public var code: String? = nil
        /// The event type associated with this operation.
        public var eventType: String? = nil
        /// The ID of the event associated with this operation.
        public var eventId: String? = nil
        /// A description of the operation.
        public var description: String? = nil

        public init() {}

        public init(code: String? = nil, eventType: String? = nil, eventId: String? = nil, description: String? = nil) {
            self.code = code
            self.eventType = eventType
            self.eventId = eventId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.eventType = dictionary["EventType"] as? String
            self.eventId = dictionary["EventId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateReservedInstancesListingRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.
        public var priceSchedules: [PriceScheduleSpecification] = []
        /// The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.
        public var instanceCount: Int32 = 0
        /// The ID of the active Standard Reserved Instance.
        public var reservedInstancesId: String = ""
        /// Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see Ensuring Idempotency.
        public var clientToken: String = ""

        public init() {}

        public init(priceSchedules: [PriceScheduleSpecification], instanceCount: Int32, reservedInstancesId: String, clientToken: String) {
            self.priceSchedules = priceSchedules
            self.instanceCount = instanceCount
            self.reservedInstancesId = reservedInstancesId
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let priceSchedules = dictionary["PriceSchedules"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("PriceSchedules") }
            self.priceSchedules = try priceSchedules.map({ try PriceScheduleSpecification(dictionary: $0) })
            guard let instanceCount = dictionary["InstanceCount"] as? Int32 else { throw InitializableError.missingRequiredParam("InstanceCount") }
            self.instanceCount = instanceCount
            guard let reservedInstancesId = dictionary["ReservedInstancesId"] as? String else { throw InitializableError.missingRequiredParam("ReservedInstancesId") }
            self.reservedInstancesId = reservedInstancesId
            guard let clientToken = dictionary["ClientToken"] as? String else { throw InitializableError.missingRequiredParam("ClientToken") }
            self.clientToken = clientToken
        }
    }

    public struct DescribeRouteTablesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more route tables.
        public var routeTables: [RouteTable]? = nil

        public init() {}

        public init(routeTables: [RouteTable]? = nil) {
            self.routeTables = routeTables
        }

        public init(dictionary: [String: Any]) throws {
            if let routeTables = dictionary["RouteTables"] as? [[String: Any]] {
                self.routeTables = try routeTables.map({ try RouteTable(dictionary: $0) })
            }
        }
    }

    public struct AssociateIamInstanceProfileResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the IAM instance profile association.
        public var iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil

        public init() {}

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

        public init(dictionary: [String: Any]) throws {
            if let iamInstanceProfileAssociation = dictionary["IamInstanceProfileAssociation"] as? [String: Any] { self.iamInstanceProfileAssociation = try Ec2.IamInstanceProfileAssociation(dictionary: iamInstanceProfileAssociation) }
        }
    }

    public struct DhcpOptions: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the set of DHCP options.
        public var dhcpOptionsId: String? = nil
        /// One or more DHCP options in the set.
        public var dhcpConfigurations: [DhcpConfiguration]? = nil
        /// Any tags assigned to the DHCP options set.
        public var tags: [Tag]? = nil

        public init() {}

        public init(dhcpOptionsId: String? = nil, dhcpConfigurations: [DhcpConfiguration]? = nil, tags: [Tag]? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
            self.dhcpConfigurations = dhcpConfigurations
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.dhcpOptionsId = dictionary["DhcpOptionsId"] as? String
            if let dhcpConfigurations = dictionary["DhcpConfigurations"] as? [[String: Any]] {
                self.dhcpConfigurations = try dhcpConfigurations.map({ try DhcpConfiguration(dictionary: $0) })
            }
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
        }
    }

    public struct DescribeClassicLinkInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more linked EC2-Classic instances.
        public var instances: [ClassicLinkInstance]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(instances: [ClassicLinkInstance]? = nil, nextToken: String? = nil) {
            self.instances = instances
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try ClassicLinkInstance(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CopyImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when encrypting the snapshots of an image during a copy operation. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. The specified CMK must exist in the region that the snapshot is being copied to. If a KmsKeyId is specified, the Encrypted flag must also be set.
        public var kmsKeyId: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        public var clientToken: String? = nil
        /// The name of the region that contains the AMI to copy.
        public var sourceRegion: String = ""
        /// The name of the new AMI in the destination region.
        public var name: String = ""
        /// Specifies whether the destination snapshots of the copied image should be encrypted. The default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        public var encrypted: Bool? = nil
        /// The ID of the AMI to copy.
        public var sourceImageId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A description for the new AMI in the destination region.
        public var description: String? = nil

        public init() {}

        public init(kmsKeyId: String? = nil, clientToken: String? = nil, sourceRegion: String, name: String, encrypted: Bool? = nil, sourceImageId: String, dryRun: Bool? = nil, description: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.clientToken = clientToken
            self.sourceRegion = sourceRegion
            self.name = name
            self.encrypted = encrypted
            self.sourceImageId = sourceImageId
            self.dryRun = dryRun
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
            self.clientToken = dictionary["ClientToken"] as? String
            guard let sourceRegion = dictionary["SourceRegion"] as? String else { throw InitializableError.missingRequiredParam("SourceRegion") }
            self.sourceRegion = sourceRegion
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.encrypted = dictionary["Encrypted"] as? Bool
            guard let sourceImageId = dictionary["SourceImageId"] as? String else { throw InitializableError.missingRequiredParam("SourceImageId") }
            self.sourceImageId = sourceImageId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeNetworkAclsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more network ACL IDs. Default: Describes all your network ACLs.
        public var networkAclIds: [String]? = nil
        /// One or more filters.    association.association-id - The ID of an association ID for the ACL.    association.network-acl-id - The ID of the network ACL involved in the association.    association.subnet-id - The ID of the subnet involved in the association.    default - Indicates whether the ACL is the default network ACL for the VPC.    entry.cidr - The IPv4 CIDR range specified in the entry.    entry.egress - Indicates whether the entry applies to egress traffic.    entry.icmp.code - The ICMP code specified in the entry, if any.    entry.icmp.type - The ICMP type specified in the entry, if any.    entry.ipv6-cidr - The IPv6 CIDR range specified in the entry.    entry.port-range.from - The start of the port range specified in the entry.     entry.port-range.to - The end of the port range specified in the entry.     entry.protocol - The protocol specified in the entry (tcp | udp | icmp or a protocol number).    entry.rule-action - Allows or denies the matching traffic (allow | deny).    entry.rule-number - The number of an entry (in other words, rule) in the ACL's set of entries.    network-acl-id - The ID of the network ACL.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the network ACL.  
        public var filters: [Filter]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkAclIds: [String]? = nil, filters: [Filter]? = nil) {
            self.dryRun = dryRun
            self.networkAclIds = networkAclIds
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let networkAclIds = dictionary["NetworkAclIds"] as? [String] {
                self.networkAclIds = networkAclIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct TerminateInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more terminated instances.
        public var terminatingInstances: [InstanceStateChange]? = nil

        public init() {}

        public init(terminatingInstances: [InstanceStateChange]? = nil) {
            self.terminatingInstances = terminatingInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let terminatingInstances = dictionary["TerminatingInstances"] as? [[String: Any]] {
                self.terminatingInstances = try terminatingInstances.map({ try InstanceStateChange(dictionary: $0) })
            }
        }
    }

    public struct CreateVolumeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes. Default: standard 
        public var volumeType: String? = nil
        /// Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        public var encrypted: Bool? = nil
        /// The size of the volume, in GiBs. Constraints: 1-16384 for gp2, 4-16384 for io1, 500-16384 for st1, 500-16384 for sc1, and 1-1024 for standard. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        public var size: Int32? = nil
        /// The snapshot from which to create the volume.
        public var snapshotId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Only valid for Provisioned IOPS SSD volumes. The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB. Constraint: Range is 100 to 20000 for Provisioned IOPS SSD volumes 
        public var iops: Int32? = nil
        /// The Availability Zone in which to create the volume. Use DescribeAvailabilityZones to list the Availability Zones that are currently available to you.
        public var availabilityZone: String = ""
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. If a KmsKeyId is specified, the Encrypted flag must also be set.
        public var kmsKeyId: String? = nil

        public init() {}

        public init(volumeType: String? = nil, encrypted: Bool? = nil, size: Int32? = nil, snapshotId: String? = nil, dryRun: Bool? = nil, iops: Int32? = nil, availabilityZone: String, kmsKeyId: String? = nil) {
            self.volumeType = volumeType
            self.encrypted = encrypted
            self.size = size
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            self.volumeType = dictionary["VolumeType"] as? String
            self.encrypted = dictionary["Encrypted"] as? Bool
            self.size = dictionary["Size"] as? Int32
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.iops = dictionary["Iops"] as? Int32
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct DescribeImportSnapshotTasksRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more filters.
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A list of import snapshot task IDs.
        public var importTaskIds: [String]? = nil
        /// A token that indicates the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, importTaskIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.importTaskIds = importTaskIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let importTaskIds = dictionary["ImportTaskIds"] as? [String] {
                self.importTaskIds = importTaskIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DisassociateSubnetCidrBlockResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// Information about the IPv6 CIDR block association.
        public var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil) {
            self.subnetId = subnetId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.SubnetIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) }
        }
    }

    public struct AllocateAddressResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.
        public var allocationId: String? = nil
        /// Indicates whether this Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).
        public var domain: String? = nil
        /// The Elastic IP address.
        public var publicIp: String? = nil

        public init() {}

        public init(allocationId: String? = nil, domain: String? = nil, publicIp: String? = nil) {
            self.allocationId = allocationId
            self.domain = domain
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.allocationId = dictionary["AllocationId"] as? String
            self.domain = dictionary["Domain"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct VolumeModification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Modification start time 
        public var startTime: Date? = nil
        /// Original IOPS rate of the volume being modified.
        public var originalIops: Int32? = nil
        /// Current state of modification. Modification state is null for unmodified volumes. 
        public var modificationState: String? = nil
        /// Original size of the volume being modified.
        public var originalSize: Int32? = nil
        /// Modification progress from 0 to 100%.
        public var progress: Int64? = nil
        /// ID of the volume being modified.
        public var volumeId: String? = nil
        /// Modification completion or failure time.
        public var endTime: Date? = nil
        /// Target EBS volume type of the volume being modified.
        public var targetVolumeType: String? = nil
        /// Target IOPS rate of the volume being modified.
        public var targetIops: Int32? = nil
        /// Original EBS volume type of the volume being modified.
        public var originalVolumeType: String? = nil
        /// Target size of the volume being modified.
        public var targetSize: Int32? = nil
        /// Generic status message on modification progress or failure.
        public var statusMessage: String? = nil

        public init() {}

        public init(startTime: Date? = nil, originalIops: Int32? = nil, modificationState: String? = nil, originalSize: Int32? = nil, progress: Int64? = nil, volumeId: String? = nil, endTime: Date? = nil, targetVolumeType: String? = nil, targetIops: Int32? = nil, originalVolumeType: String? = nil, targetSize: Int32? = nil, statusMessage: String? = nil) {
            self.startTime = startTime
            self.originalIops = originalIops
            self.modificationState = modificationState
            self.originalSize = originalSize
            self.progress = progress
            self.volumeId = volumeId
            self.endTime = endTime
            self.targetVolumeType = targetVolumeType
            self.targetIops = targetIops
            self.originalVolumeType = originalVolumeType
            self.targetSize = targetSize
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            self.originalIops = dictionary["OriginalIops"] as? Int32
            self.modificationState = dictionary["ModificationState"] as? String
            self.originalSize = dictionary["OriginalSize"] as? Int32
            self.progress = dictionary["Progress"] as? Int64
            self.volumeId = dictionary["VolumeId"] as? String
            self.endTime = dictionary["EndTime"] as? Date
            self.targetVolumeType = dictionary["TargetVolumeType"] as? String
            self.targetIops = dictionary["TargetIops"] as? Int32
            self.originalVolumeType = dictionary["OriginalVolumeType"] as? String
            self.targetSize = dictionary["TargetSize"] as? Int32
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct UserBucket: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the S3 bucket where the disk image is located.
        public var s3Bucket: String? = nil
        /// The file name of the disk image.
        public var s3Key: String? = nil

        public init() {}

        public init(s3Bucket: String? = nil, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Bucket = dictionary["S3Bucket"] as? String
            self.s3Key = dictionary["S3Key"] as? String
        }
    }

    public struct AssociateDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// The ID of the DHCP options set, or default to associate no DHCP options with the VPC.
        public var dhcpOptionsId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dhcpOptionsId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let dhcpOptionsId = dictionary["DhcpOptionsId"] as? String else { throw InitializableError.missingRequiredParam("DhcpOptionsId") }
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CreateSnapshotRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the EBS volume.
        public var volumeId: String = ""
        /// A description for the snapshot.
        public var description: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, volumeId: String, description: String? = nil) {
            self.dryRun = dryRun
            self.volumeId = volumeId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeIdFormatRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of resource: instance | reservation | snapshot | volume 
        public var resource: String? = nil

        public init() {}

        public init(resource: String? = nil) {
            self.resource = resource
        }

        public init(dictionary: [String: Any]) throws {
            self.resource = dictionary["Resource"] as? String
        }
    }

    public struct DescribeHostReservationsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more host reservation IDs.
        public var hostReservationIdSet: [String]? = nil
        /// One or more filters.    instance-family - The instance family (e.g., m4).    payment-option - The payment option (NoUpfront | PartialUpfront | AllUpfront).    state - The state of the reservation (payment-pending | payment-failed | active | retired).  
        public var filter: [Filter]? = nil
        /// The token to use to retrieve the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error.
        public var maxResults: Int32? = nil

        public init() {}

        public init(hostReservationIdSet: [String]? = nil, filter: [Filter]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.hostReservationIdSet = hostReservationIdSet
            self.filter = filter
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let hostReservationIdSet = dictionary["HostReservationIdSet"] as? [String] {
                self.hostReservationIdSet = hostReservationIdSet
            }
            if let filter = dictionary["Filter"] as? [[String: Any]] {
                self.filter = try filter.map({ try Filter(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct GetHostReservationPurchasePreviewRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID/s of the Dedicated Host/s that the reservation will be associated with.
        public var hostIdSet: [String] = []
        /// The offering ID of the reservation.
        public var offeringId: String = ""

        public init() {}

        public init(hostIdSet: [String], offeringId: String) {
            self.hostIdSet = hostIdSet
            self.offeringId = offeringId
        }

        public init(dictionary: [String: Any]) throws {
            guard let hostIdSet = dictionary["HostIdSet"] as? [String] else { throw InitializableError.missingRequiredParam("HostIdSet") }
            self.hostIdSet = hostIdSet
            guard let offeringId = dictionary["OfferingId"] as? String else { throw InitializableError.missingRequiredParam("OfferingId") }
            self.offeringId = offeringId
        }
    }

    public struct ActiveInstance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The instance type.
        public var instanceType: String? = nil
        /// The health status of the instance. If the status of both the instance status check and the system status check is impaired, the health status of the instance is unhealthy. Otherwise, the health status is healthy.
        public var instanceHealth: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The ID of the Spot instance request.
        public var spotInstanceRequestId: String? = nil

        public init() {}

        public init(instanceType: String? = nil, instanceHealth: String? = nil, instanceId: String? = nil, spotInstanceRequestId: String? = nil) {
            self.instanceType = instanceType
            self.instanceHealth = instanceHealth
            self.instanceId = instanceId
            self.spotInstanceRequestId = spotInstanceRequestId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceType = dictionary["InstanceType"] as? String
            self.instanceHealth = dictionary["InstanceHealth"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.spotInstanceRequestId = dictionary["SpotInstanceRequestId"] as? String
        }
    }

    public struct DescribeMovingAddressesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The status for each Elastic IP address.
        public var movingAddressStatuses: [MovingAddressStatus]? = nil

        public init() {}

        public init(nextToken: String? = nil, movingAddressStatuses: [MovingAddressStatus]? = nil) {
            self.nextToken = nextToken
            self.movingAddressStatuses = movingAddressStatuses
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let movingAddressStatuses = dictionary["MovingAddressStatuses"] as? [[String: Any]] {
                self.movingAddressStatuses = try movingAddressStatuses.map({ try MovingAddressStatus(dictionary: $0) })
            }
        }
    }

    public struct ExportToS3Task: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The encryption key for your S3 bucket.
        public var s3Key: String? = nil
        /// The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.
        public var containerFormat: String? = nil
        /// The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account vm-import-export@amazon.com.
        public var s3Bucket: String? = nil
        /// The format for the exported image.
        public var diskImageFormat: String? = nil

        public init() {}

        public init(s3Key: String? = nil, containerFormat: String? = nil, s3Bucket: String? = nil, diskImageFormat: String? = nil) {
            self.s3Key = s3Key
            self.containerFormat = containerFormat
            self.s3Bucket = s3Bucket
            self.diskImageFormat = diskImageFormat
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Key = dictionary["S3Key"] as? String
            self.containerFormat = dictionary["ContainerFormat"] as? String
            self.s3Bucket = dictionary["S3Bucket"] as? String
            self.diskImageFormat = dictionary["DiskImageFormat"] as? String
        }
    }

    public struct VpcAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// The current state of the attachment.
        public var state: String? = nil

        public init() {}

        public init(vpcId: String? = nil, state: String? = nil) {
            self.vpcId = vpcId
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            self.state = dictionary["State"] as? String
        }
    }

    public struct Ipv6Range: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix.
        public var cidrIpv6: String? = nil

        public init() {}

        public init(cidrIpv6: String? = nil) {
            self.cidrIpv6 = cidrIpv6
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrIpv6 = dictionary["CidrIpv6"] as? String
        }
    }

    public struct DisableVpcClassicLinkDnsSupportResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct CreateTagsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more tags. The value parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. 
        public var tags: [Tag] = []
        /// The IDs of one or more resources to tag. For example, ami-1a2b3c4d.
        public var resources: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, tags: [Tag], resources: [String]) {
            self.dryRun = dryRun
            self.tags = tags
            self.resources = resources
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
            guard let resources = dictionary["Resources"] as? [String] else { throw InitializableError.missingRequiredParam("Resources") }
            self.resources = resources
        }
    }

    public struct DescribeSnapshotsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more AWS accounts IDs that can create volumes from the snapshot.
        public var restorableByUserIds: [String]? = nil
        /// One or more snapshot IDs. Default: Describes snapshots for which you have launch permissions.
        public var snapshotIds: [String]? = nil
        /// Returns the snapshots owned by the specified owner. Multiple owners can be specified.
        public var ownerIds: [String]? = nil
        /// One or more filters.    description - A description of the snapshot.    owner-alias - Value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM consolew.    owner-id - The ID of the AWS account that owns the snapshot.    progress - The progress of the snapshot, as a percentage (for example, 80%).    snapshot-id - The snapshot ID.    start-time - The time stamp when the snapshot was initiated.    status - The status of the snapshot (pending | completed | error).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    volume-id - The ID of the volume the snapshot is for.    volume-size - The size of the volume, in GiB.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The NextToken value returned from a previous paginated DescribeSnapshots request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The maximum number of snapshot results returned by DescribeSnapshots in paginated output. When this parameter is used, DescribeSnapshots only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another DescribeSnapshots request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then DescribeSnapshots returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.
        public var maxResults: Int32? = nil

        public init() {}

        public init(restorableByUserIds: [String]? = nil, snapshotIds: [String]? = nil, ownerIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.restorableByUserIds = restorableByUserIds
            self.snapshotIds = snapshotIds
            self.ownerIds = ownerIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let restorableByUserIds = dictionary["RestorableByUserIds"] as? [String] {
                self.restorableByUserIds = restorableByUserIds
            }
            if let snapshotIds = dictionary["SnapshotIds"] as? [String] {
                self.snapshotIds = snapshotIds
            }
            if let ownerIds = dictionary["OwnerIds"] as? [String] {
                self.ownerIds = ownerIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CancelReservedInstancesListingRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Reserved Instance listing.
        public var reservedInstancesListingId: String = ""

        public init() {}

        public init(reservedInstancesListingId: String) {
            self.reservedInstancesListingId = reservedInstancesListingId
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstancesListingId = dictionary["ReservedInstancesListingId"] as? String else { throw InitializableError.missingRequiredParam("ReservedInstancesListingId") }
            self.reservedInstancesListingId = reservedInstancesListingId
        }
    }

    public struct ScheduledInstancesMonitoring: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether monitoring is enabled.
        public var enabled: Bool? = nil

        public init() {}

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.enabled = dictionary["Enabled"] as? Bool
        }
    }

    public struct CreateNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A description for the network interface.
        public var description: String? = nil
        /// The ID of the subnet to associate with the network interface.
        public var subnetId: String = ""
        /// The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in privateIpAddresses as primary (only one IP address can be designated as primary).
        public var privateIpAddress: String? = nil
        /// The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using privateIpAddresses. The number of IP addresses you can assign to a network interface varies by instance type. For more information, see IP Addresses Per ENI Per Instance Type in the Amazon Virtual Private Cloud User Guide.
        public var secondaryPrivateIpAddressCount: Int32? = nil
        /// The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the AssignIpv6AddressOnCreation attribute set to true, you can specify 0 to override this setting.
        public var ipv6AddressCount: Int32? = nil
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        public var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The IDs of one or more security groups.
        public var groups: [String]? = nil
        /// One or more private IPv4 addresses.
        public var privateIpAddresses: [PrivateIpAddressSpecification]? = nil

        public init() {}

        public init(description: String? = nil, subnetId: String, privateIpAddress: String? = nil, secondaryPrivateIpAddressCount: Int32? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, dryRun: Bool? = nil, groups: [String]? = nil, privateIpAddresses: [PrivateIpAddressSpecification]? = nil) {
            self.description = description
            self.subnetId = subnetId
            self.privateIpAddress = privateIpAddress
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.dryRun = dryRun
            self.groups = groups
            self.privateIpAddresses = privateIpAddresses
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [[String: Any]] {
                self.ipv6Addresses = try ipv6Addresses.map({ try InstanceIpv6Address(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let groups = dictionary["Groups"] as? [String] {
                self.groups = groups
            }
            if let privateIpAddresses = dictionary["PrivateIpAddresses"] as? [[String: Any]] {
                self.privateIpAddresses = try privateIpAddresses.map({ try PrivateIpAddressSpecification(dictionary: $0) })
            }
        }
    }

    public struct ModifyReservedInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the Reserved Instances to modify.
        public var reservedInstancesIds: [String] = []
        /// The configuration settings for the Reserved Instances to modify.
        public var targetConfigurations: [ReservedInstancesConfiguration] = []
        /// A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see Ensuring Idempotency.
        public var clientToken: String? = nil

        public init() {}

        public init(reservedInstancesIds: [String], targetConfigurations: [ReservedInstancesConfiguration], clientToken: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.targetConfigurations = targetConfigurations
            self.clientToken = clientToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstancesIds = dictionary["ReservedInstancesIds"] as? [String] else { throw InitializableError.missingRequiredParam("ReservedInstancesIds") }
            self.reservedInstancesIds = reservedInstancesIds
            guard let targetConfigurations = dictionary["TargetConfigurations"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TargetConfigurations") }
            self.targetConfigurations = try targetConfigurations.map({ try ReservedInstancesConfiguration(dictionary: $0) })
            self.clientToken = dictionary["ClientToken"] as? String
        }
    }

    public struct CancelSpotFleetRequestsErrorItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""
        /// The error.
        public var error: CancelSpotFleetRequestsError = CancelSpotFleetRequestsError()

        public init() {}

        public init(spotFleetRequestId: String, error: CancelSpotFleetRequestsError) {
            self.spotFleetRequestId = spotFleetRequestId
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            guard let error = dictionary["Error"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Error") }
            self.error = try Ec2.CancelSpotFleetRequestsError(dictionary: error)
        }
    }

    public struct CreateInstanceExportTaskResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the instance export task.
        public var exportTask: ExportTask? = nil

        public init() {}

        public init(exportTask: ExportTask? = nil) {
            self.exportTask = exportTask
        }

        public init(dictionary: [String: Any]) throws {
            if let exportTask = dictionary["ExportTask"] as? [String: Any] { self.exportTask = try Ec2.ExportTask(dictionary: exportTask) }
        }
    }

    public struct DescribeVolumesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more volume IDs.
        public var volumeIds: [String]? = nil
        /// One or more filters.    attachment.attach-time - The time stamp when the attachment initiated.    attachment.delete-on-termination - Whether the volume is deleted on instance termination.    attachment.device - The device name that is exposed to the instance (for example, /dev/sda1).    attachment.instance-id - The ID of the instance the volume is attached to.    attachment.status - The attachment state (attaching | attached | detaching | detached).    availability-zone - The Availability Zone in which the volume was created.    create-time - The time stamp when the volume was created.    encrypted - The encryption status of the volume.    size - The size of the volume, in GiB.    snapshot-id - The snapshot from which the volume was created.    status - The status of the volume (creating | available | in-use | deleting | deleted | error).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    volume-id - The volume ID.    volume-type - The Amazon EBS volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The NextToken value returned from a previous paginated DescribeVolumes request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The maximum number of volume results returned by DescribeVolumes in paginated output. When this parameter is used, DescribeVolumes only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another DescribeVolumes request with the returned NextToken value. This value can be between 5 and 500; if MaxResults is given a value larger than 500, only 500 results are returned. If this parameter is not used, then DescribeVolumes returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.
        public var maxResults: Int32? = nil

        public init() {}

        public init(volumeIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeIds = dictionary["VolumeIds"] as? [String] {
                self.volumeIds = volumeIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the virtual private gateway.
        public var vpnGatewayId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpnGatewayId: String) {
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct DescribeReservedInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of Reserved Instances.
        public var reservedInstances: [ReservedInstances]? = nil

        public init() {}

        public init(reservedInstances: [ReservedInstances]? = nil) {
            self.reservedInstances = reservedInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstances = dictionary["ReservedInstances"] as? [[String: Any]] {
                self.reservedInstances = try reservedInstances.map({ try ReservedInstances(dictionary: $0) })
            }
        }
    }

    public struct EnableVpcClassicLinkDnsSupportRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil

        public init() {}

        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
        }
    }

    public struct DescribeNetworkInterfaceAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// The attribute of the network interface.
        public var attribute: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkInterfaceId: String, attribute: String? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceId = networkInterfaceId
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.attribute = dictionary["Attribute"] as? String
        }
    }

    public struct SlotDateTimeRangeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The earliest date and time, in UTC, for the Scheduled Instance to start.
        public var earliestTime: Date = Date()
        /// The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.
        public var latestTime: Date = Date()

        public init() {}

        public init(earliestTime: Date, latestTime: Date) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

        public init(dictionary: [String: Any]) throws {
            guard let earliestTime = dictionary["EarliestTime"] as? Date else { throw InitializableError.missingRequiredParam("EarliestTime") }
            self.earliestTime = earliestTime
            guard let latestTime = dictionary["LatestTime"] as? Date else { throw InitializableError.missingRequiredParam("LatestTime") }
            self.latestTime = latestTime
        }
    }

    public struct DeleteVpcRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct InstanceBlockDeviceMappingSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// suppress the specified device included in the block device mapping.
        public var noDevice: String? = nil
        /// The virtual device name.
        public var virtualName: String? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public var deviceName: String? = nil
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        public var ebs: EbsInstanceBlockDeviceSpecification? = nil

        public init() {}

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.EbsInstanceBlockDeviceSpecification(dictionary: ebs) }
        }
    }

    public struct InstanceMonitoring: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The monitoring for the instance.
        public var monitoring: Monitoring? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil

        public init() {}

        public init(monitoring: Monitoring? = nil, instanceId: String? = nil) {
            self.monitoring = monitoring
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.Monitoring(dictionary: monitoring) }
            self.instanceId = dictionary["InstanceId"] as? String
        }
    }

    public struct DescribeVpcEndpointsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more endpoint IDs.
        public var vpcEndpointIds: [String]? = nil
        /// One or more filters.    service-name: The name of the AWS service.    vpc-id: The ID of the VPC in which the endpoint resides.    vpc-endpoint-id: The ID of the endpoint.    vpc-endpoint-state: The state of the endpoint. (pending | available | deleting | deleted)  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value is greater than 1000, we return only 1000 items.
        public var maxResults: Int32? = nil

        public init() {}

        public init(vpcEndpointIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.vpcEndpointIds = vpcEndpointIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcEndpointIds = dictionary["VpcEndpointIds"] as? [String] {
                self.vpcEndpointIds = vpcEndpointIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeFlowLogsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Information about the flow logs.
        public var flowLogs: [FlowLog]? = nil

        public init() {}

        public init(nextToken: String? = nil, flowLogs: [FlowLog]? = nil) {
            self.nextToken = nextToken
            self.flowLogs = flowLogs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let flowLogs = dictionary["FlowLogs"] as? [[String: Any]] {
                self.flowLogs = try flowLogs.map({ try FlowLog(dictionary: $0) })
            }
        }
    }

    public struct EnableVpcClassicLinkResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct CreateVpnConnectionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPN connection.
        public var vpnConnection: VpnConnection? = nil

        public init() {}

        public init(vpnConnection: VpnConnection? = nil) {
            self.vpnConnection = vpnConnection
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnConnection = dictionary["VpnConnection"] as? [String: Any] { self.vpnConnection = try Ec2.VpnConnection(dictionary: vpnConnection) }
        }
    }

    public struct PropagatingVgw: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the virtual private gateway (VGW).
        public var gatewayId: String? = nil

        public init() {}

        public init(gatewayId: String? = nil) {
            self.gatewayId = gatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.gatewayId = dictionary["GatewayId"] as? String
        }
    }

    public struct StartInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more started instances.
        public var startingInstances: [InstanceStateChange]? = nil

        public init() {}

        public init(startingInstances: [InstanceStateChange]? = nil) {
            self.startingInstances = startingInstances
        }

        public init(dictionary: [String: Any]) throws {
            if let startingInstances = dictionary["StartingInstances"] as? [[String: Any]] {
                self.startingInstances = try startingInstances.map({ try InstanceStateChange(dictionary: $0) })
            }
        }
    }

    public struct RevokeSecurityGroupEgressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account number for a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public var sourceSecurityGroupOwnerId: String? = nil
        /// A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.
        public var ipPermissions: [IpPermission]? = nil
        /// The CIDR IP address range. We recommend that you specify the CIDR range in a set of IP permissions instead.
        public var cidrIp: String? = nil
        /// The name of a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        public var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public var fromPort: Int32? = nil
        /// The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.
        public var ipProtocol: String? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        public var toPort: Int32? = nil
        /// The ID of the security group.
        public var groupId: String = ""

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, toPort: Int32? = nil, groupId: String) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.toPort = toPort
            self.groupId = groupId
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceSecurityGroupOwnerId = dictionary["SourceSecurityGroupOwnerId"] as? String
            if let ipPermissions = dictionary["IpPermissions"] as? [[String: Any]] {
                self.ipPermissions = try ipPermissions.map({ try IpPermission(dictionary: $0) })
            }
            self.cidrIp = dictionary["CidrIp"] as? String
            self.sourceSecurityGroupName = dictionary["SourceSecurityGroupName"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.fromPort = dictionary["FromPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.toPort = dictionary["ToPort"] as? Int32
            guard let groupId = dictionary["GroupId"] as? String else { throw InitializableError.missingRequiredParam("GroupId") }
            self.groupId = groupId
        }
    }

    public struct DescribeImportImageTasksResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to get the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.
        public var importImageTasks: [ImportImageTask]? = nil

        public init() {}

        public init(nextToken: String? = nil, importImageTasks: [ImportImageTask]? = nil) {
            self.nextToken = nextToken
            self.importImageTasks = importImageTasks
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let importImageTasks = dictionary["ImportImageTasks"] as? [[String: Any]] {
                self.importImageTasks = try importImageTasks.map({ try ImportImageTask(dictionary: $0) })
            }
        }
    }

    public struct InstanceStateChange: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The previous state of the instance.
        public var previousState: InstanceState? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The current state of the instance.
        public var currentState: InstanceState? = nil

        public init() {}

        public init(previousState: InstanceState? = nil, instanceId: String? = nil, currentState: InstanceState? = nil) {
            self.previousState = previousState
            self.instanceId = instanceId
            self.currentState = currentState
        }

        public init(dictionary: [String: Any]) throws {
            if let previousState = dictionary["PreviousState"] as? [String: Any] { self.previousState = try Ec2.InstanceState(dictionary: previousState) }
            self.instanceId = dictionary["InstanceId"] as? String
            if let currentState = dictionary["CurrentState"] as? [String: Any] { self.currentState = try Ec2.InstanceState(dictionary: currentState) }
        }
    }

    public struct GroupIdentifier: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the security group.
        public var groupId: String? = nil
        /// The name of the security group.
        public var groupName: String? = nil

        public init() {}

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.groupId = dictionary["GroupId"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct CreateSubnetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// The Availability Zone for the subnet. Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.
        public var availabilityZone: String? = nil
        /// The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
        public var ipv6CidrBlock: String? = nil
        /// The IPv4 network range for the subnet, in CIDR notation. For example, 10.0.0.0/24.
        public var cidrBlock: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpcId: String, availabilityZone: String? = nil, ipv6CidrBlock: String? = nil, cidrBlock: String) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.availabilityZone = availabilityZone
            self.ipv6CidrBlock = ipv6CidrBlock
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            guard let cidrBlock = dictionary["CidrBlock"] as? String else { throw InitializableError.missingRequiredParam("CidrBlock") }
            self.cidrBlock = cidrBlock
        }
    }

    public struct ReservedInstancesId: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Reserved Instance.
        public var reservedInstancesId: String? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
        }
    }

    public struct ResetNetworkInterfaceAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// The source/destination checking attribute. Resets the value to true.
        public var sourceDestCheck: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkInterfaceId: String, sourceDestCheck: String? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceId = networkInterfaceId
            self.sourceDestCheck = sourceDestCheck
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.sourceDestCheck = dictionary["SourceDestCheck"] as? String
        }
    }

    public struct DescribeInternetGatewaysRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Internet gateway IDs. Default: Describes all your Internet gateways.
        public var internetGatewayIds: [String]? = nil
        /// One or more filters.    attachment.state - The current state of the attachment between the gateway and the VPC (available). Present only if a VPC is attached.    attachment.vpc-id - The ID of an attached VPC.    internet-gateway-id - The ID of the Internet gateway.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(internetGatewayIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.internetGatewayIds = internetGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let internetGatewayIds = dictionary["InternetGatewayIds"] as? [String] {
                self.internetGatewayIds = internetGatewayIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeIdentityIdFormatRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the principal, which can be an IAM role, IAM user, or the root user.
        public var principalArn: String = ""
        /// The type of resource: instance | reservation | snapshot | volume 
        public var resource: String? = nil

        public init() {}

        public init(principalArn: String, resource: String? = nil) {
            self.principalArn = principalArn
            self.resource = resource
        }

        public init(dictionary: [String: Any]) throws {
            guard let principalArn = dictionary["PrincipalArn"] as? String else { throw InitializableError.missingRequiredParam("PrincipalArn") }
            self.principalArn = principalArn
            self.resource = dictionary["Resource"] as? String
        }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Any block device mapping entries.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The value is Windows for Windows AMIs; otherwise blank.
        public var platform: String? = nil
        /// The device name of the root device (for example, /dev/sda1 or /dev/xvda).
        public var rootDeviceName: String? = nil
        /// Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        public var sriovNetSupport: String? = nil
        /// The AWS account alias (for example, amazon, self) or the AWS account ID of the AMI owner.
        public var imageOwnerAlias: String? = nil
        /// Any tags assigned to the image.
        public var tags: [Tag]? = nil
        /// The current state of the AMI. If the state is available, the image is successfully registered and can be used to launch an instance.
        public var state: String? = nil
        /// The kernel associated with the image, if any. Only applicable for machine images.
        public var kernelId: String? = nil
        /// The location of the AMI.
        public var imageLocation: String? = nil
        /// The date and time the image was created.
        public var creationDate: String? = nil
        /// The reason for the state change.
        public var stateReason: StateReason? = nil
        /// The AWS account ID of the image owner.
        public var ownerId: String? = nil
        /// Indicates whether the image has public launch permissions. The value is true if this image has public launch permissions or false if it has only implicit and explicit launch permissions.
        public var `public`: Bool? = nil
        /// The description of the AMI that was provided during image creation.
        public var description: String? = nil
        /// Any product codes associated with the AMI.
        public var productCodes: [ProductCode]? = nil
        /// The hypervisor type of the image.
        public var hypervisor: String? = nil
        /// Specifies whether enhanced networking with ENA is enabled.
        public var enaSupport: Bool? = nil
        /// The name of the AMI that was provided during image creation.
        public var name: String? = nil
        /// The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.
        public var rootDeviceType: String? = nil
        /// The architecture of the image.
        public var architecture: String? = nil
        /// The ID of the AMI.
        public var imageId: String? = nil
        /// The type of image.
        public var imageType: String? = nil
        /// The RAM disk associated with the image, if any. Only applicable for machine images.
        public var ramdiskId: String? = nil
        /// The type of virtualization of the AMI.
        public var virtualizationType: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, platform: String? = nil, rootDeviceName: String? = nil, sriovNetSupport: String? = nil, imageOwnerAlias: String? = nil, tags: [Tag]? = nil, state: String? = nil, kernelId: String? = nil, imageLocation: String? = nil, creationDate: String? = nil, stateReason: StateReason? = nil, ownerId: String? = nil, public: Bool? = nil, description: String? = nil, productCodes: [ProductCode]? = nil, hypervisor: String? = nil, enaSupport: Bool? = nil, name: String? = nil, rootDeviceType: String? = nil, architecture: String? = nil, imageId: String? = nil, imageType: String? = nil, ramdiskId: String? = nil, virtualizationType: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.platform = platform
            self.rootDeviceName = rootDeviceName
            self.sriovNetSupport = sriovNetSupport
            self.imageOwnerAlias = imageOwnerAlias
            self.tags = tags
            self.state = state
            self.kernelId = kernelId
            self.imageLocation = imageLocation
            self.creationDate = creationDate
            self.stateReason = stateReason
            self.ownerId = ownerId
            self.`public` = `public`
            self.description = description
            self.productCodes = productCodes
            self.hypervisor = hypervisor
            self.enaSupport = enaSupport
            self.name = name
            self.rootDeviceType = rootDeviceType
            self.architecture = architecture
            self.imageId = imageId
            self.imageType = imageType
            self.ramdiskId = ramdiskId
            self.virtualizationType = virtualizationType
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.platform = dictionary["Platform"] as? String
            self.rootDeviceName = dictionary["RootDeviceName"] as? String
            self.sriovNetSupport = dictionary["SriovNetSupport"] as? String
            self.imageOwnerAlias = dictionary["ImageOwnerAlias"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.state = dictionary["State"] as? String
            self.kernelId = dictionary["KernelId"] as? String
            self.imageLocation = dictionary["ImageLocation"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            if let stateReason = dictionary["StateReason"] as? [String: Any] { self.stateReason = try Ec2.StateReason(dictionary: stateReason) }
            self.ownerId = dictionary["OwnerId"] as? String
            self.`public` = dictionary["Public"] as? Bool
            self.description = dictionary["Description"] as? String
            if let productCodes = dictionary["ProductCodes"] as? [[String: Any]] {
                self.productCodes = try productCodes.map({ try ProductCode(dictionary: $0) })
            }
            self.hypervisor = dictionary["Hypervisor"] as? String
            self.enaSupport = dictionary["EnaSupport"] as? Bool
            self.name = dictionary["Name"] as? String
            self.rootDeviceType = dictionary["RootDeviceType"] as? String
            self.architecture = dictionary["Architecture"] as? String
            self.imageId = dictionary["ImageId"] as? String
            self.imageType = dictionary["ImageType"] as? String
            self.ramdiskId = dictionary["RamdiskId"] as? String
            self.virtualizationType = dictionary["VirtualizationType"] as? String
        }
    }

    public struct VpnConnectionOptions: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.
        public var staticRoutesOnly: Bool? = nil

        public init() {}

        public init(staticRoutesOnly: Bool? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
        }

        public init(dictionary: [String: Any]) throws {
            self.staticRoutesOnly = dictionary["StaticRoutesOnly"] as? Bool
        }
    }

    public struct DescribeImportImageTasksRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Filter tasks using the task-state filter and one of the following values: active, completed, deleting, deleted.
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A list of import image task IDs.
        public var importTaskIds: [String]? = nil
        /// A token that indicates the next page of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, importTaskIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.importTaskIds = importTaskIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            if let importTaskIds = dictionary["ImportTaskIds"] as? [String] {
                self.importTaskIds = importTaskIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct NatGateway: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet in which the NAT gateway is located.
        public var subnetId: String? = nil
        /// The ID of the NAT gateway.
        public var natGatewayId: String? = nil
        /// The date and time the NAT gateway was deleted, if applicable.
        public var deleteTime: Date? = nil
        /// The ID of the VPC in which the NAT gateway is located.
        public var vpcId: String? = nil
        /// The state of the NAT gateway.    pending: The NAT gateway is being created and is not ready to process traffic.    failed: The NAT gateway could not be created. Check the failureCode and failureMessage fields for the reason.    available: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.    deleting: The NAT gateway is in the process of being terminated and may still be processing traffic.    deleted: The NAT gateway has been terminated and is no longer processing traffic.  
        public var state: String? = nil
        /// If the NAT gateway could not be created, specifies the error code for the failure. (InsufficientFreeAddressesInSubnet | Gateway.NotAttached | InvalidAllocationID.NotFound | Resource.AlreadyAssociated | InternalError | InvalidSubnetID.NotFound)
        public var failureCode: String? = nil
        /// The date and time the NAT gateway was created.
        public var createTime: Date? = nil
        /// If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.   For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"   For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"   For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"   For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"   For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."   For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."  
        public var failureMessage: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        public var provisionedBandwidth: ProvisionedBandwidth? = nil
        /// Information about the IP addresses and network interface associated with the NAT gateway.
        public var natGatewayAddresses: [NatGatewayAddress]? = nil

        public init() {}

        public init(subnetId: String? = nil, natGatewayId: String? = nil, deleteTime: Date? = nil, vpcId: String? = nil, state: String? = nil, failureCode: String? = nil, createTime: Date? = nil, failureMessage: String? = nil, provisionedBandwidth: ProvisionedBandwidth? = nil, natGatewayAddresses: [NatGatewayAddress]? = nil) {
            self.subnetId = subnetId
            self.natGatewayId = natGatewayId
            self.deleteTime = deleteTime
            self.vpcId = vpcId
            self.state = state
            self.failureCode = failureCode
            self.createTime = createTime
            self.failureMessage = failureMessage
            self.provisionedBandwidth = provisionedBandwidth
            self.natGatewayAddresses = natGatewayAddresses
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.natGatewayId = dictionary["NatGatewayId"] as? String
            self.deleteTime = dictionary["DeleteTime"] as? Date
            self.vpcId = dictionary["VpcId"] as? String
            self.state = dictionary["State"] as? String
            self.failureCode = dictionary["FailureCode"] as? String
            self.createTime = dictionary["CreateTime"] as? Date
            self.failureMessage = dictionary["FailureMessage"] as? String
            if let provisionedBandwidth = dictionary["ProvisionedBandwidth"] as? [String: Any] { self.provisionedBandwidth = try Ec2.ProvisionedBandwidth(dictionary: provisionedBandwidth) }
            if let natGatewayAddresses = dictionary["NatGatewayAddresses"] as? [[String: Any]] {
                self.natGatewayAddresses = try natGatewayAddresses.map({ try NatGatewayAddress(dictionary: $0) })
            }
        }
    }

    public struct InstanceCapacity: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The instance type size supported by the Dedicated Host.
        public var instanceType: String? = nil
        /// The total number of instances that can be launched onto the Dedicated Host.
        public var totalCapacity: Int32? = nil
        /// The number of instances that can still be launched onto the Dedicated Host.
        public var availableCapacity: Int32? = nil

        public init() {}

        public init(instanceType: String? = nil, totalCapacity: Int32? = nil, availableCapacity: Int32? = nil) {
            self.instanceType = instanceType
            self.totalCapacity = totalCapacity
            self.availableCapacity = availableCapacity
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceType = dictionary["InstanceType"] as? String
            self.totalCapacity = dictionary["TotalCapacity"] as? Int32
            self.availableCapacity = dictionary["AvailableCapacity"] as? Int32
        }
    }

    public struct UnassignIpv6AddressesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The IPv6 addresses that have been unassigned from the network interface.
        public var unassignedIpv6Addresses: [String]? = nil

        public init() {}

        public init(networkInterfaceId: String? = nil, unassignedIpv6Addresses: [String]? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.unassignedIpv6Addresses = unassignedIpv6Addresses
        }

        public init(dictionary: [String: Any]) throws {
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            if let unassignedIpv6Addresses = dictionary["UnassignedIpv6Addresses"] as? [String] {
                self.unassignedIpv6Addresses = unassignedIpv6Addresses
            }
        }
    }

    public struct ClassicLinkDnsSupport: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// Indicates whether ClassicLink DNS support is enabled for the VPC.
        public var classicLinkDnsSupported: Bool? = nil

        public init() {}

        public init(vpcId: String? = nil, classicLinkDnsSupported: Bool? = nil) {
            self.vpcId = vpcId
            self.classicLinkDnsSupported = classicLinkDnsSupported
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            self.classicLinkDnsSupported = dictionary["ClassicLinkDnsSupported"] as? Bool
        }
    }

    public struct CancelImportTaskResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current state of the task being canceled.
        public var previousState: String? = nil
        /// The current state of the task being canceled.
        public var state: String? = nil
        /// The ID of the task being canceled.
        public var importTaskId: String? = nil

        public init() {}

        public init(previousState: String? = nil, state: String? = nil, importTaskId: String? = nil) {
            self.previousState = previousState
            self.state = state
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.previousState = dictionary["PreviousState"] as? String
            self.state = dictionary["State"] as? String
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct PriceScheduleSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The fixed price for the term.
        public var price: Double? = nil
        /// The currency for transacting the Reserved Instance resale. At this time, the only supported currency is USD.
        public var currencyCode: String? = nil
        /// The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.
        public var term: Int64? = nil

        public init() {}

        public init(price: Double? = nil, currencyCode: String? = nil, term: Int64? = nil) {
            self.price = price
            self.currencyCode = currencyCode
            self.term = term
        }

        public init(dictionary: [String: Any]) throws {
            self.price = dictionary["Price"] as? Double
            self.currencyCode = dictionary["CurrencyCode"] as? String
            self.term = dictionary["Term"] as? Int64
        }
    }

    public struct DescribeIdentityIdFormatResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the ID format for the resources.
        public var statuses: [IdFormat]? = nil

        public init() {}

        public init(statuses: [IdFormat]? = nil) {
            self.statuses = statuses
        }

        public init(dictionary: [String: Any]) throws {
            if let statuses = dictionary["Statuses"] as? [[String: Any]] {
                self.statuses = try statuses.map({ try IdFormat(dictionary: $0) })
            }
        }
    }

    public struct CreateVpnConnectionRouteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPN connection.
        public var vpnConnectionId: String = ""
        /// The CIDR block associated with the local subnet of the customer network.
        public var destinationCidrBlock: String = ""

        public init() {}

        public init(vpnConnectionId: String, destinationCidrBlock: String) {
            self.vpnConnectionId = vpnConnectionId
            self.destinationCidrBlock = destinationCidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpnConnectionId = dictionary["VpnConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpnConnectionId") }
            self.vpnConnectionId = vpnConnectionId
            guard let destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String else { throw InitializableError.missingRequiredParam("DestinationCidrBlock") }
            self.destinationCidrBlock = destinationCidrBlock
        }
    }

    public struct ImportVolumeResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the conversion task.
        public var conversionTask: ConversionTask? = nil

        public init() {}

        public init(conversionTask: ConversionTask? = nil) {
            self.conversionTask = conversionTask
        }

        public init(dictionary: [String: Any]) throws {
            if let conversionTask = dictionary["ConversionTask"] as? [String: Any] { self.conversionTask = try Ec2.ConversionTask(dictionary: conversionTask) }
        }
    }

    public struct VpnConnection: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The VPN connection options.
        public var options: VpnConnectionOptions? = nil
        /// The ID of the customer gateway at your end of the VPN connection.
        public var customerGatewayId: String? = nil
        /// The static routes associated with the VPN connection.
        public var routes: [VpnStaticRoute]? = nil
        /// The ID of the VPN connection.
        public var vpnConnectionId: String? = nil
        /// The current state of the VPN connection.
        public var state: String? = nil
        /// Any tags assigned to the VPN connection.
        public var tags: [Tag]? = nil
        /// Information about the VPN tunnel.
        public var vgwTelemetry: [VgwTelemetry]? = nil
        /// The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the CreateVpnConnection response; however, it's present in the DescribeVpnConnections response only if the VPN connection is in the pending or available state.
        public var customerGatewayConfiguration: String? = nil
        /// The type of VPN connection.
        public var type: String? = nil
        /// The ID of the virtual private gateway at the AWS side of the VPN connection.
        public var vpnGatewayId: String? = nil

        public init() {}

        public init(options: VpnConnectionOptions? = nil, customerGatewayId: String? = nil, routes: [VpnStaticRoute]? = nil, vpnConnectionId: String? = nil, state: String? = nil, tags: [Tag]? = nil, vgwTelemetry: [VgwTelemetry]? = nil, customerGatewayConfiguration: String? = nil, type: String? = nil, vpnGatewayId: String? = nil) {
            self.options = options
            self.customerGatewayId = customerGatewayId
            self.routes = routes
            self.vpnConnectionId = vpnConnectionId
            self.state = state
            self.tags = tags
            self.vgwTelemetry = vgwTelemetry
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.type = type
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            if let options = dictionary["Options"] as? [String: Any] { self.options = try Ec2.VpnConnectionOptions(dictionary: options) }
            self.customerGatewayId = dictionary["CustomerGatewayId"] as? String
            if let routes = dictionary["Routes"] as? [[String: Any]] {
                self.routes = try routes.map({ try VpnStaticRoute(dictionary: $0) })
            }
            self.vpnConnectionId = dictionary["VpnConnectionId"] as? String
            self.state = dictionary["State"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            if let vgwTelemetry = dictionary["VgwTelemetry"] as? [[String: Any]] {
                self.vgwTelemetry = try vgwTelemetry.map({ try VgwTelemetry(dictionary: $0) })
            }
            self.customerGatewayConfiguration = dictionary["CustomerGatewayConfiguration"] as? String
            self.type = dictionary["Type"] as? String
            self.vpnGatewayId = dictionary["VpnGatewayId"] as? String
        }
    }

    public struct Address: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the AWS account that owns the network interface.
        public var networkInterfaceOwnerId: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The ID representing the association of the address with an instance in a VPC.
        public var associationId: String? = nil
        /// The ID of the instance that the address is associated with (if any).
        public var instanceId: String? = nil
        /// The ID representing the allocation of the address for use with EC2-VPC.
        public var allocationId: String? = nil
        /// The Elastic IP address.
        public var publicIp: String? = nil
        /// Indicates whether this Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).
        public var domain: String? = nil
        /// The private IP address associated with the Elastic IP address.
        public var privateIpAddress: String? = nil

        public init() {}

        public init(networkInterfaceOwnerId: String? = nil, networkInterfaceId: String? = nil, associationId: String? = nil, instanceId: String? = nil, allocationId: String? = nil, publicIp: String? = nil, domain: String? = nil, privateIpAddress: String? = nil) {
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.networkInterfaceId = networkInterfaceId
            self.associationId = associationId
            self.instanceId = instanceId
            self.allocationId = allocationId
            self.publicIp = publicIp
            self.domain = domain
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.networkInterfaceOwnerId = dictionary["NetworkInterfaceOwnerId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.associationId = dictionary["AssociationId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
            self.domain = dictionary["Domain"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
        }
    }

    public struct DescribeVpnGatewaysRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more virtual private gateway IDs. Default: Describes all your virtual private gateways.
        public var vpnGatewayIds: [String]? = nil
        /// One or more filters.    attachment.state - The current state of the attachment between the gateway and the VPC (attaching | attached | detaching | detached).    attachment.vpc-id - The ID of an attached VPC.    availability-zone - The Availability Zone for the virtual private gateway (if applicable).    state - The state of the virtual private gateway (pending | available | deleting | deleted).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of virtual private gateway. Currently the only supported type is ipsec.1.    vpn-gateway-id - The ID of the virtual private gateway.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpnGatewayIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.vpnGatewayIds = vpnGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnGatewayIds = dictionary["VpnGatewayIds"] as? [String] {
                self.vpnGatewayIds = vpnGatewayIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct TerminateInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more instance IDs. Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.
        public var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct PurchaseReservedInstancesOfferingResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the purchased Reserved Instances.
        public var reservedInstancesId: String? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesId = dictionary["ReservedInstancesId"] as? String
        }
    }

    public struct CreateNetworkAclRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVpnConnectionsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more VPN connections.
        public var vpnConnections: [VpnConnection]? = nil

        public init() {}

        public init(vpnConnections: [VpnConnection]? = nil) {
            self.vpnConnections = vpnConnections
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnConnections = dictionary["VpnConnections"] as? [[String: Any]] {
                self.vpnConnections = try vpnConnections.map({ try VpnConnection(dictionary: $0) })
            }
        }
    }

    public struct ImportInstanceTaskDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The instance operating system.
        public var platform: String? = nil
        /// One or more volumes.
        public var volumes: [ImportInstanceVolumeDetailItem] = []
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// A description of the task.
        public var description: String? = nil

        public init() {}

        public init(platform: String? = nil, volumes: [ImportInstanceVolumeDetailItem], instanceId: String? = nil, description: String? = nil) {
            self.platform = platform
            self.volumes = volumes
            self.instanceId = instanceId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.platform = dictionary["Platform"] as? String
            guard let volumes = dictionary["Volumes"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Volumes") }
            self.volumes = try volumes.map({ try ImportInstanceVolumeDetailItem(dictionary: $0) })
            self.instanceId = dictionary["InstanceId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct BundleTaskError: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The error code.
        public var code: String? = nil
        /// The error message.
        public var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct AccountAttribute: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the account attribute.
        public var attributeName: String? = nil
        /// One or more values for the account attribute.
        public var attributeValues: [AccountAttributeValue]? = nil

        public init() {}

        public init(attributeName: String? = nil, attributeValues: [AccountAttributeValue]? = nil) {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeName = dictionary["AttributeName"] as? String
            if let attributeValues = dictionary["AttributeValues"] as? [[String: Any]] {
                self.attributeValues = try attributeValues.map({ try AccountAttributeValue(dictionary: $0) })
            }
        }
    }

    public struct ModifyReservedInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID for the modification.
        public var reservedInstancesModificationId: String? = nil

        public init() {}

        public init(reservedInstancesModificationId: String? = nil) {
            self.reservedInstancesModificationId = reservedInstancesModificationId
        }

        public init(dictionary: [String: Any]) throws {
            self.reservedInstancesModificationId = dictionary["ReservedInstancesModificationId"] as? String
        }
    }

    public struct CreateCustomerGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// For devices that support BGP, the customer gateway's BGP ASN. Default: 65000
        public var bgpAsn: Int32 = 0
        /// The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
        public var publicIp: String = ""
        /// The type of VPN connection that this customer gateway supports (ipsec.1).
        public var type: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(bgpAsn: Int32, publicIp: String, type: String, dryRun: Bool? = nil) {
            self.bgpAsn = bgpAsn
            self.publicIp = publicIp
            self.type = type
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let bgpAsn = dictionary["BgpAsn"] as? Int32 else { throw InitializableError.missingRequiredParam("BgpAsn") }
            self.bgpAsn = bgpAsn
            guard let publicIp = dictionary["PublicIp"] as? String else { throw InitializableError.missingRequiredParam("PublicIp") }
            self.publicIp = publicIp
            guard let type = dictionary["Type"] as? String else { throw InitializableError.missingRequiredParam("Type") }
            self.type = type
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CancelSpotInstanceRequestsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more Spot instance request IDs.
        public var spotInstanceRequestIds: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, spotInstanceRequestIds: [String]) {
            self.dryRun = dryRun
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let spotInstanceRequestIds = dictionary["SpotInstanceRequestIds"] as? [String] else { throw InitializableError.missingRequiredParam("SpotInstanceRequestIds") }
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }
    }

    public struct DescribeEgressOnlyInternetGatewaysResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results.
        public var nextToken: String? = nil
        /// Information about the egress-only Internet gateways.
        public var egressOnlyInternetGateways: [EgressOnlyInternetGateway]? = nil

        public init() {}

        public init(nextToken: String? = nil, egressOnlyInternetGateways: [EgressOnlyInternetGateway]? = nil) {
            self.nextToken = nextToken
            self.egressOnlyInternetGateways = egressOnlyInternetGateways
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let egressOnlyInternetGateways = dictionary["EgressOnlyInternetGateways"] as? [[String: Any]] {
                self.egressOnlyInternetGateways = try egressOnlyInternetGateways.map({ try EgressOnlyInternetGateway(dictionary: $0) })
            }
        }
    }

    public struct CreateSecurityGroupRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the security group. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*
        public var groupName: String = ""
        /// [EC2-VPC] The ID of the VPC. Required for EC2-VPC.
        public var vpcId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// A description for the security group. This is informational only. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*
        public var description: String = ""

        public init() {}

        public init(groupName: String, vpcId: String? = nil, dryRun: Bool? = nil, description: String) {
            self.groupName = groupName
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let groupName = dictionary["GroupName"] as? String else { throw InitializableError.missingRequiredParam("GroupName") }
            self.groupName = groupName
            self.vpcId = dictionary["VpcId"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let description = dictionary["Description"] as? String else { throw InitializableError.missingRequiredParam("Description") }
            self.description = description
        }
    }

    public struct MoveAddressToVpcRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The Elastic IP address.
        public var publicIp: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, publicIp: String) {
            self.dryRun = dryRun
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let publicIp = dictionary["PublicIp"] as? String else { throw InitializableError.missingRequiredParam("PublicIp") }
            self.publicIp = publicIp
        }
    }

    public struct DescribeSpotFleetRequestHistoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The last date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). All records up to this time were retrieved. If nextToken indicates that there are more results, this value is not present.
        public var lastEvaluatedTime: Date = Date()
        /// The starting date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var startTime: Date = Date()
        /// Information about the events in the history of the Spot fleet request.
        public var historyRecords: [HistoryRecord] = []
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""

        public init() {}

        public init(lastEvaluatedTime: Date, startTime: Date, historyRecords: [HistoryRecord], nextToken: String? = nil, spotFleetRequestId: String) {
            self.lastEvaluatedTime = lastEvaluatedTime
            self.startTime = startTime
            self.historyRecords = historyRecords
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let lastEvaluatedTime = dictionary["LastEvaluatedTime"] as? Date else { throw InitializableError.missingRequiredParam("LastEvaluatedTime") }
            self.lastEvaluatedTime = lastEvaluatedTime
            guard let startTime = dictionary["StartTime"] as? Date else { throw InitializableError.missingRequiredParam("StartTime") }
            self.startTime = startTime
            guard let historyRecords = dictionary["HistoryRecords"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("HistoryRecords") }
            self.historyRecords = try historyRecords.map({ try HistoryRecord(dictionary: $0) })
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct CreateInternetGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the Internet gateway.
        public var internetGateway: InternetGateway? = nil

        public init() {}

        public init(internetGateway: InternetGateway? = nil) {
            self.internetGateway = internetGateway
        }

        public init(dictionary: [String: Any]) throws {
            if let internetGateway = dictionary["InternetGateway"] as? [String: Any] { self.internetGateway = try Ec2.InternetGateway(dictionary: internetGateway) }
        }
    }

    public struct DescribeImageAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AMI attribute.  Note: Depending on your account privileges, the blockDeviceMapping attribute may return a Client.AuthFailure error. If this happens, use DescribeImages to get information about the block device mapping for the AMI.
        public var attribute: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the AMI.
        public var imageId: String = ""

        public init() {}

        public init(attribute: String, dryRun: Bool? = nil, imageId: String) {
            self.attribute = attribute
            self.dryRun = dryRun
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct ReplaceNetworkAclEntryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24).
        public var cidrBlock: String? = nil
        /// ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.
        public var icmpTypeCode: IcmpTypeCode? = nil
        /// The rule number of the entry to replace.
        public var ruleNumber: Int32 = 0
        /// The IP protocol. You can specify all or -1 to mean all protocols. If you specify all, -1, or a protocol number other than tcp, udp, or icmp, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.
        public var `protocol`: String = ""
        /// Indicates whether to allow or deny the traffic that matches the rule.
        public var ruleAction: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the ACL.
        public var networkAclId: String = ""
        /// Indicates whether to replace the egress rule. Default: If no value is specified, we replace the ingress rule.
        public var egress: Bool = false
        /// The IPv6 network range to allow or deny, in CIDR notation (for example 2001:bd8:1234:1a00::/64).
        public var ipv6CidrBlock: String? = nil
        /// TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.
        public var portRange: PortRange? = nil

        public init() {}

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32, protocol: String, ruleAction: String, dryRun: Bool? = nil, networkAclId: String, egress: Bool, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.dryRun = dryRun
            self.networkAclId = networkAclId
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrBlock = dictionary["CidrBlock"] as? String
            if let icmpTypeCode = dictionary["IcmpTypeCode"] as? [String: Any] { self.icmpTypeCode = try Ec2.IcmpTypeCode(dictionary: icmpTypeCode) }
            guard let ruleNumber = dictionary["RuleNumber"] as? Int32 else { throw InitializableError.missingRequiredParam("RuleNumber") }
            self.ruleNumber = ruleNumber
            guard let `protocol` = dictionary["Protocol"] as? String else { throw InitializableError.missingRequiredParam("Protocol") }
            self.`protocol` = `protocol`
            guard let ruleAction = dictionary["RuleAction"] as? String else { throw InitializableError.missingRequiredParam("RuleAction") }
            self.ruleAction = ruleAction
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
            guard let egress = dictionary["Egress"] as? Bool else { throw InitializableError.missingRequiredParam("Egress") }
            self.egress = egress
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            if let portRange = dictionary["PortRange"] as? [String: Any] { self.portRange = try Ec2.PortRange(dictionary: portRange) }
        }
    }

    public struct DeleteKeyPairRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the key pair.
        public var keyName: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(keyName: String, dryRun: Bool? = nil) {
            self.keyName = keyName
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let keyName = dictionary["KeyName"] as? String else { throw InitializableError.missingRequiredParam("KeyName") }
            self.keyName = keyName
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct EbsBlockDevice: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the snapshot.
        public var snapshotId: String? = nil
        /// Indicates whether the EBS volume is deleted on instance termination.
        public var deleteOnTermination: Bool? = nil
        /// The volume type: gp2, io1, st1, sc1, or standard. Default: standard 
        public var volumeType: String? = nil
        /// The size of the volume, in GiB. Constraints: 1-16384 for General Purpose SSD (gp2), 4-16384 for Provisioned IOPS SSD (io1), 500-16384 for Throughput Optimized HDD (st1), 500-16384 for Cold HDD (sc1), and 1-1024 for Magnetic (standard) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        public var volumeSize: Int32? = nil
        /// The number of I/O operations per second (IOPS) that the volume supports. For io1, this represents the number of IOPS that are provisioned for the volume. For gp2, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        public var iops: Int32? = nil
        /// Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.
        public var encrypted: Bool? = nil

        public init() {}

        public init(snapshotId: String? = nil, deleteOnTermination: Bool? = nil, volumeType: String? = nil, volumeSize: Int32? = nil, iops: Int32? = nil, encrypted: Bool? = nil) {
            self.snapshotId = snapshotId
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.volumeSize = volumeSize
            self.iops = iops
            self.encrypted = encrypted
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.volumeType = dictionary["VolumeType"] as? String
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.iops = dictionary["Iops"] as? Int32
            self.encrypted = dictionary["Encrypted"] as? Bool
        }
    }

    public struct DescribeExportTasksResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the export tasks.
        public var exportTasks: [ExportTask]? = nil

        public init() {}

        public init(exportTasks: [ExportTask]? = nil) {
            self.exportTasks = exportTasks
        }

        public init(dictionary: [String: Any]) throws {
            if let exportTasks = dictionary["ExportTasks"] as? [[String: Any]] {
                self.exportTasks = try exportTasks.map({ try ExportTask(dictionary: $0) })
            }
        }
    }

    public struct CreateVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPC peering connection.
        public var vpcPeeringConnection: VpcPeeringConnection? = nil

        public init() {}

        public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
            self.vpcPeeringConnection = vpcPeeringConnection
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcPeeringConnection = dictionary["VpcPeeringConnection"] as? [String: Any] { self.vpcPeeringConnection = try Ec2.VpcPeeringConnection(dictionary: vpcPeeringConnection) }
        }
    }

    public struct IpRange: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix.
        public var cidrIp: String? = nil

        public init() {}

        public init(cidrIp: String? = nil) {
            self.cidrIp = cidrIp
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrIp = dictionary["CidrIp"] as? String
        }
    }

    public struct DhcpConfiguration: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of a DHCP option.
        public var key: String? = nil
        /// One or more values for the DHCP option.
        public var values: [AttributeValue]? = nil

        public init() {}

        public init(key: String? = nil, values: [AttributeValue]? = nil) {
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            if let values = dictionary["Values"] as? [[String: Any]] {
                self.values = try values.map({ try AttributeValue(dictionary: $0) })
            }
        }
    }

    public struct CancelConversionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the conversion task.
        public var conversionTaskId: String = ""
        /// The reason for canceling the conversion task.
        public var reasonMessage: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, conversionTaskId: String, reasonMessage: String? = nil) {
            self.dryRun = dryRun
            self.conversionTaskId = conversionTaskId
            self.reasonMessage = reasonMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let conversionTaskId = dictionary["ConversionTaskId"] as? String else { throw InitializableError.missingRequiredParam("ConversionTaskId") }
            self.conversionTaskId = conversionTaskId
            self.reasonMessage = dictionary["ReasonMessage"] as? String
        }
    }

    public struct ModifyInstancePlacementResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Is true if the request succeeds, and an error otherwise.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct DescribeVpcAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The VPC attribute.
        public var attribute: String = ""

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil, attribute: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
        }
    }

    public struct ReservedInstancesModification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of one or more Reserved Instances.
        public var reservedInstancesIds: [ReservedInstancesId]? = nil
        /// The status of the Reserved Instances modification request.
        public var status: String? = nil
        /// The time for the modification to become effective.
        public var effectiveDate: Date? = nil
        /// A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see Ensuring Idempotency.
        public var clientToken: String? = nil
        /// Contains target configurations along with their corresponding new Reserved Instance IDs.
        public var modificationResults: [ReservedInstancesModificationResult]? = nil
        /// The time when the modification request was last updated.
        public var updateDate: Date? = nil
        /// A unique ID for the Reserved Instance modification.
        public var reservedInstancesModificationId: String? = nil
        /// The time when the modification request was created.
        public var createDate: Date? = nil
        /// The reason for the status.
        public var statusMessage: String? = nil

        public init() {}

        public init(reservedInstancesIds: [ReservedInstancesId]? = nil, status: String? = nil, effectiveDate: Date? = nil, clientToken: String? = nil, modificationResults: [ReservedInstancesModificationResult]? = nil, updateDate: Date? = nil, reservedInstancesModificationId: String? = nil, createDate: Date? = nil, statusMessage: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.status = status
            self.effectiveDate = effectiveDate
            self.clientToken = clientToken
            self.modificationResults = modificationResults
            self.updateDate = updateDate
            self.reservedInstancesModificationId = reservedInstancesModificationId
            self.createDate = createDate
            self.statusMessage = statusMessage
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesIds = dictionary["ReservedInstancesIds"] as? [[String: Any]] {
                self.reservedInstancesIds = try reservedInstancesIds.map({ try ReservedInstancesId(dictionary: $0) })
            }
            self.status = dictionary["Status"] as? String
            self.effectiveDate = dictionary["EffectiveDate"] as? Date
            self.clientToken = dictionary["ClientToken"] as? String
            if let modificationResults = dictionary["ModificationResults"] as? [[String: Any]] {
                self.modificationResults = try modificationResults.map({ try ReservedInstancesModificationResult(dictionary: $0) })
            }
            self.updateDate = dictionary["UpdateDate"] as? Date
            self.reservedInstancesModificationId = dictionary["ReservedInstancesModificationId"] as? String
            self.createDate = dictionary["CreateDate"] as? Date
            self.statusMessage = dictionary["StatusMessage"] as? String
        }
    }

    public struct DescribeAvailabilityZonesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more Availability Zones.
        public var availabilityZones: [AvailabilityZone]? = nil

        public init() {}

        public init(availabilityZones: [AvailabilityZone]? = nil) {
            self.availabilityZones = availabilityZones
        }

        public init(dictionary: [String: Any]) throws {
            if let availabilityZones = dictionary["AvailabilityZones"] as? [[String: Any]] {
                self.availabilityZones = try availabilityZones.map({ try AvailabilityZone(dictionary: $0) })
            }
        }
    }

    public struct RejectVpcPeeringConnectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpcPeeringConnectionId") }
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

    public struct ReplaceIamInstanceProfileAssociationResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the IAM instance profile association.
        public var iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil

        public init() {}

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

        public init(dictionary: [String: Any]) throws {
            if let iamInstanceProfileAssociation = dictionary["IamInstanceProfileAssociation"] as? [String: Any] { self.iamInstanceProfileAssociation = try Ec2.IamInstanceProfileAssociation(dictionary: iamInstanceProfileAssociation) }
        }
    }

    public struct CreateImageResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the new AMI.
        public var imageId: String? = nil

        public init() {}

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct ImportVolumeTaskDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The image.
        public var image: DiskImageDescription = DiskImageDescription()
        /// The number of bytes converted so far.
        public var bytesConverted: Int64 = 0
        /// The volume.
        public var volume: DiskImageVolumeDescription = DiskImageVolumeDescription()
        /// The Availability Zone where the resulting volume will reside.
        public var availabilityZone: String = ""
        /// The description you provided when starting the import volume task.
        public var description: String? = nil

        public init() {}

        public init(image: DiskImageDescription, bytesConverted: Int64, volume: DiskImageVolumeDescription, availabilityZone: String, description: String? = nil) {
            self.image = image
            self.bytesConverted = bytesConverted
            self.volume = volume
            self.availabilityZone = availabilityZone
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Ec2.DiskImageDescription(dictionary: image)
            guard let bytesConverted = dictionary["BytesConverted"] as? Int64 else { throw InitializableError.missingRequiredParam("BytesConverted") }
            self.bytesConverted = bytesConverted
            guard let volume = dictionary["Volume"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Volume") }
            self.volume = try Ec2.DiskImageVolumeDescription(dictionary: volume)
            guard let availabilityZone = dictionary["AvailabilityZone"] as? String else { throw InitializableError.missingRequiredParam("AvailabilityZone") }
            self.availabilityZone = availabilityZone
            self.description = dictionary["Description"] as? String
        }
    }

    public struct NetworkInterfaceAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The address of the Elastic IP address bound to the network interface.
        public var publicIp: String? = nil
        /// The association ID.
        public var associationId: String? = nil
        /// The ID of the Elastic IP address owner.
        public var ipOwnerId: String? = nil
        /// The allocation ID.
        public var allocationId: String? = nil
        /// The public DNS name.
        public var publicDnsName: String? = nil

        public init() {}

        public init(publicIp: String? = nil, associationId: String? = nil, ipOwnerId: String? = nil, allocationId: String? = nil, publicDnsName: String? = nil) {
            self.publicIp = publicIp
            self.associationId = associationId
            self.ipOwnerId = ipOwnerId
            self.allocationId = allocationId
            self.publicDnsName = publicDnsName
        }

        public init(dictionary: [String: Any]) throws {
            self.publicIp = dictionary["PublicIp"] as? String
            self.associationId = dictionary["AssociationId"] as? String
            self.ipOwnerId = dictionary["IpOwnerId"] as? String
            self.allocationId = dictionary["AllocationId"] as? String
            self.publicDnsName = dictionary["PublicDnsName"] as? String
        }
    }

    public struct ScheduledInstanceRecurrenceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.
        public var occurrenceDays: [Int32]? = nil
        /// The frequency (Daily, Weekly, or Monthly).
        public var frequency: String? = nil
        /// The unit for OccurrenceDays (DayOfWeek or DayOfMonth). This value is required for a monthly schedule. You can't specify DayOfWeek with a weekly schedule. You can't specify this value with a daily schedule.
        public var occurrenceUnit: String? = nil
        /// Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.
        public var occurrenceRelativeToEnd: Bool? = nil
        /// The interval quantity. The interval unit depends on the value of Frequency. For example, every 2 weeks or every 2 months.
        public var interval: Int32? = nil

        public init() {}

        public init(occurrenceDays: [Int32]? = nil, frequency: String? = nil, occurrenceUnit: String? = nil, occurrenceRelativeToEnd: Bool? = nil, interval: Int32? = nil) {
            self.occurrenceDays = occurrenceDays
            self.frequency = frequency
            self.occurrenceUnit = occurrenceUnit
            self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
            self.interval = interval
        }

        public init(dictionary: [String: Any]) throws {
            if let occurrenceDays = dictionary["OccurrenceDays"] as? [Int32] {
                self.occurrenceDays = occurrenceDays
            }
            self.frequency = dictionary["Frequency"] as? String
            self.occurrenceUnit = dictionary["OccurrenceUnit"] as? String
            self.occurrenceRelativeToEnd = dictionary["OccurrenceRelativeToEnd"] as? Bool
            self.interval = dictionary["Interval"] as? Int32
        }
    }

    public struct Filter: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the filter. Filter names are case-sensitive.
        public var name: String? = nil
        /// One or more filter values. Filter values are case-sensitive.
        public var values: [String]? = nil

        public init() {}

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            if let values = dictionary["Values"] as? [String] {
                self.values = values
            }
        }
    }

    public struct MonitorInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more instance IDs.
        public var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct LaunchSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instance.
        public var subnetId: String? = nil
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var userData: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        public var ebsOptimized: Bool? = nil
        /// The ID of the kernel.
        public var kernelId: String? = nil
        public var monitoring: RunInstancesMonitoringEnabled? = nil
        /// The instance type.
        public var instanceType: String? = nil
        /// One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
        public var securityGroups: [GroupIdentifier]? = nil
        /// The name of the key pair.
        public var keyName: String? = nil
        /// Deprecated.
        public var addressingType: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// The ID of the AMI.
        public var imageId: String? = nil
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        public var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The placement information for the instance.
        public var placement: SpotPlacement? = nil
        /// The ID of the RAM disk.
        public var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, instanceType: String? = nil, securityGroups: [GroupIdentifier]? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.RunInstancesMonitoringEnabled(dictionary: monitoring) }
            self.instanceType = dictionary["InstanceType"] as? String
            if let securityGroups = dictionary["SecurityGroups"] as? [[String: Any]] {
                self.securityGroups = try securityGroups.map({ try GroupIdentifier(dictionary: $0) })
            }
            self.keyName = dictionary["KeyName"] as? String
            self.addressingType = dictionary["AddressingType"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) }
            self.imageId = dictionary["ImageId"] as? String
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try InstanceNetworkInterfaceSpecification(dictionary: $0) })
            }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.SpotPlacement(dictionary: placement) }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct RequestSpotInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Spot instance requests.
        public var spotInstanceRequests: [SpotInstanceRequest]? = nil

        public init() {}

        public init(spotInstanceRequests: [SpotInstanceRequest]? = nil) {
            self.spotInstanceRequests = spotInstanceRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let spotInstanceRequests = dictionary["SpotInstanceRequests"] as? [[String: Any]] {
                self.spotInstanceRequests = try spotInstanceRequests.map({ try SpotInstanceRequest(dictionary: $0) })
            }
        }
    }

    public struct CreateNetworkAclEntryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24).
        public var cidrBlock: String? = nil
        /// ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.
        public var icmpTypeCode: IcmpTypeCode? = nil
        /// The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number. Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.
        public var ruleNumber: Int32 = 0
        /// The protocol. A value of -1 or all means all protocols. If you specify all, -1, or a protocol number other than tcp, udp, or icmp, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.
        public var `protocol`: String = ""
        /// Indicates whether to allow or deny the traffic that matches the rule.
        public var ruleAction: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the network ACL.
        public var networkAclId: String = ""
        /// Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).
        public var egress: Bool = false
        /// The IPv6 network range to allow or deny, in CIDR notation (for example 2001:db8:1234:1a00::/64).
        public var ipv6CidrBlock: String? = nil
        /// TCP or UDP protocols: The range of ports the rule applies to.
        public var portRange: PortRange? = nil

        public init() {}

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32, protocol: String, ruleAction: String, dryRun: Bool? = nil, networkAclId: String, egress: Bool, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.dryRun = dryRun
            self.networkAclId = networkAclId
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

        public init(dictionary: [String: Any]) throws {
            self.cidrBlock = dictionary["CidrBlock"] as? String
            if let icmpTypeCode = dictionary["IcmpTypeCode"] as? [String: Any] { self.icmpTypeCode = try Ec2.IcmpTypeCode(dictionary: icmpTypeCode) }
            guard let ruleNumber = dictionary["RuleNumber"] as? Int32 else { throw InitializableError.missingRequiredParam("RuleNumber") }
            self.ruleNumber = ruleNumber
            guard let `protocol` = dictionary["Protocol"] as? String else { throw InitializableError.missingRequiredParam("Protocol") }
            self.`protocol` = `protocol`
            guard let ruleAction = dictionary["RuleAction"] as? String else { throw InitializableError.missingRequiredParam("RuleAction") }
            self.ruleAction = ruleAction
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
            guard let egress = dictionary["Egress"] as? Bool else { throw InitializableError.missingRequiredParam("Egress") }
            self.egress = egress
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            if let portRange = dictionary["PortRange"] as? [String: Any] { self.portRange = try Ec2.PortRange(dictionary: portRange) }
        }
    }

    public struct CancelBundleTaskResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the bundle task.
        public var bundleTask: BundleTask? = nil

        public init() {}

        public init(bundleTask: BundleTask? = nil) {
            self.bundleTask = bundleTask
        }

        public init(dictionary: [String: Any]) throws {
            if let bundleTask = dictionary["BundleTask"] as? [String: Any] { self.bundleTask = try Ec2.BundleTask(dictionary: bundleTask) }
        }
    }

    public struct VpcPeeringConnection: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the requester VPC.
        public var requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil
        /// Information about the accepter VPC. CIDR block information is not returned when creating a VPC peering connection, or when describing a VPC peering connection that's in the initiating-request or pending-acceptance state.
        public var accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil
        /// The status of the VPC peering connection.
        public var status: VpcPeeringConnectionStateReason? = nil
        /// The time that an unaccepted VPC peering connection will expire.
        public var expirationTime: Date? = nil
        /// Any tags assigned to the resource.
        public var tags: [Tag]? = nil
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil, accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil, status: VpcPeeringConnectionStateReason? = nil, expirationTime: Date? = nil, tags: [Tag]? = nil, vpcPeeringConnectionId: String? = nil) {
            self.requesterVpcInfo = requesterVpcInfo
            self.accepterVpcInfo = accepterVpcInfo
            self.status = status
            self.expirationTime = expirationTime
            self.tags = tags
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            if let requesterVpcInfo = dictionary["RequesterVpcInfo"] as? [String: Any] { self.requesterVpcInfo = try Ec2.VpcPeeringConnectionVpcInfo(dictionary: requesterVpcInfo) }
            if let accepterVpcInfo = dictionary["AccepterVpcInfo"] as? [String: Any] { self.accepterVpcInfo = try Ec2.VpcPeeringConnectionVpcInfo(dictionary: accepterVpcInfo) }
            if let status = dictionary["Status"] as? [String: Any] { self.status = try Ec2.VpcPeeringConnectionStateReason(dictionary: status) }
            self.expirationTime = dictionary["ExpirationTime"] as? Date
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct RegisterImageResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the newly registered AMI.
        public var imageId: String? = nil

        public init() {}

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct ClientData: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A user-defined comment about the disk upload.
        public var comment: String? = nil
        /// The time that the disk upload starts.
        public var uploadStart: Date? = nil
        /// The time that the disk upload ends.
        public var uploadEnd: Date? = nil
        /// The size of the uploaded disk image, in GiB.
        public var uploadSize: Double? = nil

        public init() {}

        public init(comment: String? = nil, uploadStart: Date? = nil, uploadEnd: Date? = nil, uploadSize: Double? = nil) {
            self.comment = comment
            self.uploadStart = uploadStart
            self.uploadEnd = uploadEnd
            self.uploadSize = uploadSize
        }

        public init(dictionary: [String: Any]) throws {
            self.comment = dictionary["Comment"] as? String
            self.uploadStart = dictionary["UploadStart"] as? Date
            self.uploadEnd = dictionary["UploadEnd"] as? Date
            self.uploadSize = dictionary["UploadSize"] as? Double
        }
    }

    public struct RejectVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct DiskImageDescription: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The disk image format.
        public var format: String = ""
        /// The checksum computed for the disk image.
        public var checksum: String? = nil
        /// The size of the disk image, in GiB.
        public var size: Int64 = 0
        /// A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the Authenticating REST Requests topic in the Amazon Simple Storage Service Developer Guide. For information about the import manifest referenced by this API action, see VM Import Manifest.
        public var importManifestUrl: String = ""

        public init() {}

        public init(format: String, checksum: String? = nil, size: Int64, importManifestUrl: String) {
            self.format = format
            self.checksum = checksum
            self.size = size
            self.importManifestUrl = importManifestUrl
        }

        public init(dictionary: [String: Any]) throws {
            guard let format = dictionary["Format"] as? String else { throw InitializableError.missingRequiredParam("Format") }
            self.format = format
            self.checksum = dictionary["Checksum"] as? String
            guard let size = dictionary["Size"] as? Int64 else { throw InitializableError.missingRequiredParam("Size") }
            self.size = size
            guard let importManifestUrl = dictionary["ImportManifestUrl"] as? String else { throw InitializableError.missingRequiredParam("ImportManifestUrl") }
            self.importManifestUrl = importManifestUrl
        }
    }

    public struct CreateSubnetResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the subnet.
        public var subnet: Subnet? = nil

        public init() {}

        public init(subnet: Subnet? = nil) {
            self.subnet = subnet
        }

        public init(dictionary: [String: Any]) throws {
            if let subnet = dictionary["Subnet"] as? [String: Any] { self.subnet = try Ec2.Subnet(dictionary: subnet) }
        }
    }

    public struct GetConsoleOutputResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time the output was last updated.
        public var timestamp: Date? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The console output, Base64-encoded. If using a command line tool, the tool decodes the output for you.
        public var output: String? = nil

        public init() {}

        public init(timestamp: Date? = nil, instanceId: String? = nil, output: String? = nil) {
            self.timestamp = timestamp
            self.instanceId = instanceId
            self.output = output
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.instanceId = dictionary["InstanceId"] as? String
            self.output = dictionary["Output"] as? String
        }
    }

    public struct DisassociateRouteTableRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The association ID representing the current association between the route table and subnet.
        public var associationId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, associationId: String) {
            self.dryRun = dryRun
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
        }
    }

    public struct AssignIpv6AddressesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        public var ipv6AddressCount: Int32? = nil
        /// One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.
        public var ipv6Addresses: [String]? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""

        public init() {}

        public init(ipv6AddressCount: Int32? = nil, ipv6Addresses: [String]? = nil, networkInterfaceId: String) {
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [String] {
                self.ipv6Addresses = ipv6Addresses
            }
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
        }
    }

    public struct DescribeImportSnapshotTasksResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to get the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.
        public var importSnapshotTasks: [ImportSnapshotTask]? = nil

        public init() {}

        public init(nextToken: String? = nil, importSnapshotTasks: [ImportSnapshotTask]? = nil) {
            self.nextToken = nextToken
            self.importSnapshotTasks = importSnapshotTasks
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let importSnapshotTasks = dictionary["ImportSnapshotTasks"] as? [[String: Any]] {
                self.importSnapshotTasks = try importSnapshotTasks.map({ try ImportSnapshotTask(dictionary: $0) })
            }
        }
    }

    public struct VolumeStatusInfo: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The details of the volume status.
        public var details: [VolumeStatusDetails]? = nil
        /// The status of the volume.
        public var status: String? = nil

        public init() {}

        public init(details: [VolumeStatusDetails]? = nil, status: String? = nil) {
            self.details = details
            self.status = status
        }

        public init(dictionary: [String: Any]) throws {
            if let details = dictionary["Details"] as? [[String: Any]] {
                self.details = try details.map({ try VolumeStatusDetails(dictionary: $0) })
            }
            self.status = dictionary["Status"] as? String
        }
    }

    public struct DisableVpcClassicLinkDnsSupportRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil

        public init() {}

        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
        }
    }

    public struct DescribeSubnetsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more subnets.
        public var subnets: [Subnet]? = nil

        public init() {}

        public init(subnets: [Subnet]? = nil) {
            self.subnets = subnets
        }

        public init(dictionary: [String: Any]) throws {
            if let subnets = dictionary["Subnets"] as? [[String: Any]] {
                self.subnets = try subnets.map({ try Subnet(dictionary: $0) })
            }
        }
    }

    public struct DeleteVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns true if the request succeeds; otherwise, it returns an error.
        public var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

        public init(dictionary: [String: Any]) throws {
            self.`return` = dictionary["Return"] as? Bool
        }
    }

    public struct UserBucketDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The S3 bucket from which the disk image was created.
        public var s3Bucket: String? = nil
        /// The file name of the disk image.
        public var s3Key: String? = nil

        public init() {}

        public init(s3Bucket: String? = nil, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Bucket = dictionary["S3Bucket"] as? String
            self.s3Key = dictionary["S3Key"] as? String
        }
    }

    public struct RequestSpotFleetResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""

        public init() {}

        public init(spotFleetRequestId: String) {
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct DeleteVpcEndpointsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the endpoints that were not successfully deleted.
        public var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(unsuccessful: [UnsuccessfulItem]? = nil) {
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let unsuccessful = dictionary["Unsuccessful"] as? [[String: Any]] {
                self.unsuccessful = try unsuccessful.map({ try UnsuccessfulItem(dictionary: $0) })
            }
        }
    }

    public struct DescribeEgressOnlyInternetGatewaysRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned.
        public var maxResults: Int32? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token to retrieve the next page of results.
        public var nextToken: String? = nil
        /// One or more egress-only Internet gateway IDs.
        public var egressOnlyInternetGatewayIds: [String]? = nil

        public init() {}

        public init(maxResults: Int32? = nil, dryRun: Bool? = nil, nextToken: String? = nil, egressOnlyInternetGatewayIds: [String]? = nil) {
            self.maxResults = maxResults
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.egressOnlyInternetGatewayIds = egressOnlyInternetGatewayIds
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            if let egressOnlyInternetGatewayIds = dictionary["EgressOnlyInternetGatewayIds"] as? [String] {
                self.egressOnlyInternetGatewayIds = egressOnlyInternetGatewayIds
            }
        }
    }

    public struct AttachInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// The ID of the Internet gateway.
        public var internetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, internetGatewayId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let internetGatewayId = dictionary["InternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("InternetGatewayId") }
            self.internetGatewayId = internetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct CopySnapshotResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the new snapshot.
        public var snapshotId: String? = nil

        public init() {}

        public init(snapshotId: String? = nil) {
            self.snapshotId = snapshotId
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
        }
    }

    public struct VpcIpv6CidrBlockAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the state of the CIDR block.
        public var ipv6CidrBlockState: VpcCidrBlockState? = nil
        /// The IPv6 CIDR block.
        public var ipv6CidrBlock: String? = nil
        /// The association ID for the IPv6 CIDR block.
        public var associationId: String? = nil

        public init() {}

        public init(ipv6CidrBlockState: VpcCidrBlockState? = nil, ipv6CidrBlock: String? = nil, associationId: String? = nil) {
            self.ipv6CidrBlockState = ipv6CidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            if let ipv6CidrBlockState = dictionary["Ipv6CidrBlockState"] as? [String: Any] { self.ipv6CidrBlockState = try Ec2.VpcCidrBlockState(dictionary: ipv6CidrBlockState) }
            self.ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct ScheduledInstancesIamInstanceProfile: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name.
        public var name: String? = nil
        /// The Amazon Resource Name (ARN).
        public var arn: String? = nil

        public init() {}

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.arn = dictionary["Arn"] as? String
        }
    }

    public struct AcceptVpcPeeringConnectionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPC peering connection.
        public var vpcPeeringConnection: VpcPeeringConnection? = nil

        public init() {}

        public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
            self.vpcPeeringConnection = vpcPeeringConnection
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcPeeringConnection = dictionary["VpcPeeringConnection"] as? [String: Any] { self.vpcPeeringConnection = try Ec2.VpcPeeringConnection(dictionary: vpcPeeringConnection) }
        }
    }

    public struct ImportSnapshotResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A description of the import snapshot task.
        public var description: String? = nil
        /// Information about the import snapshot task.
        public var snapshotTaskDetail: SnapshotTaskDetail? = nil
        /// The ID of the import snapshot task.
        public var importTaskId: String? = nil

        public init() {}

        public init(description: String? = nil, snapshotTaskDetail: SnapshotTaskDetail? = nil, importTaskId: String? = nil) {
            self.description = description
            self.snapshotTaskDetail = snapshotTaskDetail
            self.importTaskId = importTaskId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            if let snapshotTaskDetail = dictionary["SnapshotTaskDetail"] as? [String: Any] { self.snapshotTaskDetail = try Ec2.SnapshotTaskDetail(dictionary: snapshotTaskDetail) }
            self.importTaskId = dictionary["ImportTaskId"] as? String
        }
    }

    public struct SnapshotDiskContainer: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The S3 bucket for the disk image.
        public var userBucket: UserBucket? = nil
        /// The format of the disk image being imported. Valid values: RAW | VHD | VMDK | OVA 
        public var format: String? = nil
        /// The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).
        public var url: String? = nil
        /// The description of the disk image being imported.
        public var description: String? = nil

        public init() {}

        public init(userBucket: UserBucket? = nil, format: String? = nil, url: String? = nil, description: String? = nil) {
            self.userBucket = userBucket
            self.format = format
            self.url = url
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucket(dictionary: userBucket) }
            self.format = dictionary["Format"] as? String
            self.url = dictionary["Url"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DeleteFlowLogsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the flow logs that could not be deleted successfully.
        public var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(unsuccessful: [UnsuccessfulItem]? = nil) {
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let unsuccessful = dictionary["Unsuccessful"] as? [[String: Any]] {
                self.unsuccessful = try unsuccessful.map({ try UnsuccessfulItem(dictionary: $0) })
            }
        }
    }

    public struct DescribeDhcpOptionsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more DHCP options sets.
        public var dhcpOptions: [DhcpOptions]? = nil

        public init() {}

        public init(dhcpOptions: [DhcpOptions]? = nil) {
            self.dhcpOptions = dhcpOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let dhcpOptions = dictionary["DhcpOptions"] as? [[String: Any]] {
                self.dhcpOptions = try dhcpOptions.map({ try DhcpOptions(dictionary: $0) })
            }
        }
    }

    public struct DeleteRouteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the route table.
        public var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationCidrBlock: String? = nil
        /// The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationIpv6CidrBlock: String? = nil

        public init() {}

        public init(routeTableId: String, dryRun: Bool? = nil, destinationCidrBlock: String? = nil, destinationIpv6CidrBlock: String? = nil) {
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
            self.destinationIpv6CidrBlock = dictionary["DestinationIpv6CidrBlock"] as? String
        }
    }

    public struct IamInstanceProfileAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time the IAM instance profile was associated with the instance.
        public var timestamp: Date? = nil
        /// The ID of the association.
        public var associationId: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The state of the association.
        public var state: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfile? = nil

        public init() {}

        public init(timestamp: Date? = nil, associationId: String? = nil, instanceId: String? = nil, state: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil) {
            self.timestamp = timestamp
            self.associationId = associationId
            self.instanceId = instanceId
            self.state = state
            self.iamInstanceProfile = iamInstanceProfile
        }

        public init(dictionary: [String: Any]) throws {
            self.timestamp = dictionary["Timestamp"] as? Date
            self.associationId = dictionary["AssociationId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            self.state = dictionary["State"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfile(dictionary: iamInstanceProfile) }
        }
    }

    public struct PeeringConnectionOptions: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.
        public var allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil
        /// If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        public var allowDnsResolutionFromRemoteVpc: Bool? = nil
        /// If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.
        public var allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil

        public init() {}

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

        public init(dictionary: [String: Any]) throws {
            self.allowEgressFromLocalVpcToRemoteClassicLink = dictionary["AllowEgressFromLocalVpcToRemoteClassicLink"] as? Bool
            self.allowDnsResolutionFromRemoteVpc = dictionary["AllowDnsResolutionFromRemoteVpc"] as? Bool
            self.allowEgressFromLocalClassicLinkToRemoteVpc = dictionary["AllowEgressFromLocalClassicLinkToRemoteVpc"] as? Bool
        }
    }

    public struct DetachVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the virtual private gateway.
        public var vpnGatewayId: String = ""

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil, vpnGatewayId: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct RouteTableAssociation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet. A subnet ID is not returned for an implicit association.
        public var subnetId: String? = nil
        /// The ID of the route table.
        public var routeTableId: String? = nil
        /// The ID of the association between a route table and a subnet.
        public var routeTableAssociationId: String? = nil
        /// Indicates whether this is the main route table.
        public var main: Bool? = nil

        public init() {}

        public init(subnetId: String? = nil, routeTableId: String? = nil, routeTableAssociationId: String? = nil, main: Bool? = nil) {
            self.subnetId = subnetId
            self.routeTableId = routeTableId
            self.routeTableAssociationId = routeTableAssociationId
            self.main = main
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.routeTableId = dictionary["RouteTableId"] as? String
            self.routeTableAssociationId = dictionary["RouteTableAssociationId"] as? String
            self.main = dictionary["Main"] as? Bool
        }
    }

    public struct UnmonitorInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more instance IDs.
        public var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceIds = dictionary["InstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("InstanceIds") }
            self.instanceIds = instanceIds
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeExportTasksRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more export task IDs.
        public var exportTaskIds: [String]? = nil

        public init() {}

        public init(exportTaskIds: [String]? = nil) {
            self.exportTaskIds = exportTaskIds
        }

        public init(dictionary: [String: Any]) throws {
            if let exportTaskIds = dictionary["ExportTaskIds"] as? [String] {
                self.exportTaskIds = exportTaskIds
            }
        }
    }

    public struct PricingDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The price per instance.
        public var price: Double? = nil
        /// The number of reservations available for the price.
        public var count: Int32? = nil

        public init() {}

        public init(price: Double? = nil, count: Int32? = nil) {
            self.price = price
            self.count = count
        }

        public init(dictionary: [String: Any]) throws {
            self.price = dictionary["Price"] as? Double
            self.count = dictionary["Count"] as? Int32
        }
    }

    public struct GetConsoleScreenshotResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The data that comprises the image.
        public var imageData: String? = nil

        public init() {}

        public init(instanceId: String? = nil, imageData: String? = nil) {
            self.instanceId = instanceId
            self.imageData = imageData
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceId = dictionary["InstanceId"] as? String
            self.imageData = dictionary["ImageData"] as? String
        }
    }

    public struct DescribeReservedInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Reserved Instance IDs. Default: Describes all your Reserved Instances, or only those otherwise specified.
        public var reservedInstancesIds: [String]? = nil
        /// One or more filters.    availability-zone - The Availability Zone where the Reserved Instance can be used.    duration - The duration of the Reserved Instance (one year or three years), in seconds (31536000 | 94608000).    end - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).    fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).    instance-type - The instance type that is covered by the reservation.    scope - The scope of the Reserved Instance (Region or Availability Zone).    product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web | Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC)).    reserved-instances-id - The ID of the Reserved Instance.    start - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).    state - The state of the Reserved Instance (payment-pending | active | payment-failed | retired).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type.
        public var offeringType: String? = nil
        /// Describes whether the Reserved Instance is Standard or Convertible.
        public var offeringClass: String? = nil

        public init() {}

        public init(reservedInstancesIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, offeringType: String? = nil, offeringClass: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.filters = filters
            self.dryRun = dryRun
            self.offeringType = offeringType
            self.offeringClass = offeringClass
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesIds = dictionary["ReservedInstancesIds"] as? [String] {
                self.reservedInstancesIds = reservedInstancesIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.offeringType = dictionary["OfferingType"] as? String
            self.offeringClass = dictionary["OfferingClass"] as? String
        }
    }

    public struct Placement: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the ImportInstance command.
        public var affinity: String? = nil
        /// The name of the placement group the instance is in (for cluster compute instances).
        public var groupName: String? = nil
        /// The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the ImportInstance command.
        public var hostId: String? = nil
        /// The Availability Zone of the instance.
        public var availabilityZone: String? = nil
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the ImportInstance command.
        public var tenancy: String? = nil

        public init() {}

        public init(affinity: String? = nil, groupName: String? = nil, hostId: String? = nil, availabilityZone: String? = nil, tenancy: String? = nil) {
            self.affinity = affinity
            self.groupName = groupName
            self.hostId = hostId
            self.availabilityZone = availabilityZone
            self.tenancy = tenancy
        }

        public init(dictionary: [String: Any]) throws {
            self.affinity = dictionary["Affinity"] as? String
            self.groupName = dictionary["GroupName"] as? String
            self.hostId = dictionary["HostId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.tenancy = dictionary["Tenancy"] as? String
        }
    }

    public struct DescribeStaleSecurityGroupsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the stale security groups.
        public var staleSecurityGroupSet: [StaleSecurityGroup]? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        public var nextToken: String? = nil

        public init() {}

        public init(staleSecurityGroupSet: [StaleSecurityGroup]? = nil, nextToken: String? = nil) {
            self.staleSecurityGroupSet = staleSecurityGroupSet
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let staleSecurityGroupSet = dictionary["StaleSecurityGroupSet"] as? [[String: Any]] {
                self.staleSecurityGroupSet = try staleSecurityGroupSet.map({ try StaleSecurityGroup(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct ScheduledInstancesNetworkInterface: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The index of the device for the network interface attachment.
        public var deviceIndex: Int32? = nil
        /// The ID of the subnet.
        public var subnetId: String? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String? = nil
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: String? = nil
        /// The private IPv4 addresses.
        public var privateIpAddressConfigs: [ScheduledInstancesPrivateIpAddressConfig]? = nil
        /// The number of secondary private IPv4 addresses.
        public var secondaryPrivateIpAddressCount: Int32? = nil
        /// The description.
        public var description: String? = nil
        /// The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.
        public var ipv6AddressCount: Int32? = nil
        /// One or more specific IPv6 addresses from the subnet range.
        public var ipv6Addresses: [ScheduledInstancesIpv6Address]? = nil
        /// Indicates whether to delete the interface when the instance is terminated.
        public var deleteOnTermination: Bool? = nil
        /// The IDs of one or more security groups.
        public var groups: [String]? = nil
        /// Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
        public var associatePublicIpAddress: Bool? = nil

        public init() {}

        public init(deviceIndex: Int32? = nil, subnetId: String? = nil, networkInterfaceId: String? = nil, privateIpAddress: String? = nil, privateIpAddressConfigs: [ScheduledInstancesPrivateIpAddressConfig]? = nil, secondaryPrivateIpAddressCount: Int32? = nil, description: String? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: [ScheduledInstancesIpv6Address]? = nil, deleteOnTermination: Bool? = nil, groups: [String]? = nil, associatePublicIpAddress: Bool? = nil) {
            self.deviceIndex = deviceIndex
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddressConfigs = privateIpAddressConfigs
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.description = description
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.deleteOnTermination = deleteOnTermination
            self.groups = groups
            self.associatePublicIpAddress = associatePublicIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.deviceIndex = dictionary["DeviceIndex"] as? Int32
            self.subnetId = dictionary["SubnetId"] as? String
            self.networkInterfaceId = dictionary["NetworkInterfaceId"] as? String
            self.privateIpAddress = dictionary["PrivateIpAddress"] as? String
            if let privateIpAddressConfigs = dictionary["PrivateIpAddressConfigs"] as? [[String: Any]] {
                self.privateIpAddressConfigs = try privateIpAddressConfigs.map({ try ScheduledInstancesPrivateIpAddressConfig(dictionary: $0) })
            }
            self.secondaryPrivateIpAddressCount = dictionary["SecondaryPrivateIpAddressCount"] as? Int32
            self.description = dictionary["Description"] as? String
            self.ipv6AddressCount = dictionary["Ipv6AddressCount"] as? Int32
            if let ipv6Addresses = dictionary["Ipv6Addresses"] as? [[String: Any]] {
                self.ipv6Addresses = try ipv6Addresses.map({ try ScheduledInstancesIpv6Address(dictionary: $0) })
            }
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            if let groups = dictionary["Groups"] as? [String] {
                self.groups = groups
            }
            self.associatePublicIpAddress = dictionary["AssociatePublicIpAddress"] as? Bool
        }
    }

    public struct UserIdGroupPair: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
        public var userId: String? = nil
        /// The status of a VPC peering connection, if applicable.
        public var peeringStatus: String? = nil
        /// The ID of the VPC for the referenced security group, if applicable.
        public var vpcId: String? = nil
        /// The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
        public var groupName: String? = nil
        /// The ID of the security group.
        public var groupId: String? = nil
        /// The ID of the VPC peering connection, if applicable.
        public var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(userId: String? = nil, peeringStatus: String? = nil, vpcId: String? = nil, groupName: String? = nil, groupId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.userId = userId
            self.peeringStatus = peeringStatus
            self.vpcId = vpcId
            self.groupName = groupName
            self.groupId = groupId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            self.peeringStatus = dictionary["PeeringStatus"] as? String
            self.vpcId = dictionary["VpcId"] as? String
            self.groupName = dictionary["GroupName"] as? String
            self.groupId = dictionary["GroupId"] as? String
            self.vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String
        }
    }

    public struct DescribeConversionTasksRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more conversion task IDs.
        public var conversionTaskIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, conversionTaskIds: [String]? = nil) {
            self.dryRun = dryRun
            self.conversionTaskIds = conversionTaskIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let conversionTaskIds = dictionary["ConversionTaskIds"] as? [String] {
                self.conversionTaskIds = conversionTaskIds
            }
        }
    }

    public struct ModifySubnetAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Specify true to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).
        public var mapPublicIpOnLaunch: AttributeBooleanValue? = nil
        /// The ID of the subnet.
        public var subnetId: String = ""
        /// Specify true to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address).  If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version 2016-11-15 or later of the Amazon EC2 API.
        public var assignIpv6AddressOnCreation: AttributeBooleanValue? = nil

        public init() {}

        public init(mapPublicIpOnLaunch: AttributeBooleanValue? = nil, subnetId: String, assignIpv6AddressOnCreation: AttributeBooleanValue? = nil) {
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.subnetId = subnetId
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        }

        public init(dictionary: [String: Any]) throws {
            if let mapPublicIpOnLaunch = dictionary["MapPublicIpOnLaunch"] as? [String: Any] { self.mapPublicIpOnLaunch = try Ec2.AttributeBooleanValue(dictionary: mapPublicIpOnLaunch) }
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            if let assignIpv6AddressOnCreation = dictionary["AssignIpv6AddressOnCreation"] as? [String: Any] { self.assignIpv6AddressOnCreation = try Ec2.AttributeBooleanValue(dictionary: assignIpv6AddressOnCreation) }
        }
    }

    public struct PlacementGroup: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The state of the placement group.
        public var state: String? = nil
        /// The placement strategy.
        public var strategy: String? = nil
        /// The name of the placement group.
        public var groupName: String? = nil

        public init() {}

        public init(state: String? = nil, strategy: String? = nil, groupName: String? = nil) {
            self.state = state
            self.strategy = strategy
            self.groupName = groupName
        }

        public init(dictionary: [String: Any]) throws {
            self.state = dictionary["State"] as? String
            self.strategy = dictionary["Strategy"] as? String
            self.groupName = dictionary["GroupName"] as? String
        }
    }

    public struct AssociateAddressResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.
        public var associationId: String? = nil

        public init() {}

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct Reservation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).
        public var requesterId: String? = nil
        /// One or more instances.
        public var instances: [Instance]? = nil
        /// The ID of the reservation.
        public var reservationId: String? = nil
        /// The ID of the AWS account that owns the reservation.
        public var ownerId: String? = nil
        /// [EC2-Classic only] One or more security groups.
        public var groups: [GroupIdentifier]? = nil

        public init() {}

        public init(requesterId: String? = nil, instances: [Instance]? = nil, reservationId: String? = nil, ownerId: String? = nil, groups: [GroupIdentifier]? = nil) {
            self.requesterId = requesterId
            self.instances = instances
            self.reservationId = reservationId
            self.ownerId = ownerId
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            self.requesterId = dictionary["RequesterId"] as? String
            if let instances = dictionary["Instances"] as? [[String: Any]] {
                self.instances = try instances.map({ try Instance(dictionary: $0) })
            }
            self.reservationId = dictionary["ReservationId"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            if let groups = dictionary["Groups"] as? [[String: Any]] {
                self.groups = try groups.map({ try GroupIdentifier(dictionary: $0) })
            }
        }
    }

    public struct SpotFleetRequestConfigData: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O.
        public var targetCapacity: Int32 = 0
        /// A unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see Ensuring Idempotency.
        public var clientToken: String? = nil
        /// Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using CancelSpotFleetRequests or when the Spot fleet request expires, if you set terminateInstancesWithExpiration.
        public var iamFleetRole: String = ""
        /// The bid price per unit hour.
        public var spotPrice: String = ""
        /// The end date and time of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request.
        public var validUntil: Date? = nil
        /// Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is lowestPrice.
        public var allocationStrategy: String? = nil
        /// Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.
        public var excessCapacityTerminationPolicy: String? = nil
        /// Information about the launch specifications for the Spot fleet request.
        public var launchSpecifications: [SpotFleetLaunchSpecification] = []
        /// The start date and time of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). The default is to start fulfilling the request immediately.
        public var validFrom: Date? = nil
        /// Indicates whether running Spot instances should be terminated when the Spot fleet request expires.
        public var terminateInstancesWithExpiration: Bool? = nil
        /// Indicates whether Spot fleet should replace unhealthy instances.
        public var replaceUnhealthyInstances: Bool? = nil
        /// The number of units fulfilled by this request compared to the set target capacity.
        public var fulfilledCapacity: Double? = nil
        /// The type of request. Indicates whether the fleet will only request the target capacity or also attempt to maintain it. When you request a certain target capacity, the fleet will only place the required bids. It will not attempt to replenish Spot instances if capacity is diminished, nor will it submit bids in alternative Spot pools if capacity is not available. When you want to maintain a certain target capacity, fleet will place the required bids to meet this target capacity. It will also automatically replenish any interrupted instances. Default: maintain.
        public var type: String? = nil

        public init() {}

        public init(targetCapacity: Int32, clientToken: String? = nil, iamFleetRole: String, spotPrice: String, validUntil: Date? = nil, allocationStrategy: String? = nil, excessCapacityTerminationPolicy: String? = nil, launchSpecifications: [SpotFleetLaunchSpecification], validFrom: Date? = nil, terminateInstancesWithExpiration: Bool? = nil, replaceUnhealthyInstances: Bool? = nil, fulfilledCapacity: Double? = nil, type: String? = nil) {
            self.targetCapacity = targetCapacity
            self.clientToken = clientToken
            self.iamFleetRole = iamFleetRole
            self.spotPrice = spotPrice
            self.validUntil = validUntil
            self.allocationStrategy = allocationStrategy
            self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
            self.launchSpecifications = launchSpecifications
            self.validFrom = validFrom
            self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
            self.replaceUnhealthyInstances = replaceUnhealthyInstances
            self.fulfilledCapacity = fulfilledCapacity
            self.type = type
        }

        public init(dictionary: [String: Any]) throws {
            guard let targetCapacity = dictionary["TargetCapacity"] as? Int32 else { throw InitializableError.missingRequiredParam("TargetCapacity") }
            self.targetCapacity = targetCapacity
            self.clientToken = dictionary["ClientToken"] as? String
            guard let iamFleetRole = dictionary["IamFleetRole"] as? String else { throw InitializableError.missingRequiredParam("IamFleetRole") }
            self.iamFleetRole = iamFleetRole
            guard let spotPrice = dictionary["SpotPrice"] as? String else { throw InitializableError.missingRequiredParam("SpotPrice") }
            self.spotPrice = spotPrice
            self.validUntil = dictionary["ValidUntil"] as? Date
            self.allocationStrategy = dictionary["AllocationStrategy"] as? String
            self.excessCapacityTerminationPolicy = dictionary["ExcessCapacityTerminationPolicy"] as? String
            guard let launchSpecifications = dictionary["LaunchSpecifications"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("LaunchSpecifications") }
            self.launchSpecifications = try launchSpecifications.map({ try SpotFleetLaunchSpecification(dictionary: $0) })
            self.validFrom = dictionary["ValidFrom"] as? Date
            self.terminateInstancesWithExpiration = dictionary["TerminateInstancesWithExpiration"] as? Bool
            self.replaceUnhealthyInstances = dictionary["ReplaceUnhealthyInstances"] as? Bool
            self.fulfilledCapacity = dictionary["FulfilledCapacity"] as? Double
            self.type = dictionary["Type"] as? String
        }
    }

    public struct DeleteInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Internet gateway.
        public var internetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(internetGatewayId: String, dryRun: Bool? = nil) {
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let internetGatewayId = dictionary["InternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("InternetGatewayId") }
            self.internetGatewayId = internetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ScheduledInstancesBlockDeviceMapping: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Suppresses the specified device included in the block device mapping of the AMI.
        public var noDevice: String? = nil
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for ephemeral0 and ephemeral1.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        public var virtualName: String? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        public var deviceName: String? = nil
        /// Parameters used to set up EBS volumes automatically when the instance is launched.
        public var ebs: ScheduledInstancesEbs? = nil

        public init() {}

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: ScheduledInstancesEbs? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

        public init(dictionary: [String: Any]) throws {
            self.noDevice = dictionary["NoDevice"] as? String
            self.virtualName = dictionary["VirtualName"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            if let ebs = dictionary["Ebs"] as? [String: Any] { self.ebs = try Ec2.ScheduledInstancesEbs(dictionary: ebs) }
        }
    }

    public struct StateReason: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The reason code for the state change.
        public var code: String? = nil
        /// The message for the state change.    Server.InsufficientInstanceCapacity: There was insufficient instance capacity to satisfy the launch request.    Server.InternalError: An internal error occurred during instance launch, resulting in termination.    Server.ScheduledStop: The instance was stopped due to a scheduled retirement.    Server.SpotInstanceTermination: A Spot instance was terminated due to an increase in the market price.    Client.InternalError: A client error caused the instance to terminate on launch.    Client.InstanceInitiatedShutdown: The instance was shut down using the shutdown -h command from the instance.    Client.UserInitiatedShutdown: The instance was shut down using the Amazon EC2 API.    Client.VolumeLimitExceeded: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your limits.    Client.InvalidSnapshot.NotFound: The specified snapshot was not found.  
        public var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.code = dictionary["Code"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DeleteTagsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more tags to delete. If you omit the value parameter, we delete the tag regardless of its value. If you specify this parameter with an empty string as the value, we delete the key only if its value is an empty string.
        public var tags: [Tag]? = nil
        /// The ID of the resource. For example, ami-1a2b3c4d. You can specify more than one resource ID.
        public var resources: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, tags: [Tag]? = nil, resources: [String]) {
            self.dryRun = dryRun
            self.tags = tags
            self.resources = resources
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            guard let resources = dictionary["Resources"] as? [String] else { throw InitializableError.missingRequiredParam("Resources") }
            self.resources = resources
        }
    }

    public struct DescribeSpotInstanceRequestsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    availability-zone-group - The Availability Zone group.    create-time - The time stamp when the Spot instance request was created.    fault-code - The fault code related to the request.    fault-message - The fault message related to the request.    instance-id - The ID of the instance that fulfilled the request.    launch-group - The Spot instance launch group.    launch.block-device-mapping.delete-on-termination - Indicates whether the Amazon EBS volume is deleted on instance termination.    launch.block-device-mapping.device-name - The device name for the Amazon EBS volume (for example, /dev/sdh).    launch.block-device-mapping.snapshot-id - The ID of the snapshot used for the Amazon EBS volume.    launch.block-device-mapping.volume-size - The size of the Amazon EBS volume, in GiB.    launch.block-device-mapping.volume-type - The type of the Amazon EBS volume: gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1for Cold HDD, or standard for Magnetic.    launch.group-id - The security group for the instance.    launch.image-id - The ID of the AMI.    launch.instance-type - The type of instance (for example, m3.medium).    launch.kernel-id - The kernel ID.    launch.key-name - The name of the key pair the instance launched with.    launch.monitoring-enabled - Whether monitoring is enabled for the Spot instance.    launch.ramdisk-id - The RAM disk ID.    network-interface.network-interface-id - The ID of the network interface.    network-interface.device-index - The index of the device for the network interface attachment on the instance.    network-interface.subnet-id - The ID of the subnet for the instance.    network-interface.description - A description of the network interface.    network-interface.private-ip-address - The primary private IP address of the network interface.    network-interface.delete-on-termination - Indicates whether the network interface is deleted when the instance is terminated.    network-interface.group-id - The ID of the security group associated with the network interface.    network-interface.group-name - The name of the security group associated with the network interface.    network-interface.addresses.primary - Indicates whether the IP address is the primary private IP address.    product-description - The product description associated with the instance (Linux/UNIX | Windows).    spot-instance-request-id - The Spot instance request ID.    spot-price - The maximum hourly price for any Spot instance launched to fulfill the request.    state - The state of the Spot instance request (open | active | closed | cancelled | failed). Spot bid status information can help you track your Amazon EC2 Spot instance requests. For more information, see Spot Bid Status in the Amazon Elastic Compute Cloud User Guide.    status-code - The short code describing the most recent evaluation of your Spot instance request.    status-message - The message explaining the status of the Spot instance request.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of Spot instance request (one-time | persistent).    launched-availability-zone - The Availability Zone in which the bid is launched.    valid-from - The start date of the request.    valid-until - The end date of the request.  
        public var filters: [Filter]? = nil
        /// One or more Spot instance request IDs.
        public var spotInstanceRequestIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, spotInstanceRequestIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let spotInstanceRequestIds = dictionary["SpotInstanceRequestIds"] as? [String] {
                self.spotInstanceRequestIds = spotInstanceRequestIds
            }
        }
    }

    public struct AttachClassicLinkVpcRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of a ClassicLink-enabled VPC.
        public var vpcId: String = ""
        /// The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.
        public var instanceId: String = ""
        /// The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.
        public var groups: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, vpcId: String, instanceId: String, groups: [String]) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let groups = dictionary["Groups"] as? [String] else { throw InitializableError.missingRequiredParam("Groups") }
            self.groups = groups
        }
    }

    public struct ReleaseHostsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the Dedicated Hosts that were successfully released.
        public var successful: [String]? = nil
        /// The IDs of the Dedicated Hosts that could not be released, including an error message.
        public var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(successful: [String]? = nil, unsuccessful: [UnsuccessfulItem]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let successful = dictionary["Successful"] as? [String] {
                self.successful = successful
            }
            if let unsuccessful = dictionary["Unsuccessful"] as? [[String: Any]] {
                self.unsuccessful = try unsuccessful.map({ try UnsuccessfulItem(dictionary: $0) })
            }
        }
    }

    public struct ExportToS3TaskSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.
        public var s3Prefix: String? = nil
        /// The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.
        public var containerFormat: String? = nil
        /// The format for the exported image.
        public var diskImageFormat: String? = nil
        /// The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account vm-import-export@amazon.com.
        public var s3Bucket: String? = nil

        public init() {}

        public init(s3Prefix: String? = nil, containerFormat: String? = nil, diskImageFormat: String? = nil, s3Bucket: String? = nil) {
            self.s3Prefix = s3Prefix
            self.containerFormat = containerFormat
            self.diskImageFormat = diskImageFormat
            self.s3Bucket = s3Bucket
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Prefix = dictionary["S3Prefix"] as? String
            self.containerFormat = dictionary["ContainerFormat"] as? String
            self.diskImageFormat = dictionary["DiskImageFormat"] as? String
            self.s3Bucket = dictionary["S3Bucket"] as? String
        }
    }

    public struct CancelSpotFleetRequestsError: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The error code.
        public var code: String = ""
        /// The description for the error code.
        public var message: String = ""

        public init() {}

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            guard let code = dictionary["Code"] as? String else { throw InitializableError.missingRequiredParam("Code") }
            self.code = code
            guard let message = dictionary["Message"] as? String else { throw InitializableError.missingRequiredParam("Message") }
            self.message = message
        }
    }

    public struct DescribeKeyPairsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    fingerprint - The fingerprint of the key pair.    key-name - The name of the key pair.  
        public var filters: [Filter]? = nil
        /// One or more key pair names. Default: Describes all your key pairs.
        public var keyNames: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, keyNames: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.keyNames = keyNames
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let keyNames = dictionary["KeyNames"] as? [String] {
                self.keyNames = keyNames
            }
        }
    }

    public struct DescribeReservedInstancesOfferingsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of Reserved Instances offerings.
        public var reservedInstancesOfferings: [ReservedInstancesOffering]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(reservedInstancesOfferings: [ReservedInstancesOffering]? = nil, nextToken: String? = nil) {
            self.reservedInstancesOfferings = reservedInstancesOfferings
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let reservedInstancesOfferings = dictionary["ReservedInstancesOfferings"] as? [[String: Any]] {
                self.reservedInstancesOfferings = try reservedInstancesOfferings.map({ try ReservedInstancesOffering(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct VpnStaticRoute: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The CIDR block associated with the local subnet of the customer data center.
        public var destinationCidrBlock: String? = nil
        /// The current state of the static route.
        public var state: String? = nil
        /// Indicates how the routes were provided.
        public var source: String? = nil

        public init() {}

        public init(destinationCidrBlock: String? = nil, state: String? = nil, source: String? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
            self.source = source
        }

        public init(dictionary: [String: Any]) throws {
            self.destinationCidrBlock = dictionary["DestinationCidrBlock"] as? String
            self.state = dictionary["State"] as? String
            self.source = dictionary["Source"] as? String
        }
    }

    public struct CopySnapshotRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A description for the EBS snapshot.
        public var description: String? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when creating the snapshot copy. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. The specified CMK must exist in the region that the snapshot is being copied to. If a KmsKeyId is specified, the Encrypted flag must also be set.
        public var kmsKeyId: String? = nil
        /// The ID of the region that contains the snapshot to be copied.
        public var sourceRegion: String = ""
        /// Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot using this flag, but you cannot use it to create an unencrypted copy from an encrypted snapshot. Your default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        public var encrypted: Bool? = nil
        /// The destination region to use in the PresignedUrl parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a PresignedUrl parameter, where it is required.   CopySnapshot sends the snapshot copy to the regional endpoint that you send the HTTP request to, such as ec2.us-east-1.amazonaws.com (in the AWS CLI, this is specified with the --region parameter or the default region in your AWS configuration file). 
        public var destinationRegion: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The pre-signed URL that facilitates copying an encrypted snapshot. This parameter is only required when copying an encrypted snapshot with the Amazon EC2 Query API; it is available as an optional parameter in all other cases. The PresignedUrl should use the snapshot source endpoint, the CopySnapshot action, and include the SourceRegion, SourceSnapshotId, and DestinationRegion parameters. The PresignedUrl must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in Authenticating Requests by Using Query Parameters (AWS Signature Version 4) in the Amazon Simple Storage Service API Reference. An invalid or improperly signed PresignedUrl will cause the copy operation to fail asynchronously, and the snapshot will move to an error state.
        public var presignedUrl: String? = nil
        /// The ID of the EBS snapshot to copy.
        public var sourceSnapshotId: String = ""

        public init() {}

        public init(description: String? = nil, kmsKeyId: String? = nil, sourceRegion: String, encrypted: Bool? = nil, destinationRegion: String? = nil, dryRun: Bool? = nil, presignedUrl: String? = nil, sourceSnapshotId: String) {
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.sourceRegion = sourceRegion
            self.encrypted = encrypted
            self.destinationRegion = destinationRegion
            self.dryRun = dryRun
            self.presignedUrl = presignedUrl
            self.sourceSnapshotId = sourceSnapshotId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
            guard let sourceRegion = dictionary["SourceRegion"] as? String else { throw InitializableError.missingRequiredParam("SourceRegion") }
            self.sourceRegion = sourceRegion
            self.encrypted = dictionary["Encrypted"] as? Bool
            self.destinationRegion = dictionary["DestinationRegion"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.presignedUrl = dictionary["PresignedUrl"] as? String
            guard let sourceSnapshotId = dictionary["SourceSnapshotId"] as? String else { throw InitializableError.missingRequiredParam("SourceSnapshotId") }
            self.sourceSnapshotId = sourceSnapshotId
        }
    }

    public struct DescribePlacementGroupsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more placement groups.
        public var placementGroups: [PlacementGroup]? = nil

        public init() {}

        public init(placementGroups: [PlacementGroup]? = nil) {
            self.placementGroups = placementGroups
        }

        public init(dictionary: [String: Any]) throws {
            if let placementGroups = dictionary["PlacementGroups"] as? [[String: Any]] {
                self.placementGroups = try placementGroups.map({ try PlacementGroup(dictionary: $0) })
            }
        }
    }

    public struct DetachVolumeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The device name.
        public var device: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The ID of the volume.
        public var volumeId: String = ""
        /// Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.
        public var force: Bool? = nil

        public init() {}

        public init(device: String? = nil, dryRun: Bool? = nil, instanceId: String? = nil, volumeId: String, force: Bool? = nil) {
            self.device = device
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.volumeId = volumeId
            self.force = force
        }

        public init(dictionary: [String: Any]) throws {
            self.device = dictionary["Device"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.instanceId = dictionary["InstanceId"] as? String
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.force = dictionary["Force"] as? Bool
        }
    }

    public struct EgressOnlyInternetGateway: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the egress-only Internet gateway.
        public var egressOnlyInternetGatewayId: String? = nil
        /// Information about the attachment of the egress-only Internet gateway.
        public var attachments: [InternetGatewayAttachment]? = nil

        public init() {}

        public init(egressOnlyInternetGatewayId: String? = nil, attachments: [InternetGatewayAttachment]? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.attachments = attachments
        }

        public init(dictionary: [String: Any]) throws {
            self.egressOnlyInternetGatewayId = dictionary["EgressOnlyInternetGatewayId"] as? String
            if let attachments = dictionary["Attachments"] as? [[String: Any]] {
                self.attachments = try attachments.map({ try InternetGatewayAttachment(dictionary: $0) })
            }
        }
    }

    public struct EnableVgwRoutePropagationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the virtual private gateway.
        public var gatewayId: String = ""
        /// The ID of the route table.
        public var routeTableId: String = ""

        public init() {}

        public init(gatewayId: String, routeTableId: String) {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }

        public init(dictionary: [String: Any]) throws {
            guard let gatewayId = dictionary["GatewayId"] as? String else { throw InitializableError.missingRequiredParam("GatewayId") }
            self.gatewayId = gatewayId
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
        }
    }

    public struct GetReservedInstancesExchangeQuoteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the Convertible Reserved Instances to exchange.
        public var reservedInstanceIds: [String] = []
        /// The configuration requirements of the Convertible Reserved Instances to exchange for your current Convertible Reserved Instances.
        public var targetConfigurations: [TargetConfigurationRequest]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(reservedInstanceIds: [String], targetConfigurations: [TargetConfigurationRequest]? = nil, dryRun: Bool? = nil) {
            self.reservedInstanceIds = reservedInstanceIds
            self.targetConfigurations = targetConfigurations
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let reservedInstanceIds = dictionary["ReservedInstanceIds"] as? [String] else { throw InitializableError.missingRequiredParam("ReservedInstanceIds") }
            self.reservedInstanceIds = reservedInstanceIds
            if let targetConfigurations = dictionary["TargetConfigurations"] as? [[String: Any]] {
                self.targetConfigurations = try targetConfigurations.map({ try TargetConfigurationRequest(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct SpotFleetLaunchSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more block device mapping entries.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".
        public var subnetId: String? = nil
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var userData: String? = nil
        /// Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        public var ebsOptimized: Bool? = nil
        /// The ID of the kernel.
        public var kernelId: String? = nil
        /// The bid price per unit hour for the specified instance type. If this value is not specified, the default is the Spot bid price specified for the fleet. To determine the bid price per unit hour, divide the Spot bid price by the value of WeightedCapacity.
        public var spotPrice: String? = nil
        /// Enable or disable monitoring for the instances.
        public var monitoring: SpotFleetMonitoring? = nil
        /// The instance type. Note that T2 and HS1 instance types are not supported.
        public var instanceType: String? = nil
        /// The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O). If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.
        public var weightedCapacity: Double? = nil
        /// One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
        public var securityGroups: [GroupIdentifier]? = nil
        /// The name of the key pair.
        public var keyName: String? = nil
        /// Deprecated.
        public var addressingType: String? = nil
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// The ID of the AMI.
        public var imageId: String? = nil
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        public var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The placement information.
        public var placement: SpotPlacement? = nil
        /// The ID of the RAM disk.
        public var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, spotPrice: String? = nil, monitoring: SpotFleetMonitoring? = nil, instanceType: String? = nil, weightedCapacity: Double? = nil, securityGroups: [GroupIdentifier]? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.spotPrice = spotPrice
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.subnetId = dictionary["SubnetId"] as? String
            self.userData = dictionary["UserData"] as? String
            self.ebsOptimized = dictionary["EbsOptimized"] as? Bool
            self.kernelId = dictionary["KernelId"] as? String
            self.spotPrice = dictionary["SpotPrice"] as? String
            if let monitoring = dictionary["Monitoring"] as? [String: Any] { self.monitoring = try Ec2.SpotFleetMonitoring(dictionary: monitoring) }
            self.instanceType = dictionary["InstanceType"] as? String
            self.weightedCapacity = dictionary["WeightedCapacity"] as? Double
            if let securityGroups = dictionary["SecurityGroups"] as? [[String: Any]] {
                self.securityGroups = try securityGroups.map({ try GroupIdentifier(dictionary: $0) })
            }
            self.keyName = dictionary["KeyName"] as? String
            self.addressingType = dictionary["AddressingType"] as? String
            if let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] { self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile) }
            self.imageId = dictionary["ImageId"] as? String
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try InstanceNetworkInterfaceSpecification(dictionary: $0) })
            }
            if let placement = dictionary["Placement"] as? [String: Any] { self.placement = try Ec2.SpotPlacement(dictionary: placement) }
            self.ramdiskId = dictionary["RamdiskId"] as? String
        }
    }

    public struct Region: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The region service endpoint.
        public var endpoint: String? = nil
        /// The name of the region.
        public var regionName: String? = nil

        public init() {}

        public init(endpoint: String? = nil, regionName: String? = nil) {
            self.endpoint = endpoint
            self.regionName = regionName
        }

        public init(dictionary: [String: Any]) throws {
            self.endpoint = dictionary["Endpoint"] as? String
            self.regionName = dictionary["RegionName"] as? String
        }
    }

    public struct PurchaseRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The purchase token.
        public var purchaseToken: String = ""
        /// The number of instances.
        public var instanceCount: Int32 = 0

        public init() {}

        public init(purchaseToken: String, instanceCount: Int32) {
            self.purchaseToken = purchaseToken
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let purchaseToken = dictionary["PurchaseToken"] as? String else { throw InitializableError.missingRequiredParam("PurchaseToken") }
            self.purchaseToken = purchaseToken
            guard let instanceCount = dictionary["InstanceCount"] as? Int32 else { throw InitializableError.missingRequiredParam("InstanceCount") }
            self.instanceCount = instanceCount
        }
    }

    public struct DetachInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// The ID of the Internet gateway.
        public var internetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, internetGatewayId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            guard let internetGatewayId = dictionary["InternetGatewayId"] as? String else { throw InitializableError.missingRequiredParam("InternetGatewayId") }
            self.internetGatewayId = internetGatewayId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeVpcClassicLinkDnsSupportResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the ClassicLink DNS support status of the VPCs.
        public var vpcs: [ClassicLinkDnsSupport]? = nil
        /// The token to use when requesting the next set of items.
        public var nextToken: String? = nil

        public init() {}

        public init(vpcs: [ClassicLinkDnsSupport]? = nil, nextToken: String? = nil) {
            self.vpcs = vpcs
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcs = dictionary["Vpcs"] as? [[String: Any]] {
                self.vpcs = try vpcs.map({ try ClassicLinkDnsSupport(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct CreateInternetGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct VpnConnectionOptionsSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.
        public var staticRoutesOnly: Bool? = nil

        public init() {}

        public init(staticRoutesOnly: Bool? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
        }

        public init(dictionary: [String: Any]) throws {
            self.staticRoutesOnly = dictionary["StaticRoutesOnly"] as? Bool
        }
    }

    public struct HistoryRecord: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The event type.    error - Indicates an error with the Spot fleet request.    fleetRequestChange - Indicates a change in the status or configuration of the Spot fleet request.    instanceChange - Indicates that an instance was launched or terminated.  
        public var eventType: String = ""
        /// The date and time of the event, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var timestamp: Date = Date()
        /// Information about the event.
        public var eventInformation: EventInformation = EventInformation()

        public init() {}

        public init(eventType: String, timestamp: Date, eventInformation: EventInformation) {
            self.eventType = eventType
            self.timestamp = timestamp
            self.eventInformation = eventInformation
        }

        public init(dictionary: [String: Any]) throws {
            guard let eventType = dictionary["EventType"] as? String else { throw InitializableError.missingRequiredParam("EventType") }
            self.eventType = eventType
            guard let timestamp = dictionary["Timestamp"] as? Date else { throw InitializableError.missingRequiredParam("Timestamp") }
            self.timestamp = timestamp
            guard let eventInformation = dictionary["EventInformation"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EventInformation") }
            self.eventInformation = try Ec2.EventInformation(dictionary: eventInformation)
        }
    }

    public struct DescribeSpotFleetRequestsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// Information about the configuration of your Spot fleet.
        public var spotFleetRequestConfigs: [SpotFleetRequestConfig] = []

        public init() {}

        public init(nextToken: String? = nil, spotFleetRequestConfigs: [SpotFleetRequestConfig]) {
            self.nextToken = nextToken
            self.spotFleetRequestConfigs = spotFleetRequestConfigs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestConfigs = dictionary["SpotFleetRequestConfigs"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("SpotFleetRequestConfigs") }
            self.spotFleetRequestConfigs = try spotFleetRequestConfigs.map({ try SpotFleetRequestConfig(dictionary: $0) })
        }
    }

    public struct VpcPeeringConnectionOptionsDescription: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        public var allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        public var allowDnsResolutionFromRemoteVpc: Bool? = nil
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        public var allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil

        public init() {}

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

        public init(dictionary: [String: Any]) throws {
            self.allowEgressFromLocalVpcToRemoteClassicLink = dictionary["AllowEgressFromLocalVpcToRemoteClassicLink"] as? Bool
            self.allowDnsResolutionFromRemoteVpc = dictionary["AllowDnsResolutionFromRemoteVpc"] as? Bool
            self.allowEgressFromLocalClassicLinkToRemoteVpc = dictionary["AllowEgressFromLocalClassicLinkToRemoteVpc"] as? Bool
        }
    }

    public struct InstanceStatus: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The intended state of the instance. DescribeInstanceStatus requires that an instance be in the running state.
        public var instanceState: InstanceState? = nil
        /// Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.
        public var systemStatus: InstanceStatusSummary? = nil
        /// Any scheduled events associated with the instance.
        public var events: [InstanceStatusEvent]? = nil
        /// Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.
        public var instanceStatus: InstanceStatusSummary? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// The Availability Zone of the instance.
        public var availabilityZone: String? = nil

        public init() {}

        public init(instanceState: InstanceState? = nil, systemStatus: InstanceStatusSummary? = nil, events: [InstanceStatusEvent]? = nil, instanceStatus: InstanceStatusSummary? = nil, instanceId: String? = nil, availabilityZone: String? = nil) {
            self.instanceState = instanceState
            self.systemStatus = systemStatus
            self.events = events
            self.instanceStatus = instanceStatus
            self.instanceId = instanceId
            self.availabilityZone = availabilityZone
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceState = dictionary["InstanceState"] as? [String: Any] { self.instanceState = try Ec2.InstanceState(dictionary: instanceState) }
            if let systemStatus = dictionary["SystemStatus"] as? [String: Any] { self.systemStatus = try Ec2.InstanceStatusSummary(dictionary: systemStatus) }
            if let events = dictionary["Events"] as? [[String: Any]] {
                self.events = try events.map({ try InstanceStatusEvent(dictionary: $0) })
            }
            if let instanceStatus = dictionary["InstanceStatus"] as? [String: Any] { self.instanceStatus = try Ec2.InstanceStatusSummary(dictionary: instanceStatus) }
            self.instanceId = dictionary["InstanceId"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
        }
    }

    public struct VpcPeeringConnectionVpcInfo: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        public var peeringOptions: VpcPeeringConnectionOptionsDescription? = nil
        /// The IPv6 CIDR block for the VPC.
        public var ipv6CidrBlockSet: [Ipv6CidrBlock]? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// The AWS account ID of the VPC owner.
        public var ownerId: String? = nil
        /// The IPv4 CIDR block for the VPC.
        public var cidrBlock: String? = nil

        public init() {}

        public init(peeringOptions: VpcPeeringConnectionOptionsDescription? = nil, ipv6CidrBlockSet: [Ipv6CidrBlock]? = nil, vpcId: String? = nil, ownerId: String? = nil, cidrBlock: String? = nil) {
            self.peeringOptions = peeringOptions
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.vpcId = vpcId
            self.ownerId = ownerId
            self.cidrBlock = cidrBlock
        }

        public init(dictionary: [String: Any]) throws {
            if let peeringOptions = dictionary["PeeringOptions"] as? [String: Any] { self.peeringOptions = try Ec2.VpcPeeringConnectionOptionsDescription(dictionary: peeringOptions) }
            if let ipv6CidrBlockSet = dictionary["Ipv6CidrBlockSet"] as? [[String: Any]] {
                self.ipv6CidrBlockSet = try ipv6CidrBlockSet.map({ try Ipv6CidrBlock(dictionary: $0) })
            }
            self.vpcId = dictionary["VpcId"] as? String
            self.ownerId = dictionary["OwnerId"] as? String
            self.cidrBlock = dictionary["CidrBlock"] as? String
        }
    }

    public struct SnapshotTaskDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A brief status for the import snapshot task.
        public var status: String? = nil
        /// The percentage of completion for the import snapshot task.
        public var progress: String? = nil
        /// The URL of the disk image from which the snapshot is created.
        public var url: String? = nil
        /// The size of the disk in the snapshot, in GiB.
        public var diskImageSize: Double? = nil
        /// The format of the disk image from which the snapshot is created.
        public var format: String? = nil
        /// The snapshot ID of the disk being imported.
        public var snapshotId: String? = nil
        /// The S3 bucket for the disk image.
        public var userBucket: UserBucketDetails? = nil
        /// A detailed status message for the import snapshot task.
        public var statusMessage: String? = nil
        /// The description of the snapshot.
        public var description: String? = nil

        public init() {}

        public init(status: String? = nil, progress: String? = nil, url: String? = nil, diskImageSize: Double? = nil, format: String? = nil, snapshotId: String? = nil, userBucket: UserBucketDetails? = nil, statusMessage: String? = nil, description: String? = nil) {
            self.status = status
            self.progress = progress
            self.url = url
            self.diskImageSize = diskImageSize
            self.format = format
            self.snapshotId = snapshotId
            self.userBucket = userBucket
            self.statusMessage = statusMessage
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.progress = dictionary["Progress"] as? String
            self.url = dictionary["Url"] as? String
            self.diskImageSize = dictionary["DiskImageSize"] as? Double
            self.format = dictionary["Format"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucketDetails(dictionary: userBucket) }
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateSpotDatafeedSubscriptionResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Spot instance data feed subscription.
        public var spotDatafeedSubscription: SpotDatafeedSubscription? = nil

        public init() {}

        public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
            self.spotDatafeedSubscription = spotDatafeedSubscription
        }

        public init(dictionary: [String: Any]) throws {
            if let spotDatafeedSubscription = dictionary["SpotDatafeedSubscription"] as? [String: Any] { self.spotDatafeedSubscription = try Ec2.SpotDatafeedSubscription(dictionary: spotDatafeedSubscription) }
        }
    }

    public struct DescribeSpotInstanceRequestsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more Spot instance requests.
        public var spotInstanceRequests: [SpotInstanceRequest]? = nil

        public init() {}

        public init(spotInstanceRequests: [SpotInstanceRequest]? = nil) {
            self.spotInstanceRequests = spotInstanceRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let spotInstanceRequests = dictionary["SpotInstanceRequests"] as? [[String: Any]] {
                self.spotInstanceRequests = try spotInstanceRequests.map({ try SpotInstanceRequest(dictionary: $0) })
            }
        }
    }

    public struct ModifyVpcPeeringConnectionOptionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The VPC peering connection options for the accepter VPC.
        public var accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil
        /// The VPC peering connection options for the requester VPC.
        public var requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: String = ""

        public init() {}

        public init(accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil, requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil, dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
            self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public init(dictionary: [String: Any]) throws {
            if let accepterPeeringConnectionOptions = dictionary["AccepterPeeringConnectionOptions"] as? [String: Any] { self.accepterPeeringConnectionOptions = try Ec2.PeeringConnectionOptionsRequest(dictionary: accepterPeeringConnectionOptions) }
            if let requesterPeeringConnectionOptions = dictionary["RequesterPeeringConnectionOptions"] as? [String: Any] { self.requesterPeeringConnectionOptions = try Ec2.PeeringConnectionOptionsRequest(dictionary: requesterPeeringConnectionOptions) }
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpcPeeringConnectionId = dictionary["VpcPeeringConnectionId"] as? String else { throw InitializableError.missingRequiredParam("VpcPeeringConnectionId") }
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

    public struct IamInstanceProfileSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the instance profile.
        public var name: String? = nil
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: String? = nil

        public init() {}

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            self.arn = dictionary["Arn"] as? String
        }
    }

    public struct ConfirmProductInstanceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// The product code. This must be a product code that you own.
        public var productCode: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, productCode: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.productCode = productCode
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let productCode = dictionary["ProductCode"] as? String else { throw InitializableError.missingRequiredParam("ProductCode") }
            self.productCode = productCode
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DisableVgwRoutePropagationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the virtual private gateway.
        public var gatewayId: String = ""
        /// The ID of the route table.
        public var routeTableId: String = ""

        public init() {}

        public init(gatewayId: String, routeTableId: String) {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }

        public init(dictionary: [String: Any]) throws {
            guard let gatewayId = dictionary["GatewayId"] as? String else { throw InitializableError.missingRequiredParam("GatewayId") }
            self.gatewayId = gatewayId
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
        }
    }

    public struct DescribeSpotPriceHistoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var startTime: Date? = nil
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil
        /// Filters the results by the specified basic product descriptions.
        public var productDescriptions: [String]? = nil
        /// The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        public var endTime: Date? = nil
        /// One or more filters.    availability-zone - The Availability Zone for which prices should be returned.    instance-type - The type of instance (for example, m3.medium).    product-description - The product description for the Spot price (Linux/UNIX | SUSE Linux | Windows | Linux/UNIX (Amazon VPC) | SUSE Linux (Amazon VPC) | Windows (Amazon VPC)).    spot-price - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).    timestamp - The timestamp of the Spot price history, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). You can use wildcards (* and ?). Greater than or less than comparison is not supported.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Filters the results by the specified Availability Zone.
        public var availabilityZone: String? = nil
        /// The token for the next set of results.
        public var nextToken: String? = nil
        /// Filters the results by the specified instance types. Note that T2 and HS1 instance types are not supported.
        public var instanceTypes: [String]? = nil

        public init() {}

        public init(startTime: Date? = nil, maxResults: Int32? = nil, productDescriptions: [String]? = nil, endTime: Date? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, availabilityZone: String? = nil, nextToken: String? = nil, instanceTypes: [String]? = nil) {
            self.startTime = startTime
            self.maxResults = maxResults
            self.productDescriptions = productDescriptions
            self.endTime = endTime
            self.filters = filters
            self.dryRun = dryRun
            self.availabilityZone = availabilityZone
            self.nextToken = nextToken
            self.instanceTypes = instanceTypes
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? Date
            self.maxResults = dictionary["MaxResults"] as? Int32
            if let productDescriptions = dictionary["ProductDescriptions"] as? [String] {
                self.productDescriptions = productDescriptions
            }
            self.endTime = dictionary["EndTime"] as? Date
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            if let instanceTypes = dictionary["InstanceTypes"] as? [String] {
                self.instanceTypes = instanceTypes
            }
        }
    }

    public struct ConversionTask: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If the task is for importing an instance, this contains information about the import instance task.
        public var importInstance: ImportInstanceTaskDetails? = nil
        /// The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.
        public var expirationTime: String? = nil
        /// Any tags assigned to the task.
        public var tags: [Tag]? = nil
        /// The state of the conversion task.
        public var state: String = ""
        /// The ID of the conversion task.
        public var conversionTaskId: String = ""
        /// The status message related to the conversion task.
        public var statusMessage: String? = nil
        /// If the task is for importing a volume, this contains information about the import volume task.
        public var importVolume: ImportVolumeTaskDetails? = nil

        public init() {}

        public init(importInstance: ImportInstanceTaskDetails? = nil, expirationTime: String? = nil, tags: [Tag]? = nil, state: String, conversionTaskId: String, statusMessage: String? = nil, importVolume: ImportVolumeTaskDetails? = nil) {
            self.importInstance = importInstance
            self.expirationTime = expirationTime
            self.tags = tags
            self.state = state
            self.conversionTaskId = conversionTaskId
            self.statusMessage = statusMessage
            self.importVolume = importVolume
        }

        public init(dictionary: [String: Any]) throws {
            if let importInstance = dictionary["ImportInstance"] as? [String: Any] { self.importInstance = try Ec2.ImportInstanceTaskDetails(dictionary: importInstance) }
            self.expirationTime = dictionary["ExpirationTime"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            guard let state = dictionary["State"] as? String else { throw InitializableError.missingRequiredParam("State") }
            self.state = state
            guard let conversionTaskId = dictionary["ConversionTaskId"] as? String else { throw InitializableError.missingRequiredParam("ConversionTaskId") }
            self.conversionTaskId = conversionTaskId
            self.statusMessage = dictionary["StatusMessage"] as? String
            if let importVolume = dictionary["ImportVolume"] as? [String: Any] { self.importVolume = try Ec2.ImportVolumeTaskDetails(dictionary: importVolume) }
        }
    }

    public struct ReplaceRouteTableAssociationResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the new association.
        public var newAssociationId: String? = nil

        public init() {}

        public init(newAssociationId: String? = nil) {
            self.newAssociationId = newAssociationId
        }

        public init(dictionary: [String: Any]) throws {
            self.newAssociationId = dictionary["NewAssociationId"] as? String
        }
    }

    public struct ModifyVolumeResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A VolumeModification object.
        public var volumeModification: VolumeModification? = nil

        public init() {}

        public init(volumeModification: VolumeModification? = nil) {
            self.volumeModification = volumeModification
        }

        public init(dictionary: [String: Any]) throws {
            if let volumeModification = dictionary["VolumeModification"] as? [String: Any] { self.volumeModification = try Ec2.VolumeModification(dictionary: volumeModification) }
        }
    }

    public struct KeyPair: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the key pair.
        public var keyName: String? = nil
        /// The SHA-1 digest of the DER encoded private key.
        public var keyFingerprint: String? = nil
        /// An unencrypted PEM encoded RSA private key.
        public var keyMaterial: String? = nil

        public init() {}

        public init(keyName: String? = nil, keyFingerprint: String? = nil, keyMaterial: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
            self.keyMaterial = keyMaterial
        }

        public init(dictionary: [String: Any]) throws {
            self.keyName = dictionary["KeyName"] as? String
            self.keyFingerprint = dictionary["KeyFingerprint"] as? String
            self.keyMaterial = dictionary["KeyMaterial"] as? String
        }
    }

    public struct DescribeVpnGatewaysResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more virtual private gateways.
        public var vpnGateways: [VpnGateway]? = nil

        public init() {}

        public init(vpnGateways: [VpnGateway]? = nil) {
            self.vpnGateways = vpnGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnGateways = dictionary["VpnGateways"] as? [[String: Any]] {
                self.vpnGateways = try vpnGateways.map({ try VpnGateway(dictionary: $0) })
            }
        }
    }

    public struct DescribeSpotFleetInstancesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The token for the next set of results.
        public var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, nextToken: String? = nil, spotFleetRequestId: String, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.nextToken = dictionary["NextToken"] as? String
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteVpcEndpointsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more endpoint IDs.
        public var vpcEndpointIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(vpcEndpointIds: [String], dryRun: Bool? = nil) {
            self.vpcEndpointIds = vpcEndpointIds
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcEndpointIds = dictionary["VpcEndpointIds"] as? [String] else { throw InitializableError.missingRequiredParam("VpcEndpointIds") }
            self.vpcEndpointIds = vpcEndpointIds
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeReservedInstancesModificationsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The Reserved Instance modification information.
        public var reservedInstancesModifications: [ReservedInstancesModification]? = nil

        public init() {}

        public init(nextToken: String? = nil, reservedInstancesModifications: [ReservedInstancesModification]? = nil) {
            self.nextToken = nextToken
            self.reservedInstancesModifications = reservedInstancesModifications
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let reservedInstancesModifications = dictionary["ReservedInstancesModifications"] as? [[String: Any]] {
                self.reservedInstancesModifications = try reservedInstancesModifications.map({ try ReservedInstancesModification(dictionary: $0) })
            }
        }
    }

    public struct AssociateSubnetCidrBlockRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.
        public var ipv6CidrBlock: String = ""
        /// The ID of your subnet.
        public var subnetId: String = ""

        public init() {}

        public init(ipv6CidrBlock: String, subnetId: String) {
            self.ipv6CidrBlock = ipv6CidrBlock
            self.subnetId = subnetId
        }

        public init(dictionary: [String: Any]) throws {
            guard let ipv6CidrBlock = dictionary["Ipv6CidrBlock"] as? String else { throw InitializableError.missingRequiredParam("Ipv6CidrBlock") }
            self.ipv6CidrBlock = ipv6CidrBlock
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
        }
    }

    public struct DescribeDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of one or more DHCP options sets. Default: Describes all your DHCP options sets.
        public var dhcpOptionsIds: [String]? = nil
        /// One or more filters.    dhcp-options-id - The ID of a set of DHCP options.    key - The key for one of the options (for example, domain-name).    value - The value for one of the options.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        public var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(dhcpOptionsIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.dhcpOptionsIds = dhcpOptionsIds
            self.filters = filters
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            if let dhcpOptionsIds = dictionary["DhcpOptionsIds"] as? [String] {
                self.dhcpOptionsIds = dhcpOptionsIds
            }
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct LaunchPermissionModifications: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID to remove from the list of launch permissions for the AMI.
        public var remove: [LaunchPermission]? = nil
        /// The AWS account ID to add to the list of launch permissions for the AMI.
        public var add: [LaunchPermission]? = nil

        public init() {}

        public init(remove: [LaunchPermission]? = nil, add: [LaunchPermission]? = nil) {
            self.remove = remove
            self.add = add
        }

        public init(dictionary: [String: Any]) throws {
            if let remove = dictionary["Remove"] as? [[String: Any]] {
                self.remove = try remove.map({ try LaunchPermission(dictionary: $0) })
            }
            if let add = dictionary["Add"] as? [[String: Any]] {
                self.add = try add.map({ try LaunchPermission(dictionary: $0) })
            }
        }
    }

    public struct ModifyHostsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The host IDs of the Dedicated Hosts you want to modify.
        public var hostIds: [String] = []
        /// Specify whether to enable or disable auto-placement.
        public var autoPlacement: String = ""

        public init() {}

        public init(hostIds: [String], autoPlacement: String) {
            self.hostIds = hostIds
            self.autoPlacement = autoPlacement
        }

        public init(dictionary: [String: Any]) throws {
            guard let hostIds = dictionary["HostIds"] as? [String] else { throw InitializableError.missingRequiredParam("HostIds") }
            self.hostIds = hostIds
            guard let autoPlacement = dictionary["AutoPlacement"] as? String else { throw InitializableError.missingRequiredParam("AutoPlacement") }
            self.autoPlacement = autoPlacement
        }
    }

    public struct ReleaseAddressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// [EC2-VPC] The allocation ID. Required for EC2-VPC.
        public var allocationId: String? = nil
        /// [EC2-Classic] The Elastic IP address. Required for EC2-Classic.
        public var publicIp: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, allocationId: String? = nil, publicIp: String? = nil) {
            self.dryRun = dryRun
            self.allocationId = allocationId
            self.publicIp = publicIp
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            self.allocationId = dictionary["AllocationId"] as? String
            self.publicIp = dictionary["PublicIp"] as? String
        }
    }

    public struct VpcEndpoint: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date and time the VPC endpoint was created.
        public var creationTimestamp: Date? = nil
        /// The ID of the VPC to which the endpoint is associated.
        public var vpcId: String? = nil
        /// The state of the VPC endpoint.
        public var state: String? = nil
        /// The name of the AWS service to which the endpoint is associated.
        public var serviceName: String? = nil
        /// The ID of the VPC endpoint.
        public var vpcEndpointId: String? = nil
        /// The policy document associated with the endpoint.
        public var policyDocument: String? = nil
        /// One or more route tables associated with the endpoint.
        public var routeTableIds: [String]? = nil

        public init() {}

        public init(creationTimestamp: Date? = nil, vpcId: String? = nil, state: String? = nil, serviceName: String? = nil, vpcEndpointId: String? = nil, policyDocument: String? = nil, routeTableIds: [String]? = nil) {
            self.creationTimestamp = creationTimestamp
            self.vpcId = vpcId
            self.state = state
            self.serviceName = serviceName
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = policyDocument
            self.routeTableIds = routeTableIds
        }

        public init(dictionary: [String: Any]) throws {
            self.creationTimestamp = dictionary["CreationTimestamp"] as? Date
            self.vpcId = dictionary["VpcId"] as? String
            self.state = dictionary["State"] as? String
            self.serviceName = dictionary["ServiceName"] as? String
            self.vpcEndpointId = dictionary["VpcEndpointId"] as? String
            self.policyDocument = dictionary["PolicyDocument"] as? String
            if let routeTableIds = dictionary["RouteTableIds"] as? [String] {
                self.routeTableIds = routeTableIds
            }
        }
    }

    public struct AssociateIamInstanceProfileRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// The IAM instance profile.
        public var iamInstanceProfile: IamInstanceProfileSpecification = IamInstanceProfileSpecification()

        public init() {}

        public init(instanceId: String, iamInstanceProfile: IamInstanceProfileSpecification) {
            self.instanceId = instanceId
            self.iamInstanceProfile = iamInstanceProfile
        }

        public init(dictionary: [String: Any]) throws {
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            guard let iamInstanceProfile = dictionary["IamInstanceProfile"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IamInstanceProfile") }
            self.iamInstanceProfile = try Ec2.IamInstanceProfileSpecification(dictionary: iamInstanceProfile)
        }
    }

    public struct DisassociateVpcCidrBlockResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// Information about the IPv6 CIDR block association.
        public var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(vpcId: String? = nil, ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil) {
            self.vpcId = vpcId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let ipv6CidrBlockAssociation = dictionary["Ipv6CidrBlockAssociation"] as? [String: Any] { self.ipv6CidrBlockAssociation = try Ec2.VpcIpv6CidrBlockAssociation(dictionary: ipv6CidrBlockAssociation) }
        }
    }

    public struct DeleteDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the DHCP options set.
        public var dhcpOptionsId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(dhcpOptionsId: String, dryRun: Bool? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let dhcpOptionsId = dictionary["DhcpOptionsId"] as? String else { throw InitializableError.missingRequiredParam("DhcpOptionsId") }
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct DescribeHostReservationsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Details about the reservation's configuration.
        public var hostReservationSet: [HostReservation]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(hostReservationSet: [HostReservation]? = nil, nextToken: String? = nil) {
            self.hostReservationSet = hostReservationSet
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let hostReservationSet = dictionary["HostReservationSet"] as? [[String: Any]] {
                self.hostReservationSet = try hostReservationSet.map({ try HostReservation(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct ModifyNetworkInterfaceAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A description for the network interface.
        public var description: AttributeValue? = nil
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.
        public var attachment: NetworkInterfaceAttachmentChanges? = nil
        /// Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.
        public var groups: [String]? = nil
        /// Indicates whether source/destination checking is enabled. A value of true means checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT. For more information, see NAT Instances in the Amazon Virtual Private Cloud User Guide.
        public var sourceDestCheck: AttributeBooleanValue? = nil

        public init() {}

        public init(description: AttributeValue? = nil, networkInterfaceId: String, dryRun: Bool? = nil, attachment: NetworkInterfaceAttachmentChanges? = nil, groups: [String]? = nil, sourceDestCheck: AttributeBooleanValue? = nil) {
            self.description = description
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
            self.attachment = attachment
            self.groups = groups
            self.sourceDestCheck = sourceDestCheck
        }

        public init(dictionary: [String: Any]) throws {
            if let description = dictionary["Description"] as? [String: Any] { self.description = try Ec2.AttributeValue(dictionary: description) }
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dictionary["DryRun"] as? Bool
            if let attachment = dictionary["Attachment"] as? [String: Any] { self.attachment = try Ec2.NetworkInterfaceAttachmentChanges(dictionary: attachment) }
            if let groups = dictionary["Groups"] as? [String] {
                self.groups = groups
            }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) }
        }
    }

    public struct AttributeBooleanValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The attribute value. The valid values are true or false.
        public var value: Bool? = nil

        public init() {}

        public init(value: Bool? = nil) {
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct AttachVpnGatewayRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the virtual private gateway.
        public var vpnGatewayId: String = ""

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil, vpnGatewayId: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            guard let vpcId = dictionary["VpcId"] as? String else { throw InitializableError.missingRequiredParam("VpcId") }
            self.vpcId = vpcId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let vpnGatewayId = dictionary["VpnGatewayId"] as? String else { throw InitializableError.missingRequiredParam("VpnGatewayId") }
            self.vpnGatewayId = vpnGatewayId
        }
    }

    public struct CreateEgressOnlyInternetGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        public var clientToken: String? = nil
        /// Information about the egress-only Internet gateway.
        public var egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil

        public init() {}

        public init(clientToken: String? = nil, egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil) {
            self.clientToken = clientToken
            self.egressOnlyInternetGateway = egressOnlyInternetGateway
        }

        public init(dictionary: [String: Any]) throws {
            self.clientToken = dictionary["ClientToken"] as? String
            if let egressOnlyInternetGateway = dictionary["EgressOnlyInternetGateway"] as? [String: Any] { self.egressOnlyInternetGateway = try Ec2.EgressOnlyInternetGateway(dictionary: egressOnlyInternetGateway) }
        }
    }

    public struct NetworkInterfaceAttachmentChanges: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Bool? = nil
        /// The ID of the network interface attachment.
        public var attachmentId: String? = nil

        public init() {}

        public init(deleteOnTermination: Bool? = nil, attachmentId: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.attachmentId = attachmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.attachmentId = dictionary["AttachmentId"] as? String
        }
    }

    public struct CancelExportTaskRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the export task. This is the ID returned by CreateInstanceExportTask.
        public var exportTaskId: String = ""

        public init() {}

        public init(exportTaskId: String) {
            self.exportTaskId = exportTaskId
        }

        public init(dictionary: [String: Any]) throws {
            guard let exportTaskId = dictionary["ExportTaskId"] as? String else { throw InitializableError.missingRequiredParam("ExportTaskId") }
            self.exportTaskId = exportTaskId
        }
    }

    public struct ResetImageAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The attribute to reset (currently you can only reset the launch permission attribute).
        public var attribute: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the AMI.
        public var imageId: String = ""

        public init() {}

        public init(attribute: String, dryRun: Bool? = nil, imageId: String) {
            self.attribute = attribute
            self.dryRun = dryRun
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            guard let attribute = dictionary["Attribute"] as? String else { throw InitializableError.missingRequiredParam("Attribute") }
            self.attribute = attribute
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let imageId = dictionary["ImageId"] as? String else { throw InitializableError.missingRequiredParam("ImageId") }
            self.imageId = imageId
        }
    }

    public struct AssociateRouteTableRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the subnet.
        public var subnetId: String = ""
        /// The ID of the route table.
        public var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(subnetId: String, routeTableId: String, dryRun: Bool? = nil) {
            self.subnetId = subnetId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetId = dictionary["SubnetId"] as? String else { throw InitializableError.missingRequiredParam("SubnetId") }
            self.subnetId = subnetId
            guard let routeTableId = dictionary["RouteTableId"] as? String else { throw InitializableError.missingRequiredParam("RouteTableId") }
            self.routeTableId = routeTableId
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct PrivateIpAddressSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        public var primary: Bool? = nil
        /// The private IPv4 addresses.
        public var privateIpAddress: String = ""

        public init() {}

        public init(primary: Bool? = nil, privateIpAddress: String) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.primary = dictionary["Primary"] as? Bool
            guard let privateIpAddress = dictionary["PrivateIpAddress"] as? String else { throw InitializableError.missingRequiredParam("PrivateIpAddress") }
            self.privateIpAddress = privateIpAddress
        }
    }

    public struct ClassicLinkInstance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// The ID of the instance.
        public var instanceId: String? = nil
        /// A list of security groups.
        public var groups: [GroupIdentifier]? = nil
        /// Any tags assigned to the instance.
        public var tags: [Tag]? = nil

        public init() {}

        public init(vpcId: String? = nil, instanceId: String? = nil, groups: [GroupIdentifier]? = nil, tags: [Tag]? = nil) {
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.groups = groups
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            self.instanceId = dictionary["InstanceId"] as? String
            if let groups = dictionary["Groups"] as? [[String: Any]] {
                self.groups = try groups.map({ try GroupIdentifier(dictionary: $0) })
            }
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
        }
    }

    public struct DescribePlacementGroupsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// One or more filters.    group-name - The name of the placement group.    state - The state of the placement group (pending | available | deleting | deleted).    strategy - The strategy of the placement group (cluster).  
        public var filters: [Filter]? = nil
        /// One or more placement group names. Default: Describes all your placement groups, or only those otherwise specified.
        public var groupNames: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, groupNames: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.groupNames = groupNames
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
            if let groupNames = dictionary["GroupNames"] as? [String] {
                self.groupNames = groupNames
            }
        }
    }

    public struct ReplaceNetworkAclAssociationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the current association between the original network ACL and the subnet.
        public var associationId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the new network ACL to associate with the subnet.
        public var networkAclId: String = ""

        public init() {}

        public init(associationId: String, dryRun: Bool? = nil, networkAclId: String) {
            self.associationId = associationId
            self.dryRun = dryRun
            self.networkAclId = networkAclId
        }

        public init(dictionary: [String: Any]) throws {
            guard let associationId = dictionary["AssociationId"] as? String else { throw InitializableError.missingRequiredParam("AssociationId") }
            self.associationId = associationId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let networkAclId = dictionary["NetworkAclId"] as? String else { throw InitializableError.missingRequiredParam("NetworkAclId") }
            self.networkAclId = networkAclId
        }
    }

    public struct CreateImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more block device mappings.
        public var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// A description for the new image.
        public var description: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.
        public var noReboot: Bool? = nil
        /// A name for the new image. Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)
        public var name: String = ""
        /// The ID of the instance.
        public var instanceId: String = ""

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, description: String? = nil, dryRun: Bool? = nil, noReboot: Bool? = nil, name: String, instanceId: String) {
            self.blockDeviceMappings = blockDeviceMappings
            self.description = description
            self.dryRun = dryRun
            self.noReboot = noReboot
            self.name = name
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try BlockDeviceMapping(dictionary: $0) })
            }
            self.description = dictionary["Description"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.noReboot = dictionary["NoReboot"] as? Bool
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct ModifyVpcPeeringConnectionOptionsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the VPC peering connection options for the accepter VPC.
        public var accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil
        /// Information about the VPC peering connection options for the requester VPC.
        public var requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil

        public init() {}

        public init(accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil, requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil) {
            self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
            self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
        }

        public init(dictionary: [String: Any]) throws {
            if let accepterPeeringConnectionOptions = dictionary["AccepterPeeringConnectionOptions"] as? [String: Any] { self.accepterPeeringConnectionOptions = try Ec2.PeeringConnectionOptions(dictionary: accepterPeeringConnectionOptions) }
            if let requesterPeeringConnectionOptions = dictionary["RequesterPeeringConnectionOptions"] as? [String: Any] { self.requesterPeeringConnectionOptions = try Ec2.PeeringConnectionOptions(dictionary: requesterPeeringConnectionOptions) }
        }
    }

    public struct DescribeVpcAttributeResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil
        /// Indicates whether DNS resolution is enabled for the VPC. If this attribute is true, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.
        public var enableDnsSupport: AttributeBooleanValue? = nil
        /// Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is true, instances in the VPC get DNS hostnames; otherwise, they do not.
        public var enableDnsHostnames: AttributeBooleanValue? = nil

        public init() {}

        public init(vpcId: String? = nil, enableDnsSupport: AttributeBooleanValue? = nil, enableDnsHostnames: AttributeBooleanValue? = nil) {
            self.vpcId = vpcId
            self.enableDnsSupport = enableDnsSupport
            self.enableDnsHostnames = enableDnsHostnames
        }

        public init(dictionary: [String: Any]) throws {
            self.vpcId = dictionary["VpcId"] as? String
            if let enableDnsSupport = dictionary["EnableDnsSupport"] as? [String: Any] { self.enableDnsSupport = try Ec2.AttributeBooleanValue(dictionary: enableDnsSupport) }
            if let enableDnsHostnames = dictionary["EnableDnsHostnames"] as? [String: Any] { self.enableDnsHostnames = try Ec2.AttributeBooleanValue(dictionary: enableDnsHostnames) }
        }
    }

    public struct ModifyVolumeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Target EBS volume type of the volume to be modified  The API does not support modifications for volume type standard. You also cannot change the type of a volume to standard.  Default: If no type is specified, the existing type is retained. 
        public var volumeType: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Target IOPS rate of the volume to be modified. Only valid for Provisioned IOPS SSD (io1) volumes. For more information about io1 IOPS configuration, see http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops. Default: If no IOPS value is specified, the existing value is retained. 
        public var iops: Int32? = nil
        public var volumeId: String = ""
        /// Target size in GiB of the volume to be modified. Target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html. Default: If no size is specified, the existing size is retained. 
        public var size: Int32? = nil

        public init() {}

        public init(volumeType: String? = nil, dryRun: Bool? = nil, iops: Int32? = nil, volumeId: String, size: Int32? = nil) {
            self.volumeType = volumeType
            self.dryRun = dryRun
            self.iops = iops
            self.volumeId = volumeId
            self.size = size
        }

        public init(dictionary: [String: Any]) throws {
            self.volumeType = dictionary["VolumeType"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.iops = dictionary["Iops"] as? Int32
            guard let volumeId = dictionary["VolumeId"] as? String else { throw InitializableError.missingRequiredParam("VolumeId") }
            self.volumeId = volumeId
            self.size = dictionary["Size"] as? Int32
        }
    }

    public struct DescribeCustomerGatewaysResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more customer gateways.
        public var customerGateways: [CustomerGateway]? = nil

        public init() {}

        public init(customerGateways: [CustomerGateway]? = nil) {
            self.customerGateways = customerGateways
        }

        public init(dictionary: [String: Any]) throws {
            if let customerGateways = dictionary["CustomerGateways"] as? [[String: Any]] {
                self.customerGateways = try customerGateways.map({ try CustomerGateway(dictionary: $0) })
            }
        }
    }

    public struct ModifyInstanceAttributeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Modifies the DeleteOnTermination attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for DeleteOnTermination, the default is true and the volume is deleted when the instance is terminated. To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see Updating the Block Device Mapping when Launching an Instance in the Amazon Elastic Compute Cloud User Guide.
        public var blockDeviceMappings: [InstanceBlockDeviceMappingSpecification]? = nil
        /// If the value is true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.
        public var disableApiTermination: AttributeBooleanValue? = nil
        /// Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        public var userData: BlobAttributeValue? = nil
        /// Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance. There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.
        public var sriovNetSupport: AttributeValue? = nil
        /// Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
        public var ebsOptimized: AttributeBooleanValue? = nil
        /// Specifies whether source/destination checking is enabled. A value of true means that checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.
        public var sourceDestCheck: AttributeBooleanValue? = nil
        /// The name of the attribute.
        public var attribute: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// Changes the instance type to the specified value. For more information, see Instance Types. If the instance type is not valid, the error returned is InvalidInstanceAttributeValue.
        public var instanceType: AttributeValue? = nil
        /// Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB.
        public var ramdisk: AttributeValue? = nil
        /// A new value for the attribute. Use only with the kernel, ramdisk, userData, disableApiTermination, or instanceInitiatedShutdownBehavior attribute.
        public var value: String? = nil
        /// Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB.
        public var kernel: AttributeValue? = nil
        /// The ID of the instance.
        public var instanceId: String = ""
        /// Set to true to enable enhanced networking with ENA for the instance. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.
        public var enaSupport: AttributeBooleanValue? = nil
        /// Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        public var instanceInitiatedShutdownBehavior: AttributeValue? = nil
        /// [EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.
        public var groups: [String]? = nil

        public init() {}

        public init(blockDeviceMappings: [InstanceBlockDeviceMappingSpecification]? = nil, disableApiTermination: AttributeBooleanValue? = nil, userData: BlobAttributeValue? = nil, sriovNetSupport: AttributeValue? = nil, ebsOptimized: AttributeBooleanValue? = nil, sourceDestCheck: AttributeBooleanValue? = nil, attribute: String? = nil, dryRun: Bool? = nil, instanceType: AttributeValue? = nil, ramdisk: AttributeValue? = nil, value: String? = nil, kernel: AttributeValue? = nil, instanceId: String, enaSupport: AttributeBooleanValue? = nil, instanceInitiatedShutdownBehavior: AttributeValue? = nil, groups: [String]? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.disableApiTermination = disableApiTermination
            self.userData = userData
            self.sriovNetSupport = sriovNetSupport
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.attribute = attribute
            self.dryRun = dryRun
            self.instanceType = instanceType
            self.ramdisk = ramdisk
            self.value = value
            self.kernel = kernel
            self.instanceId = instanceId
            self.enaSupport = enaSupport
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.groups = groups
        }

        public init(dictionary: [String: Any]) throws {
            if let blockDeviceMappings = dictionary["BlockDeviceMappings"] as? [[String: Any]] {
                self.blockDeviceMappings = try blockDeviceMappings.map({ try InstanceBlockDeviceMappingSpecification(dictionary: $0) })
            }
            if let disableApiTermination = dictionary["DisableApiTermination"] as? [String: Any] { self.disableApiTermination = try Ec2.AttributeBooleanValue(dictionary: disableApiTermination) }
            if let userData = dictionary["UserData"] as? [String: Any] { self.userData = try Ec2.BlobAttributeValue(dictionary: userData) }
            if let sriovNetSupport = dictionary["SriovNetSupport"] as? [String: Any] { self.sriovNetSupport = try Ec2.AttributeValue(dictionary: sriovNetSupport) }
            if let ebsOptimized = dictionary["EbsOptimized"] as? [String: Any] { self.ebsOptimized = try Ec2.AttributeBooleanValue(dictionary: ebsOptimized) }
            if let sourceDestCheck = dictionary["SourceDestCheck"] as? [String: Any] { self.sourceDestCheck = try Ec2.AttributeBooleanValue(dictionary: sourceDestCheck) }
            self.attribute = dictionary["Attribute"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            if let instanceType = dictionary["InstanceType"] as? [String: Any] { self.instanceType = try Ec2.AttributeValue(dictionary: instanceType) }
            if let ramdisk = dictionary["Ramdisk"] as? [String: Any] { self.ramdisk = try Ec2.AttributeValue(dictionary: ramdisk) }
            self.value = dictionary["Value"] as? String
            if let kernel = dictionary["Kernel"] as? [String: Any] { self.kernel = try Ec2.AttributeValue(dictionary: kernel) }
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
            if let enaSupport = dictionary["EnaSupport"] as? [String: Any] { self.enaSupport = try Ec2.AttributeBooleanValue(dictionary: enaSupport) }
            if let instanceInitiatedShutdownBehavior = dictionary["InstanceInitiatedShutdownBehavior"] as? [String: Any] { self.instanceInitiatedShutdownBehavior = try Ec2.AttributeValue(dictionary: instanceInitiatedShutdownBehavior) }
            if let groups = dictionary["Groups"] as? [String] {
                self.groups = groups
            }
        }
    }

    public struct ScheduledInstanceRecurrence: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The frequency (Daily, Weekly, or Monthly).
        public var frequency: String? = nil
        /// The unit for occurrenceDaySet (DayOfWeek or DayOfMonth).
        public var occurrenceUnit: String? = nil
        /// Indicates whether the occurrence is relative to the end of the specified week or month.
        public var occurrenceRelativeToEnd: Bool? = nil
        /// The interval quantity. The interval unit depends on the value of frequency. For example, every 2 weeks or every 2 months.
        public var interval: Int32? = nil
        /// The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).
        public var occurrenceDaySet: [Int32]? = nil

        public init() {}

        public init(frequency: String? = nil, occurrenceUnit: String? = nil, occurrenceRelativeToEnd: Bool? = nil, interval: Int32? = nil, occurrenceDaySet: [Int32]? = nil) {
            self.frequency = frequency
            self.occurrenceUnit = occurrenceUnit
            self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
            self.interval = interval
            self.occurrenceDaySet = occurrenceDaySet
        }

        public init(dictionary: [String: Any]) throws {
            self.frequency = dictionary["Frequency"] as? String
            self.occurrenceUnit = dictionary["OccurrenceUnit"] as? String
            self.occurrenceRelativeToEnd = dictionary["OccurrenceRelativeToEnd"] as? Bool
            self.interval = dictionary["Interval"] as? Int32
            if let occurrenceDaySet = dictionary["OccurrenceDaySet"] as? [Int32] {
                self.occurrenceDaySet = occurrenceDaySet
            }
        }
    }

    public struct CreateVpnGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the virtual private gateway.
        public var vpnGateway: VpnGateway? = nil

        public init() {}

        public init(vpnGateway: VpnGateway? = nil) {
            self.vpnGateway = vpnGateway
        }

        public init(dictionary: [String: Any]) throws {
            if let vpnGateway = dictionary["VpnGateway"] as? [String: Any] { self.vpnGateway = try Ec2.VpnGateway(dictionary: vpnGateway) }
        }
    }

    public struct SnapshotDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A brief status of the snapshot creation.
        public var status: String? = nil
        /// The percentage of progress for the task.
        public var progress: String? = nil
        /// The URL used to access the disk image.
        public var url: String? = nil
        /// The size of the disk in the snapshot, in GiB.
        public var diskImageSize: Double? = nil
        /// The format of the disk image from which the snapshot is created.
        public var format: String? = nil
        /// The snapshot ID of the disk being imported.
        public var snapshotId: String? = nil
        /// The S3 bucket for the disk image.
        public var userBucket: UserBucketDetails? = nil
        /// A detailed status message for the snapshot creation.
        public var statusMessage: String? = nil
        /// The block device mapping for the snapshot.
        public var deviceName: String? = nil
        /// A description for the snapshot.
        public var description: String? = nil

        public init() {}

        public init(status: String? = nil, progress: String? = nil, url: String? = nil, diskImageSize: Double? = nil, format: String? = nil, snapshotId: String? = nil, userBucket: UserBucketDetails? = nil, statusMessage: String? = nil, deviceName: String? = nil, description: String? = nil) {
            self.status = status
            self.progress = progress
            self.url = url
            self.diskImageSize = diskImageSize
            self.format = format
            self.snapshotId = snapshotId
            self.userBucket = userBucket
            self.statusMessage = statusMessage
            self.deviceName = deviceName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.progress = dictionary["Progress"] as? String
            self.url = dictionary["Url"] as? String
            self.diskImageSize = dictionary["DiskImageSize"] as? Double
            self.format = dictionary["Format"] as? String
            self.snapshotId = dictionary["SnapshotId"] as? String
            if let userBucket = dictionary["UserBucket"] as? [String: Any] { self.userBucket = try Ec2.UserBucketDetails(dictionary: userBucket) }
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.deviceName = dictionary["DeviceName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeVpcClassicLinkDnsSupportRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more VPC IDs.
        public var vpcIds: [String]? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        public var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.
        public var maxResults: Int32? = nil

        public init() {}

        public init(vpcIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.vpcIds = vpcIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            if let vpcIds = dictionary["VpcIds"] as? [String] {
                self.vpcIds = vpcIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteNatGatewayResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the NAT gateway.
        public var natGatewayId: String? = nil

        public init() {}

        public init(natGatewayId: String? = nil) {
            self.natGatewayId = natGatewayId
        }

        public init(dictionary: [String: Any]) throws {
            self.natGatewayId = dictionary["NatGatewayId"] as? String
        }
    }

    public struct AttachNetworkInterfaceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The index of the device for the network interface attachment.
        public var deviceIndex: Int32 = 0
        /// The ID of the network interface.
        public var networkInterfaceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The ID of the instance.
        public var instanceId: String = ""

        public init() {}

        public init(deviceIndex: Int32, networkInterfaceId: String, dryRun: Bool? = nil, instanceId: String) {
            self.deviceIndex = deviceIndex
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
            self.instanceId = instanceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let deviceIndex = dictionary["DeviceIndex"] as? Int32 else { throw InitializableError.missingRequiredParam("DeviceIndex") }
            self.deviceIndex = deviceIndex
            guard let networkInterfaceId = dictionary["NetworkInterfaceId"] as? String else { throw InitializableError.missingRequiredParam("NetworkInterfaceId") }
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dictionary["DryRun"] as? Bool
            guard let instanceId = dictionary["InstanceId"] as? String else { throw InitializableError.missingRequiredParam("InstanceId") }
            self.instanceId = instanceId
        }
    }

    public struct IpPermission: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more security group and AWS account ID pairs.
        public var userIdGroupPairs: [UserIdGroupPair]? = nil
        /// One or more IPv4 ranges.
        public var ipRanges: [IpRange]? = nil
        /// [EC2-VPC only] One or more IPv6 ranges.
        public var ipv6Ranges: [Ipv6Range]? = nil
        /// (Valid for AuthorizeSecurityGroupEgress, RevokeSecurityGroupEgress and DescribeSecurityGroups only) One or more prefix list IDs for an AWS service. In an AuthorizeSecurityGroupEgress request, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
        public var prefixListIds: [PrefixListId]? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes for the specified ICMP type.
        public var toPort: Int32? = nil
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers).  [EC2-VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. 
        public var ipProtocol: String? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.
        public var fromPort: Int32? = nil

        public init() {}

        public init(userIdGroupPairs: [UserIdGroupPair]? = nil, ipRanges: [IpRange]? = nil, ipv6Ranges: [Ipv6Range]? = nil, prefixListIds: [PrefixListId]? = nil, toPort: Int32? = nil, ipProtocol: String? = nil, fromPort: Int32? = nil) {
            self.userIdGroupPairs = userIdGroupPairs
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.ipProtocol = ipProtocol
            self.fromPort = fromPort
        }

        public init(dictionary: [String: Any]) throws {
            if let userIdGroupPairs = dictionary["UserIdGroupPairs"] as? [[String: Any]] {
                self.userIdGroupPairs = try userIdGroupPairs.map({ try UserIdGroupPair(dictionary: $0) })
            }
            if let ipRanges = dictionary["IpRanges"] as? [[String: Any]] {
                self.ipRanges = try ipRanges.map({ try IpRange(dictionary: $0) })
            }
            if let ipv6Ranges = dictionary["Ipv6Ranges"] as? [[String: Any]] {
                self.ipv6Ranges = try ipv6Ranges.map({ try Ipv6Range(dictionary: $0) })
            }
            if let prefixListIds = dictionary["PrefixListIds"] as? [[String: Any]] {
                self.prefixListIds = try prefixListIds.map({ try PrefixListId(dictionary: $0) })
            }
            self.toPort = dictionary["ToPort"] as? Int32
            self.ipProtocol = dictionary["IpProtocol"] as? String
            self.fromPort = dictionary["FromPort"] as? Int32
        }
    }

    public struct VgwTelemetry: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the VPN tunnel.
        public var status: String? = nil
        /// The date and time of the last change in status.
        public var lastStatusChange: Date? = nil
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        public var outsideIpAddress: String? = nil
        /// If an error occurs, a description of the error.
        public var statusMessage: String? = nil
        /// The number of accepted routes.
        public var acceptedRouteCount: Int32? = nil

        public init() {}

        public init(status: String? = nil, lastStatusChange: Date? = nil, outsideIpAddress: String? = nil, statusMessage: String? = nil, acceptedRouteCount: Int32? = nil) {
            self.status = status
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.statusMessage = statusMessage
            self.acceptedRouteCount = acceptedRouteCount
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.lastStatusChange = dictionary["LastStatusChange"] as? Date
            self.outsideIpAddress = dictionary["OutsideIpAddress"] as? String
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.acceptedRouteCount = dictionary["AcceptedRouteCount"] as? Int32
        }
    }

    public struct ReplaceNetworkAclAssociationResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the new association.
        public var newAssociationId: String? = nil

        public init() {}

        public init(newAssociationId: String? = nil) {
            self.newAssociationId = newAssociationId
        }

        public init(dictionary: [String: Any]) throws {
            self.newAssociationId = dictionary["NewAssociationId"] as? String
        }
    }

    public struct DiskImageVolumeDescription: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The size of the volume, in GiB.
        public var size: Int64? = nil
        /// The volume identifier.
        public var id: String = ""

        public init() {}

        public init(size: Int64? = nil, id: String) {
            self.size = size
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.size = dictionary["Size"] as? Int64
            guard let id = dictionary["Id"] as? String else { throw InitializableError.missingRequiredParam("Id") }
            self.id = id
        }
    }

    public struct AttributeValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The attribute value. Note that the value is case-sensitive.
        public var value: String? = nil

        public init() {}

        public init(value: String? = nil) {
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
        }
    }

    public struct ImportInstanceResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about the conversion task.
        public var conversionTask: ConversionTask? = nil

        public init() {}

        public init(conversionTask: ConversionTask? = nil) {
            self.conversionTask = conversionTask
        }

        public init(dictionary: [String: Any]) throws {
            if let conversionTask = dictionary["ConversionTask"] as? [String: Any] { self.conversionTask = try Ec2.ConversionTask(dictionary: conversionTask) }
        }
    }

    public struct CreateDhcpOptionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A DHCP configuration option.
        public var dhcpConfigurations: [NewDhcpConfiguration] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil

        public init() {}

        public init(dhcpConfigurations: [NewDhcpConfiguration], dryRun: Bool? = nil) {
            self.dhcpConfigurations = dhcpConfigurations
            self.dryRun = dryRun
        }

        public init(dictionary: [String: Any]) throws {
            guard let dhcpConfigurations = dictionary["DhcpConfigurations"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("DhcpConfigurations") }
            self.dhcpConfigurations = try dhcpConfigurations.map({ try NewDhcpConfiguration(dictionary: $0) })
            self.dryRun = dictionary["DryRun"] as? Bool
        }
    }

    public struct ModifyIdentityIdFormatRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify all to modify the ID format for all IAM users, IAM roles, and the root user of the account.
        public var principalArn: String = ""
        /// The type of resource: instance | reservation | snapshot | volume 
        public var resource: String = ""
        /// Indicates whether the resource should use longer IDs (17-character IDs)
        public var useLongIds: Bool = false

        public init() {}

        public init(principalArn: String, resource: String, useLongIds: Bool) {
            self.principalArn = principalArn
            self.resource = resource
            self.useLongIds = useLongIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let principalArn = dictionary["PrincipalArn"] as? String else { throw InitializableError.missingRequiredParam("PrincipalArn") }
            self.principalArn = principalArn
            guard let resource = dictionary["Resource"] as? String else { throw InitializableError.missingRequiredParam("Resource") }
            self.resource = resource
            guard let useLongIds = dictionary["UseLongIds"] as? Bool else { throw InitializableError.missingRequiredParam("UseLongIds") }
            self.useLongIds = useLongIds
        }
    }

    public struct SpotFleetRequestConfig: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The state of the Spot fleet request.
        public var spotFleetRequestState: String = ""
        /// The creation date and time of the request.
        public var createTime: Date = Date()
        /// The progress of the Spot fleet request. If there is an error, the status is error. After all bids are placed, the status is pending_fulfillment. If the size of the fleet is equal to or greater than its target capacity, the status is fulfilled. If the size of the fleet is decreased, the status is pending_termination while Spot instances are terminating.
        public var activityStatus: String? = nil
        /// Information about the configuration of the Spot fleet request.
        public var spotFleetRequestConfig: SpotFleetRequestConfigData = SpotFleetRequestConfigData()
        /// The ID of the Spot fleet request.
        public var spotFleetRequestId: String = ""

        public init() {}

        public init(spotFleetRequestState: String, createTime: Date, activityStatus: String? = nil, spotFleetRequestConfig: SpotFleetRequestConfigData, spotFleetRequestId: String) {
            self.spotFleetRequestState = spotFleetRequestState
            self.createTime = createTime
            self.activityStatus = activityStatus
            self.spotFleetRequestConfig = spotFleetRequestConfig
            self.spotFleetRequestId = spotFleetRequestId
        }

        public init(dictionary: [String: Any]) throws {
            guard let spotFleetRequestState = dictionary["SpotFleetRequestState"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestState") }
            self.spotFleetRequestState = spotFleetRequestState
            guard let createTime = dictionary["CreateTime"] as? Date else { throw InitializableError.missingRequiredParam("CreateTime") }
            self.createTime = createTime
            self.activityStatus = dictionary["ActivityStatus"] as? String
            guard let spotFleetRequestConfig = dictionary["SpotFleetRequestConfig"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SpotFleetRequestConfig") }
            self.spotFleetRequestConfig = try Ec2.SpotFleetRequestConfigData(dictionary: spotFleetRequestConfig)
            guard let spotFleetRequestId = dictionary["SpotFleetRequestId"] as? String else { throw InitializableError.missingRequiredParam("SpotFleetRequestId") }
            self.spotFleetRequestId = spotFleetRequestId
        }
    }

    public struct ModifyHostsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The IDs of the Dedicated Hosts that were successfully modified.
        public var successful: [String]? = nil
        /// The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.
        public var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(successful: [String]? = nil, unsuccessful: [UnsuccessfulItem]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        public init(dictionary: [String: Any]) throws {
            if let successful = dictionary["Successful"] as? [String] {
                self.successful = successful
            }
            if let unsuccessful = dictionary["Unsuccessful"] as? [[String: Any]] {
                self.unsuccessful = try unsuccessful.map({ try UnsuccessfulItem(dictionary: $0) })
            }
        }
    }

    public struct DisassociateAddressRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// [EC2-Classic] The Elastic IP address. Required for EC2-Classic.
        public var publicIp: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// [EC2-VPC] The association ID. Required for EC2-VPC.
        public var associationId: String? = nil

        public init() {}

        public init(publicIp: String? = nil, dryRun: Bool? = nil, associationId: String? = nil) {
            self.publicIp = publicIp
            self.dryRun = dryRun
            self.associationId = associationId
        }

        public init(dictionary: [String: Any]) throws {
            self.publicIp = dictionary["PublicIp"] as? String
            self.dryRun = dictionary["DryRun"] as? Bool
            self.associationId = dictionary["AssociationId"] as? String
        }
    }

    public struct ScheduledInstancesEbs: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the snapshot.
        public var snapshotId: String? = nil
        /// Indicates whether the volume is deleted on instance termination.
        public var deleteOnTermination: Bool? = nil
        /// The volume type. gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, Throughput Optimized HDD for st1, Cold HDD for sc1, or standard for Magnetic. Default: standard 
        public var volumeType: String? = nil
        /// The size of the volume, in GiB. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        public var volumeSize: Int32? = nil
        /// The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about gp2 baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        public var iops: Int32? = nil
        /// Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.
        public var encrypted: Bool? = nil

        public init() {}

        public init(snapshotId: String? = nil, deleteOnTermination: Bool? = nil, volumeType: String? = nil, volumeSize: Int32? = nil, iops: Int32? = nil, encrypted: Bool? = nil) {
            self.snapshotId = snapshotId
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.volumeSize = volumeSize
            self.iops = iops
            self.encrypted = encrypted
        }

        public init(dictionary: [String: Any]) throws {
            self.snapshotId = dictionary["SnapshotId"] as? String
            self.deleteOnTermination = dictionary["DeleteOnTermination"] as? Bool
            self.volumeType = dictionary["VolumeType"] as? String
            self.volumeSize = dictionary["VolumeSize"] as? Int32
            self.iops = dictionary["Iops"] as? Int32
            self.encrypted = dictionary["Encrypted"] as? Bool
        }
    }

    public struct UnmonitorInstancesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The monitoring information.
        public var instanceMonitorings: [InstanceMonitoring]? = nil

        public init() {}

        public init(instanceMonitorings: [InstanceMonitoring]? = nil) {
            self.instanceMonitorings = instanceMonitorings
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceMonitorings = dictionary["InstanceMonitorings"] as? [[String: Any]] {
                self.instanceMonitorings = try instanceMonitorings.map({ try InstanceMonitoring(dictionary: $0) })
            }
        }
    }

    public struct InternetGateway: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Any tags assigned to the Internet gateway.
        public var tags: [Tag]? = nil
        /// The ID of the Internet gateway.
        public var internetGatewayId: String? = nil
        /// Any VPCs attached to the Internet gateway.
        public var attachments: [InternetGatewayAttachment]? = nil

        public init() {}

        public init(tags: [Tag]? = nil, internetGatewayId: String? = nil, attachments: [InternetGatewayAttachment]? = nil) {
            self.tags = tags
            self.internetGatewayId = internetGatewayId
            self.attachments = attachments
        }

        public init(dictionary: [String: Any]) throws {
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.internetGatewayId = dictionary["InternetGatewayId"] as? String
            if let attachments = dictionary["Attachments"] as? [[String: Any]] {
                self.attachments = try attachments.map({ try InternetGatewayAttachment(dictionary: $0) })
            }
        }
    }

    public struct CreateVolumePermissionModifications: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Removes a specific AWS account ID or group from a volume's list of create volume permissions.
        public var remove: [CreateVolumePermission]? = nil
        /// Adds a specific AWS account ID or group to a volume's list of create volume permissions.
        public var add: [CreateVolumePermission]? = nil

        public init() {}

        public init(remove: [CreateVolumePermission]? = nil, add: [CreateVolumePermission]? = nil) {
            self.remove = remove
            self.add = add
        }

        public init(dictionary: [String: Any]) throws {
            if let remove = dictionary["Remove"] as? [[String: Any]] {
                self.remove = try remove.map({ try CreateVolumePermission(dictionary: $0) })
            }
            if let add = dictionary["Add"] as? [[String: Any]] {
                self.add = try add.map({ try CreateVolumePermission(dictionary: $0) })
            }
        }
    }

    public struct DescribeSpotFleetRequestsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public var dryRun: Bool? = nil
        /// The IDs of the Spot fleet requests.
        public var spotFleetRequestIds: [String]? = nil
        /// The token for the next set of results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        public var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, spotFleetRequestIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.spotFleetRequestIds = spotFleetRequestIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.dryRun = dictionary["DryRun"] as? Bool
            if let spotFleetRequestIds = dictionary["SpotFleetRequestIds"] as? [String] {
                self.spotFleetRequestIds = spotFleetRequestIds
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeNetworkInterfacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Information about one or more network interfaces.
        public var networkInterfaces: [NetworkInterface]? = nil

        public init() {}

        public init(networkInterfaces: [NetworkInterface]? = nil) {
            self.networkInterfaces = networkInterfaces
        }

        public init(dictionary: [String: Any]) throws {
            if let networkInterfaces = dictionary["NetworkInterfaces"] as? [[String: Any]] {
                self.networkInterfaces = try networkInterfaces.map({ try NetworkInterface(dictionary: $0) })
            }
        }
    }

    public struct TargetConfigurationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Convertible Reserved Instance offering ID.
        public var offeringId: String = ""
        /// The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request
        public var instanceCount: Int32? = nil

        public init() {}

        public init(offeringId: String, instanceCount: Int32? = nil) {
            self.offeringId = offeringId
            self.instanceCount = instanceCount
        }

        public init(dictionary: [String: Any]) throws {
            guard let offeringId = dictionary["OfferingId"] as? String else { throw InitializableError.missingRequiredParam("OfferingId") }
            self.offeringId = offeringId
            self.instanceCount = dictionary["InstanceCount"] as? Int32
        }
    }

    public struct DescribeInstanceStatusResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// One or more instance status descriptions.
        public var instanceStatuses: [InstanceStatus]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(instanceStatuses: [InstanceStatus]? = nil, nextToken: String? = nil) {
            self.instanceStatuses = instanceStatuses
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let instanceStatuses = dictionary["InstanceStatuses"] as? [[String: Any]] {
                self.instanceStatuses = try instanceStatuses.map({ try InstanceStatus(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

}