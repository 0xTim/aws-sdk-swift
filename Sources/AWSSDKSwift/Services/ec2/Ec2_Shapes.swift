// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Ec2 {

    public struct DescribeVpcClassicLinkResult: Serializable, Initializable {
        /// The ClassicLink status of one or more VPCs.
        var vpcs: [VpcClassicLink]? = nil

        public init() {}

        public init(vpcs: [VpcClassicLink]? = nil) {
            self.vpcs = vpcs
        }

    }

    public struct GetConsoleScreenshotRequest: Serializable, Initializable {
        /// When set to true, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.
        var wakeUp: Bool? = nil
        /// The ID of the instance.
        var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(wakeUp: Bool? = nil, instanceId: String, dryRun: Bool? = nil) {
            self.wakeUp = wakeUp
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

    }

    public struct DescribeIamInstanceProfileAssociationsRequest: Serializable, Initializable {
        /// One or more IAM instance profile associations.
        var associationIds: [String]? = nil
        /// One or more filters.    instance-id - The ID of the instance.    state - The state of the association (associating | associated | disassociating | disassociated).  
        var filters: [Filter]? = nil
        /// The token to request the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(associationIds: [String]? = nil, filters: [Filter]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.associationIds = associationIds
            self.filters = filters
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DescribeInstanceAttributeRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the instance.
        var instanceId: String = ""
        /// The instance attribute. Note: The enaSupport attribute is not supported at this time.
        var attribute: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, instanceId: String, attribute: String) {
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.attribute = attribute
        }

    }

    public struct BlobAttributeValue: Serializable, Initializable {
        var value: Data? = nil

        public init() {}

        public init(value: Data? = nil) {
            self.value = value
        }

    }

    public struct ModifyVolumeAttributeRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Indicates whether the volume should be auto-enabled for I/O operations.
        var autoEnableIO: AttributeBooleanValue? = nil
        /// The ID of the volume.
        var volumeId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, autoEnableIO: AttributeBooleanValue? = nil, volumeId: String) {
            self.dryRun = dryRun
            self.autoEnableIO = autoEnableIO
            self.volumeId = volumeId
        }

    }

    public struct InternetGatewayAttachment: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// The current state of the attachment.
        var state: String? = nil

        public init() {}

        public init(vpcId: String? = nil, state: String? = nil) {
            self.vpcId = vpcId
            self.state = state
        }

    }

    public struct DescribeScheduledInstanceAvailabilityResult: Serializable, Initializable {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Information about the available Scheduled Instances.
        var scheduledInstanceAvailabilitySet: [ScheduledInstanceAvailability]? = nil

        public init() {}

        public init(nextToken: String? = nil, scheduledInstanceAvailabilitySet: [ScheduledInstanceAvailability]? = nil) {
            self.nextToken = nextToken
            self.scheduledInstanceAvailabilitySet = scheduledInstanceAvailabilitySet
        }

    }

    public struct DescribeAddressesResult: Serializable, Initializable {
        /// Information about one or more Elastic IP addresses.
        var addresses: [Address]? = nil

        public init() {}

        public init(addresses: [Address]? = nil) {
            self.addresses = addresses
        }

    }

    public struct DescribeNatGatewaysResult: Serializable, Initializable {
        /// Information about the NAT gateways.
        var natGateways: [NatGateway]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(natGateways: [NatGateway]? = nil, nextToken: String? = nil) {
            self.natGateways = natGateways
            self.nextToken = nextToken
        }

    }

    public struct CreateEgressOnlyInternetGatewayRequest: Serializable, Initializable {
        /// The ID of the VPC for which to create the egress-only Internet gateway.
        var vpcId: String = ""
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, clientToken: String? = nil, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.clientToken = clientToken
            self.dryRun = dryRun
        }

    }

    public struct ModifyVpcAttributeRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" will succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.
        var enableDnsSupport: AttributeBooleanValue? = nil
        /// Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.
        var enableDnsHostnames: AttributeBooleanValue? = nil

        public init() {}

        public init(vpcId: String, enableDnsSupport: AttributeBooleanValue? = nil, enableDnsHostnames: AttributeBooleanValue? = nil) {
            self.vpcId = vpcId
            self.enableDnsSupport = enableDnsSupport
            self.enableDnsHostnames = enableDnsHostnames
        }

    }

    public struct CreateVpcPeeringConnectionRequest: Serializable, Initializable {
        /// The AWS account ID of the owner of the peer VPC. Default: Your AWS account ID
        var peerOwnerId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the requester VPC.
        var vpcId: String? = nil
        /// The ID of the VPC with which you are creating the VPC peering connection.
        var peerVpcId: String? = nil

        public init() {}

        public init(peerOwnerId: String? = nil, dryRun: Bool? = nil, vpcId: String? = nil, peerVpcId: String? = nil) {
            self.peerOwnerId = peerOwnerId
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.peerVpcId = peerVpcId
        }

    }

    public struct Host: Serializable, Initializable {
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide. 
        var clientToken: String? = nil
        /// Whether auto-placement is on or off.
        var autoPlacement: String? = nil
        /// The ID of the Dedicated Host.
        var hostId: String? = nil
        /// The Dedicated Host's state.
        var state: String? = nil
        /// The number of new instances that can be launched onto the Dedicated Host.
        var availableCapacity: AvailableCapacity? = nil
        /// The reservation ID of the Dedicated Host. This returns a null response if the Dedicated Host doesn't have an associated reservation.
        var hostReservationId: String? = nil
        /// The IDs and instance type that are currently running on the Dedicated Host.
        var instances: [HostInstance]? = nil
        /// The hardware specifications of the Dedicated Host.
        var hostProperties: HostProperties? = nil
        /// The Availability Zone of the Dedicated Host.
        var availabilityZone: String? = nil

        public init() {}

        public init(clientToken: String? = nil, autoPlacement: String? = nil, hostId: String? = nil, state: String? = nil, availableCapacity: AvailableCapacity? = nil, hostReservationId: String? = nil, instances: [HostInstance]? = nil, hostProperties: HostProperties? = nil, availabilityZone: String? = nil) {
            self.clientToken = clientToken
            self.autoPlacement = autoPlacement
            self.hostId = hostId
            self.state = state
            self.availableCapacity = availableCapacity
            self.hostReservationId = hostReservationId
            self.instances = instances
            self.hostProperties = hostProperties
            self.availabilityZone = availabilityZone
        }

    }

    public struct TargetReservationValue: Serializable, Initializable {
        /// The configuration of the Convertible Reserved Instances that make up the exchange.
        var targetConfiguration: TargetConfiguration? = nil
        /// The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.
        var reservationValue: ReservationValue? = nil

        public init() {}

        public init(targetConfiguration: TargetConfiguration? = nil, reservationValue: ReservationValue? = nil) {
            self.targetConfiguration = targetConfiguration
            self.reservationValue = reservationValue
        }

    }

    public struct ImportKeyPairResult: Serializable, Initializable {
        /// The key pair name you provided.
        var keyName: String? = nil
        /// The MD5 public key fingerprint as specified in section 4 of RFC 4716.
        var keyFingerprint: String? = nil

        public init() {}

        public init(keyName: String? = nil, keyFingerprint: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
        }

    }

    public struct DescribeSnapshotsResult: Serializable, Initializable {
        /// The NextToken value to include in a future DescribeSnapshots request. When the results of a DescribeSnapshots request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Information about the snapshots.
        var snapshots: [Snapshot]? = nil

        public init() {}

        public init(nextToken: String? = nil, snapshots: [Snapshot]? = nil) {
            self.nextToken = nextToken
            self.snapshots = snapshots
        }

    }

    public struct DescribeInstanceStatusRequest: Serializable, Initializable {
        /// One or more filters.    availability-zone - The Availability Zone of the instance.    event.code - The code for the scheduled event (instance-reboot | system-reboot | system-maintenance | instance-retirement | instance-stop).    event.description - A description of the event.    event.not-after - The latest end time for the scheduled event (for example, 2014-09-15T17:15:20.000Z).    event.not-before - The earliest start time for the scheduled event (for example, 2014-09-15T17:15:20.000Z).    instance-state-code - The code for the instance state, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).    instance-state-name - The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).    instance-status.reachability - Filters on instance status where the name is reachability (passed | failed | initializing | insufficient-data).    instance-status.status - The status of the instance (ok | impaired | initializing | insufficient-data | not-applicable).    system-status.reachability - Filters on system status where the name is reachability (passed | failed | initializing | insufficient-data).    system-status.status - The system status of the instance (ok | impaired | initializing | insufficient-data | not-applicable).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// When true, includes the health status for all instances. When false, includes the health status for running instances only. Default: false 
        var includeAllInstances: Bool? = nil
        /// One or more instance IDs. Default: Describes all your instances. Constraints: Maximum 100 explicitly specified instance IDs.
        var instanceIds: [String]? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, includeAllInstances: Bool? = nil, instanceIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.includeAllInstances = includeAllInstances
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct VolumeStatusItem: Serializable, Initializable {
        /// The details of the operation.
        var actions: [VolumeStatusAction]? = nil
        /// A list of events associated with the volume.
        var events: [VolumeStatusEvent]? = nil
        /// The volume status.
        var volumeStatus: VolumeStatusInfo? = nil
        /// The Availability Zone of the volume.
        var availabilityZone: String? = nil
        /// The volume ID.
        var volumeId: String? = nil

        public init() {}

        public init(actions: [VolumeStatusAction]? = nil, events: [VolumeStatusEvent]? = nil, volumeStatus: VolumeStatusInfo? = nil, availabilityZone: String? = nil, volumeId: String? = nil) {
            self.actions = actions
            self.events = events
            self.volumeStatus = volumeStatus
            self.availabilityZone = availabilityZone
            self.volumeId = volumeId
        }

    }

    public struct CreateRouteTableResult: Serializable, Initializable {
        /// Information about the route table.
        var routeTable: RouteTable? = nil

        public init() {}

        public init(routeTable: RouteTable? = nil) {
            self.routeTable = routeTable
        }

    }

    public struct EnableVpcClassicLinkRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

    }

    public struct InstanceNetworkInterface: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The MAC address.
        var macAddress: String? = nil
        /// Indicates whether to validate network traffic to or from this network interface.
        var sourceDestCheck: Bool? = nil
        /// The private DNS name.
        var privateDnsName: String? = nil
        /// The ID of the AWS account that created the network interface.
        var ownerId: String? = nil
        /// The network interface attachment.
        var attachment: InstanceNetworkInterfaceAttachment? = nil
        /// The description.
        var description: String? = nil
        /// The IPv4 address of the network interface within the subnet.
        var privateIpAddress: String? = nil
        /// The status of the network interface.
        var status: String? = nil
        /// One or more private IPv4 addresses associated with the network interface.
        var privateIpAddresses: [InstancePrivateIpAddress]? = nil
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// One or more IPv6 addresses associated with the network interface.
        var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// One or more security groups.
        var groups: [GroupIdentifier]? = nil
        /// The association information for an Elastic IPv4 associated with the network interface.
        var association: InstanceNetworkInterfaceAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, networkInterfaceId: String? = nil, macAddress: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, ownerId: String? = nil, attachment: InstanceNetworkInterfaceAttachment? = nil, description: String? = nil, privateIpAddress: String? = nil, status: String? = nil, privateIpAddresses: [InstancePrivateIpAddress]? = nil, vpcId: String? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, groups: [GroupIdentifier]? = nil, association: InstanceNetworkInterfaceAssociation? = nil) {
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.macAddress = macAddress
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.ownerId = ownerId
            self.attachment = attachment
            self.description = description
            self.privateIpAddress = privateIpAddress
            self.status = status
            self.privateIpAddresses = privateIpAddresses
            self.vpcId = vpcId
            self.ipv6Addresses = ipv6Addresses
            self.groups = groups
            self.association = association
        }

    }

    public struct CreateNetworkInterfaceResult: Serializable, Initializable {
        /// Information about the network interface.
        var networkInterface: NetworkInterface? = nil

        public init() {}

        public init(networkInterface: NetworkInterface? = nil) {
            self.networkInterface = networkInterface
        }

    }

    public struct ResetInstanceAttributeRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the instance.
        var instanceId: String = ""
        /// The attribute to reset.  You can only reset the following attributes: kernel | ramdisk | sourceDestCheck. To change an instance attribute, use ModifyInstanceAttribute. 
        var attribute: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, instanceId: String, attribute: String) {
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.attribute = attribute
        }

    }

    public struct Monitoring: Serializable, Initializable {
        /// Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
        var state: String? = nil

        public init() {}

        public init(state: String? = nil) {
            self.state = state
        }

    }

    public struct RequestSpotLaunchSpecification: Serializable, Initializable {
        /// One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instance.
        var subnetId: String? = nil
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var userData: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        var ebsOptimized: Bool? = nil
        var securityGroupIds: [String]? = nil
        /// The ID of the kernel.
        var kernelId: String? = nil
        var monitoring: RunInstancesMonitoringEnabled? = nil
        /// The instance type.
        var instanceType: String? = nil
        var securityGroups: [String]? = nil
        /// The name of the key pair.
        var keyName: String? = nil
        /// Deprecated.
        var addressingType: String? = nil
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// The ID of the AMI.
        var imageId: String? = nil
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The placement information for the instance.
        var placement: SpotPlacement? = nil
        /// The ID of the RAM disk.
        var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, securityGroupIds: [String]? = nil, kernelId: String? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, instanceType: String? = nil, securityGroups: [String]? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.securityGroupIds = securityGroupIds
            self.kernelId = kernelId
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

    }

    public struct AssociateVpcCidrBlockRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
        var amazonProvidedIpv6CidrBlock: Bool? = nil

        public init() {}

        public init(vpcId: String, amazonProvidedIpv6CidrBlock: Bool? = nil) {
            self.vpcId = vpcId
            self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
        }

    }

    public struct ImageDiskContainer: Serializable, Initializable {
        /// The S3 bucket for the disk image.
        var userBucket: UserBucket? = nil
        /// The format of the disk image being imported. Valid values: RAW | VHD | VMDK | OVA 
        var format: String? = nil
        /// The ID of the EBS snapshot to be used for importing the snapshot.
        var snapshotId: String? = nil
        /// The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)
        var url: String? = nil
        /// The block device mapping for the disk.
        var deviceName: String? = nil
        /// The description of the disk image.
        var description: String? = nil

        public init() {}

        public init(userBucket: UserBucket? = nil, format: String? = nil, snapshotId: String? = nil, url: String? = nil, deviceName: String? = nil, description: String? = nil) {
            self.userBucket = userBucket
            self.format = format
            self.snapshotId = snapshotId
            self.url = url
            self.deviceName = deviceName
            self.description = description
        }

    }

    public struct PurchaseReservedInstancesOfferingRequest: Serializable, Initializable {
        /// The ID of the Reserved Instance offering to purchase.
        var reservedInstancesOfferingId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The number of Reserved Instances to purchase.
        var instanceCount: Int32 = 0
        /// Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.
        var limitPrice: ReservedInstanceLimitPrice? = nil

        public init() {}

        public init(reservedInstancesOfferingId: String, dryRun: Bool? = nil, instanceCount: Int32, limitPrice: ReservedInstanceLimitPrice? = nil) {
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.dryRun = dryRun
            self.instanceCount = instanceCount
            self.limitPrice = limitPrice
        }

    }

    public struct ReservedInstances: Serializable, Initializable {
        /// The recurring charge tag assigned to the resource.
        var recurringCharges: [RecurringCharge]? = nil
        /// The usage price of the Reserved Instance, per hour.
        var usagePrice: Float? = nil
        /// The state of the Reserved Instance purchase.
        var state: String? = nil
        /// The tenancy of the instance.
        var instanceTenancy: String? = nil
        /// Any tags assigned to the resource.
        var tags: [Tag]? = nil
        /// The instance type on which the Reserved Instance can be used.
        var instanceType: String? = nil
        /// The Reserved Instance offering type.
        var offeringType: String? = nil
        /// The Reserved Instance product platform description.
        var productDescription: String? = nil
        /// The Availability Zone in which the Reserved Instance can be used.
        var availabilityZone: String? = nil
        /// The offering class of the Reserved Instance.
        var offeringClass: String? = nil
        /// The date and time the Reserved Instance started.
        var start: Date? = nil
        /// The time when the Reserved Instance expires.
        var end: Date? = nil
        /// The ID of the Reserved Instance.
        var reservedInstancesId: String? = nil
        /// The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The number of reservations purchased.
        var instanceCount: Int32? = nil
        /// The duration of the Reserved Instance, in seconds.
        var duration: Int64? = nil
        /// The scope of the Reserved Instance.
        var scope: String? = nil
        /// The purchase price of the Reserved Instance.
        var fixedPrice: Float? = nil

        public init() {}

        public init(recurringCharges: [RecurringCharge]? = nil, usagePrice: Float? = nil, state: String? = nil, instanceTenancy: String? = nil, tags: [Tag]? = nil, instanceType: String? = nil, offeringType: String? = nil, productDescription: String? = nil, availabilityZone: String? = nil, offeringClass: String? = nil, start: Date? = nil, end: Date? = nil, reservedInstancesId: String? = nil, currencyCode: String? = nil, instanceCount: Int32? = nil, duration: Int64? = nil, scope: String? = nil, fixedPrice: Float? = nil) {
            self.recurringCharges = recurringCharges
            self.usagePrice = usagePrice
            self.state = state
            self.instanceTenancy = instanceTenancy
            self.tags = tags
            self.instanceType = instanceType
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.availabilityZone = availabilityZone
            self.offeringClass = offeringClass
            self.start = start
            self.end = end
            self.reservedInstancesId = reservedInstancesId
            self.currencyCode = currencyCode
            self.instanceCount = instanceCount
            self.duration = duration
            self.scope = scope
            self.fixedPrice = fixedPrice
        }

    }

    public struct NetworkInterfaceIpv6Address: Serializable, Initializable {
        /// The IPv6 address.
        var ipv6Address: String? = nil

        public init() {}

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

    }

    public struct DescribeCustomerGatewaysRequest: Serializable, Initializable {
        /// One or more customer gateway IDs. Default: Describes all your customer gateways.
        var customerGatewayIds: [String]? = nil
        /// One or more filters.    bgp-asn - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).    customer-gateway-id - The ID of the customer gateway.    ip-address - The IP address of the customer gateway's Internet-routable external interface.    state - The state of the customer gateway (pending | available | deleting | deleted).    type - The type of customer gateway. Currently, the only supported type is ipsec.1.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(customerGatewayIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.customerGatewayIds = customerGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct NetworkInterface: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The MAC address.
        var macAddress: String? = nil
        /// Indicates whether traffic to or from the instance is validated.
        var sourceDestCheck: Bool? = nil
        /// The private DNS name.
        var privateDnsName: String? = nil
        /// The network interface attachment.
        var attachment: NetworkInterfaceAttachment? = nil
        /// The type of interface.
        var interfaceType: String? = nil
        /// Any tags assigned to the network interface.
        var tagSet: [Tag]? = nil
        /// The AWS account ID of the owner of the network interface.
        var ownerId: String? = nil
        /// The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).
        var requesterId: String? = nil
        /// The IPv4 address of the network interface within the subnet.
        var privateIpAddress: String? = nil
        /// A description.
        var description: String? = nil
        /// The private IPv4 addresses associated with the network interface.
        var privateIpAddresses: [NetworkInterfacePrivateIpAddress]? = nil
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// The Availability Zone.
        var availabilityZone: String? = nil
        /// The status of the network interface.
        var status: String? = nil
        /// Indicates whether the network interface is being managed by AWS.
        var requesterManaged: Bool? = nil
        /// The IPv6 addresses associated with the network interface.
        var ipv6Addresses: [NetworkInterfaceIpv6Address]? = nil
        /// Any security groups for the network interface.
        var groups: [GroupIdentifier]? = nil
        /// The association information for an Elastic IP address (IPv4) associated with the network interface.
        var association: NetworkInterfaceAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, networkInterfaceId: String? = nil, macAddress: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, attachment: NetworkInterfaceAttachment? = nil, interfaceType: String? = nil, tagSet: [Tag]? = nil, ownerId: String? = nil, requesterId: String? = nil, privateIpAddress: String? = nil, description: String? = nil, privateIpAddresses: [NetworkInterfacePrivateIpAddress]? = nil, vpcId: String? = nil, availabilityZone: String? = nil, status: String? = nil, requesterManaged: Bool? = nil, ipv6Addresses: [NetworkInterfaceIpv6Address]? = nil, groups: [GroupIdentifier]? = nil, association: NetworkInterfaceAssociation? = nil) {
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.macAddress = macAddress
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.attachment = attachment
            self.interfaceType = interfaceType
            self.tagSet = tagSet
            self.ownerId = ownerId
            self.requesterId = requesterId
            self.privateIpAddress = privateIpAddress
            self.description = description
            self.privateIpAddresses = privateIpAddresses
            self.vpcId = vpcId
            self.availabilityZone = availabilityZone
            self.status = status
            self.requesterManaged = requesterManaged
            self.ipv6Addresses = ipv6Addresses
            self.groups = groups
            self.association = association
        }

    }

    public struct Subnet: Serializable, Initializable {
        /// Indicates whether instances launched in this subnet receive a public IPv4 address.
        var mapPublicIpOnLaunch: Bool? = nil
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// Indicates whether this is the default subnet for the Availability Zone.
        var defaultForAz: Bool? = nil
        /// The ID of the VPC the subnet is in.
        var vpcId: String? = nil
        /// The current state of the subnet.
        var state: String? = nil
        /// Any tags assigned to the subnet.
        var tags: [Tag]? = nil
        /// Indicates whether a network interface created in this subnet (including a network interface created by RunInstances) receives an IPv6 address.
        var assignIpv6AddressOnCreation: Bool? = nil
        /// Information about the IPv6 CIDR blocks associated with the subnet.
        var ipv6CidrBlockAssociationSet: [SubnetIpv6CidrBlockAssociation]? = nil
        /// The number of unused private IPv4 addresses in the subnet. Note that the IPv4 addresses for any stopped instances are considered unavailable.
        var availableIpAddressCount: Int32? = nil
        /// The Availability Zone of the subnet.
        var availabilityZone: String? = nil
        /// The IPv4 CIDR block assigned to the subnet.
        var cidrBlock: String? = nil

        public init() {}

        public init(mapPublicIpOnLaunch: Bool? = nil, subnetId: String? = nil, defaultForAz: Bool? = nil, vpcId: String? = nil, state: String? = nil, tags: [Tag]? = nil, assignIpv6AddressOnCreation: Bool? = nil, ipv6CidrBlockAssociationSet: [SubnetIpv6CidrBlockAssociation]? = nil, availableIpAddressCount: Int32? = nil, availabilityZone: String? = nil, cidrBlock: String? = nil) {
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.subnetId = subnetId
            self.defaultForAz = defaultForAz
            self.vpcId = vpcId
            self.state = state
            self.tags = tags
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.availableIpAddressCount = availableIpAddressCount
            self.availabilityZone = availabilityZone
            self.cidrBlock = cidrBlock
        }

    }

    public struct CancelSpotInstanceRequestsResult: Serializable, Initializable {
        /// One or more Spot instance requests.
        var cancelledSpotInstanceRequests: [CancelledSpotInstanceRequest]? = nil

        public init() {}

        public init(cancelledSpotInstanceRequests: [CancelledSpotInstanceRequest]? = nil) {
            self.cancelledSpotInstanceRequests = cancelledSpotInstanceRequests
        }

    }

    public struct EnableVolumeIORequest: Serializable, Initializable {
        /// The ID of the volume.
        var volumeId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(volumeId: String, dryRun: Bool? = nil) {
            self.volumeId = volumeId
            self.dryRun = dryRun
        }

    }

    public struct AssociateSubnetCidrBlockResult: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// Information about the IPv6 CIDR block association.
        var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil) {
            self.subnetId = subnetId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

    }

    public struct EventInformation: Serializable, Initializable {
        /// The event. The following are the error events.    iamFleetRoleInvalid - The Spot fleet did not have the required permissions either to launch or terminate an instance.    launchSpecTemporarilyBlacklisted - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.    spotFleetRequestConfigurationInvalid - The configuration is not valid. For more information, see the description of the event.    spotInstanceCountLimitExceeded - You've reached the limit on the number of Spot instances that you can launch.   The following are the fleetRequestChange events.    active - The Spot fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot instances.    cancelled - The Spot fleet is canceled and has no running Spot instances. The Spot fleet will be deleted two days after its instances were terminated.    cancelled_running - The Spot fleet is canceled and will not launch additional Spot instances, but its existing Spot instances continue to run until they are interrupted or terminated.    cancelled_terminating - The Spot fleet is canceled and its Spot instances are terminating.    expired - The Spot fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with TerminateInstancesWithExpiration set.    modify_in_progress - A request to modify the Spot fleet request was accepted and is in progress.    modify_successful - The Spot fleet request was modified.    price_update - The bid price for a launch configuration was adjusted because it was too high. This change is permanent.    submitted - The Spot fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot instances.   The following are the instanceChange events.    launched - A bid was fulfilled and a new instance was launched.    terminated - An instance was terminated by the user.  
        var eventSubType: String? = nil
        /// The ID of the instance. This information is available only for instanceChange events.
        var instanceId: String? = nil
        /// The description of the event.
        var eventDescription: String? = nil

        public init() {}

        public init(eventSubType: String? = nil, instanceId: String? = nil, eventDescription: String? = nil) {
            self.eventSubType = eventSubType
            self.instanceId = instanceId
            self.eventDescription = eventDescription
        }

    }

    public struct DescribeSubnetsRequest: Serializable, Initializable {
        /// One or more subnet IDs. Default: Describes all your subnets.
        var subnetIds: [String]? = nil
        /// One or more filters.    availabilityZone - The Availability Zone for the subnet. You can also use availability-zone as the filter name.    available-ip-address-count - The number of IPv4 addresses in the subnet that are available.    cidrBlock - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use cidr or cidr-block as the filter names.    defaultForAz - Indicates whether this is the default subnet for the Availability Zone. You can also use default-for-az as the filter name.    ipv6-cidr-block-association.ipv6-cidr-block - An IPv6 CIDR block associated with the subnet.    ipv6-cidr-block-association.association-id - An association ID for an IPv6 CIDR block associated with the subnet.    ipv6-cidr-block-association.state - The state of an IPv6 CIDR block associated with the subnet.    state - The state of the subnet (pending | available).    subnet-id - The ID of the subnet.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the subnet.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(subnetIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.subnetIds = subnetIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct DescribeTagsResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return..
        var nextToken: String? = nil
        /// A list of tags.
        var tags: [TagDescription]? = nil

        public init() {}

        public init(nextToken: String? = nil, tags: [TagDescription]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

    }

    public struct AcceptReservedInstancesExchangeQuoteResult: Serializable, Initializable {
        /// The ID of the successful exchange.
        var exchangeId: String? = nil

        public init() {}

        public init(exchangeId: String? = nil) {
            self.exchangeId = exchangeId
        }

    }

    public struct DescribeNatGatewaysRequest: Serializable, Initializable {
        /// One or more filters.    nat-gateway-id - The ID of the NAT gateway.    state - The state of the NAT gateway (pending | failed | available | deleting | deleted).    subnet-id - The ID of the subnet in which the NAT gateway resides.    vpc-id - The ID of the VPC in which the NAT gateway resides.  
        var filter: [Filter]? = nil
        /// One or more NAT gateway IDs.
        var natGatewayIds: [String]? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value specified is greater than 1000, we return only 1000 items.
        var maxResults: Int32? = nil

        public init() {}

        public init(filter: [Filter]? = nil, natGatewayIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.natGatewayIds = natGatewayIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct NetworkInterfacePrivateIpAddress: Serializable, Initializable {
        /// The private IPv4 address.
        var privateIpAddress: String? = nil
        /// The private DNS name.
        var privateDnsName: String? = nil
        /// Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.
        var primary: Bool? = nil
        /// The association information for an Elastic IP address (IPv4) associated with the network interface.
        var association: NetworkInterfaceAssociation? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, privateDnsName: String? = nil, primary: Bool? = nil, association: NetworkInterfaceAssociation? = nil) {
            self.privateIpAddress = privateIpAddress
            self.privateDnsName = privateDnsName
            self.primary = primary
            self.association = association
        }

    }

    public struct DescribeNetworkAclsResult: Serializable, Initializable {
        /// Information about one or more network ACLs.
        var networkAcls: [NetworkAcl]? = nil

        public init() {}

        public init(networkAcls: [NetworkAcl]? = nil) {
            self.networkAcls = networkAcls
        }

    }

    public struct ReservedInstancesListing: Serializable, Initializable {
        /// The status of the Reserved Instance listing.
        var status: String? = nil
        /// The price of the Reserved Instance listing.
        var priceSchedules: [PriceSchedule]? = nil
        /// The ID of the Reserved Instance listing.
        var reservedInstancesListingId: String? = nil
        /// A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see Ensuring Idempotency.
        var clientToken: String? = nil
        /// Any tags assigned to the resource.
        var tags: [Tag]? = nil
        /// The last modified timestamp of the listing.
        var updateDate: Date? = nil
        /// The ID of the Reserved Instance.
        var reservedInstancesId: String? = nil
        /// The time the listing was created.
        var createDate: Date? = nil
        /// The reason for the current status of the Reserved Instance listing. The response can be blank.
        var statusMessage: String? = nil
        /// The number of instances in this state.
        var instanceCounts: [InstanceCount]? = nil

        public init() {}

        public init(status: String? = nil, priceSchedules: [PriceSchedule]? = nil, reservedInstancesListingId: String? = nil, clientToken: String? = nil, tags: [Tag]? = nil, updateDate: Date? = nil, reservedInstancesId: String? = nil, createDate: Date? = nil, statusMessage: String? = nil, instanceCounts: [InstanceCount]? = nil) {
            self.status = status
            self.priceSchedules = priceSchedules
            self.reservedInstancesListingId = reservedInstancesListingId
            self.clientToken = clientToken
            self.tags = tags
            self.updateDate = updateDate
            self.reservedInstancesId = reservedInstancesId
            self.createDate = createDate
            self.statusMessage = statusMessage
            self.instanceCounts = instanceCounts
        }

    }

    public struct DeleteNetworkAclRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the network ACL.
        var networkAclId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, networkAclId: String) {
            self.dryRun = dryRun
            self.networkAclId = networkAclId
        }

    }

    public struct AllocateHostsRequest: Serializable, Initializable {
        /// This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID. Default: Enabled
        var autoPlacement: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide. 
        var clientToken: String? = nil
        /// Specify the instance type that you want your Dedicated Hosts to be configured for. When you specify the instance type, that is the only instance type that you can launch onto that host.
        var instanceType: String = ""
        /// The Availability Zone for the Dedicated Hosts.
        var availabilityZone: String = ""
        /// The number of Dedicated Hosts you want to allocate to your account with these parameters.
        var quantity: Int32 = 0

        public init() {}

        public init(autoPlacement: String? = nil, clientToken: String? = nil, instanceType: String, availabilityZone: String, quantity: Int32) {
            self.autoPlacement = autoPlacement
            self.clientToken = clientToken
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.quantity = quantity
        }

    }

    public struct DescribeVpcEndpointServicesRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value is greater than 1000, we return only 1000 items.
        var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct UnassignIpv6AddressesRequest: Serializable, Initializable {
        /// The IPv6 addresses to unassign from the network interface.
        var ipv6Addresses: [String] = []
        /// The ID of the network interface.
        var networkInterfaceId: String = ""

        public init() {}

        public init(ipv6Addresses: [String], networkInterfaceId: String) {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

    }

    public struct BundleInstanceResult: Serializable, Initializable {
        /// Information about the bundle task.
        var bundleTask: BundleTask? = nil

        public init() {}

        public init(bundleTask: BundleTask? = nil) {
            self.bundleTask = bundleTask
        }

    }

    public struct DeletePlacementGroupRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The name of the placement group.
        var groupName: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, groupName: String) {
            self.dryRun = dryRun
            self.groupName = groupName
        }

    }

    public struct PrefixListId: Serializable, Initializable {
        /// The ID of the prefix.
        var prefixListId: String? = nil

        public init() {}

        public init(prefixListId: String? = nil) {
            self.prefixListId = prefixListId
        }

    }

    public struct PeeringConnectionOptionsRequest: Serializable, Initializable {
        /// If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.
        var allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil
        /// If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        var allowDnsResolutionFromRemoteVpc: Bool? = nil
        /// If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.
        var allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil

        public init() {}

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

    }

    public struct AccountAttributeValue: Serializable, Initializable {
        /// The value of the attribute.
        var attributeValue: String? = nil

        public init() {}

        public init(attributeValue: String? = nil) {
            self.attributeValue = attributeValue
        }

    }

    public struct PurchaseScheduledInstancesRequest: Serializable, Initializable {
        /// One or more purchase requests.
        var purchaseRequests: [PurchaseRequest] = []
        /// Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see Ensuring Idempotency.
        var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(purchaseRequests: [PurchaseRequest], clientToken: String? = nil, dryRun: Bool? = nil) {
            self.purchaseRequests = purchaseRequests
            self.clientToken = clientToken
            self.dryRun = dryRun
        }

    }

    public struct DescribeHostReservationOfferingsRequest: Serializable, Initializable {
        /// This is the maximum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.
        var maxDuration: Int32? = nil
        /// This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.
        var minDuration: Int32? = nil
        /// One or more filters.    instance-family - The instance family of the offering (e.g., m4).    payment-option - The payment option (NoUpfront | PartialUpfront | AllUpfront).  
        var filter: [Filter]? = nil
        /// The token to use to retrieve the next page of results.
        var nextToken: String? = nil
        /// The ID of the reservation offering.
        var offeringId: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error.
        var maxResults: Int32? = nil

        public init() {}

        public init(maxDuration: Int32? = nil, minDuration: Int32? = nil, filter: [Filter]? = nil, nextToken: String? = nil, offeringId: String? = nil, maxResults: Int32? = nil) {
            self.maxDuration = maxDuration
            self.minDuration = minDuration
            self.filter = filter
            self.nextToken = nextToken
            self.offeringId = offeringId
            self.maxResults = maxResults
        }

    }

    public struct StopInstancesResult: Serializable, Initializable {
        /// Information about one or more stopped instances.
        var stoppingInstances: [InstanceStateChange]? = nil

        public init() {}

        public init(stoppingInstances: [InstanceStateChange]? = nil) {
            self.stoppingInstances = stoppingInstances
        }

    }

    public struct DescribeScheduledInstanceAvailabilityRequest: Serializable, Initializable {
        /// The time period for the first schedule to start.
        var firstSlotStartTimeRange: SlotDateTimeRangeRequest = SlotDateTimeRangeRequest()
        /// The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.
        var minSlotDurationInHours: Int32? = nil
        /// The maximum available duration, in hours. This value must be greater than MinSlotDurationInHours and less than 1,720.
        var maxSlotDurationInHours: Int32? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    availability-zone - The Availability Zone (for example, us-west-2a).    instance-type - The instance type (for example, c4.large).    network-platform - The network platform (EC2-Classic or EC2-VPC).    platform - The platform (Linux/UNIX or Windows).  
        var filters: [Filter]? = nil
        /// The token for the next set of results.
        var nextToken: String? = nil
        /// The schedule recurrence.
        var recurrence: ScheduledInstanceRecurrenceRequest = ScheduledInstanceRecurrenceRequest()
        /// The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(firstSlotStartTimeRange: SlotDateTimeRangeRequest, minSlotDurationInHours: Int32? = nil, maxSlotDurationInHours: Int32? = nil, dryRun: Bool? = nil, filters: [Filter]? = nil, nextToken: String? = nil, recurrence: ScheduledInstanceRecurrenceRequest, maxResults: Int32? = nil) {
            self.firstSlotStartTimeRange = firstSlotStartTimeRange
            self.minSlotDurationInHours = minSlotDurationInHours
            self.maxSlotDurationInHours = maxSlotDurationInHours
            self.dryRun = dryRun
            self.filters = filters
            self.nextToken = nextToken
            self.recurrence = recurrence
            self.maxResults = maxResults
        }

    }

    public struct ReservedInstancesModificationResult: Serializable, Initializable {
        /// The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.
        var reservedInstancesId: String? = nil
        /// The target Reserved Instances configurations supplied as part of the modification request.
        var targetConfiguration: ReservedInstancesConfiguration? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil, targetConfiguration: ReservedInstancesConfiguration? = nil) {
            self.reservedInstancesId = reservedInstancesId
            self.targetConfiguration = targetConfiguration
        }

    }

    public struct EnableVpcClassicLinkDnsSupportResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct ImportVolumeRequest: Serializable, Initializable {
        /// The disk image.
        var image: DiskImageDetail = DiskImageDetail()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The volume size.
        var volume: VolumeDetail = VolumeDetail()
        /// The Availability Zone for the resulting EBS volume.
        var availabilityZone: String = ""
        /// A description of the volume.
        var description: String? = nil

        public init() {}

        public init(image: DiskImageDetail, dryRun: Bool? = nil, volume: VolumeDetail, availabilityZone: String, description: String? = nil) {
            self.image = image
            self.dryRun = dryRun
            self.volume = volume
            self.availabilityZone = availabilityZone
            self.description = description
        }

    }

    public struct DescribeAddressesRequest: Serializable, Initializable {
        /// [EC2-Classic] One or more Elastic IP addresses. Default: Describes all your Elastic IP addresses.
        var publicIps: [String]? = nil
        /// [EC2-VPC] One or more allocation IDs. Default: Describes all your Elastic IP addresses.
        var allocationIds: [String]? = nil
        /// One or more filters. Filter names and values are case-sensitive.    allocation-id - [EC2-VPC] The allocation ID for the address.    association-id - [EC2-VPC] The association ID for the address.    domain - Indicates whether the address is for use in EC2-Classic (standard) or in a VPC (vpc).    instance-id - The ID of the instance the address is associated with, if any.    network-interface-id - [EC2-VPC] The ID of the network interface that the address is associated with, if any.    network-interface-owner-id - The AWS account ID of the owner.    private-ip-address - [EC2-VPC] The private IP address associated with the Elastic IP address.    public-ip - The Elastic IP address.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(publicIps: [String]? = nil, allocationIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.publicIps = publicIps
            self.allocationIds = allocationIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct Ipv6CidrBlock: Serializable, Initializable {
        /// The IPv6 CIDR block.
        var ipv6CidrBlock: String? = nil

        public init() {}

        public init(ipv6CidrBlock: String? = nil) {
            self.ipv6CidrBlock = ipv6CidrBlock
        }

    }

    public struct SecurityGroup: Serializable, Initializable {
        /// [EC2-VPC] One or more outbound rules associated with the security group.
        var ipPermissionsEgress: [IpPermission]? = nil
        /// The name of the security group.
        var groupName: String? = nil
        /// [EC2-VPC] The ID of the VPC for the security group.
        var vpcId: String? = nil
        /// One or more inbound rules associated with the security group.
        var ipPermissions: [IpPermission]? = nil
        /// Any tags assigned to the security group.
        var tags: [Tag]? = nil
        /// The AWS account ID of the owner of the security group.
        var ownerId: String? = nil
        /// The ID of the security group.
        var groupId: String? = nil
        /// A description of the security group.
        var description: String? = nil

        public init() {}

        public init(ipPermissionsEgress: [IpPermission]? = nil, groupName: String? = nil, vpcId: String? = nil, ipPermissions: [IpPermission]? = nil, tags: [Tag]? = nil, ownerId: String? = nil, groupId: String? = nil, description: String? = nil) {
            self.ipPermissionsEgress = ipPermissionsEgress
            self.groupName = groupName
            self.vpcId = vpcId
            self.ipPermissions = ipPermissions
            self.tags = tags
            self.ownerId = ownerId
            self.groupId = groupId
            self.description = description
        }

    }

    public struct DescribeAccountAttributesResult: Serializable, Initializable {
        /// Information about one or more account attributes.
        var accountAttributes: [AccountAttribute]? = nil

        public init() {}

        public init(accountAttributes: [AccountAttribute]? = nil) {
            self.accountAttributes = accountAttributes
        }

    }

    public struct ReplaceRouteRequest: Serializable, Initializable {
        /// [IPv4 traffic only] The ID of a NAT gateway.
        var natGatewayId: String? = nil
        /// The ID of a network interface.
        var networkInterfaceId: String? = nil
        /// The ID of a NAT instance in your VPC.
        var instanceId: String? = nil
        /// The IPv6 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.
        var destinationIpv6CidrBlock: String? = nil
        /// The ID of a VPC peering connection.
        var vpcPeeringConnectionId: String? = nil
        /// The ID of the route table.
        var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// [IPv6 traffic only] The ID of an egress-only Internet gateway.
        var egressOnlyInternetGatewayId: String? = nil
        /// The ID of an Internet gateway or virtual private gateway.
        var gatewayId: String? = nil
        /// The IPv4 CIDR address block used for the destination match. The value you provide must match the CIDR of an existing route in the table.
        var destinationCidrBlock: String? = nil

        public init() {}

        public init(natGatewayId: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, destinationIpv6CidrBlock: String? = nil, vpcPeeringConnectionId: String? = nil, routeTableId: String, dryRun: Bool? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

    }

    public struct CreateRouteRequest: Serializable, Initializable {
        /// [IPv4 traffic only] The ID of a NAT gateway.
        var natGatewayId: String? = nil
        /// The ID of a network interface.
        var networkInterfaceId: String? = nil
        /// The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        var instanceId: String? = nil
        /// The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.
        var destinationIpv6CidrBlock: String? = nil
        /// The ID of a VPC peering connection.
        var vpcPeeringConnectionId: String? = nil
        /// The ID of the route table for the route.
        var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// [IPv6 traffic only] The ID of an egress-only Internet gateway.
        var egressOnlyInternetGatewayId: String? = nil
        /// The ID of an Internet gateway or virtual private gateway attached to your VPC.
        var gatewayId: String? = nil
        /// The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.
        var destinationCidrBlock: String? = nil

        public init() {}

        public init(natGatewayId: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, destinationIpv6CidrBlock: String? = nil, vpcPeeringConnectionId: String? = nil, routeTableId: String, dryRun: Bool? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

    }

    public struct DeleteVpnConnectionRouteRequest: Serializable, Initializable {
        /// The ID of the VPN connection.
        var vpnConnectionId: String = ""
        /// The CIDR block associated with the local subnet of the customer network.
        var destinationCidrBlock: String = ""

        public init() {}

        public init(vpnConnectionId: String, destinationCidrBlock: String) {
            self.vpnConnectionId = vpnConnectionId
            self.destinationCidrBlock = destinationCidrBlock
        }

    }

    public struct KeyPairInfo: Serializable, Initializable {
        /// The name of the key pair.
        var keyName: String? = nil
        /// If you used CreateKeyPair to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used ImportKeyPair to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.
        var keyFingerprint: String? = nil

        public init() {}

        public init(keyName: String? = nil, keyFingerprint: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
        }

    }

    public struct VolumeAttachment: Serializable, Initializable {
        /// The time stamp when the attachment initiated.
        var attachTime: Date? = nil
        /// Indicates whether the EBS volume is deleted on instance termination.
        var deleteOnTermination: Bool? = nil
        /// The device name.
        var device: String? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The ID of the volume.
        var volumeId: String? = nil
        /// The attachment state of the volume.
        var state: String? = nil

        public init() {}

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, device: String? = nil, instanceId: String? = nil, volumeId: String? = nil, state: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.device = device
            self.instanceId = instanceId
            self.volumeId = volumeId
            self.state = state
        }

    }

    public struct ImportSnapshotTask: Serializable, Initializable {
        /// A description of the import snapshot task.
        var description: String? = nil
        /// Describes an import snapshot task.
        var snapshotTaskDetail: SnapshotTaskDetail? = nil
        /// The ID of the import snapshot task.
        var importTaskId: String? = nil

        public init() {}

        public init(description: String? = nil, snapshotTaskDetail: SnapshotTaskDetail? = nil, importTaskId: String? = nil) {
            self.description = description
            self.snapshotTaskDetail = snapshotTaskDetail
            self.importTaskId = importTaskId
        }

    }

    public struct CreateNatGatewayRequest: Serializable, Initializable {
        /// The subnet in which to create the NAT gateway.
        var subnetId: String = ""
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency. Constraint: Maximum 64 ASCII characters.
        var clientToken: String? = nil
        /// The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.
        var allocationId: String = ""

        public init() {}

        public init(subnetId: String, clientToken: String? = nil, allocationId: String) {
            self.subnetId = subnetId
            self.clientToken = clientToken
            self.allocationId = allocationId
        }

    }

    public struct AttachVpnGatewayResult: Serializable, Initializable {
        /// Information about the attachment.
        var vpcAttachment: VpcAttachment? = nil

        public init() {}

        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

    }

    public struct RequestSpotInstancesRequest: Serializable, Initializable {
        /// The required duration for the Spot instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360). The duration period starts as soon as your Spot instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates. Note that you can't specify an Availability Zone group or a launch group if you specify a duration.
        var blockDurationMinutes: Int32? = nil
        /// The user-specified name for a logical grouping of bids. When you specify an Availability Zone group in a Spot Instance request, all Spot instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to bids for Spot Instances of the same instance type. Any additional Spot instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active. If there is no active instance running in the Availability Zone group that you specify for a new Spot instance request (all instances are terminated, the bid is expired, or the bid falls below current market), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group. Default: Instances are launched in any available Availability Zone.
        var availabilityZoneGroup: String? = nil
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        var clientToken: String? = nil
        var launchSpecification: RequestSpotLaunchSpecification? = nil
        /// The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled. Default: The request is effective indefinitely.
        var validFrom: Date? = nil
        /// The maximum hourly price (bid) for any Spot instance launched to fulfill the request.
        var spotPrice: String = ""
        /// The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. Default: The request is effective indefinitely.
        var validUntil: Date? = nil
        /// The Spot instance request type. Default: one-time 
        var type: String? = nil
        /// The maximum number of Spot instances to launch. Default: 1
        var instanceCount: Int32? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The instance launch group. Launch groups are Spot instances that launch together and terminate together. Default: Instances are launched and terminated individually
        var launchGroup: String? = nil

        public init() {}

        public init(blockDurationMinutes: Int32? = nil, availabilityZoneGroup: String? = nil, clientToken: String? = nil, launchSpecification: RequestSpotLaunchSpecification? = nil, validFrom: Date? = nil, spotPrice: String, validUntil: Date? = nil, type: String? = nil, instanceCount: Int32? = nil, dryRun: Bool? = nil, launchGroup: String? = nil) {
            self.blockDurationMinutes = blockDurationMinutes
            self.availabilityZoneGroup = availabilityZoneGroup
            self.clientToken = clientToken
            self.launchSpecification = launchSpecification
            self.validFrom = validFrom
            self.spotPrice = spotPrice
            self.validUntil = validUntil
            self.type = type
            self.instanceCount = instanceCount
            self.dryRun = dryRun
            self.launchGroup = launchGroup
        }

    }

    public struct DescribeImagesRequest: Serializable, Initializable {
        /// One or more filters.    architecture - The image architecture (i386 | x86_64).    block-device-mapping.delete-on-termination - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.    block-device-mapping.device-name - The device name for the EBS volume (for example, /dev/sdh).    block-device-mapping.snapshot-id - The ID of the snapshot used for the EBS volume.    block-device-mapping.volume-size - The volume size of the EBS volume, in GiB.    block-device-mapping.volume-type - The volume type of the EBS volume (gp2 | io1 | st1 | sc1 | standard).    description - The description of the image (provided during image creation).    ena-support - A Boolean that indicates whether enhanced networking with ENA is enabled.    hypervisor - The hypervisor type (ovm | xen).    image-id - The ID of the image.    image-type - The image type (machine | kernel | ramdisk).    is-public - A Boolean that indicates whether the image is public.    kernel-id - The kernel ID.    manifest-location - The location of the image manifest.    name - The name of the AMI (provided during image creation).    owner-alias - String value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.    owner-id - The AWS account ID of the image owner.    platform - The platform. To only list Windows-based AMIs, use windows.    product-code - The product code.    product-code.type - The type of the product code (devpay | marketplace).    ramdisk-id - The RAM disk ID.    root-device-name - The name of the root device volume (for example, /dev/sda1).    root-device-type - The type of the root device volume (ebs | instance-store).    state - The state of the image (available | pending | failed).    state-reason-code - The reason code for the state change.    state-reason-message - The message for the state change.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    virtualization-type - The virtualization type (paravirtual | hvm).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Scopes the images by users with explicit launch permissions. Specify an AWS account ID, self (the sender of the request), or all (public AMIs).
        var executableUsers: [String]? = nil
        /// One or more image IDs. Default: Describes all images available to you.
        var imageIds: [String]? = nil
        /// Filters the images by the owner. Specify an AWS account ID, self (owner is the sender of the request), or an AWS owner alias (valid values are amazon | aws-marketplace | microsoft). Omitting this option returns all images for which you have launch permissions, regardless of ownership.
        var owners: [String]? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, executableUsers: [String]? = nil, imageIds: [String]? = nil, owners: [String]? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.executableUsers = executableUsers
            self.imageIds = imageIds
            self.owners = owners
        }

    }

    public struct HostOffering: Serializable, Initializable {
        /// The upfront price of the offering. Does not apply to No Upfront offerings.
        var upfrontPrice: String? = nil
        /// The available payment option.
        var paymentOption: String? = nil
        /// The ID of the offering.
        var offeringId: String? = nil
        /// The hourly price of the offering.
        var hourlyPrice: String? = nil
        /// The currency of the offering.
        var currencyCode: String? = nil
        /// The duration of the offering (in seconds).
        var duration: Int32? = nil
        /// The instance family of the offering.
        var instanceFamily: String? = nil

        public init() {}

        public init(upfrontPrice: String? = nil, paymentOption: String? = nil, offeringId: String? = nil, hourlyPrice: String? = nil, currencyCode: String? = nil, duration: Int32? = nil, instanceFamily: String? = nil) {
            self.upfrontPrice = upfrontPrice
            self.paymentOption = paymentOption
            self.offeringId = offeringId
            self.hourlyPrice = hourlyPrice
            self.currencyCode = currencyCode
            self.duration = duration
            self.instanceFamily = instanceFamily
        }

    }

    public struct InstanceNetworkInterfaceSpecification: Serializable, Initializable {
        /// Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
        var associatePublicIpAddress: Bool? = nil
        /// The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.
        var subnetId: String? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a RunInstances request, you must provide the device index.
        var deviceIndex: Int32? = nil
        /// The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        var privateIpAddress: String? = nil
        /// The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        var secondaryPrivateIpAddressCount: Int32? = nil
        /// One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a RunInstances request.
        var privateIpAddresses: [PrivateIpAddressSpecification]? = nil
        /// A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        var ipv6AddressCount: Int32? = nil
        /// One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// If set to true, the interface is deleted when the instance is terminated. You can specify true only if creating a new network interface when launching an instance.
        var deleteOnTermination: Bool? = nil
        /// The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        var groups: [String]? = nil
        /// The description of the network interface. Applies only if creating a network interface when launching an instance.
        var description: String? = nil

        public init() {}

        public init(associatePublicIpAddress: Bool? = nil, subnetId: String? = nil, networkInterfaceId: String? = nil, deviceIndex: Int32? = nil, privateIpAddress: String? = nil, secondaryPrivateIpAddressCount: Int32? = nil, privateIpAddresses: [PrivateIpAddressSpecification]? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, deleteOnTermination: Bool? = nil, groups: [String]? = nil, description: String? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.deviceIndex = deviceIndex
            self.privateIpAddress = privateIpAddress
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.privateIpAddresses = privateIpAddresses
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.deleteOnTermination = deleteOnTermination
            self.groups = groups
            self.description = description
        }

    }

    public struct DeleteRouteTableRequest: Serializable, Initializable {
        /// The ID of the route table.
        var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(routeTableId: String, dryRun: Bool? = nil) {
            self.routeTableId = routeTableId
            self.dryRun = dryRun
        }

    }

    public struct NatGatewayAddress: Serializable, Initializable {
        /// The ID of the network interface associated with the NAT gateway.
        var networkInterfaceId: String? = nil
        /// The Elastic IP address associated with the NAT gateway.
        var publicIp: String? = nil
        /// The private IP address associated with the Elastic IP address.
        var privateIp: String? = nil
        /// The allocation ID of the Elastic IP address that's associated with the NAT gateway.
        var allocationId: String? = nil

        public init() {}

        public init(networkInterfaceId: String? = nil, publicIp: String? = nil, privateIp: String? = nil, allocationId: String? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.publicIp = publicIp
            self.privateIp = privateIp
            self.allocationId = allocationId
        }

    }

    public struct DescribeNetworkInterfaceAttributeResult: Serializable, Initializable {
        /// The description of the network interface.
        var description: AttributeValue? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The attachment (if any) of the network interface.
        var attachment: NetworkInterfaceAttachment? = nil
        /// The security groups associated with the network interface.
        var groups: [GroupIdentifier]? = nil
        /// Indicates whether source/destination checking is enabled.
        var sourceDestCheck: AttributeBooleanValue? = nil

        public init() {}

        public init(description: AttributeValue? = nil, networkInterfaceId: String? = nil, attachment: NetworkInterfaceAttachment? = nil, groups: [GroupIdentifier]? = nil, sourceDestCheck: AttributeBooleanValue? = nil) {
            self.description = description
            self.networkInterfaceId = networkInterfaceId
            self.attachment = attachment
            self.groups = groups
            self.sourceDestCheck = sourceDestCheck
        }

    }

    public struct ModifyVpcEndpointResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct ImportSnapshotRequest: Serializable, Initializable {
        /// Token to enable idempotency for VM import requests.
        var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The name of the role to use when not using the default role, 'vmimport'.
        var roleName: String? = nil
        /// The client-specific data.
        var clientData: ClientData? = nil
        /// Information about the disk container.
        var diskContainer: SnapshotDiskContainer? = nil
        /// The description string for the import snapshot task.
        var description: String? = nil

        public init() {}

        public init(clientToken: String? = nil, dryRun: Bool? = nil, roleName: String? = nil, clientData: ClientData? = nil, diskContainer: SnapshotDiskContainer? = nil, description: String? = nil) {
            self.clientToken = clientToken
            self.dryRun = dryRun
            self.roleName = roleName
            self.clientData = clientData
            self.diskContainer = diskContainer
            self.description = description
        }

    }

    public struct CreateVpcRequest: Serializable, Initializable {
        /// The tenancy options for instances launched into the VPC. For default, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For dedicated, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of dedicated or host into a dedicated tenancy VPC.   Important: The host value cannot be used with this parameter. Use the default or dedicated values only. Default: default 
        var instanceTenancy: String? = nil
        /// Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.
        var amazonProvidedIpv6CidrBlock: Bool? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The IPv4 network range for the VPC, in CIDR notation. For example, 10.0.0.0/16.
        var cidrBlock: String = ""

        public init() {}

        public init(instanceTenancy: String? = nil, amazonProvidedIpv6CidrBlock: Bool? = nil, dryRun: Bool? = nil, cidrBlock: String) {
            self.instanceTenancy = instanceTenancy
            self.amazonProvidedIpv6CidrBlock = amazonProvidedIpv6CidrBlock
            self.dryRun = dryRun
            self.cidrBlock = cidrBlock
        }

    }

    public struct CreateRouteTableRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

    }

    public struct DescribeVpcsResult: Serializable, Initializable {
        /// Information about one or more VPCs.
        var vpcs: [Vpc]? = nil

        public init() {}

        public init(vpcs: [Vpc]? = nil) {
            self.vpcs = vpcs
        }

    }

    public struct ImportInstanceRequest: Serializable, Initializable {
        /// The disk image.
        var diskImages: [DiskImage]? = nil
        /// The instance operating system.
        var platform: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The launch specification.
        var launchSpecification: ImportInstanceLaunchSpecification? = nil
        /// A description for the instance being imported.
        var description: String? = nil

        public init() {}

        public init(diskImages: [DiskImage]? = nil, platform: String, dryRun: Bool? = nil, launchSpecification: ImportInstanceLaunchSpecification? = nil, description: String? = nil) {
            self.diskImages = diskImages
            self.platform = platform
            self.dryRun = dryRun
            self.launchSpecification = launchSpecification
            self.description = description
        }

    }

    public struct CreateVpcEndpointRequest: Serializable, Initializable {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        var clientToken: String? = nil
        /// The AWS service name, in the form com.amazonaws.region.service . To get a list of available services, use the DescribeVpcEndpointServices request.
        var serviceName: String = ""
        /// The ID of the VPC in which the endpoint will be used.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.
        var policyDocument: String? = nil
        /// One or more route table IDs.
        var routeTableIds: [String]? = nil

        public init() {}

        public init(clientToken: String? = nil, serviceName: String, vpcId: String, dryRun: Bool? = nil, policyDocument: String? = nil, routeTableIds: [String]? = nil) {
            self.clientToken = clientToken
            self.serviceName = serviceName
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.policyDocument = policyDocument
            self.routeTableIds = routeTableIds
        }

    }

    public struct MovingAddressStatus: Serializable, Initializable {
        /// The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.
        var moveStatus: String? = nil
        /// The Elastic IP address.
        var publicIp: String? = nil

        public init() {}

        public init(moveStatus: String? = nil, publicIp: String? = nil) {
            self.moveStatus = moveStatus
            self.publicIp = publicIp
        }

    }

    public struct DeregisterImageRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the AMI.
        var imageId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, imageId: String) {
            self.dryRun = dryRun
            self.imageId = imageId
        }

    }

    public struct DeleteSnapshotRequest: Serializable, Initializable {
        /// The ID of the EBS snapshot.
        var snapshotId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(snapshotId: String, dryRun: Bool? = nil) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
        }

    }

    public struct DescribeReservedInstancesOfferingsRequest: Serializable, Initializable {
        /// The maximum duration (in seconds) to filter when searching for offerings. Default: 94608000 (3 years)
        var maxDuration: Int64? = nil
        /// The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of dedicated is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances). Default: default 
        var instanceTenancy: String? = nil
        /// One or more Reserved Instances offering IDs.
        var reservedInstancesOfferingIds: [String]? = nil
        /// One or more filters.    availability-zone - The Availability Zone where the Reserved Instance can be used.    duration - The duration of the Reserved Instance (for example, one year or three years), in seconds (31536000 | 94608000).    fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).    instance-type - The instance type that is covered by the reservation.    marketplace - Set to true to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.    product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web |  Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC))     reserved-instances-offering-id - The Reserved Instances offering ID.    scope - The scope of the Reserved Instance (Availability Zone or Region).    usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The instance type that the reservation will cover (for example, m1.small). For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide.
        var instanceType: String? = nil
        /// The Availability Zone in which the Reserved Instance can be used.
        var availabilityZone: String? = nil
        /// The Reserved Instance product platform description. Instances that include (Amazon VPC) in the description are for use with Amazon VPC.
        var productDescription: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. The maximum is 100. Default: 100
        var maxResults: Int32? = nil
        /// The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type. 
        var offeringType: String? = nil
        /// The offering class of the Reserved Instance. Can be standard or convertible.
        var offeringClass: String? = nil
        /// Include Reserved Instance Marketplace offerings in the response.
        var includeMarketplace: Bool? = nil
        /// The minimum duration (in seconds) to filter when searching for offerings. Default: 2592000 (1 month)
        var minDuration: Int64? = nil
        /// The maximum number of instances to filter when searching for offerings. Default: 20
        var maxInstanceCount: Int32? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil

        public init() {}

        public init(maxDuration: Int64? = nil, instanceTenancy: String? = nil, reservedInstancesOfferingIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, instanceType: String? = nil, availabilityZone: String? = nil, productDescription: String? = nil, maxResults: Int32? = nil, offeringType: String? = nil, offeringClass: String? = nil, includeMarketplace: Bool? = nil, minDuration: Int64? = nil, maxInstanceCount: Int32? = nil, nextToken: String? = nil) {
            self.maxDuration = maxDuration
            self.instanceTenancy = instanceTenancy
            self.reservedInstancesOfferingIds = reservedInstancesOfferingIds
            self.filters = filters
            self.dryRun = dryRun
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.productDescription = productDescription
            self.maxResults = maxResults
            self.offeringType = offeringType
            self.offeringClass = offeringClass
            self.includeMarketplace = includeMarketplace
            self.minDuration = minDuration
            self.maxInstanceCount = maxInstanceCount
            self.nextToken = nextToken
        }

    }

    public struct CancelledSpotInstanceRequest: Serializable, Initializable {
        /// The ID of the Spot instance request.
        var spotInstanceRequestId: String? = nil
        /// The state of the Spot instance request.
        var state: String? = nil

        public init() {}

        public init(spotInstanceRequestId: String? = nil, state: String? = nil) {
            self.spotInstanceRequestId = spotInstanceRequestId
            self.state = state
        }

    }

    public struct ModifyImageAttributeRequest: Serializable, Initializable {
        /// One or more product codes. After you add a product code to an AMI, it can't be removed. This is only valid when modifying the productCodes attribute.
        var productCodes: [String]? = nil
        /// A description for the AMI.
        var description: AttributeValue? = nil
        /// One or more AWS account IDs. This is only valid when modifying the launchPermission attribute.
        var userIds: [String]? = nil
        /// One or more user groups. This is only valid when modifying the launchPermission attribute.
        var userGroups: [String]? = nil
        /// The ID of the AMI.
        var imageId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The name of the attribute to modify.
        var attribute: String? = nil
        /// The value of the attribute being modified. This is only valid when modifying the description attribute.
        var value: String? = nil
        /// A launch permission modification.
        var launchPermission: LaunchPermissionModifications? = nil
        /// The operation type.
        var operationType: String? = nil

        public init() {}

        public init(productCodes: [String]? = nil, description: AttributeValue? = nil, userIds: [String]? = nil, userGroups: [String]? = nil, imageId: String, dryRun: Bool? = nil, attribute: String? = nil, value: String? = nil, launchPermission: LaunchPermissionModifications? = nil, operationType: String? = nil) {
            self.productCodes = productCodes
            self.description = description
            self.userIds = userIds
            self.userGroups = userGroups
            self.imageId = imageId
            self.dryRun = dryRun
            self.attribute = attribute
            self.value = value
            self.launchPermission = launchPermission
            self.operationType = operationType
        }

    }

    public struct SubnetIpv6CidrBlockAssociation: Serializable, Initializable {
        /// Information about the state of the CIDR block.
        var ipv6CidrBlockState: SubnetCidrBlockState? = nil
        /// The IPv6 CIDR block.
        var ipv6CidrBlock: String? = nil
        /// The association ID for the CIDR block.
        var associationId: String? = nil

        public init() {}

        public init(ipv6CidrBlockState: SubnetCidrBlockState? = nil, ipv6CidrBlock: String? = nil, associationId: String? = nil) {
            self.ipv6CidrBlockState = ipv6CidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
            self.associationId = associationId
        }

    }

    public struct CreateDhcpOptionsResult: Serializable, Initializable {
        /// A set of DHCP options.
        var dhcpOptions: DhcpOptions? = nil

        public init() {}

        public init(dhcpOptions: DhcpOptions? = nil) {
            self.dhcpOptions = dhcpOptions
        }

    }

    public struct InstanceNetworkInterfaceAssociation: Serializable, Initializable {
        /// The public DNS name.
        var publicDnsName: String? = nil
        /// The ID of the owner of the Elastic IP address.
        var ipOwnerId: String? = nil
        /// The public IP address or Elastic IP address bound to the network interface.
        var publicIp: String? = nil

        public init() {}

        public init(publicDnsName: String? = nil, ipOwnerId: String? = nil, publicIp: String? = nil) {
            self.publicDnsName = publicDnsName
            self.ipOwnerId = ipOwnerId
            self.publicIp = publicIp
        }

    }

    public struct EbsInstanceBlockDevice: Serializable, Initializable {
        /// The time stamp when the attachment initiated.
        var attachTime: Date? = nil
        /// Indicates whether the volume is deleted on instance termination.
        var deleteOnTermination: Bool? = nil
        /// The attachment state.
        var status: String? = nil
        /// The ID of the EBS volume.
        var volumeId: String? = nil

        public init() {}

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, status: String? = nil, volumeId: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.status = status
            self.volumeId = volumeId
        }

    }

    public struct CancelImportTaskRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The reason for canceling the task.
        var cancelReason: String? = nil
        /// The ID of the import image or import snapshot task to be canceled.
        var importTaskId: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, cancelReason: String? = nil, importTaskId: String? = nil) {
            self.dryRun = dryRun
            self.cancelReason = cancelReason
            self.importTaskId = importTaskId
        }

    }

    public struct ReservedInstanceReservationValue: Serializable, Initializable {
        /// The ID of the Convertible Reserved Instance that you are exchanging.
        var reservedInstanceId: String? = nil
        /// The total value of the Convertible Reserved Instance that you are exchanging.
        var reservationValue: ReservationValue? = nil

        public init() {}

        public init(reservedInstanceId: String? = nil, reservationValue: ReservationValue? = nil) {
            self.reservedInstanceId = reservedInstanceId
            self.reservationValue = reservationValue
        }

    }

    public struct CreateFlowLogsResult: Serializable, Initializable {
        /// The IDs of the flow logs.
        var flowLogIds: [String]? = nil
        /// Information about the flow logs that could not be created successfully.
        var unsuccessful: [UnsuccessfulItem]? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        var clientToken: String? = nil

        public init() {}

        public init(flowLogIds: [String]? = nil, unsuccessful: [UnsuccessfulItem]? = nil, clientToken: String? = nil) {
            self.flowLogIds = flowLogIds
            self.unsuccessful = unsuccessful
            self.clientToken = clientToken
        }

    }

    public struct StopInstancesRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more instance IDs.
        var instanceIds: [String] = []
        /// Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances. Default: false 
        var force: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil, instanceIds: [String], force: Bool? = nil) {
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.force = force
        }

    }

    public struct AvailabilityZone: Serializable, Initializable {
        /// The name of the Availability Zone.
        var zoneName: String? = nil
        /// The state of the Availability Zone.
        var state: String? = nil
        /// Any messages about the Availability Zone.
        var messages: [AvailabilityZoneMessage]? = nil
        /// The name of the region.
        var regionName: String? = nil

        public init() {}

        public init(zoneName: String? = nil, state: String? = nil, messages: [AvailabilityZoneMessage]? = nil, regionName: String? = nil) {
            self.zoneName = zoneName
            self.state = state
            self.messages = messages
            self.regionName = regionName
        }

    }

    public struct VolumeStatusDetails: Serializable, Initializable {
        /// The name of the volume status.
        var name: String? = nil
        /// The intended status of the volume status.
        var status: String? = nil

        public init() {}

        public init(name: String? = nil, status: String? = nil) {
            self.name = name
            self.status = status
        }

    }

    public struct DisassociateIamInstanceProfileResult: Serializable, Initializable {
        /// Information about the IAM instance profile association.
        var iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil

        public init() {}

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

    }

    public struct DescribeReservedInstancesModificationsRequest: Serializable, Initializable {
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// One or more filters.    client-token - The idempotency token for the modification request.    create-date - The time when the modification request was created.    effective-date - The time when the modification becomes effective.    modification-result.reserved-instances-id - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is fulfilled.    modification-result.target-configuration.availability-zone - The Availability Zone for the new Reserved Instances.    modification-result.target-configuration.instance-count  - The number of new Reserved Instances.    modification-result.target-configuration.instance-type - The instance type of the new Reserved Instances.    modification-result.target-configuration.platform - The network platform of the new Reserved Instances (EC2-Classic | EC2-VPC).    reserved-instances-id - The ID of the Reserved Instances modified.    reserved-instances-modification-id - The ID of the modification request.    status - The status of the Reserved Instances modification request (processing | fulfilled | failed).    status-message - The reason for the status.    update-date - The time when the modification request was last updated.  
        var filters: [Filter]? = nil
        /// IDs for the submitted modification request.
        var reservedInstancesModificationIds: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, filters: [Filter]? = nil, reservedInstancesModificationIds: [String]? = nil) {
            self.nextToken = nextToken
            self.filters = filters
            self.reservedInstancesModificationIds = reservedInstancesModificationIds
        }

    }

    public struct SpotInstanceStateFault: Serializable, Initializable {
        /// The reason code for the Spot instance state change.
        var code: String? = nil
        /// The message for the Spot instance state change.
        var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

    }

    public struct DescribeImagesResult: Serializable, Initializable {
        /// Information about one or more images.
        var images: [Image]? = nil

        public init() {}

        public init(images: [Image]? = nil) {
            self.images = images
        }

    }

    public struct ScheduledInstancesPlacement: Serializable, Initializable {
        /// The Availability Zone.
        var availabilityZone: String? = nil
        /// The name of the placement group.
        var groupName: String? = nil

        public init() {}

        public init(availabilityZone: String? = nil, groupName: String? = nil) {
            self.availabilityZone = availabilityZone
            self.groupName = groupName
        }

    }

    public struct CancelSpotFleetRequestsSuccessItem: Serializable, Initializable {
        /// The current state of the Spot fleet request.
        var currentSpotFleetRequestState: String = ""
        /// The previous state of the Spot fleet request.
        var previousSpotFleetRequestState: String = ""
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""

        public init() {}

        public init(currentSpotFleetRequestState: String, previousSpotFleetRequestState: String, spotFleetRequestId: String) {
            self.currentSpotFleetRequestState = currentSpotFleetRequestState
            self.previousSpotFleetRequestState = previousSpotFleetRequestState
            self.spotFleetRequestId = spotFleetRequestId
        }

    }

    public struct AuthorizeSecurityGroupIngressRequest: Serializable, Initializable {
        /// [EC2-Classic] The AWS account number for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.
        var sourceSecurityGroupOwnerId: String? = nil
        /// [EC2-Classic, default VPC] The name of the security group.
        var groupName: String? = nil
        /// A set of IP permissions. Can be used to specify multiple rules in a single command.
        var ipPermissions: [IpPermission]? = nil
        /// The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.
        var cidrIp: String? = nil
        /// [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.
        var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use -1 to specify all codes.
        var toPort: Int32? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use -1 to specify all types.
        var fromPort: Int32? = nil
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). (VPC only) Use -1 to specify all protocols. If you specify -1, or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For tcp, udp, and icmp, you must specify a port range. For protocol 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.
        var ipProtocol: String? = nil
        /// The ID of the security group. Required for a nondefault VPC.
        var groupId: String? = nil

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, groupName: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, toPort: Int32? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, groupId: String? = nil) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.toPort = toPort
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.groupId = groupId
        }

    }

    public struct PortRange: Serializable, Initializable {
        /// The first port in the range.
        var from: Int32? = nil
        /// The last port in the range.
        var to: Int32? = nil

        public init() {}

        public init(from: Int32? = nil, to: Int32? = nil) {
            self.from = from
            self.to = to
        }

    }

    public struct InstanceState: Serializable, Initializable {
        /// The current state of the instance.
        var name: String? = nil
        /// The low byte represents the state. The high byte is an opaque internal value and should be ignored.    0 : pending     16 : running     32 : shutting-down     48 : terminated     64 : stopping     80 : stopped   
        var code: Int32? = nil

        public init() {}

        public init(name: String? = nil, code: Int32? = nil) {
            self.name = name
            self.code = code
        }

    }

    public struct InstancePrivateIpAddress: Serializable, Initializable {
        /// The private IPv4 address of the network interface.
        var privateIpAddress: String? = nil
        /// The private IPv4 DNS name.
        var privateDnsName: String? = nil
        /// Indicates whether this IPv4 address is the primary private IP address of the network interface.
        var primary: Bool? = nil
        /// The association information for an Elastic IP address for the network interface.
        var association: InstanceNetworkInterfaceAssociation? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, privateDnsName: String? = nil, primary: Bool? = nil, association: InstanceNetworkInterfaceAssociation? = nil) {
            self.privateIpAddress = privateIpAddress
            self.privateDnsName = privateDnsName
            self.primary = primary
            self.association = association
        }

    }

    public struct HostProperties: Serializable, Initializable {
        /// The number of sockets on the Dedicated Host.
        var sockets: Int32? = nil
        /// The instance type size that the Dedicated Host supports (for example, m3.medium).
        var instanceType: String? = nil
        /// The number of vCPUs on the Dedicated Host.
        var totalVCpus: Int32? = nil
        /// The number of cores on the Dedicated Host.
        var cores: Int32? = nil

        public init() {}

        public init(sockets: Int32? = nil, instanceType: String? = nil, totalVCpus: Int32? = nil, cores: Int32? = nil) {
            self.sockets = sockets
            self.instanceType = instanceType
            self.totalVCpus = totalVCpus
            self.cores = cores
        }

    }

    public struct UnassignPrivateIpAddressesRequest: Serializable, Initializable {
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.
        var privateIpAddresses: [String] = []

        public init() {}

        public init(networkInterfaceId: String, privateIpAddresses: [String]) {
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
        }

    }

    public struct SecurityGroupReference: Serializable, Initializable {
        /// The ID of the VPC with the referencing security group.
        var referencingVpcId: String = ""
        /// The ID of your security group.
        var groupId: String = ""
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(referencingVpcId: String, groupId: String, vpcPeeringConnectionId: String? = nil) {
            self.referencingVpcId = referencingVpcId
            self.groupId = groupId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct PriceSchedule: Serializable, Initializable {
        /// The current price schedule, as determined by the term remaining for the Reserved Instance in the listing. A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.
        var active: Bool? = nil
        /// The currency for transacting the Reserved Instance resale. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.
        var term: Int64? = nil
        /// The fixed price for the term.
        var price: Double? = nil

        public init() {}

        public init(active: Bool? = nil, currencyCode: String? = nil, term: Int64? = nil, price: Double? = nil) {
            self.active = active
            self.currencyCode = currencyCode
            self.term = term
            self.price = price
        }

    }

    public struct DescribePrefixListsRequest: Serializable, Initializable {
        /// One or more prefix list IDs.
        var prefixListIds: [String]? = nil
        /// One or more filters.    prefix-list-id: The ID of a prefix list.    prefix-list-name: The name of a prefix list.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value specified is greater than 1000, we return only 1000 items.
        var maxResults: Int32? = nil

        public init() {}

        public init(prefixListIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.prefixListIds = prefixListIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DiskImage: Serializable, Initializable {
        /// Information about the disk image.
        var image: DiskImageDetail? = nil
        /// Information about the volume.
        var volume: VolumeDetail? = nil
        /// A description of the disk image.
        var description: String? = nil

        public init() {}

        public init(image: DiskImageDetail? = nil, volume: VolumeDetail? = nil, description: String? = nil) {
            self.image = image
            self.volume = volume
            self.description = description
        }

    }

    public struct DescribeRouteTablesRequest: Serializable, Initializable {
        /// One or more route table IDs. Default: Describes all your route tables.
        var routeTableIds: [String]? = nil
        /// One or more filters.    association.route-table-association-id - The ID of an association ID for the route table.    association.route-table-id - The ID of the route table involved in the association.    association.subnet-id - The ID of the subnet involved in the association.    association.main - Indicates whether the route table is the main route table for the VPC (true | false).    route-table-id - The ID of the route table.    route.destination-cidr-block - The IPv4 CIDR range specified in a route in the table.    route.destination-ipv6-cidr-block - The IPv6 CIDR range specified in a route in the route table.    route.destination-prefix-list-id - The ID (prefix) of the AWS service specified in a route in the table.    route.egress-only-internet-gateway-id - The ID of an egress-only Internet gateway specified in a route in the route table.    route.gateway-id - The ID of a gateway specified in a route in the table.    route.instance-id - The ID of an instance specified in a route in the table.    route.nat-gateway-id - The ID of a NAT gateway.    route.origin - Describes how the route was created. CreateRouteTable indicates that the route was automatically created when the route table was created; CreateRoute indicates that the route was manually added to the route table; EnableVgwRoutePropagation indicates that the route was propagated by route propagation.    route.state - The state of a route in the route table (active | blackhole). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).    route.vpc-peering-connection-id - The ID of a VPC peering connection specified in a route in the table.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the route table.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(routeTableIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.routeTableIds = routeTableIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct DescribeInternetGatewaysResult: Serializable, Initializable {
        /// Information about one or more Internet gateways.
        var internetGateways: [InternetGateway]? = nil

        public init() {}

        public init(internetGateways: [InternetGateway]? = nil) {
            self.internetGateways = internetGateways
        }

    }

    public struct InstanceNetworkInterfaceAttachment: Serializable, Initializable {
        /// The time stamp when the attachment initiated.
        var attachTime: Date? = nil
        /// Indicates whether the network interface is deleted when the instance is terminated.
        var deleteOnTermination: Bool? = nil
        /// The index of the device on the instance for the network interface attachment.
        var deviceIndex: Int32? = nil
        /// The ID of the network interface attachment.
        var attachmentId: String? = nil
        /// The attachment state.
        var status: String? = nil

        public init() {}

        public init(attachTime: Date? = nil, deleteOnTermination: Bool? = nil, deviceIndex: Int32? = nil, attachmentId: String? = nil, status: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.attachmentId = attachmentId
            self.status = status
        }

    }

    public struct DisassociateVpcCidrBlockRequest: Serializable, Initializable {
        /// The association ID for the CIDR block.
        var associationId: String = ""

        public init() {}

        public init(associationId: String) {
            self.associationId = associationId
        }

    }

    public struct DescribeVpcPeeringConnectionsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    accepter-vpc-info.cidr-block - The IPv4 CIDR block of the peer VPC.    accepter-vpc-info.owner-id - The AWS account ID of the owner of the peer VPC.    accepter-vpc-info.vpc-id - The ID of the peer VPC.    expiration-time - The expiration date and time for the VPC peering connection.    requester-vpc-info.cidr-block - The IPv4 CIDR block of the requester's VPC.    requester-vpc-info.owner-id - The AWS account ID of the owner of the requester VPC.    requester-vpc-info.vpc-id - The ID of the requester VPC.    status-code - The status of the VPC peering connection (pending-acceptance | failed | expired | provisioning | active | deleted | rejected).    status-message - A message that provides more information about the status of the VPC peering connection, if applicable.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-peering-connection-id - The ID of the VPC peering connection.  
        var filters: [Filter]? = nil
        /// One or more VPC peering connection IDs. Default: Describes all your VPC peering connections.
        var vpcPeeringConnectionIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, vpcPeeringConnectionIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcPeeringConnectionIds = vpcPeeringConnectionIds
        }

    }

    public struct DetachClassicLinkVpcRequest: Serializable, Initializable {
        /// The ID of the VPC to which the instance is linked.
        var vpcId: String = ""
        /// The ID of the instance to unlink from the VPC.
        var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, instanceId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

    }

    public struct ReservationValue: Serializable, Initializable {
        /// The hourly rate of the reservation.
        var hourlyPrice: String? = nil
        /// The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).
        var remainingTotalValue: String? = nil
        /// The remaining upfront cost of the reservation.
        var remainingUpfrontValue: String? = nil

        public init() {}

        public init(hourlyPrice: String? = nil, remainingTotalValue: String? = nil, remainingUpfrontValue: String? = nil) {
            self.hourlyPrice = hourlyPrice
            self.remainingTotalValue = remainingTotalValue
            self.remainingUpfrontValue = remainingUpfrontValue
        }

    }

    public struct DetachClassicLinkVpcResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct S3Storage: Serializable, Initializable {
        /// The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.
        var bucket: String? = nil
        /// The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in Best Practices for Managing AWS Access Keys.
        var aWSAccessKeyId: String? = nil
        /// The signature of the JSON document.
        var uploadPolicySignature: String? = nil
        /// The beginning of the file name of the AMI.
        var prefix: String? = nil
        /// An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.
        var uploadPolicy: Data? = nil

        public init() {}

        public init(bucket: String? = nil, aWSAccessKeyId: String? = nil, uploadPolicySignature: String? = nil, prefix: String? = nil, uploadPolicy: Data? = nil) {
            self.bucket = bucket
            self.aWSAccessKeyId = aWSAccessKeyId
            self.uploadPolicySignature = uploadPolicySignature
            self.prefix = prefix
            self.uploadPolicy = uploadPolicy
        }

    }

    public struct DescribeInstancesResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Zero or more reservations.
        var reservations: [Reservation]? = nil

        public init() {}

        public init(nextToken: String? = nil, reservations: [Reservation]? = nil) {
            self.nextToken = nextToken
            self.reservations = reservations
        }

    }

    public struct DescribeReservedInstancesListingsRequest: Serializable, Initializable {
        /// One or more Reserved Instance IDs.
        var reservedInstancesId: String? = nil
        /// One or more Reserved Instance listing IDs.
        var reservedInstancesListingId: String? = nil
        /// One or more filters.    reserved-instances-id - The ID of the Reserved Instances.    reserved-instances-listing-id - The ID of the Reserved Instances listing.    status - The status of the Reserved Instance listing (pending | active | cancelled | closed).    status-message - The reason for the status.  
        var filters: [Filter]? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil, reservedInstancesListingId: String? = nil, filters: [Filter]? = nil) {
            self.reservedInstancesId = reservedInstancesId
            self.reservedInstancesListingId = reservedInstancesListingId
            self.filters = filters
        }

    }

    public struct CancelBundleTaskRequest: Serializable, Initializable {
        /// The ID of the bundle task.
        var bundleId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(bundleId: String, dryRun: Bool? = nil) {
            self.bundleId = bundleId
            self.dryRun = dryRun
        }

    }

    public struct DeleteCustomerGatewayRequest: Serializable, Initializable {
        /// The ID of the customer gateway.
        var customerGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(customerGatewayId: String, dryRun: Bool? = nil) {
            self.customerGatewayId = customerGatewayId
            self.dryRun = dryRun
        }

    }

    public struct DescribeHostsResult: Serializable, Initializable {
        /// Information about the Dedicated Hosts.
        var hosts: [Host]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(hosts: [Host]? = nil, nextToken: String? = nil) {
            self.hosts = hosts
            self.nextToken = nextToken
        }

    }

    public struct PurchaseHostReservationResult: Serializable, Initializable {
        /// Describes the details of the purchase.
        var purchase: [Purchase]? = nil
        /// The total amount that will be charged to your account when you purchase the reservation.
        var totalUpfrontPrice: String? = nil
        /// The currency in which the totalUpfrontPrice and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide 
        var clientToken: String? = nil
        /// The total hourly price of the reservation calculated per hour.
        var totalHourlyPrice: String? = nil

        public init() {}

        public init(purchase: [Purchase]? = nil, totalUpfrontPrice: String? = nil, currencyCode: String? = nil, clientToken: String? = nil, totalHourlyPrice: String? = nil) {
            self.purchase = purchase
            self.totalUpfrontPrice = totalUpfrontPrice
            self.currencyCode = currencyCode
            self.clientToken = clientToken
            self.totalHourlyPrice = totalHourlyPrice
        }

    }

    public struct DeleteEgressOnlyInternetGatewayResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var returnCode: Bool? = nil

        public init() {}

        public init(returnCode: Bool? = nil) {
            self.returnCode = returnCode
        }

    }

    public struct DeleteVolumeRequest: Serializable, Initializable {
        /// The ID of the volume.
        var volumeId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(volumeId: String, dryRun: Bool? = nil) {
            self.volumeId = volumeId
            self.dryRun = dryRun
        }

    }

    public struct TargetConfiguration: Serializable, Initializable {
        /// The ID of the Convertible Reserved Instance offering.
        var offeringId: String? = nil
        /// The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request
        var instanceCount: Int32? = nil

        public init() {}

        public init(offeringId: String? = nil, instanceCount: Int32? = nil) {
            self.offeringId = offeringId
            self.instanceCount = instanceCount
        }

    }

    public struct CreateCustomerGatewayResult: Serializable, Initializable {
        /// Information about the customer gateway.
        var customerGateway: CustomerGateway? = nil

        public init() {}

        public init(customerGateway: CustomerGateway? = nil) {
            self.customerGateway = customerGateway
        }

    }

    public struct DescribeBundleTasksResult: Serializable, Initializable {
        /// Information about one or more bundle tasks.
        var bundleTasks: [BundleTask]? = nil

        public init() {}

        public init(bundleTasks: [BundleTask]? = nil) {
            self.bundleTasks = bundleTasks
        }

    }

    public struct GetReservedInstancesExchangeQuoteResult: Serializable, Initializable {
        /// The new end date of the reservation term.
        var outputReservedInstancesWillExpireAt: Date? = nil
        /// The cost associated with the Reserved Instance.
        var targetConfigurationValueRollup: ReservationValue? = nil
        /// If true, the exchange is valid. If false, the exchange cannot be completed.
        var isValidExchange: Bool? = nil
        /// The cost associated with the Reserved Instance.
        var reservedInstanceValueRollup: ReservationValue? = nil
        /// The configuration of your Convertible Reserved Instances.
        var reservedInstanceValueSet: [ReservedInstanceReservationValue]? = nil
        /// The total true upfront charge for the exchange.
        var paymentDue: String? = nil
        /// The currency of the transaction.
        var currencyCode: String? = nil
        /// The values of the target Convertible Reserved Instances.
        var targetConfigurationValueSet: [TargetReservationValue]? = nil
        /// Describes the reason why the exchange cannot be completed.
        var validationFailureReason: String? = nil

        public init() {}

        public init(outputReservedInstancesWillExpireAt: Date? = nil, targetConfigurationValueRollup: ReservationValue? = nil, isValidExchange: Bool? = nil, reservedInstanceValueRollup: ReservationValue? = nil, reservedInstanceValueSet: [ReservedInstanceReservationValue]? = nil, paymentDue: String? = nil, currencyCode: String? = nil, targetConfigurationValueSet: [TargetReservationValue]? = nil, validationFailureReason: String? = nil) {
            self.outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAt
            self.targetConfigurationValueRollup = targetConfigurationValueRollup
            self.isValidExchange = isValidExchange
            self.reservedInstanceValueRollup = reservedInstanceValueRollup
            self.reservedInstanceValueSet = reservedInstanceValueSet
            self.paymentDue = paymentDue
            self.currencyCode = currencyCode
            self.targetConfigurationValueSet = targetConfigurationValueSet
            self.validationFailureReason = validationFailureReason
        }

    }

    public struct InstanceExportDetails: Serializable, Initializable {
        /// The ID of the resource being exported.
        var instanceId: String? = nil
        /// The target virtualization environment.
        var targetEnvironment: String? = nil

        public init() {}

        public init(instanceId: String? = nil, targetEnvironment: String? = nil) {
            self.instanceId = instanceId
            self.targetEnvironment = targetEnvironment
        }

    }

    public struct NetworkAcl: Serializable, Initializable {
        /// Indicates whether this is the default network ACL for the VPC.
        var isDefault: Bool? = nil
        /// One or more entries (rules) in the network ACL.
        var entries: [NetworkAclEntry]? = nil
        /// The ID of the network ACL.
        var networkAclId: String? = nil
        /// The ID of the VPC for the network ACL.
        var vpcId: String? = nil
        /// Any tags assigned to the network ACL.
        var tags: [Tag]? = nil
        /// Any associations between the network ACL and one or more subnets
        var associations: [NetworkAclAssociation]? = nil

        public init() {}

        public init(isDefault: Bool? = nil, entries: [NetworkAclEntry]? = nil, networkAclId: String? = nil, vpcId: String? = nil, tags: [Tag]? = nil, associations: [NetworkAclAssociation]? = nil) {
            self.isDefault = isDefault
            self.entries = entries
            self.networkAclId = networkAclId
            self.vpcId = vpcId
            self.tags = tags
            self.associations = associations
        }

    }

    public struct RevokeSecurityGroupIngressRequest: Serializable, Initializable {
        /// [EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.
        var sourceSecurityGroupOwnerId: String? = nil
        /// [EC2-Classic, default VPC] The name of the security group.
        var groupName: String? = nil
        /// A set of IP permissions. You can't specify a source security group and a CIDR IP address range.
        var ipPermissions: [IpPermission]? = nil
        /// The CIDR IP address range. You can't specify this parameter when specifying a source security group.
        var cidrIp: String? = nil
        /// [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.
        var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use -1 to specify all ICMP codes for the ICMP type.
        var toPort: Int32? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use -1 to specify all ICMP types.
        var fromPort: Int32? = nil
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). Use -1 to specify all.
        var ipProtocol: String? = nil
        /// The ID of the security group. Required for a security group in a nondefault VPC.
        var groupId: String? = nil

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, groupName: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, toPort: Int32? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, groupId: String? = nil) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.toPort = toPort
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.groupId = groupId
        }

    }

    public struct DescribeKeyPairsResult: Serializable, Initializable {
        /// Information about one or more key pairs.
        var keyPairs: [KeyPairInfo]? = nil

        public init() {}

        public init(keyPairs: [KeyPairInfo]? = nil) {
            self.keyPairs = keyPairs
        }

    }

    public struct ScheduledInstancesPrivateIpAddressConfig: Serializable, Initializable {
        /// Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.
        var primary: Bool? = nil
        /// The IPv4 address.
        var privateIpAddress: String? = nil

        public init() {}

        public init(primary: Bool? = nil, privateIpAddress: String? = nil) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

    }

    public struct CancelReservedInstancesListingResult: Serializable, Initializable {
        /// The Reserved Instance listing.
        var reservedInstancesListings: [ReservedInstancesListing]? = nil

        public init() {}

        public init(reservedInstancesListings: [ReservedInstancesListing]? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

    }

    public struct AcceptReservedInstancesExchangeQuoteRequest: Serializable, Initializable {
        /// The IDs of the Convertible Reserved Instances to exchange for other Convertible Reserved Instances of the same or higher value.
        var reservedInstanceIds: [String] = []
        /// The configurations of the Convertible Reserved Instance offerings that you are purchasing in this exchange.
        var targetConfigurations: [TargetConfigurationRequest]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(reservedInstanceIds: [String], targetConfigurations: [TargetConfigurationRequest]? = nil, dryRun: Bool? = nil) {
            self.reservedInstanceIds = reservedInstanceIds
            self.targetConfigurations = targetConfigurations
            self.dryRun = dryRun
        }

    }

    public struct BundleInstanceRequest: Serializable, Initializable {
        /// The ID of the instance to bundle. Type: String Default: None Required: Yes
        var instanceId: String = ""
        /// The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.
        var storage: Storage = Storage()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, storage: Storage, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.storage = storage
            self.dryRun = dryRun
        }

    }

    public struct DescribeVolumesModificationsResult: Serializable, Initializable {
        /// Token for pagination, null if there are no more results 
        var nextToken: String? = nil
        /// A list of returned VolumeModification objects.
        var volumesModifications: [VolumeModification]? = nil

        public init() {}

        public init(nextToken: String? = nil, volumesModifications: [VolumeModification]? = nil) {
            self.nextToken = nextToken
            self.volumesModifications = volumesModifications
        }

    }

    public struct DescribeVpcClassicLinkRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    is-classic-link-enabled - Whether the VPC is enabled for ClassicLink (true | false).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        var filters: [Filter]? = nil
        /// One or more VPCs for which you want to describe the ClassicLink status.
        var vpcIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, vpcIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcIds = vpcIds
        }

    }

    public struct DescribeVolumeAttributeRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the volume.
        var volumeId: String = ""
        /// The instance attribute.
        var attribute: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, volumeId: String, attribute: String? = nil) {
            self.dryRun = dryRun
            self.volumeId = volumeId
            self.attribute = attribute
        }

    }

    public struct GetPasswordDataRequest: Serializable, Initializable {
        /// The ID of the Windows instance.
        var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

    }

    public struct ReportInstanceStatusRequest: Serializable, Initializable {
        /// The time at which the reported instance health state began.
        var startTime: Date? = nil
        /// The status of all instances listed.
        var status: String = ""
        /// The time at which the reported instance health state ended.
        var endTime: Date? = nil
        /// One or more instances.
        var instances: [String] = []
        /// One or more reason codes that describes the health state of your instance.    instance-stuck-in-state: My instance is stuck in a state.    unresponsive: My instance is unresponsive.    not-accepting-credentials: My instance is not accepting my credentials.    password-not-available: A password is not available for my instance.    performance-network: My instance is experiencing performance problems which I believe are network related.    performance-instance-store: My instance is experiencing performance problems which I believe are related to the instance stores.    performance-ebs-volume: My instance is experiencing performance problems which I believe are related to an EBS volume.    performance-other: My instance is experiencing performance problems.    other: [explain using the description parameter]  
        var reasonCodes: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Descriptive text about the health state of your instance.
        var description: String? = nil

        public init() {}

        public init(startTime: Date? = nil, status: String, endTime: Date? = nil, instances: [String], reasonCodes: [String], dryRun: Bool? = nil, description: String? = nil) {
            self.startTime = startTime
            self.status = status
            self.endTime = endTime
            self.instances = instances
            self.reasonCodes = reasonCodes
            self.dryRun = dryRun
            self.description = description
        }

    }

    public struct AllocateHostsResult: Serializable, Initializable {
        /// The ID of the allocated Dedicated Host. This is used when you want to launch an instance onto a specific host.
        var hostIds: [String]? = nil

        public init() {}

        public init(hostIds: [String]? = nil) {
            self.hostIds = hostIds
        }

    }

    public struct Tag: Serializable, Initializable {
        /// The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        var value: String? = nil
        /// The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws: 
        var key: String? = nil

        public init() {}

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

    }

    public struct DescribeRegionsRequest: Serializable, Initializable {
        /// The names of one or more regions.
        var regionNames: [String]? = nil
        /// One or more filters.    endpoint - The endpoint of the region (for example, ec2.us-east-1.amazonaws.com).    region-name - The name of the region (for example, us-east-1).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(regionNames: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.regionNames = regionNames
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct TagDescription: Serializable, Initializable {
        /// The tag key.
        var key: String? = nil
        /// The ID of the resource. For example, ami-1a2b3c4d.
        var resourceId: String? = nil
        /// The tag value.
        var value: String? = nil
        /// The resource type.
        var resourceType: String? = nil

        public init() {}

        public init(key: String? = nil, resourceId: String? = nil, value: String? = nil, resourceType: String? = nil) {
            self.key = key
            self.resourceId = resourceId
            self.value = value
            self.resourceType = resourceType
        }

    }

    public struct ProvisionedBandwidth: Serializable, Initializable {
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        var provisioned: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        var status: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        var requestTime: Date? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        var provisionTime: Date? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        var requested: String? = nil

        public init() {}

        public init(provisioned: String? = nil, status: String? = nil, requestTime: Date? = nil, provisionTime: Date? = nil, requested: String? = nil) {
            self.provisioned = provisioned
            self.status = status
            self.requestTime = requestTime
            self.provisionTime = provisionTime
            self.requested = requested
        }

    }

    public struct DescribeSnapshotAttributeRequest: Serializable, Initializable {
        /// The ID of the EBS snapshot.
        var snapshotId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The snapshot attribute you would like to view.
        var attribute: String = ""

        public init() {}

        public init(snapshotId: String, dryRun: Bool? = nil, attribute: String) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.attribute = attribute
        }

    }

    public struct DescribeSpotDatafeedSubscriptionRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

    }

    public struct DescribeSnapshotAttributeResult: Serializable, Initializable {
        /// A list of permissions for creating volumes from the snapshot.
        var createVolumePermissions: [CreateVolumePermission]? = nil
        /// A list of product codes.
        var productCodes: [ProductCode]? = nil
        /// The ID of the EBS snapshot.
        var snapshotId: String? = nil

        public init() {}

        public init(createVolumePermissions: [CreateVolumePermission]? = nil, productCodes: [ProductCode]? = nil, snapshotId: String? = nil) {
            self.createVolumePermissions = createVolumePermissions
            self.productCodes = productCodes
            self.snapshotId = snapshotId
        }

    }

    public struct RecurringCharge: Serializable, Initializable {
        /// The frequency of the recurring charge.
        var frequency: String? = nil
        /// The amount of the recurring charge.
        var amount: Double? = nil

        public init() {}

        public init(frequency: String? = nil, amount: Double? = nil) {
            self.frequency = frequency
            self.amount = amount
        }

    }

    public struct DeleteVpcPeeringConnectionRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct DescribeAvailabilityZonesRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The names of one or more Availability Zones.
        var zoneNames: [String]? = nil
        /// One or more filters.    message - Information about the Availability Zone.    region-name - The name of the region for the Availability Zone (for example, us-east-1).    state - The state of the Availability Zone (available | information | impaired | unavailable).    zone-name - The name of the Availability Zone (for example, us-east-1a).  
        var filters: [Filter]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, zoneNames: [String]? = nil, filters: [Filter]? = nil) {
            self.dryRun = dryRun
            self.zoneNames = zoneNames
            self.filters = filters
        }

    }

    public struct AssociateRouteTableResult: Serializable, Initializable {
        /// The route table association ID (needed to disassociate the route table).
        var associationId: String? = nil

        public init() {}

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

    }

    public struct IcmpTypeCode: Serializable, Initializable {
        /// The ICMP type. A value of -1 means all types.
        var type: Int32? = nil
        /// The ICMP code. A value of -1 means all codes for the specified ICMP type.
        var code: Int32? = nil

        public init() {}

        public init(type: Int32? = nil, code: Int32? = nil) {
            self.type = type
            self.code = code
        }

    }

    public struct DeleteFlowLogsRequest: Serializable, Initializable {
        /// One or more flow log IDs.
        var flowLogIds: [String] = []

        public init() {}

        public init(flowLogIds: [String]) {
            self.flowLogIds = flowLogIds
        }

    }

    public struct DescribeVpnConnectionsRequest: Serializable, Initializable {
        /// One or more VPN connection IDs. Default: Describes your VPN connections.
        var vpnConnectionIds: [String]? = nil
        /// One or more filters.    customer-gateway-configuration - The configuration information for the customer gateway.    customer-gateway-id - The ID of a customer gateway associated with the VPN connection.    state - The state of the VPN connection (pending | available | deleting | deleted).    option.static-routes-only - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).    route.destination-cidr-block - The destination CIDR block. This corresponds to the subnet used in a customer data center.    bgp-asn - The BGP Autonomous System Number (ASN) associated with a BGP device.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of VPN connection. Currently the only supported type is ipsec.1.    vpn-connection-id - The ID of the VPN connection.    vpn-gateway-id - The ID of a virtual private gateway associated with the VPN connection.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpnConnectionIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.vpnConnectionIds = vpnConnectionIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct ReservedInstanceLimitPrice: Serializable, Initializable {
        /// The currency in which the limitPrice amount is specified. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).
        var amount: Double? = nil

        public init() {}

        public init(currencyCode: String? = nil, amount: Double? = nil) {
            self.currencyCode = currencyCode
            self.amount = amount
        }

    }

    public struct NewDhcpConfiguration: Serializable, Initializable {
        var key: String? = nil
        var values: [String]? = nil

        public init() {}

        public init(key: String? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

    }

    public struct NetworkAclEntry: Serializable, Initializable {
        /// The IPv4 network range to allow or deny, in CIDR notation.
        var cidrBlock: String? = nil
        /// ICMP protocol: The ICMP type and code.
        var icmpTypeCode: IcmpTypeCode? = nil
        /// The rule number for the entry. ACL entries are processed in ascending order by rule number.
        var ruleNumber: Int32? = nil
        /// The protocol. A value of -1 means all protocols.
        var `protocol`: String? = nil
        /// Indicates whether to allow or deny the traffic that matches the rule.
        var ruleAction: String? = nil
        /// Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).
        var egress: Bool? = nil
        /// The IPv6 network range to allow or deny, in CIDR notation.
        var ipv6CidrBlock: String? = nil
        /// TCP or UDP protocols: The range of ports the rule applies to.
        var portRange: PortRange? = nil

        public init() {}

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32? = nil, protocol: String? = nil, ruleAction: String? = nil, egress: Bool? = nil, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

    }

    public struct Vpc: Serializable, Initializable {
        /// Indicates whether the VPC is the default VPC.
        var isDefault: Bool? = nil
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// The current state of the VPC.
        var state: String? = nil
        /// Any tags assigned to the VPC.
        var tags: [Tag]? = nil
        /// The ID of the set of DHCP options you've associated with the VPC (or default if the default options are associated with the VPC).
        var dhcpOptionsId: String? = nil
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        var ipv6CidrBlockAssociationSet: [VpcIpv6CidrBlockAssociation]? = nil
        /// The allowed tenancy of instances launched into the VPC.
        var instanceTenancy: String? = nil
        /// The IPv4 CIDR block for the VPC.
        var cidrBlock: String? = nil

        public init() {}

        public init(isDefault: Bool? = nil, vpcId: String? = nil, state: String? = nil, tags: [Tag]? = nil, dhcpOptionsId: String? = nil, ipv6CidrBlockAssociationSet: [VpcIpv6CidrBlockAssociation]? = nil, instanceTenancy: String? = nil, cidrBlock: String? = nil) {
            self.isDefault = isDefault
            self.vpcId = vpcId
            self.state = state
            self.tags = tags
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.instanceTenancy = instanceTenancy
            self.cidrBlock = cidrBlock
        }

    }

    public struct AvailabilityZoneMessage: Serializable, Initializable {
        /// The message about the Availability Zone.
        var message: String? = nil

        public init() {}

        public init(message: String? = nil) {
            self.message = message
        }

    }

    public struct DescribeStaleSecurityGroupsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the VPC.
        var vpcId: String = ""
        /// The token for the next set of items to return. (You received this token from a prior call.)
        var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.
        var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, vpcId: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct RestoreAddressToClassicRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The Elastic IP address.
        var publicIp: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, publicIp: String) {
            self.dryRun = dryRun
            self.publicIp = publicIp
        }

    }

    public struct RouteTable: Serializable, Initializable {
        /// The routes in the route table.
        var routes: [Route]? = nil
        /// Any virtual private gateway (VGW) propagating routes.
        var propagatingVgws: [PropagatingVgw]? = nil
        /// The ID of the route table.
        var routeTableId: String? = nil
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// Any tags assigned to the route table.
        var tags: [Tag]? = nil
        /// The associations between the route table and one or more subnets.
        var associations: [RouteTableAssociation]? = nil

        public init() {}

        public init(routes: [Route]? = nil, propagatingVgws: [PropagatingVgw]? = nil, routeTableId: String? = nil, vpcId: String? = nil, tags: [Tag]? = nil, associations: [RouteTableAssociation]? = nil) {
            self.routes = routes
            self.propagatingVgws = propagatingVgws
            self.routeTableId = routeTableId
            self.vpcId = vpcId
            self.tags = tags
            self.associations = associations
        }

    }

    public struct VolumeStatusEvent: Serializable, Initializable {
        /// The earliest start time of the event.
        var notBefore: Date? = nil
        /// The type of this event.
        var eventType: String? = nil
        /// The latest end time of the event.
        var notAfter: Date? = nil
        /// The ID of this event.
        var eventId: String? = nil
        /// A description of the event.
        var description: String? = nil

        public init() {}

        public init(notBefore: Date? = nil, eventType: String? = nil, notAfter: Date? = nil, eventId: String? = nil, description: String? = nil) {
            self.notBefore = notBefore
            self.eventType = eventType
            self.notAfter = notAfter
            self.eventId = eventId
            self.description = description
        }

    }

    public struct ModifyVpcEndpointRequest: Serializable, Initializable {
        /// One or more route tables IDs to associate with the endpoint.
        var addRouteTableIds: [String]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the endpoint.
        var vpcEndpointId: String = ""
        /// A policy document to attach to the endpoint. The policy must be in valid JSON format.
        var policyDocument: String? = nil
        /// Specify true to reset the policy document to the default policy. The default policy allows access to the service.
        var resetPolicy: Bool? = nil
        /// One or more route table IDs to disassociate from the endpoint.
        var removeRouteTableIds: [String]? = nil

        public init() {}

        public init(addRouteTableIds: [String]? = nil, dryRun: Bool? = nil, vpcEndpointId: String, policyDocument: String? = nil, resetPolicy: Bool? = nil, removeRouteTableIds: [String]? = nil) {
            self.addRouteTableIds = addRouteTableIds
            self.dryRun = dryRun
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = policyDocument
            self.resetPolicy = resetPolicy
            self.removeRouteTableIds = removeRouteTableIds
        }

    }

    public struct VpcClassicLink: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// Any tags assigned to the VPC.
        var tags: [Tag]? = nil
        /// Indicates whether the VPC is enabled for ClassicLink.
        var classicLinkEnabled: Bool? = nil

        public init() {}

        public init(vpcId: String? = nil, tags: [Tag]? = nil, classicLinkEnabled: Bool? = nil) {
            self.vpcId = vpcId
            self.tags = tags
            self.classicLinkEnabled = classicLinkEnabled
        }

    }

    public struct DisassociateIamInstanceProfileRequest: Serializable, Initializable {
        /// The ID of the IAM instance profile association.
        var associationId: String = ""

        public init() {}

        public init(associationId: String) {
            self.associationId = associationId
        }

    }

    public struct DescribeHostReservationOfferingsResult: Serializable, Initializable {
        /// Information about the offerings.
        var offeringSet: [HostOffering]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(offeringSet: [HostOffering]? = nil, nextToken: String? = nil) {
            self.offeringSet = offeringSet
            self.nextToken = nextToken
        }

    }

    public struct VpcCidrBlockState: Serializable, Initializable {
        /// The state of the CIDR block.
        var state: String? = nil
        /// A message about the status of the CIDR block, if applicable.
        var statusMessage: String? = nil

        public init() {}

        public init(state: String? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

    }

    public struct NetworkAclAssociation: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// The ID of the association between a network ACL and a subnet.
        var networkAclAssociationId: String? = nil
        /// The ID of the network ACL.
        var networkAclId: String? = nil

        public init() {}

        public init(subnetId: String? = nil, networkAclAssociationId: String? = nil, networkAclId: String? = nil) {
            self.subnetId = subnetId
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
        }

    }

    public struct DeleteNatGatewayRequest: Serializable, Initializable {
        /// The ID of the NAT gateway.
        var natGatewayId: String = ""

        public init() {}

        public init(natGatewayId: String) {
            self.natGatewayId = natGatewayId
        }

    }

    public struct PurchaseScheduledInstancesResult: Serializable, Initializable {
        /// Information about the Scheduled Instances.
        var scheduledInstanceSet: [ScheduledInstance]? = nil

        public init() {}

        public init(scheduledInstanceSet: [ScheduledInstance]? = nil) {
            self.scheduledInstanceSet = scheduledInstanceSet
        }

    }

    public struct DescribeVolumeStatusResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// A list of volumes.
        var volumeStatuses: [VolumeStatusItem]? = nil

        public init() {}

        public init(nextToken: String? = nil, volumeStatuses: [VolumeStatusItem]? = nil) {
            self.nextToken = nextToken
            self.volumeStatuses = volumeStatuses
        }

    }

    public struct AvailableCapacity: Serializable, Initializable {
        /// The total number of instances that the Dedicated Host supports.
        var availableInstanceCapacity: [InstanceCapacity]? = nil
        /// The number of vCPUs available on the Dedicated Host.
        var availableVCpus: Int32? = nil

        public init() {}

        public init(availableInstanceCapacity: [InstanceCapacity]? = nil, availableVCpus: Int32? = nil) {
            self.availableInstanceCapacity = availableInstanceCapacity
            self.availableVCpus = availableVCpus
        }

    }

    public struct SpotPrice: Serializable, Initializable {
        /// The date and time the request was created, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var timestamp: Date? = nil
        /// The instance type. Note that T2 and HS1 instance types are not supported.
        var instanceType: String? = nil
        /// The Availability Zone.
        var availabilityZone: String? = nil
        /// The maximum price (bid) that you are willing to pay for a Spot instance.
        var spotPrice: String? = nil
        /// A general description of the AMI.
        var productDescription: String? = nil

        public init() {}

        public init(timestamp: Date? = nil, instanceType: String? = nil, availabilityZone: String? = nil, spotPrice: String? = nil, productDescription: String? = nil) {
            self.timestamp = timestamp
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.spotPrice = spotPrice
            self.productDescription = productDescription
        }

    }

    public struct ReservedInstancesConfiguration: Serializable, Initializable {
        /// The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.
        var platform: String? = nil
        /// The number of modified Reserved Instances.
        var instanceCount: Int32? = nil
        /// The instance type for the modified Reserved Instances.
        var instanceType: String? = nil
        /// The Availability Zone for the modified Reserved Instances.
        var availabilityZone: String? = nil
        /// Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.
        var scope: String? = nil

        public init() {}

        public init(platform: String? = nil, instanceCount: Int32? = nil, instanceType: String? = nil, availabilityZone: String? = nil, scope: String? = nil) {
            self.platform = platform
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.availabilityZone = availabilityZone
            self.scope = scope
        }

    }

    public struct CreatePlacementGroupRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The placement strategy.
        var strategy: String = ""
        /// A name for the placement group. Constraints: Up to 255 ASCII characters
        var groupName: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, strategy: String, groupName: String) {
            self.dryRun = dryRun
            self.strategy = strategy
            self.groupName = groupName
        }

    }

    public struct DescribeSecurityGroupReferencesRequest: Serializable, Initializable {
        /// One or more security group IDs in your account.
        var groupId: [String] = []
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(groupId: [String], dryRun: Bool? = nil) {
            self.groupId = groupId
            self.dryRun = dryRun
        }

    }

    public struct DescribeVolumesModificationsRequest: Serializable, Initializable {
        /// One or more volume IDs for which in-progress modifications will be described.
        var volumeIds: [String]? = nil
        /// One or more filters. Supported filters: volume-id, modification-state, target-size, target-iops, target-volume-type, original-size, original-iops, original-volume-type, start-time. 
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The nextToken value returned by a previous paginated request.
        var nextToken: String? = nil
        /// The maximum number of results (up to a limit of 500) to be returned in a paginated request.
        var maxResults: Int32? = nil

        public init() {}

        public init(volumeIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct ImageAttribute: Serializable, Initializable {
        /// One or more block device mapping entries.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// One or more product codes.
        var productCodes: [ProductCode]? = nil
        /// One or more launch permissions.
        var launchPermissions: [LaunchPermission]? = nil
        /// Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        var sriovNetSupport: AttributeValue? = nil
        /// The kernel ID.
        var kernelId: AttributeValue? = nil
        /// The ID of the AMI.
        var imageId: String? = nil
        /// The RAM disk ID.
        var ramdiskId: AttributeValue? = nil
        /// A description for the AMI.
        var description: AttributeValue? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, productCodes: [ProductCode]? = nil, launchPermissions: [LaunchPermission]? = nil, sriovNetSupport: AttributeValue? = nil, kernelId: AttributeValue? = nil, imageId: String? = nil, ramdiskId: AttributeValue? = nil, description: AttributeValue? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.productCodes = productCodes
            self.launchPermissions = launchPermissions
            self.sriovNetSupport = sriovNetSupport
            self.kernelId = kernelId
            self.imageId = imageId
            self.ramdiskId = ramdiskId
            self.description = description
        }

    }

    public struct CreateInstanceExportTaskRequest: Serializable, Initializable {
        /// The target virtualization environment.
        var targetEnvironment: String? = nil
        /// The format and location for an instance export task.
        var exportToS3Task: ExportToS3TaskSpecification? = nil
        /// The ID of the instance.
        var instanceId: String = ""
        /// A description for the conversion task or the resource being exported. The maximum length is 255 bytes.
        var description: String? = nil

        public init() {}

        public init(targetEnvironment: String? = nil, exportToS3Task: ExportToS3TaskSpecification? = nil, instanceId: String, description: String? = nil) {
            self.targetEnvironment = targetEnvironment
            self.exportToS3Task = exportToS3Task
            self.instanceId = instanceId
            self.description = description
        }

    }

    public struct CreateFlowLogsRequest: Serializable, Initializable {
        /// The type of traffic to log.
        var trafficType: String = ""
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see How to Ensure Idempotency.
        var clientToken: String? = nil
        /// One or more subnet, network interface, or VPC IDs. Constraints: Maximum of 1000 resources
        var resourceIds: [String] = []
        /// The ARN for the IAM role that's used to post flow logs to a CloudWatch Logs log group.
        var deliverLogsPermissionArn: String = ""
        /// The type of resource on which to create the flow log.
        var resourceType: String = ""
        /// The name of the CloudWatch log group.
        var logGroupName: String = ""

        public init() {}

        public init(trafficType: String, clientToken: String? = nil, resourceIds: [String], deliverLogsPermissionArn: String, resourceType: String, logGroupName: String) {
            self.trafficType = trafficType
            self.clientToken = clientToken
            self.resourceIds = resourceIds
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            self.resourceType = resourceType
            self.logGroupName = logGroupName
        }

    }

    public struct ImportImageTask: Serializable, Initializable {
        /// The license type of the virtual machine.
        var licenseType: String? = nil
        /// A brief status for the import image task.
        var status: String? = nil
        /// The description string for the import image task.
        var platform: String? = nil
        /// The percentage of progress of the import image task.
        var progress: String? = nil
        /// The target hypervisor for the import task. Valid values: xen 
        var hypervisor: String? = nil
        /// The architecture of the virtual machine. Valid values: i386 | x86_64 
        var architecture: String? = nil
        /// The ID of the Amazon Machine Image (AMI) of the imported virtual machine.
        var imageId: String? = nil
        /// The ID of the import image task.
        var importTaskId: String? = nil
        /// A descriptive status message for the import image task.
        var statusMessage: String? = nil
        /// Information about the snapshots.
        var snapshotDetails: [SnapshotDetail]? = nil
        /// A description of the import task.
        var description: String? = nil

        public init() {}

        public init(licenseType: String? = nil, status: String? = nil, platform: String? = nil, progress: String? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, importTaskId: String? = nil, statusMessage: String? = nil, snapshotDetails: [SnapshotDetail]? = nil, description: String? = nil) {
            self.licenseType = licenseType
            self.status = status
            self.platform = platform
            self.progress = progress
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.importTaskId = importTaskId
            self.statusMessage = statusMessage
            self.snapshotDetails = snapshotDetails
            self.description = description
        }

    }

    public struct DescribeVolumesResult: Serializable, Initializable {
        /// Information about the volumes.
        var volumes: [Volume]? = nil
        /// The NextToken value to include in a future DescribeVolumes request. When the results of a DescribeVolumes request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(volumes: [Volume]? = nil, nextToken: String? = nil) {
            self.volumes = volumes
            self.nextToken = nextToken
        }

    }

    public struct ModifyInstancePlacementRequest: Serializable, Initializable {
        /// The new affinity setting for the instance.
        var affinity: String? = nil
        /// The ID of the Dedicated Host that the instance will have affinity with.
        var hostId: String? = nil
        /// The ID of the instance that you are modifying.
        var instanceId: String = ""
        /// The tenancy of the instance that you are modifying.
        var tenancy: String? = nil

        public init() {}

        public init(affinity: String? = nil, hostId: String? = nil, instanceId: String, tenancy: String? = nil) {
            self.affinity = affinity
            self.hostId = hostId
            self.instanceId = instanceId
            self.tenancy = tenancy
        }

    }

    public struct ScheduledInstancesLaunchSpecification: Serializable, Initializable {
        /// One or more block device mapping entries.
        var blockDeviceMappings: [ScheduledInstancesBlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instances.
        var subnetId: String? = nil
        /// The base64-encoded MIME user data.
        var userData: String? = nil
        /// Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false 
        var ebsOptimized: Bool? = nil
        /// The IDs of one or more security groups.
        var securityGroupIds: [String]? = nil
        /// The ID of the kernel.
        var kernelId: String? = nil
        /// Enable or disable monitoring for the instances.
        var monitoring: ScheduledInstancesMonitoring? = nil
        /// The instance type.
        var instanceType: String? = nil
        /// The name of the key pair.
        var keyName: String? = nil
        /// The IAM instance profile.
        var iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil
        /// The ID of the Amazon Machine Image (AMI).
        var imageId: String = ""
        /// One or more network interfaces.
        var networkInterfaces: [ScheduledInstancesNetworkInterface]? = nil
        /// The placement information.
        var placement: ScheduledInstancesPlacement? = nil
        /// The ID of the RAM disk.
        var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [ScheduledInstancesBlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, securityGroupIds: [String]? = nil, kernelId: String? = nil, monitoring: ScheduledInstancesMonitoring? = nil, instanceType: String? = nil, keyName: String? = nil, iamInstanceProfile: ScheduledInstancesIamInstanceProfile? = nil, imageId: String, networkInterfaces: [ScheduledInstancesNetworkInterface]? = nil, placement: ScheduledInstancesPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.securityGroupIds = securityGroupIds
            self.kernelId = kernelId
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.keyName = keyName
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

    }

    public struct DisableVpcClassicLinkRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

    }

    public struct MoveAddressToVpcResult: Serializable, Initializable {
        /// The status of the move of the IP address.
        var status: String? = nil
        /// The allocation ID for the Elastic IP address.
        var allocationId: String? = nil

        public init() {}

        public init(status: String? = nil, allocationId: String? = nil) {
            self.status = status
            self.allocationId = allocationId
        }

    }

    public struct DeleteVpnConnectionRequest: Serializable, Initializable {
        /// The ID of the VPN connection.
        var vpnConnectionId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpnConnectionId: String, dryRun: Bool? = nil) {
            self.vpnConnectionId = vpnConnectionId
            self.dryRun = dryRun
        }

    }

    public struct CreateVolumePermission: Serializable, Initializable {
        /// The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.
        var userId: String? = nil
        /// The specific group that is to be added or removed from a volume's list of create volume permissions.
        var group: String? = nil

        public init() {}

        public init(userId: String? = nil, group: String? = nil) {
            self.userId = userId
            self.group = group
        }

    }

    public struct CustomerGateway: Serializable, Initializable {
        /// The ID of the customer gateway.
        var customerGatewayId: String? = nil
        /// The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).
        var bgpAsn: String? = nil
        /// The type of VPN connection the customer gateway supports (ipsec.1).
        var type: String? = nil
        /// Any tags assigned to the customer gateway.
        var tags: [Tag]? = nil
        /// The current state of the customer gateway (pending | available | deleting | deleted).
        var state: String? = nil
        /// The Internet-routable IP address of the customer gateway's outside interface.
        var ipAddress: String? = nil

        public init() {}

        public init(customerGatewayId: String? = nil, bgpAsn: String? = nil, type: String? = nil, tags: [Tag]? = nil, state: String? = nil, ipAddress: String? = nil) {
            self.customerGatewayId = customerGatewayId
            self.bgpAsn = bgpAsn
            self.type = type
            self.tags = tags
            self.state = state
            self.ipAddress = ipAddress
        }

    }

    public struct DescribeAccountAttributesRequest: Serializable, Initializable {
        /// One or more account attribute names.
        var attributeNames: [String]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(attributeNames: [String]? = nil, dryRun: Bool? = nil) {
            self.attributeNames = attributeNames
            self.dryRun = dryRun
        }

    }

    public struct CreateVpnGatewayRequest: Serializable, Initializable {
        /// The type of VPN connection this virtual private gateway supports.
        var type: String = ""
        /// The Availability Zone for the virtual private gateway.
        var availabilityZone: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(type: String, availabilityZone: String? = nil, dryRun: Bool? = nil) {
            self.type = type
            self.availabilityZone = availabilityZone
            self.dryRun = dryRun
        }

    }

    public struct DeleteSpotDatafeedSubscriptionRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

    }

    public struct Route: Serializable, Initializable {
        /// The ID of the egress-only Internet gateway.
        var egressOnlyInternetGatewayId: String? = nil
        /// The ID of a NAT gateway.
        var natGatewayId: String? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// Describes how the route was created.    CreateRouteTable - The route was automatically created when the route table was created.    CreateRoute - The route was manually added to the route table.    EnableVgwRoutePropagation - The route was propagated by route propagation.  
        var origin: String? = nil
        /// The state of the route. The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).
        var state: String? = nil
        /// The IPv6 CIDR block used for the destination match.
        var destinationIpv6CidrBlock: String? = nil
        /// The prefix of the AWS service.
        var destinationPrefixListId: String? = nil
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String? = nil
        /// The ID of a NAT instance in your VPC.
        var instanceId: String? = nil
        /// The AWS account ID of the owner of the instance.
        var instanceOwnerId: String? = nil
        /// The ID of a gateway attached to your VPC.
        var gatewayId: String? = nil
        /// The IPv4 CIDR block used for the destination match.
        var destinationCidrBlock: String? = nil

        public init() {}

        public init(egressOnlyInternetGatewayId: String? = nil, natGatewayId: String? = nil, networkInterfaceId: String? = nil, origin: String? = nil, state: String? = nil, destinationIpv6CidrBlock: String? = nil, destinationPrefixListId: String? = nil, vpcPeeringConnectionId: String? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, gatewayId: String? = nil, destinationCidrBlock: String? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.origin = origin
            self.state = state
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.gatewayId = gatewayId
            self.destinationCidrBlock = destinationCidrBlock
        }

    }

    public struct CancelSpotFleetRequestsResponse: Serializable, Initializable {
        /// Information about the Spot fleet requests that are successfully canceled.
        var successfulFleetRequests: [CancelSpotFleetRequestsSuccessItem]? = nil
        /// Information about the Spot fleet requests that are not successfully canceled.
        var unsuccessfulFleetRequests: [CancelSpotFleetRequestsErrorItem]? = nil

        public init() {}

        public init(successfulFleetRequests: [CancelSpotFleetRequestsSuccessItem]? = nil, unsuccessfulFleetRequests: [CancelSpotFleetRequestsErrorItem]? = nil) {
            self.successfulFleetRequests = successfulFleetRequests
            self.unsuccessfulFleetRequests = unsuccessfulFleetRequests
        }

    }

    public struct DeleteSecurityGroupRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the security group. Required for a nondefault VPC.
        var groupId: String? = nil
        /// [EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.
        var groupName: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, groupId: String? = nil, groupName: String? = nil) {
            self.dryRun = dryRun
            self.groupId = groupId
            self.groupName = groupName
        }

    }

    public struct CreateVpcResult: Serializable, Initializable {
        /// Information about the VPC.
        var vpc: Vpc? = nil

        public init() {}

        public init(vpc: Vpc? = nil) {
            self.vpc = vpc
        }

    }

    public struct DescribeInstancesRequest: Serializable, Initializable {
        /// One or more filters.    affinity - The affinity setting for an instance running on a Dedicated Host (default | host).    architecture - The instance architecture (i386 | x86_64).    association.public-ip - The address of the Elastic IP address (IPv4) bound to the network interface.    association.ip-owner-id - The owner of the Elastic IP address (IPv4) associated with the network interface.    association.allocation-id - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.    association.association-id - The association ID returned when the network interface was associated with an IPv4 address.    availability-zone - The Availability Zone of the instance.    block-device-mapping.attach-time - The attach time for an EBS volume mapped to the instance, for example, 2010-09-15T17:15:20.000Z.    block-device-mapping.delete-on-termination - A Boolean that indicates whether the EBS volume is deleted on instance termination.    block-device-mapping.device-name - The device name for the EBS volume (for example, /dev/sdh or xvdh).    block-device-mapping.status - The status for the EBS volume (attaching | attached | detaching | detached).    block-device-mapping.volume-id - The volume ID of the EBS volume.    client-token - The idempotency token you provided when you launched the instance.    dns-name - The public DNS name of the instance.    group-id - The ID of the security group for the instance. EC2-Classic only.    group-name - The name of the security group for the instance. EC2-Classic only.    host-id - The ID of the Dedicated Host on which the instance is running, if applicable.    hypervisor - The hypervisor type of the instance (ovm | xen).    iam-instance-profile.arn - The instance profile associated with the instance. Specified as an ARN.    image-id - The ID of the image used to launch the instance.    instance-id - The ID of the instance.    instance-lifecycle - Indicates whether this is a Spot Instance or a Scheduled Instance (spot | scheduled).    instance-state-code - The state of the instance, as a 16-bit unsigned integer. The high byte is an opaque internal value and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).    instance-state-name - The state of the instance (pending | running | shutting-down | terminated | stopping | stopped).    instance-type - The type of instance (for example, t2.micro).    instance.group-id - The ID of the security group for the instance.     instance.group-name - The name of the security group for the instance.     ip-address - The public IPv4 address of the instance.    kernel-id - The kernel ID.    key-name - The name of the key pair used when the instance was launched.    launch-index - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on).     launch-time - The time when the instance was launched.    monitoring-state - Indicates whether detailed monitoring is enabled (disabled | enabled).    network-interface.addresses.private-ip-address - The private IPv4 address associated with the network interface.    network-interface.addresses.primary - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.    network-interface.addresses.association.public-ip - The ID of the association of an Elastic IP address (IPv4) with a network interface.    network-interface.addresses.association.ip-owner-id - The owner ID of the private IPv4 address associated with the network interface.    network-interface.attachment.attachment-id - The ID of the interface attachment.    network-interface.attachment.instance-id - The ID of the instance to which the network interface is attached.    network-interface.attachment.instance-owner-id - The owner ID of the instance to which the network interface is attached.    network-interface.attachment.device-index - The device index to which the network interface is attached.    network-interface.attachment.status - The status of the attachment (attaching | attached | detaching | detached).    network-interface.attachment.attach-time - The time that the network interface was attached to an instance.    network-interface.attachment.delete-on-termination - Specifies whether the attachment is deleted when an instance is terminated.    network-interface.availability-zone - The Availability Zone for the network interface.    network-interface.description - The description of the network interface.    network-interface.group-id - The ID of a security group associated with the network interface.    network-interface.group-name - The name of a security group associated with the network interface.    network-interface.ipv6-addresses.ipv6-address - The IPv6 address associated with the network interface.    network-interface.mac-address - The MAC address of the network interface.    network-interface.network-interface-id - The ID of the network interface.    network-interface.owner-id - The ID of the owner of the network interface.    network-interface.private-dns-name - The private DNS name of the network interface.    network-interface.requester-id - The requester ID for the network interface.    network-interface.requester-managed - Indicates whether the network interface is being managed by AWS.    network-interface.status - The status of the network interface (available) | in-use).    network-interface.source-dest-check - Whether the network interface performs source/destination checking. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the network interface to perform network address translation (NAT) in your VPC.    network-interface.subnet-id - The ID of the subnet for the network interface.    network-interface.vpc-id - The ID of the VPC for the network interface.    owner-id - The AWS account ID of the instance owner.    placement-group-name - The name of the placement group for the instance.    platform - The platform. Use windows if you have Windows instances; otherwise, leave blank.    private-dns-name - The private IPv4 DNS name of the instance.    private-ip-address - The private IPv4 address of the instance.    product-code - The product code associated with the AMI used to launch the instance.    product-code.type - The type of product code (devpay | marketplace).    ramdisk-id - The RAM disk ID.    reason - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.    requester-id - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).    reservation-id - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you'll get one reservation ID. If you launch ten instances using the same launch request, you'll also get one reservation ID.    root-device-name - The name of the root device for the instance (for example, /dev/sda1 or /dev/xvda).    root-device-type - The type of root device that the instance uses (ebs | instance-store).    source-dest-check - Indicates whether the instance performs source/destination checking. A value of true means that checking is enabled, and false means checking is disabled. The value must be false for the instance to perform network address translation (NAT) in your VPC.     spot-instance-request-id - The ID of the Spot instance request.    state-reason-code - The reason code for the state change.    state-reason-message - A message that describes the state change.    subnet-id - The ID of the subnet for the instance.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    tenancy - The tenancy of an instance (dedicated | default | host).    virtualization-type - The virtualization type of the instance (paravirtual | hvm).    vpc-id - The ID of the VPC that the instance is running in.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more instance IDs. Default: Describes all your instances.
        var instanceIds: [String]? = nil
        /// The token to request the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter or tag filters in the same call.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, instanceIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DescribeScheduledInstancesResult: Serializable, Initializable {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Information about the Scheduled Instances.
        var scheduledInstanceSet: [ScheduledInstance]? = nil

        public init() {}

        public init(nextToken: String? = nil, scheduledInstanceSet: [ScheduledInstance]? = nil) {
            self.nextToken = nextToken
            self.scheduledInstanceSet = scheduledInstanceSet
        }

    }

    public struct DeleteNetworkAclEntryRequest: Serializable, Initializable {
        /// The ID of the network ACL.
        var networkAclId: String = ""
        /// The rule number of the entry to delete.
        var ruleNumber: Int32 = 0
        /// Indicates whether the rule is an egress rule.
        var egress: Bool = false
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(networkAclId: String, ruleNumber: Int32, egress: Bool, dryRun: Bool? = nil) {
            self.networkAclId = networkAclId
            self.ruleNumber = ruleNumber
            self.egress = egress
            self.dryRun = dryRun
        }

    }

    public struct ResetSnapshotAttributeRequest: Serializable, Initializable {
        /// The ID of the snapshot.
        var snapshotId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.
        var attribute: String = ""

        public init() {}

        public init(snapshotId: String, dryRun: Bool? = nil, attribute: String) {
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.attribute = attribute
        }

    }

    public struct VpnGateway: Serializable, Initializable {
        /// Any VPCs attached to the virtual private gateway.
        var vpcAttachments: [VpcAttachment]? = nil
        /// The ID of the virtual private gateway.
        var vpnGatewayId: String? = nil
        /// The type of VPN connection the virtual private gateway supports.
        var type: String? = nil
        /// The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.
        var availabilityZone: String? = nil
        /// Any tags assigned to the virtual private gateway.
        var tags: [Tag]? = nil
        /// The current state of the virtual private gateway.
        var state: String? = nil

        public init() {}

        public init(vpcAttachments: [VpcAttachment]? = nil, vpnGatewayId: String? = nil, type: String? = nil, availabilityZone: String? = nil, tags: [Tag]? = nil, state: String? = nil) {
            self.vpcAttachments = vpcAttachments
            self.vpnGatewayId = vpnGatewayId
            self.type = type
            self.availabilityZone = availabilityZone
            self.tags = tags
            self.state = state
        }

    }

    public struct CancelSpotFleetRequestsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Indicates whether to terminate instances for a Spot fleet request if it is canceled successfully.
        var terminateInstances: Bool = false
        /// The IDs of the Spot fleet requests.
        var spotFleetRequestIds: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, terminateInstances: Bool, spotFleetRequestIds: [String]) {
            self.dryRun = dryRun
            self.terminateInstances = terminateInstances
            self.spotFleetRequestIds = spotFleetRequestIds
        }

    }

    public struct DescribeVolumeStatusRequest: Serializable, Initializable {
        /// One or more volume IDs. Default: Describes all your volumes.
        var volumeIds: [String]? = nil
        /// One or more filters.    action.code - The action code for the event (for example, enable-volume-io).    action.description - A description of the action.    action.event-id - The event ID associated with the action.    availability-zone - The Availability Zone of the instance.    event.description - A description of the event.    event.event-id - The event ID.    event.event-type - The event type (for io-enabled: passed | failed; for io-performance: io-performance:degraded | io-performance:severely-degraded | io-performance:stalled).    event.not-after - The latest end time for the event.    event.not-before - The earliest start time for the event.    volume-status.details-name - The cause for volume-status.status (io-enabled | io-performance).    volume-status.details-status - The status of volume-status.details-name (for io-enabled: passed | failed; for io-performance: normal | degraded | severely-degraded | stalled).    volume-status.status - The status of the volume (ok | impaired | warning | insufficient-data).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The NextToken value to include in a future DescribeVolumeStatus request. When the results of the request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The maximum number of volume results returned by DescribeVolumeStatus in paginated output. When this parameter is used, the request only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then DescribeVolumeStatus returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.
        var maxResults: Int32? = nil

        public init() {}

        public init(volumeIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DescribeSecurityGroupsRequest: Serializable, Initializable {
        /// One or more security group IDs. Required for security groups in a nondefault VPC. Default: Describes all your security groups.
        var groupIds: [String]? = nil
        /// One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.    description - The description of the security group.    egress.ip-permission.prefix-list-id - The ID (prefix) of the AWS service to which the security group allows access.    group-id - The ID of the security group.     group-name - The name of the security group.    ip-permission.cidr - An IPv4 CIDR range that has been granted permission in a security group rule.    ip-permission.from-port - The start of port range for the TCP and UDP protocols, or an ICMP type number.    ip-permission.group-id - The ID of a security group that has been granted permission.    ip-permission.group-name - The name of a security group that has been granted permission.    ip-permission.ipv6-cidr - An IPv6 CIDR range that has been granted permission in a security group rule.    ip-permission.protocol - The IP protocol for the permission (tcp | udp | icmp or a protocol number).    ip-permission.to-port - The end of port range for the TCP and UDP protocols, or an ICMP code.    ip-permission.user-id - The ID of an AWS account that has been granted permission.    owner-id - The AWS account ID of the owner of the security group.    tag-key - The key of a tag assigned to the security group.    tag-value - The value of a tag assigned to the security group.    vpc-id - The ID of the VPC specified when the security group was created.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// [EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the group-name filter to describe security groups by name. Default: Describes all your security groups.
        var groupNames: [String]? = nil

        public init() {}

        public init(groupIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, groupNames: [String]? = nil) {
            self.groupIds = groupIds
            self.filters = filters
            self.dryRun = dryRun
            self.groupNames = groupNames
        }

    }

    public struct Snapshot: Serializable, Initializable {
        /// Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the DescribeSnapshots API operation.
        var stateMessage: String? = nil
        /// The snapshot state.
        var state: String? = nil
        /// Indicates whether the snapshot is encrypted.
        var encrypted: Bool? = nil
        /// Any tags assigned to the snapshot.
        var tags: [Tag]? = nil
        /// The ID of the volume that was used to create the snapshot. Snapshots created by the CopySnapshot action have an arbitrary volume ID that should not be used for any purpose.
        var volumeId: String? = nil
        /// The AWS account ID of the EBS snapshot owner.
        var ownerId: String? = nil
        /// The description for the snapshot.
        var description: String? = nil
        /// The time stamp when the snapshot was initiated.
        var startTime: Date? = nil
        /// The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the DescribeSnapshots API operation.
        var dataEncryptionKeyId: String? = nil
        /// The progress of the snapshot, as a percentage.
        var progress: String? = nil
        /// The ID of the snapshot. Each snapshot receives a unique identifier when it is created.
        var snapshotId: String? = nil
        /// The size of the volume, in GiB.
        var volumeSize: Int32? = nil
        ///  Value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. 
        var ownerAlias: String? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.
        var kmsKeyId: String? = nil

        public init() {}

        public init(stateMessage: String? = nil, state: String? = nil, encrypted: Bool? = nil, tags: [Tag]? = nil, volumeId: String? = nil, ownerId: String? = nil, description: String? = nil, startTime: Date? = nil, dataEncryptionKeyId: String? = nil, progress: String? = nil, snapshotId: String? = nil, volumeSize: Int32? = nil, ownerAlias: String? = nil, kmsKeyId: String? = nil) {
            self.stateMessage = stateMessage
            self.state = state
            self.encrypted = encrypted
            self.tags = tags
            self.volumeId = volumeId
            self.ownerId = ownerId
            self.description = description
            self.startTime = startTime
            self.dataEncryptionKeyId = dataEncryptionKeyId
            self.progress = progress
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.ownerAlias = ownerAlias
            self.kmsKeyId = kmsKeyId
        }

    }

    public struct DescribeVpcsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    cidr - The IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, /28).    dhcp-options-id - The ID of a set of DHCP options.    ipv6-cidr-block-association.ipv6-cidr-block - An IPv6 CIDR block associated with the VPC.    ipv6-cidr-block-association.association-id - The association ID for an IPv6 CIDR block associated with the VPC.    ipv6-cidr-block-association.state - The state of an IPv6 CIDR block associated with the VPC.    isDefault - Indicates whether the VPC is the default VPC.    state - The state of the VPC (pending | available).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC.  
        var filters: [Filter]? = nil
        /// One or more VPC IDs. Default: Describes all your VPCs.
        var vpcIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, vpcIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.vpcIds = vpcIds
        }

    }

    public struct DescribeIdFormatResult: Serializable, Initializable {
        /// Information about the ID format for the resource.
        var statuses: [IdFormat]? = nil

        public init() {}

        public init(statuses: [IdFormat]? = nil) {
            self.statuses = statuses
        }

    }

    public struct RegisterImageRequest: Serializable, Initializable {
        /// The billing product codes.
        var billingProducts: [String]? = nil
        /// One or more block device mapping entries.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI. There is no way to disable sriovNetSupport at this time. This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.
        var sriovNetSupport: String? = nil
        /// The name of the root device (for example, /dev/sda1, or /dev/xvda).
        var rootDeviceName: String? = nil
        /// The full path to your AMI manifest in Amazon S3 storage.
        var imageLocation: String? = nil
        /// The ID of the kernel.
        var kernelId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A description for your AMI.
        var description: String? = nil
        /// A name for your AMI. Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)
        var name: String = ""
        /// The architecture of the AMI. Default: For Amazon EBS-backed AMIs, i386. For instance store-backed AMIs, the architecture specified in the manifest file.
        var architecture: String? = nil
        /// Set to true to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI. This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.
        var enaSupport: Bool? = nil
        /// The type of virtualization. Default: paravirtual 
        var virtualizationType: String? = nil
        /// The ID of the RAM disk.
        var ramdiskId: String? = nil

        public init() {}

        public init(billingProducts: [String]? = nil, blockDeviceMappings: [BlockDeviceMapping]? = nil, sriovNetSupport: String? = nil, rootDeviceName: String? = nil, imageLocation: String? = nil, kernelId: String? = nil, dryRun: Bool? = nil, description: String? = nil, name: String, architecture: String? = nil, enaSupport: Bool? = nil, virtualizationType: String? = nil, ramdiskId: String? = nil) {
            self.billingProducts = billingProducts
            self.blockDeviceMappings = blockDeviceMappings
            self.sriovNetSupport = sriovNetSupport
            self.rootDeviceName = rootDeviceName
            self.imageLocation = imageLocation
            self.kernelId = kernelId
            self.dryRun = dryRun
            self.description = description
            self.name = name
            self.architecture = architecture
            self.enaSupport = enaSupport
            self.virtualizationType = virtualizationType
            self.ramdiskId = ramdiskId
        }

    }

    public struct DescribeMovingAddressesRequest: Serializable, Initializable {
        /// One or more Elastic IP addresses.
        var publicIps: [String]? = nil
        /// One or more filters.    moving-status - The status of the Elastic IP address (MovingToVpc | RestoringToClassic).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token to use to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value outside of this range, an error is returned. Default: If no value is provided, the default is 1000.
        var maxResults: Int32? = nil

        public init() {}

        public init(publicIps: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.publicIps = publicIps
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct MonitorInstancesResult: Serializable, Initializable {
        /// The monitoring information.
        var instanceMonitorings: [InstanceMonitoring]? = nil

        public init() {}

        public init(instanceMonitorings: [InstanceMonitoring]? = nil) {
            self.instanceMonitorings = instanceMonitorings
        }

    }

    public struct AssignIpv6AddressesResult: Serializable, Initializable {
        /// The IPv6 addresses assigned to the network interface.
        var assignedIpv6Addresses: [String]? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil

        public init() {}

        public init(assignedIpv6Addresses: [String]? = nil, networkInterfaceId: String? = nil) {
            self.assignedIpv6Addresses = assignedIpv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

    }

    public struct AssignPrivateIpAddressesRequest: Serializable, Initializable {
        /// Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.
        var allowReassignment: Bool? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.
        var secondaryPrivateIpAddressCount: Int32? = nil
        /// One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses. If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.
        var privateIpAddresses: [String]? = nil

        public init() {}

        public init(allowReassignment: Bool? = nil, networkInterfaceId: String, secondaryPrivateIpAddressCount: Int32? = nil, privateIpAddresses: [String]? = nil) {
            self.allowReassignment = allowReassignment
            self.networkInterfaceId = networkInterfaceId
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.privateIpAddresses = privateIpAddresses
        }

    }

    public struct RunInstancesRequest: Serializable, Initializable {
        /// If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to false after launch, use ModifyInstanceAttribute. Alternatively, if you set InstanceInitiatedShutdownBehavior to terminate, you can terminate the instance by running the shutdown command from the instance. Default: false 
        var disableApiTermination: Bool? = nil
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see Ensuring Idempotency. Constraints: Maximum 64 ASCII characters
        var clientToken: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false 
        var ebsOptimized: Bool? = nil
        /// The ID of the kernel.  We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see  PV-GRUB in the Amazon Elastic Compute Cloud User Guide. 
        var kernelId: String? = nil
        /// [EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        var ipv6AddressCount: Int32? = nil
        /// The instance type. For more information, see Instance Types in the Amazon Elastic Compute Cloud User Guide. Default: m1.small 
        var instanceType: String? = nil
        /// [EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.
        var privateIpAddress: String? = nil
        /// The name of the key pair. You can create a key pair using CreateKeyPair or ImportKeyPair.  If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in. 
        var keyName: String? = nil
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: stop 
        var instanceInitiatedShutdownBehavior: String? = nil
        /// [EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances. Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see How many instances can I run in Amazon EC2 in the Amazon EC2 General FAQ.
        var minCount: Int32 = 0
        /// The ID of the RAM disk.  We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see  PV-GRUB in the Amazon Elastic Compute Cloud User Guide. 
        var ramdiskId: String? = nil
        /// The block device mapping.  Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action. 
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// [EC2-VPC] The ID of the subnet to launch the instance into.
        var subnetId: String? = nil
        /// The user data to make available to the instance. For more information, see Running Commands on Your Linux Instance at Launch (Linux) and Adding User Data (Windows). If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var userData: String? = nil
        /// One or more security group IDs. You can create a security group using CreateSecurityGroup. Default: Amazon EC2 uses the default security group.
        var securityGroupIds: [String]? = nil
        /// The monitoring for the instance.
        var monitoring: RunInstancesMonitoringEnabled? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// [EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead. Default: Amazon EC2 uses the default security group.
        var securityGroups: [String]? = nil
        /// The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above MinCount. Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see How many instances can I run in Amazon EC2 in the Amazon EC2 FAQ.
        var maxCount: Int32 = 0
        /// Reserved.
        var additionalInfo: String? = nil
        /// The placement for the instance.
        var placement: Placement? = nil
        /// One or more network interfaces.
        var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The ID of the AMI, which you can get by calling DescribeImages.
        var imageId: String = ""

        public init() {}

        public init(disableApiTermination: Bool? = nil, clientToken: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, ipv6AddressCount: Int32? = nil, instanceType: String? = nil, privateIpAddress: String? = nil, keyName: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, instanceInitiatedShutdownBehavior: String? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, minCount: Int32, ramdiskId: String? = nil, blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, securityGroupIds: [String]? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, dryRun: Bool? = nil, securityGroups: [String]? = nil, maxCount: Int32, additionalInfo: String? = nil, placement: Placement? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, imageId: String) {
            self.disableApiTermination = disableApiTermination
            self.clientToken = clientToken
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.ipv6AddressCount = ipv6AddressCount
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.keyName = keyName
            self.iamInstanceProfile = iamInstanceProfile
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.ipv6Addresses = ipv6Addresses
            self.minCount = minCount
            self.ramdiskId = ramdiskId
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.securityGroupIds = securityGroupIds
            self.monitoring = monitoring
            self.dryRun = dryRun
            self.securityGroups = securityGroups
            self.maxCount = maxCount
            self.additionalInfo = additionalInfo
            self.placement = placement
            self.networkInterfaces = networkInterfaces
            self.imageId = imageId
        }

    }

    public struct SpotInstanceRequest: Serializable, Initializable {
        /// The Availability Zone in which the bid is launched.
        var launchedAvailabilityZone: String? = nil
        /// The ID of the Spot instance request.
        var spotInstanceRequestId: String? = nil
        /// The state of the Spot instance request. Spot bid status information can help you track your Spot instance requests. For more information, see Spot Bid Status in the Amazon Elastic Compute Cloud User Guide.
        var state: String? = nil
        /// The maximum hourly price (bid) for the Spot instance launched to fulfill the request.
        var spotPrice: String? = nil
        /// Any tags assigned to the resource.
        var tags: [Tag]? = nil
        /// The end date of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached.
        var validUntil: Date? = nil
        /// The fault codes for the Spot instance request, if any.
        var fault: SpotInstanceStateFault? = nil
        /// The product description associated with the Spot instance.
        var productDescription: String? = nil
        /// The Availability Zone group. If you specify the same Availability Zone group for all Spot instance requests, all Spot instances are launched in the same Availability Zone.
        var availabilityZoneGroup: String? = nil
        /// The status code and status message describing the Spot instance request.
        var status: SpotInstanceStatus? = nil
        /// The start date of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). The request becomes active at this date and time.
        var validFrom: Date? = nil
        /// The instance ID, if an instance has been launched to fulfill the Spot instance request.
        var instanceId: String? = nil
        /// If you specified a duration and your Spot instance request was fulfilled, this is the fixed hourly price in effect for the Spot instance while it runs.
        var actualBlockHourlyPrice: String? = nil
        /// The duration for the Spot instance, in minutes.
        var blockDurationMinutes: Int32? = nil
        /// Additional information for launching instances.
        var launchSpecification: LaunchSpecification? = nil
        /// The Spot instance request type.
        var type: String? = nil
        /// The instance launch group. Launch groups are Spot instances that launch together and terminate together.
        var launchGroup: String? = nil
        /// The date and time when the Spot instance request was created, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var createTime: Date? = nil

        public init() {}

        public init(launchedAvailabilityZone: String? = nil, spotInstanceRequestId: String? = nil, state: String? = nil, spotPrice: String? = nil, tags: [Tag]? = nil, validUntil: Date? = nil, fault: SpotInstanceStateFault? = nil, productDescription: String? = nil, availabilityZoneGroup: String? = nil, status: SpotInstanceStatus? = nil, validFrom: Date? = nil, instanceId: String? = nil, actualBlockHourlyPrice: String? = nil, blockDurationMinutes: Int32? = nil, launchSpecification: LaunchSpecification? = nil, type: String? = nil, launchGroup: String? = nil, createTime: Date? = nil) {
            self.launchedAvailabilityZone = launchedAvailabilityZone
            self.spotInstanceRequestId = spotInstanceRequestId
            self.state = state
            self.spotPrice = spotPrice
            self.tags = tags
            self.validUntil = validUntil
            self.fault = fault
            self.productDescription = productDescription
            self.availabilityZoneGroup = availabilityZoneGroup
            self.status = status
            self.validFrom = validFrom
            self.instanceId = instanceId
            self.actualBlockHourlyPrice = actualBlockHourlyPrice
            self.blockDurationMinutes = blockDurationMinutes
            self.launchSpecification = launchSpecification
            self.type = type
            self.launchGroup = launchGroup
            self.createTime = createTime
        }

    }

    public struct RebootInstancesRequest: Serializable, Initializable {
        /// One or more instance IDs.
        var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

    }

    public struct VpcPeeringConnectionStateReason: Serializable, Initializable {
        /// The status of the VPC peering connection.
        var code: String? = nil
        /// A message that provides more information about the status, if applicable.
        var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

    }

    public struct ScheduledInstance: Serializable, Initializable {
        /// The platform (Linux/UNIX or Windows).
        var platform: String? = nil
        /// The time that the previous schedule ended or will end.
        var previousSlotEndTime: Date? = nil
        /// The total number of hours for a single instance for the entire term.
        var totalScheduledInstanceHours: Int32? = nil
        /// The date when the Scheduled Instance was purchased.
        var createDate: Date? = nil
        /// The hourly price for a single instance.
        var hourlyPrice: String? = nil
        /// The instance type.
        var instanceType: String? = nil
        /// The number of hours in the schedule.
        var slotDurationInHours: Int32? = nil
        /// The Scheduled Instance ID.
        var scheduledInstanceId: String? = nil
        /// The Availability Zone.
        var availabilityZone: String? = nil
        /// The start date for the Scheduled Instance.
        var termStartDate: Date? = nil
        /// The end date for the Scheduled Instance.
        var termEndDate: Date? = nil
        /// The time for the next schedule to start.
        var nextSlotStartTime: Date? = nil
        /// The number of instances.
        var instanceCount: Int32? = nil
        /// The network platform (EC2-Classic or EC2-VPC).
        var networkPlatform: String? = nil
        /// The schedule recurrence.
        var recurrence: ScheduledInstanceRecurrence? = nil

        public init() {}

        public init(platform: String? = nil, previousSlotEndTime: Date? = nil, totalScheduledInstanceHours: Int32? = nil, createDate: Date? = nil, hourlyPrice: String? = nil, instanceType: String? = nil, slotDurationInHours: Int32? = nil, scheduledInstanceId: String? = nil, availabilityZone: String? = nil, termStartDate: Date? = nil, termEndDate: Date? = nil, nextSlotStartTime: Date? = nil, instanceCount: Int32? = nil, networkPlatform: String? = nil, recurrence: ScheduledInstanceRecurrence? = nil) {
            self.platform = platform
            self.previousSlotEndTime = previousSlotEndTime
            self.totalScheduledInstanceHours = totalScheduledInstanceHours
            self.createDate = createDate
            self.hourlyPrice = hourlyPrice
            self.instanceType = instanceType
            self.slotDurationInHours = slotDurationInHours
            self.scheduledInstanceId = scheduledInstanceId
            self.availabilityZone = availabilityZone
            self.termStartDate = termStartDate
            self.termEndDate = termEndDate
            self.nextSlotStartTime = nextSlotStartTime
            self.instanceCount = instanceCount
            self.networkPlatform = networkPlatform
            self.recurrence = recurrence
        }

    }

    public struct DescribeSpotFleetInstancesResponse: Serializable, Initializable {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""
        /// The running instances. Note that this list is refreshed periodically and might be out of date.
        var activeInstances: [ActiveInstance] = []

        public init() {}

        public init(nextToken: String? = nil, spotFleetRequestId: String, activeInstances: [ActiveInstance]) {
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.activeInstances = activeInstances
        }

    }

    public struct ProductCode: Serializable, Initializable {
        /// The type of product code.
        var productCodeType: String? = nil
        /// The product code.
        var productCodeId: String? = nil

        public init() {}

        public init(productCodeType: String? = nil, productCodeId: String? = nil) {
            self.productCodeType = productCodeType
            self.productCodeId = productCodeId
        }

    }

    public struct InstanceStatusEvent: Serializable, Initializable {
        /// The event code.
        var code: String? = nil
        /// The earliest scheduled start time for the event.
        var notBefore: Date? = nil
        /// The latest scheduled end time for the event.
        var notAfter: Date? = nil
        /// A description of the event. After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].
        var description: String? = nil

        public init() {}

        public init(code: String? = nil, notBefore: Date? = nil, notAfter: Date? = nil, description: String? = nil) {
            self.code = code
            self.notBefore = notBefore
            self.notAfter = notAfter
            self.description = description
        }

    }

    public struct DescribeVolumeAttributeResult: Serializable, Initializable {
        /// A list of product codes.
        var productCodes: [ProductCode]? = nil
        /// The ID of the volume.
        var volumeId: String? = nil
        /// The state of autoEnableIO attribute.
        var autoEnableIO: AttributeBooleanValue? = nil

        public init() {}

        public init(productCodes: [ProductCode]? = nil, volumeId: String? = nil, autoEnableIO: AttributeBooleanValue? = nil) {
            self.productCodes = productCodes
            self.volumeId = volumeId
            self.autoEnableIO = autoEnableIO
        }

    }

    public struct DeleteNetworkInterfaceRequest: Serializable, Initializable {
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(networkInterfaceId: String, dryRun: Bool? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
        }

    }

    public struct SpotDatafeedSubscription: Serializable, Initializable {
        /// The Amazon S3 bucket where the Spot instance data feed is located.
        var bucket: String? = nil
        /// The AWS account ID of the account.
        var ownerId: String? = nil
        /// The state of the Spot instance data feed subscription.
        var state: String? = nil
        /// The fault codes for the Spot instance request, if any.
        var fault: SpotInstanceStateFault? = nil
        /// The prefix that is prepended to data feed files.
        var prefix: String? = nil

        public init() {}

        public init(bucket: String? = nil, ownerId: String? = nil, state: String? = nil, fault: SpotInstanceStateFault? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.ownerId = ownerId
            self.state = state
            self.fault = fault
            self.prefix = prefix
        }

    }

    public struct ImportImageRequest: Serializable, Initializable {
        /// Information about the disk containers.
        var diskContainers: [ImageDiskContainer]? = nil
        /// The operating system of the virtual machine. Valid values: Windows | Linux 
        var platform: String? = nil
        /// The token to enable idempotency for VM import requests.
        var clientToken: String? = nil
        /// The license type to be used for the Amazon Machine Image (AMI) after importing.  Note: You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see Prerequisites in the VM Import/Export User Guide. Valid values: AWS | BYOL 
        var licenseType: String? = nil
        /// The target hypervisor platform. Valid values: xen 
        var hypervisor: String? = nil
        /// The architecture of the virtual machine. Valid values: i386 | x86_64 
        var architecture: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The name of the role to use when not using the default role, 'vmimport'.
        var roleName: String? = nil
        /// The client-specific data.
        var clientData: ClientData? = nil
        /// A description string for the import image task.
        var description: String? = nil

        public init() {}

        public init(diskContainers: [ImageDiskContainer]? = nil, platform: String? = nil, clientToken: String? = nil, licenseType: String? = nil, hypervisor: String? = nil, architecture: String? = nil, dryRun: Bool? = nil, roleName: String? = nil, clientData: ClientData? = nil, description: String? = nil) {
            self.diskContainers = diskContainers
            self.platform = platform
            self.clientToken = clientToken
            self.licenseType = licenseType
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.dryRun = dryRun
            self.roleName = roleName
            self.clientData = clientData
            self.description = description
        }

    }

    public struct ImportInstanceVolumeDetailItem: Serializable, Initializable {
        /// The status of the import of this particular disk image.
        var status: String = ""
        /// The number of bytes converted so far.
        var bytesConverted: Int64 = 0
        /// The volume.
        var volume: DiskImageVolumeDescription = DiskImageVolumeDescription()
        /// The image.
        var image: DiskImageDescription = DiskImageDescription()
        /// The status information or errors related to the disk image.
        var statusMessage: String? = nil
        /// The Availability Zone where the resulting instance will reside.
        var availabilityZone: String = ""
        /// A description of the task.
        var description: String? = nil

        public init() {}

        public init(status: String, bytesConverted: Int64, volume: DiskImageVolumeDescription, image: DiskImageDescription, statusMessage: String? = nil, availabilityZone: String, description: String? = nil) {
            self.status = status
            self.bytesConverted = bytesConverted
            self.volume = volume
            self.image = image
            self.statusMessage = statusMessage
            self.availabilityZone = availabilityZone
            self.description = description
        }

    }

    public struct UnsuccessfulItem: Serializable, Initializable {
        /// The ID of the resource.
        var resourceId: String? = nil
        /// Information about the error.
        var error: UnsuccessfulItemError = UnsuccessfulItemError()

        public init() {}

        public init(resourceId: String? = nil, error: UnsuccessfulItemError) {
            self.resourceId = resourceId
            self.error = error
        }

    }

    public struct DescribeIamInstanceProfileAssociationsResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Information about one or more IAM instance profile associations.
        var iamInstanceProfileAssociations: [IamInstanceProfileAssociation]? = nil

        public init() {}

        public init(nextToken: String? = nil, iamInstanceProfileAssociations: [IamInstanceProfileAssociation]? = nil) {
            self.nextToken = nextToken
            self.iamInstanceProfileAssociations = iamInstanceProfileAssociations
        }

    }

    public struct ModifySpotFleetRequestResponse: Serializable, Initializable {
        /// Is true if the request succeeds, and an error otherwise.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct Volume: Serializable, Initializable {
        /// The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.
        var volumeType: String? = nil
        /// The volume state.
        var state: String? = nil
        /// Any tags assigned to the volume.
        var tags: [Tag]? = nil
        /// The size of the volume, in GiBs.
        var size: Int32? = nil
        /// The ID of the volume.
        var volumeId: String? = nil
        /// The snapshot from which the volume was created, if applicable.
        var snapshotId: String? = nil
        /// Indicates whether the volume will be encrypted.
        var encrypted: Bool? = nil
        /// The time stamp when volume creation was initiated.
        var createTime: Date? = nil
        /// The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information on General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        var iops: Int32? = nil
        /// The Availability Zone for the volume.
        var availabilityZone: String? = nil
        /// Information about the volume attachments.
        var attachments: [VolumeAttachment]? = nil
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.
        var kmsKeyId: String? = nil

        public init() {}

        public init(volumeType: String? = nil, state: String? = nil, tags: [Tag]? = nil, size: Int32? = nil, volumeId: String? = nil, snapshotId: String? = nil, encrypted: Bool? = nil, createTime: Date? = nil, iops: Int32? = nil, availabilityZone: String? = nil, attachments: [VolumeAttachment]? = nil, kmsKeyId: String? = nil) {
            self.volumeType = volumeType
            self.state = state
            self.tags = tags
            self.size = size
            self.volumeId = volumeId
            self.snapshotId = snapshotId
            self.encrypted = encrypted
            self.createTime = createTime
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.attachments = attachments
            self.kmsKeyId = kmsKeyId
        }

    }

    public struct PurchaseHostReservationRequest: Serializable, Initializable {
        /// The currency in which the totalUpfrontPrice, LimitPrice, and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        var clientToken: String? = nil
        /// The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request will fail. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is USD. For example, to indicate a limit price of USD 100, specify 100.00.
        var limitPrice: String? = nil
        /// The ID of the offering.
        var offeringId: String = ""
        /// The ID/s of the Dedicated Host/s that the reservation will be associated with.
        var hostIdSet: [String] = []

        public init() {}

        public init(currencyCode: String? = nil, clientToken: String? = nil, limitPrice: String? = nil, offeringId: String, hostIdSet: [String]) {
            self.currencyCode = currencyCode
            self.clientToken = clientToken
            self.limitPrice = limitPrice
            self.offeringId = offeringId
            self.hostIdSet = hostIdSet
        }

    }

    public struct SubnetCidrBlockState: Serializable, Initializable {
        /// The state of a CIDR block.
        var state: String? = nil
        /// A message about the status of the CIDR block, if applicable.
        var statusMessage: String? = nil

        public init() {}

        public init(state: String? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

    }

    public struct InstanceAttribute: Serializable, Initializable {
        /// The block device mapping of the instance.
        var blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil
        /// If the value is true, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.
        var disableApiTermination: AttributeBooleanValue? = nil
        /// The user data.
        var userData: AttributeValue? = nil
        /// Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        var sriovNetSupport: AttributeValue? = nil
        /// The name of the root device (for example, /dev/sda1 or /dev/xvda).
        var rootDeviceName: AttributeValue? = nil
        /// Indicates whether the instance is optimized for EBS I/O.
        var ebsOptimized: AttributeBooleanValue? = nil
        /// Indicates whether source/destination checking is enabled. A value of true means checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.
        var sourceDestCheck: AttributeBooleanValue? = nil
        /// The kernel ID.
        var kernelId: AttributeValue? = nil
        /// The instance type.
        var instanceType: AttributeValue? = nil
        /// A list of product codes.
        var productCodes: [ProductCode]? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// Indicates whether enhanced networking with ENA is enabled.
        var enaSupport: AttributeBooleanValue? = nil
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        var instanceInitiatedShutdownBehavior: AttributeValue? = nil
        /// The RAM disk ID.
        var ramdiskId: AttributeValue? = nil
        /// The security groups associated with the instance.
        var groups: [GroupIdentifier]? = nil

        public init() {}

        public init(blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, disableApiTermination: AttributeBooleanValue? = nil, userData: AttributeValue? = nil, sriovNetSupport: AttributeValue? = nil, rootDeviceName: AttributeValue? = nil, ebsOptimized: AttributeBooleanValue? = nil, sourceDestCheck: AttributeBooleanValue? = nil, kernelId: AttributeValue? = nil, instanceType: AttributeValue? = nil, productCodes: [ProductCode]? = nil, instanceId: String? = nil, enaSupport: AttributeBooleanValue? = nil, instanceInitiatedShutdownBehavior: AttributeValue? = nil, ramdiskId: AttributeValue? = nil, groups: [GroupIdentifier]? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.disableApiTermination = disableApiTermination
            self.userData = userData
            self.sriovNetSupport = sriovNetSupport
            self.rootDeviceName = rootDeviceName
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.kernelId = kernelId
            self.instanceType = instanceType
            self.productCodes = productCodes
            self.instanceId = instanceId
            self.enaSupport = enaSupport
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.ramdiskId = ramdiskId
            self.groups = groups
        }

    }

    public struct DescribeConversionTasksResult: Serializable, Initializable {
        /// Information about the conversion tasks.
        var conversionTasks: [ConversionTask]? = nil

        public init() {}

        public init(conversionTasks: [ConversionTask]? = nil) {
            self.conversionTasks = conversionTasks
        }

    }

    public struct ModifySnapshotAttributeRequest: Serializable, Initializable {
        /// The account ID to modify for the snapshot.
        var userIds: [String]? = nil
        /// The ID of the snapshot.
        var snapshotId: String = ""
        /// A JSON representation of the snapshot attribute modification.
        var createVolumePermission: CreateVolumePermissionModifications? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The snapshot attribute to modify.  Only volume creation permissions may be modified at the customer level. 
        var attribute: String? = nil
        /// The type of operation to perform to the attribute.
        var operationType: String? = nil
        /// The group to modify for the snapshot.
        var groupNames: [String]? = nil

        public init() {}

        public init(userIds: [String]? = nil, snapshotId: String, createVolumePermission: CreateVolumePermissionModifications? = nil, dryRun: Bool? = nil, attribute: String? = nil, operationType: String? = nil, groupNames: [String]? = nil) {
            self.userIds = userIds
            self.snapshotId = snapshotId
            self.createVolumePermission = createVolumePermission
            self.dryRun = dryRun
            self.attribute = attribute
            self.operationType = operationType
            self.groupNames = groupNames
        }

    }

    public struct AttachClassicLinkVpcResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct ModifySpotFleetRequestRequest: Serializable, Initializable {
        /// The size of the fleet.
        var targetCapacity: Int32? = nil
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""
        /// Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.
        var excessCapacityTerminationPolicy: String? = nil

        public init() {}

        public init(targetCapacity: Int32? = nil, spotFleetRequestId: String, excessCapacityTerminationPolicy: String? = nil) {
            self.targetCapacity = targetCapacity
            self.spotFleetRequestId = spotFleetRequestId
            self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
        }

    }

    public struct HostReservation: Serializable, Initializable {
        /// The upfront price of the reservation.
        var upfrontPrice: String? = nil
        /// The state of the reservation.
        var state: String? = nil
        /// The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.
        var offeringId: String? = nil
        /// The number of Dedicated Hosts the reservation is associated with.
        var count: Int32? = nil
        /// The payment option selected for this reservation.
        var paymentOption: String? = nil
        /// The ID of the reservation that specifies the associated Dedicated Hosts.
        var hostReservationId: String? = nil
        /// The hourly price of the reservation.
        var hourlyPrice: String? = nil
        /// The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.
        var instanceFamily: String? = nil
        /// The date and time that the reservation started.
        var start: Date? = nil
        /// The date and time that the reservation ends.
        var end: Date? = nil
        /// The IDs of the Dedicated Hosts associated with the reservation.
        var hostIdSet: [String]? = nil
        /// The currency in which the upfrontPrice and hourlyPrice amounts are specified. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The length of the reservation's term, specified in seconds. Can be 31536000 (1 year) | 94608000 (3 years).
        var duration: Int32? = nil

        public init() {}

        public init(upfrontPrice: String? = nil, state: String? = nil, offeringId: String? = nil, count: Int32? = nil, paymentOption: String? = nil, hostReservationId: String? = nil, hourlyPrice: String? = nil, instanceFamily: String? = nil, start: Date? = nil, end: Date? = nil, hostIdSet: [String]? = nil, currencyCode: String? = nil, duration: Int32? = nil) {
            self.upfrontPrice = upfrontPrice
            self.state = state
            self.offeringId = offeringId
            self.count = count
            self.paymentOption = paymentOption
            self.hostReservationId = hostReservationId
            self.hourlyPrice = hourlyPrice
            self.instanceFamily = instanceFamily
            self.start = start
            self.end = end
            self.hostIdSet = hostIdSet
            self.currencyCode = currencyCode
            self.duration = duration
        }

    }

    public struct CreateReservedInstancesListingResult: Serializable, Initializable {
        /// Information about the Standard Reserved Instance listing.
        var reservedInstancesListings: [ReservedInstancesListing]? = nil

        public init() {}

        public init(reservedInstancesListings: [ReservedInstancesListing]? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

    }

    public struct DescribeHostsRequest: Serializable, Initializable {
        /// One or more filters.    instance-type - The instance type size that the Dedicated Host is configured to support.    auto-placement - Whether auto-placement is enabled or disabled (on | off).    host-reservation-id - The ID of the reservation assigned to this host.    client-token - The idempotency token you provided when you launched the instance    state- The allocation state of the Dedicated Host (available | under-assessment | permanent-failure | released | released-permanent-failure).    availability-zone - The Availability Zone of the host.  
        var filter: [Filter]? = nil
        /// The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.
        var hostIds: [String]? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error. You cannot specify this parameter and the host IDs parameter in the same request.
        var maxResults: Int32? = nil

        public init() {}

        public init(filter: [Filter]? = nil, hostIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.hostIds = hostIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct AllocateAddressRequest: Serializable, Initializable {
        /// Set to vpc to allocate the address for use with instances in a VPC. Default: The address is for use with instances in EC2-Classic.
        var domain: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(domain: String? = nil, dryRun: Bool? = nil) {
            self.domain = domain
            self.dryRun = dryRun
        }

    }

    public struct DescribeBundleTasksRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    bundle-id - The ID of the bundle task.    error-code - If the task failed, the error code returned.    error-message - If the task failed, the error message returned.    instance-id - The ID of the instance.    progress - The level of task completion, as a percentage (for example, 20%).    s3-bucket - The Amazon S3 bucket to store the AMI.    s3-prefix - The beginning of the AMI name.    start-time - The time the task started (for example, 2013-09-15T17:15:20.000Z).    state - The state of the task (pending | waiting-for-shutdown | bundling | storing | cancelling | complete | failed).    update-time - The time of the most recent update for the task.  
        var filters: [Filter]? = nil
        /// One or more bundle task IDs. Default: Describes all your bundle tasks.
        var bundleIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, bundleIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.bundleIds = bundleIds
        }

    }

    public struct RunScheduledInstancesResult: Serializable, Initializable {
        /// The IDs of the newly launched instances.
        var instanceIdSet: [String]? = nil

        public init() {}

        public init(instanceIdSet: [String]? = nil) {
            self.instanceIdSet = instanceIdSet
        }

    }

    public struct DescribeVpcEndpointServicesResult: Serializable, Initializable {
        /// A list of supported AWS services.
        var serviceNames: [String]? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        var nextToken: String? = nil

        public init() {}

        public init(serviceNames: [String]? = nil, nextToken: String? = nil) {
            self.serviceNames = serviceNames
            self.nextToken = nextToken
        }

    }

    public struct AssociateVpcCidrBlockResult: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// Information about the IPv6 CIDR block association.
        var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(vpcId: String? = nil, ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil) {
            self.vpcId = vpcId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

    }

    public struct UserData: Serializable, Initializable {
        /// The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var data: String? = nil

        public init() {}

        public init(data: String? = nil) {
            self.data = data
        }

    }

    public struct AssociateAddressRequest: Serializable, Initializable {
        /// [EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
        var privateIpAddress: String? = nil
        /// [EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.
        var networkInterfaceId: String? = nil
        /// The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.
        var instanceId: String? = nil
        /// [EC2-VPC] The allocation ID. This is required for EC2-VPC.
        var allocationId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The Elastic IP address. This is required for EC2-Classic.
        var publicIp: String? = nil
        /// [EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.
        var allowReassociation: Bool? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, networkInterfaceId: String? = nil, instanceId: String? = nil, allocationId: String? = nil, dryRun: Bool? = nil, publicIp: String? = nil, allowReassociation: Bool? = nil) {
            self.privateIpAddress = privateIpAddress
            self.networkInterfaceId = networkInterfaceId
            self.instanceId = instanceId
            self.allocationId = allocationId
            self.dryRun = dryRun
            self.publicIp = publicIp
            self.allowReassociation = allowReassociation
        }

    }

    public struct DisassociateSubnetCidrBlockRequest: Serializable, Initializable {
        /// The association ID for the CIDR block.
        var associationId: String = ""

        public init() {}

        public init(associationId: String) {
            self.associationId = associationId
        }

    }

    public struct DeleteEgressOnlyInternetGatewayRequest: Serializable, Initializable {
        /// The ID of the egress-only Internet gateway.
        var egressOnlyInternetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(egressOnlyInternetGatewayId: String, dryRun: Bool? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.dryRun = dryRun
        }

    }

    public struct AuthorizeSecurityGroupEgressRequest: Serializable, Initializable {
        /// The AWS account number for a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        var sourceSecurityGroupOwnerId: String? = nil
        /// A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.
        var ipPermissions: [IpPermission]? = nil
        /// The CIDR IPv4 address range. We recommend that you specify the CIDR range in a set of IP permissions instead.
        var cidrIp: String? = nil
        /// The name of a destination security group. To authorize outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        var fromPort: Int32? = nil
        /// The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.
        var ipProtocol: String? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        var toPort: Int32? = nil
        /// The ID of the security group.
        var groupId: String = ""

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, toPort: Int32? = nil, groupId: String) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.toPort = toPort
            self.groupId = groupId
        }

    }

    public struct FlowLog: Serializable, Initializable {
        /// The name of the flow log group.
        var logGroupName: String? = nil
        /// The status of the flow log (ACTIVE).
        var flowLogStatus: String? = nil
        /// The flow log ID.
        var flowLogId: String? = nil
        /// The date and time the flow log was created.
        var creationTime: Date? = nil
        /// The type of traffic captured for the flow log.
        var trafficType: String? = nil
        /// The ARN of the IAM role that posts logs to CloudWatch Logs.
        var deliverLogsPermissionArn: String? = nil
        /// The ID of the resource on which the flow log was created.
        var resourceId: String? = nil
        /// The status of the logs delivery (SUCCESS | FAILED).
        var deliverLogsStatus: String? = nil
        /// Information about the error that occurred. Rate limited indicates that CloudWatch logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of CloudWatch Logs log groups that you can create. Access error indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. Unknown error indicates an internal error.
        var deliverLogsErrorMessage: String? = nil

        public init() {}

        public init(logGroupName: String? = nil, flowLogStatus: String? = nil, flowLogId: String? = nil, creationTime: Date? = nil, trafficType: String? = nil, deliverLogsPermissionArn: String? = nil, resourceId: String? = nil, deliverLogsStatus: String? = nil, deliverLogsErrorMessage: String? = nil) {
            self.logGroupName = logGroupName
            self.flowLogStatus = flowLogStatus
            self.flowLogId = flowLogId
            self.creationTime = creationTime
            self.trafficType = trafficType
            self.deliverLogsPermissionArn = deliverLogsPermissionArn
            self.resourceId = resourceId
            self.deliverLogsStatus = deliverLogsStatus
            self.deliverLogsErrorMessage = deliverLogsErrorMessage
        }

    }

    public struct CreateVpcEndpointResult: Serializable, Initializable {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        var clientToken: String? = nil
        /// Information about the endpoint.
        var vpcEndpoint: VpcEndpoint? = nil

        public init() {}

        public init(clientToken: String? = nil, vpcEndpoint: VpcEndpoint? = nil) {
            self.clientToken = clientToken
            self.vpcEndpoint = vpcEndpoint
        }

    }

    public struct AttachNetworkInterfaceResult: Serializable, Initializable {
        /// The ID of the network interface attachment.
        var attachmentId: String? = nil

        public init() {}

        public init(attachmentId: String? = nil) {
            self.attachmentId = attachmentId
        }

    }

    public struct DescribeVpcEndpointsResult: Serializable, Initializable {
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        var nextToken: String? = nil
        /// Information about the endpoints.
        var vpcEndpoints: [VpcEndpoint]? = nil

        public init() {}

        public init(nextToken: String? = nil, vpcEndpoints: [VpcEndpoint]? = nil) {
            self.nextToken = nextToken
            self.vpcEndpoints = vpcEndpoints
        }

    }

    public struct CreateKeyPairRequest: Serializable, Initializable {
        /// A unique name for the key pair. Constraints: Up to 255 ASCII characters
        var keyName: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(keyName: String, dryRun: Bool? = nil) {
            self.keyName = keyName
            self.dryRun = dryRun
        }

    }

    public struct StaleSecurityGroup: Serializable, Initializable {
        /// Information about the stale inbound rules in the security group.
        var staleIpPermissions: [StaleIpPermission]? = nil
        /// Information about the stale outbound rules in the security group.
        var staleIpPermissionsEgress: [StaleIpPermission]? = nil
        /// The name of the security group.
        var groupName: String? = nil
        /// The ID of the VPC for the security group.
        var vpcId: String? = nil
        /// The ID of the security group.
        var groupId: String = ""
        /// The description of the security group.
        var description: String? = nil

        public init() {}

        public init(staleIpPermissions: [StaleIpPermission]? = nil, staleIpPermissionsEgress: [StaleIpPermission]? = nil, groupName: String? = nil, vpcId: String? = nil, groupId: String, description: String? = nil) {
            self.staleIpPermissions = staleIpPermissions
            self.staleIpPermissionsEgress = staleIpPermissionsEgress
            self.groupName = groupName
            self.vpcId = vpcId
            self.groupId = groupId
            self.description = description
        }

    }

    public struct ConfirmProductInstanceResult: Serializable, Initializable {
        /// The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.
        var ownerId: String? = nil
        /// The return value of the request. Returns true if the specified product code is owned by the requester and associated with the specified instance.
        var `return`: Bool? = nil

        public init() {}

        public init(ownerId: String? = nil, return: Bool? = nil) {
            self.ownerId = ownerId
            self.`return` = `return`
        }

    }

    public struct ImportKeyPairRequest: Serializable, Initializable {
        /// A unique name for the key pair.
        var keyName: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.
        var publicKeyMaterial: Data = Data()

        public init() {}

        public init(keyName: String, dryRun: Bool? = nil, publicKeyMaterial: Data) {
            self.keyName = keyName
            self.dryRun = dryRun
            self.publicKeyMaterial = publicKeyMaterial
        }

    }

    public struct RunInstancesMonitoringEnabled: Serializable, Initializable {
        /// Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.
        var enabled: Bool = false

        public init() {}

        public init(enabled: Bool) {
            self.enabled = enabled
        }

    }

    public struct GetPasswordDataResult: Serializable, Initializable {
        /// The time the data was last updated.
        var timestamp: Date? = nil
        /// The password of the instance.
        var passwordData: String? = nil
        /// The ID of the Windows instance.
        var instanceId: String? = nil

        public init() {}

        public init(timestamp: Date? = nil, passwordData: String? = nil, instanceId: String? = nil) {
            self.timestamp = timestamp
            self.passwordData = passwordData
            self.instanceId = instanceId
        }

    }

    public struct IdFormat: Serializable, Initializable {
        /// The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.
        var deadline: Date? = nil
        /// The type of resource.
        var resource: String? = nil
        /// Indicates whether longer IDs (17-character IDs) are enabled for the resource.
        var useLongIds: Bool? = nil

        public init() {}

        public init(deadline: Date? = nil, resource: String? = nil, useLongIds: Bool? = nil) {
            self.deadline = deadline
            self.resource = resource
            self.useLongIds = useLongIds
        }

    }

    public struct DescribeClassicLinkInstancesRequest: Serializable, Initializable {
        /// One or more filters.    group-id - The ID of a VPC security group that's associated with the instance.    instance-id - The ID of the instance.    tag:key=value - The key/value combination of a tag assigned to the resource.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC that the instance is linked to.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more instance IDs. Must be instances linked to a VPC through ClassicLink.
        var instanceIds: [String]? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request. Constraint: If the value is greater than 1000, we return only 1000 items.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, instanceIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct RunScheduledInstancesRequest: Serializable, Initializable {
        /// Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see Ensuring Idempotency.
        var clientToken: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.
        var launchSpecification: ScheduledInstancesLaunchSpecification = ScheduledInstancesLaunchSpecification()
        /// The number of instances. Default: 1
        var instanceCount: Int32? = nil
        /// The Scheduled Instance ID.
        var scheduledInstanceId: String = ""

        public init() {}

        public init(clientToken: String? = nil, dryRun: Bool? = nil, launchSpecification: ScheduledInstancesLaunchSpecification, instanceCount: Int32? = nil, scheduledInstanceId: String) {
            self.clientToken = clientToken
            self.dryRun = dryRun
            self.launchSpecification = launchSpecification
            self.instanceCount = instanceCount
            self.scheduledInstanceId = scheduledInstanceId
        }

    }

    public struct BlockDeviceMapping: Serializable, Initializable {
        /// Suppresses the specified device included in the block device mapping of the AMI.
        var noDevice: String? = nil
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        var virtualName: String? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        var deviceName: String? = nil
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        var ebs: EbsBlockDevice? = nil

        public init() {}

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsBlockDevice? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

    }

    public struct ReplaceIamInstanceProfileAssociationRequest: Serializable, Initializable {
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfileSpecification = IamInstanceProfileSpecification()
        /// The ID of the existing IAM instance profile association.
        var associationId: String = ""

        public init() {}

        public init(iamInstanceProfile: IamInstanceProfileSpecification, associationId: String) {
            self.iamInstanceProfile = iamInstanceProfile
            self.associationId = associationId
        }

    }

    public struct ScheduledInstancesIpv6Address: Serializable, Initializable {
        /// The IPv6 address.
        var ipv6Address: String? = nil

        public init() {}

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

    }

    public struct DescribeSpotFleetRequestHistoryRequest: Serializable, Initializable {
        /// The starting date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var startTime: Date = Date()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The type of events to describe. By default, all events are described.
        var eventType: String? = nil
        /// The token for the next set of results.
        var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(startTime: Date, dryRun: Bool? = nil, eventType: String? = nil, nextToken: String? = nil, spotFleetRequestId: String, maxResults: Int32? = nil) {
            self.startTime = startTime
            self.dryRun = dryRun
            self.eventType = eventType
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = maxResults
        }

    }

    public struct ScheduledInstanceAvailability: Serializable, Initializable {
        /// The platform (Linux/UNIX or Windows).
        var platform: String? = nil
        /// The total number of hours for a single instance for the entire term.
        var totalScheduledInstanceHours: Int32? = nil
        /// The minimum term. The only possible value is 365 days.
        var minTermDurationInDays: Int32? = nil
        /// The maximum term. The only possible value is 365 days.
        var maxTermDurationInDays: Int32? = nil
        /// The hourly price for a single instance.
        var hourlyPrice: String? = nil
        /// The instance type. You can specify one of the C3, C4, M4, or R3 instance types.
        var instanceType: String? = nil
        /// The number of hours in the schedule.
        var slotDurationInHours: Int32? = nil
        /// The Availability Zone.
        var availabilityZone: String? = nil
        /// The number of available instances.
        var availableInstanceCount: Int32? = nil
        /// The time period for the first schedule to start.
        var firstSlotStartTime: Date? = nil
        /// The network platform (EC2-Classic or EC2-VPC).
        var networkPlatform: String? = nil
        /// The purchase token. This token expires in two hours.
        var purchaseToken: String? = nil
        /// The schedule recurrence.
        var recurrence: ScheduledInstanceRecurrence? = nil

        public init() {}

        public init(platform: String? = nil, totalScheduledInstanceHours: Int32? = nil, minTermDurationInDays: Int32? = nil, maxTermDurationInDays: Int32? = nil, hourlyPrice: String? = nil, instanceType: String? = nil, slotDurationInHours: Int32? = nil, availabilityZone: String? = nil, availableInstanceCount: Int32? = nil, firstSlotStartTime: Date? = nil, networkPlatform: String? = nil, purchaseToken: String? = nil, recurrence: ScheduledInstanceRecurrence? = nil) {
            self.platform = platform
            self.totalScheduledInstanceHours = totalScheduledInstanceHours
            self.minTermDurationInDays = minTermDurationInDays
            self.maxTermDurationInDays = maxTermDurationInDays
            self.hourlyPrice = hourlyPrice
            self.instanceType = instanceType
            self.slotDurationInHours = slotDurationInHours
            self.availabilityZone = availabilityZone
            self.availableInstanceCount = availableInstanceCount
            self.firstSlotStartTime = firstSlotStartTime
            self.networkPlatform = networkPlatform
            self.purchaseToken = purchaseToken
            self.recurrence = recurrence
        }

    }

    public struct VolumeDetail: Serializable, Initializable {
        /// The size of the volume, in GiB.
        var size: Int64 = 0

        public init() {}

        public init(size: Int64) {
            self.size = size
        }

    }

    public struct ReleaseHostsRequest: Serializable, Initializable {
        /// The IDs of the Dedicated Hosts you want to release.
        var hostIds: [String] = []

        public init() {}

        public init(hostIds: [String]) {
            self.hostIds = hostIds
        }

    }

    public struct InstanceStatusDetails: Serializable, Initializable {
        /// The type of instance status.
        var name: String? = nil
        /// The status.
        var status: String? = nil
        /// The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.
        var impairedSince: Date? = nil

        public init() {}

        public init(name: String? = nil, status: String? = nil, impairedSince: Date? = nil) {
            self.name = name
            self.status = status
            self.impairedSince = impairedSince
        }

    }

    public struct StartInstancesRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more instance IDs.
        var instanceIds: [String] = []
        /// Reserved.
        var additionalInfo: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, instanceIds: [String], additionalInfo: String? = nil) {
            self.dryRun = dryRun
            self.instanceIds = instanceIds
            self.additionalInfo = additionalInfo
        }

    }

    public struct SlotStartTimeRangeRequest: Serializable, Initializable {
        /// The earliest date and time, in UTC, for the Scheduled Instance to start.
        var earliestTime: Date? = nil
        /// The latest date and time, in UTC, for the Scheduled Instance to start.
        var latestTime: Date? = nil

        public init() {}

        public init(earliestTime: Date? = nil, latestTime: Date? = nil) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

    }

    public struct CreateRouteResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct DescribeReservedInstancesListingsResult: Serializable, Initializable {
        /// Information about the Reserved Instance listing.
        var reservedInstancesListings: [ReservedInstancesListing]? = nil

        public init() {}

        public init(reservedInstancesListings: [ReservedInstancesListing]? = nil) {
            self.reservedInstancesListings = reservedInstancesListings
        }

    }

    public struct GetHostReservationPurchasePreviewResult: Serializable, Initializable {
        /// The purchase information of the Dedicated Host Reservation and the Dedicated Hosts associated with it.
        var purchase: [Purchase]? = nil
        /// The potential total upfront price. This is billed immediately.
        var totalUpfrontPrice: String? = nil
        /// The currency in which the totalUpfrontPrice and totalHourlyPrice amounts are specified. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The potential total hourly price of the reservation per hour.
        var totalHourlyPrice: String? = nil

        public init() {}

        public init(purchase: [Purchase]? = nil, totalUpfrontPrice: String? = nil, currencyCode: String? = nil, totalHourlyPrice: String? = nil) {
            self.purchase = purchase
            self.totalUpfrontPrice = totalUpfrontPrice
            self.currencyCode = currencyCode
            self.totalHourlyPrice = totalHourlyPrice
        }

    }

    public struct ExportTask: Serializable, Initializable {
        /// Information about the instance to export.
        var instanceExportDetails: InstanceExportDetails? = nil
        /// The ID of the export task.
        var exportTaskId: String? = nil
        /// Information about the export task.
        var exportToS3Task: ExportToS3Task? = nil
        /// The state of the export task.
        var state: String? = nil
        /// The status message related to the export task.
        var statusMessage: String? = nil
        /// A description of the resource being exported.
        var description: String? = nil

        public init() {}

        public init(instanceExportDetails: InstanceExportDetails? = nil, exportTaskId: String? = nil, exportToS3Task: ExportToS3Task? = nil, state: String? = nil, statusMessage: String? = nil, description: String? = nil) {
            self.instanceExportDetails = instanceExportDetails
            self.exportTaskId = exportTaskId
            self.exportToS3Task = exportToS3Task
            self.state = state
            self.statusMessage = statusMessage
            self.description = description
        }

    }

    public struct CreateSpotDatafeedSubscriptionRequest: Serializable, Initializable {
        /// The Amazon S3 bucket in which to store the Spot instance data feed.
        var bucket: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A prefix for the data feed file names.
        var prefix: String? = nil

        public init() {}

        public init(bucket: String, dryRun: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.dryRun = dryRun
            self.prefix = prefix
        }

    }

    public struct DescribeScheduledInstancesRequest: Serializable, Initializable {
        /// The time period for the first schedule to start.
        var slotStartTimeRange: SlotStartTimeRangeRequest? = nil
        /// The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil
        /// One or more filters.    availability-zone - The Availability Zone (for example, us-west-2a).    instance-type - The instance type (for example, c4.large).    network-platform - The network platform (EC2-Classic or EC2-VPC).    platform - The platform (Linux/UNIX or Windows).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token for the next set of results.
        var nextToken: String? = nil
        /// One or more Scheduled Instance IDs.
        var scheduledInstanceIds: [String]? = nil

        public init() {}

        public init(slotStartTimeRange: SlotStartTimeRangeRequest? = nil, maxResults: Int32? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, scheduledInstanceIds: [String]? = nil) {
            self.slotStartTimeRange = slotStartTimeRange
            self.maxResults = maxResults
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.scheduledInstanceIds = scheduledInstanceIds
        }

    }

    public struct DeleteSubnetRequest: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(subnetId: String, dryRun: Bool? = nil) {
            self.subnetId = subnetId
            self.dryRun = dryRun
        }

    }

    public struct EbsInstanceBlockDeviceSpecification: Serializable, Initializable {
        /// Indicates whether the volume is deleted on instance termination.
        var deleteOnTermination: Bool? = nil
        /// The ID of the EBS volume.
        var volumeId: String? = nil

        public init() {}

        public init(deleteOnTermination: Bool? = nil, volumeId: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.volumeId = volumeId
        }

    }

    public struct NetworkInterfaceAttachment: Serializable, Initializable {
        /// The device index of the network interface attachment on the instance.
        var deviceIndex: Int32? = nil
        /// The attachment state.
        var status: String? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The timestamp indicating when the attachment initiated.
        var attachTime: Date? = nil
        /// Indicates whether the network interface is deleted when the instance is terminated.
        var deleteOnTermination: Bool? = nil
        /// The ID of the network interface attachment.
        var attachmentId: String? = nil
        /// The AWS account ID of the owner of the instance.
        var instanceOwnerId: String? = nil

        public init() {}

        public init(deviceIndex: Int32? = nil, status: String? = nil, instanceId: String? = nil, attachTime: Date? = nil, deleteOnTermination: Bool? = nil, attachmentId: String? = nil, instanceOwnerId: String? = nil) {
            self.deviceIndex = deviceIndex
            self.status = status
            self.instanceId = instanceId
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.attachmentId = attachmentId
            self.instanceOwnerId = instanceOwnerId
        }

    }

    public struct DescribePrefixListsResult: Serializable, Initializable {
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        var nextToken: String? = nil
        /// All available prefix lists.
        var prefixLists: [PrefixList]? = nil

        public init() {}

        public init(nextToken: String? = nil, prefixLists: [PrefixList]? = nil) {
            self.nextToken = nextToken
            self.prefixLists = prefixLists
        }

    }

    public struct ReplaceRouteTableAssociationRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the new route table to associate with the subnet.
        var routeTableId: String = ""
        /// The association ID.
        var associationId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, routeTableId: String, associationId: String) {
            self.dryRun = dryRun
            self.routeTableId = routeTableId
            self.associationId = associationId
        }

    }

    public struct InstanceStatusSummary: Serializable, Initializable {
        /// The system instance health or application instance health.
        var details: [InstanceStatusDetails]? = nil
        /// The status.
        var status: String? = nil

        public init() {}

        public init(details: [InstanceStatusDetails]? = nil, status: String? = nil) {
            self.details = details
            self.status = status
        }

    }

    public struct UnsuccessfulItemError: Serializable, Initializable {
        /// The error code.
        var code: String = ""
        /// The error message accompanying the error code.
        var message: String = ""

        public init() {}

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

    }

    public struct RestoreAddressToClassicResult: Serializable, Initializable {
        /// The move status for the IP address.
        var status: String? = nil
        /// The Elastic IP address.
        var publicIp: String? = nil

        public init() {}

        public init(status: String? = nil, publicIp: String? = nil) {
            self.status = status
            self.publicIp = publicIp
        }

    }

    public struct CopyImageResult: Serializable, Initializable {
        /// The ID of the new AMI.
        var imageId: String? = nil

        public init() {}

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

    }

    public struct DescribeSecurityGroupReferencesResult: Serializable, Initializable {
        /// Information about the VPCs with the referencing security groups.
        var securityGroupReferenceSet: [SecurityGroupReference]? = nil

        public init() {}

        public init(securityGroupReferenceSet: [SecurityGroupReference]? = nil) {
            self.securityGroupReferenceSet = securityGroupReferenceSet
        }

    }

    public struct LaunchPermission: Serializable, Initializable {
        /// The AWS account ID.
        var userId: String? = nil
        /// The name of the group.
        var group: String? = nil

        public init() {}

        public init(userId: String? = nil, group: String? = nil) {
            self.userId = userId
            self.group = group
        }

    }

    public struct ImportImageResult: Serializable, Initializable {
        /// The license type of the virtual machine.
        var licenseType: String? = nil
        /// A brief status of the task.
        var status: String? = nil
        /// The operating system of the virtual machine.
        var platform: String? = nil
        /// The progress of the task.
        var progress: String? = nil
        /// The target hypervisor of the import task.
        var hypervisor: String? = nil
        /// The architecture of the virtual machine.
        var architecture: String? = nil
        /// The ID of the Amazon Machine Image (AMI) created by the import task.
        var imageId: String? = nil
        /// The task ID of the import image task.
        var importTaskId: String? = nil
        /// A detailed status message of the import task.
        var statusMessage: String? = nil
        /// Information about the snapshots.
        var snapshotDetails: [SnapshotDetail]? = nil
        /// A description of the import task.
        var description: String? = nil

        public init() {}

        public init(licenseType: String? = nil, status: String? = nil, platform: String? = nil, progress: String? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, importTaskId: String? = nil, statusMessage: String? = nil, snapshotDetails: [SnapshotDetail]? = nil, description: String? = nil) {
            self.licenseType = licenseType
            self.status = status
            self.platform = platform
            self.progress = progress
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.importTaskId = importTaskId
            self.statusMessage = statusMessage
            self.snapshotDetails = snapshotDetails
            self.description = description
        }

    }

    public struct DescribeVpcPeeringConnectionsResult: Serializable, Initializable {
        /// Information about the VPC peering connections.
        var vpcPeeringConnections: [VpcPeeringConnection]? = nil

        public init() {}

        public init(vpcPeeringConnections: [VpcPeeringConnection]? = nil) {
            self.vpcPeeringConnections = vpcPeeringConnections
        }

    }

    public struct DiskImageDetail: Serializable, Initializable {
        /// The disk image format.
        var format: String = ""
        /// A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the Authenticating REST Requests topic in the Amazon Simple Storage Service Developer Guide. For information about the import manifest referenced by this API action, see VM Import Manifest.
        var importManifestUrl: String = ""
        /// The size of the disk image, in GiB.
        var bytes: Int64 = 0

        public init() {}

        public init(format: String, importManifestUrl: String, bytes: Int64) {
            self.format = format
            self.importManifestUrl = importManifestUrl
            self.bytes = bytes
        }

    }

    public struct PrefixList: Serializable, Initializable {
        /// The ID of the prefix.
        var prefixListId: String? = nil
        /// The IP address range of the AWS service.
        var cidrs: [String]? = nil
        /// The name of the prefix.
        var prefixListName: String? = nil

        public init() {}

        public init(prefixListId: String? = nil, cidrs: [String]? = nil, prefixListName: String? = nil) {
            self.prefixListId = prefixListId
            self.cidrs = cidrs
            self.prefixListName = prefixListName
        }

    }

    public struct ModifyIdFormatRequest: Serializable, Initializable {
        /// The type of resource: instance | reservation | snapshot | volume 
        var resource: String = ""
        /// Indicate whether the resource should use longer IDs (17-character IDs).
        var useLongIds: Bool = false

        public init() {}

        public init(resource: String, useLongIds: Bool) {
            self.resource = resource
            self.useLongIds = useLongIds
        }

    }

    public struct DescribeTagsRequest: Serializable, Initializable {
        /// One or more filters.    key - The tag key.    resource-id - The resource ID.    resource-type - The resource type (customer-gateway | dhcp-options | image | instance | internet-gateway | network-acl | network-interface | reserved-instances | route-table | security-group | snapshot | spot-instances-request | subnet | volume | vpc | vpn-connection | vpn-gateway).    value - The tag value.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct BundleTask: Serializable, Initializable {
        /// The time this task started.
        var startTime: Date? = nil
        /// If the task fails, a description of the error.
        var bundleTaskError: BundleTaskError? = nil
        /// The level of task completion, as a percent (for example, 20%).
        var progress: String? = nil
        /// The ID of the instance associated with this bundle task.
        var instanceId: String? = nil
        /// The state of the task.
        var state: String? = nil
        /// The time of the most recent update for the task.
        var updateTime: Date? = nil
        /// The Amazon S3 storage locations.
        var storage: Storage? = nil
        /// The ID of the bundle task.
        var bundleId: String? = nil

        public init() {}

        public init(startTime: Date? = nil, bundleTaskError: BundleTaskError? = nil, progress: String? = nil, instanceId: String? = nil, state: String? = nil, updateTime: Date? = nil, storage: Storage? = nil, bundleId: String? = nil) {
            self.startTime = startTime
            self.bundleTaskError = bundleTaskError
            self.progress = progress
            self.instanceId = instanceId
            self.state = state
            self.updateTime = updateTime
            self.storage = storage
            self.bundleId = bundleId
        }

    }

    public struct DetachNetworkInterfaceRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the attachment.
        var attachmentId: String = ""
        /// Specifies whether to force a detachment.
        var force: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil, attachmentId: String, force: Bool? = nil) {
            self.dryRun = dryRun
            self.attachmentId = attachmentId
            self.force = force
        }

    }

    public struct DescribeRegionsResult: Serializable, Initializable {
        /// Information about one or more regions.
        var regions: [Region]? = nil

        public init() {}

        public init(regions: [Region]? = nil) {
            self.regions = regions
        }

    }

    public struct GetConsoleOutputRequest: Serializable, Initializable {
        /// The ID of the instance.
        var instanceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.dryRun = dryRun
        }

    }

    public struct CreateVpnConnectionRequest: Serializable, Initializable {
        /// Indicates whether the VPN connection requires static routes. If you are creating a VPN connection for a device that does not support BGP, you must specify true. Default: false 
        var options: VpnConnectionOptionsSpecification? = nil
        /// The ID of the customer gateway.
        var customerGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The type of VPN connection (ipsec.1).
        var type: String = ""
        /// The ID of the virtual private gateway.
        var vpnGatewayId: String = ""

        public init() {}

        public init(options: VpnConnectionOptionsSpecification? = nil, customerGatewayId: String, dryRun: Bool? = nil, type: String, vpnGatewayId: String) {
            self.options = options
            self.customerGatewayId = customerGatewayId
            self.dryRun = dryRun
            self.type = type
            self.vpnGatewayId = vpnGatewayId
        }

    }

    public struct DescribeSpotPriceHistoryResult: Serializable, Initializable {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The historical Spot prices.
        var spotPriceHistory: [SpotPrice]? = nil

        public init() {}

        public init(nextToken: String? = nil, spotPriceHistory: [SpotPrice]? = nil) {
            self.nextToken = nextToken
            self.spotPriceHistory = spotPriceHistory
        }

    }

    public struct CreateSecurityGroupResult: Serializable, Initializable {
        /// The ID of the security group.
        var groupId: String? = nil

        public init() {}

        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

    }

    public struct CreateNatGatewayResult: Serializable, Initializable {
        /// Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.
        var clientToken: String? = nil
        /// Information about the NAT gateway.
        var natGateway: NatGateway? = nil

        public init() {}

        public init(clientToken: String? = nil, natGateway: NatGateway? = nil) {
            self.clientToken = clientToken
            self.natGateway = natGateway
        }

    }

    public struct SpotPlacement: Serializable, Initializable {
        /// The Availability Zone. [Spot fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        var availabilityZone: String? = nil
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for Spot instances.
        var tenancy: String? = nil
        /// The name of the placement group (for cluster instances).
        var groupName: String? = nil

        public init() {}

        public init(availabilityZone: String? = nil, tenancy: String? = nil, groupName: String? = nil) {
            self.availabilityZone = availabilityZone
            self.tenancy = tenancy
            self.groupName = groupName
        }

    }

    public struct Instance: Serializable, Initializable {
        /// The idempotency token you provided when you launched the instance, if applicable.
        var clientToken: String? = nil
        /// The root device name (for example, /dev/sda1 or /dev/xvda).
        var rootDeviceName: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
        var ebsOptimized: Bool? = nil
        /// The kernel associated with this instance, if applicable.
        var kernelId: String? = nil
        /// Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the instance to perform NAT. For more information, see NAT Instances in the Amazon Virtual Private Cloud User Guide.
        var sourceDestCheck: Bool? = nil
        /// (IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the running state.  [EC2-VPC] The Amazon-provided DNS server will resolve Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.
        var privateDnsName: String? = nil
        /// The instance type.
        var instanceType: String? = nil
        /// The private IPv4 address assigned to the instance.
        var privateIpAddress: String? = nil
        /// The product codes attached to this instance, if applicable.
        var productCodes: [ProductCode]? = nil
        /// The name of the key pair, if this instance was launched with an associated key pair.
        var keyName: String? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The IAM instance profile associated with the instance, if applicable.
        var iamInstanceProfile: IamInstanceProfile? = nil
        /// (IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the running state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.
        var publicDnsName: String? = nil
        /// [EC2-VPC] The ID of the VPC in which the instance is running.
        var vpcId: String? = nil
        /// The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.
        var rootDeviceType: String? = nil
        /// The RAM disk associated with this instance, if applicable.
        var ramdiskId: String? = nil
        /// Indicates whether this is a Spot instance or a Scheduled Instance.
        var instanceLifecycle: String? = nil
        /// Any block device mapping entries for the instance.
        var blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil
        /// [EC2-VPC] The ID of the subnet in which the instance is running.
        var subnetId: String? = nil
        /// Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        var sriovNetSupport: String? = nil
        /// The value is Windows for Windows instances; otherwise blank.
        var platform: String? = nil
        /// If the request is a Spot instance request, the ID of the request.
        var spotInstanceRequestId: String? = nil
        /// Any tags assigned to the instance.
        var tags: [Tag]? = nil
        /// The time the instance was launched.
        var launchTime: Date? = nil
        /// The current state of the instance.
        var state: InstanceState? = nil
        /// The public IPv4 address assigned to the instance, if applicable.
        var publicIpAddress: String? = nil
        /// The monitoring for the instance.
        var monitoring: Monitoring? = nil
        /// The reason for the most recent state transition. This might be an empty string.
        var stateTransitionReason: String? = nil
        /// The reason for the most recent state transition.
        var stateReason: StateReason? = nil
        /// One or more security groups for the instance.
        var securityGroups: [GroupIdentifier]? = nil
        /// The hypervisor type of the instance.
        var hypervisor: String? = nil
        /// The architecture of the image.
        var architecture: String? = nil
        /// The ID of the AMI used to launch the instance.
        var imageId: String? = nil
        /// Specifies whether enhanced networking with ENA is enabled.
        var enaSupport: Bool? = nil
        /// [EC2-VPC] One or more network interfaces for the instance.
        var networkInterfaces: [InstanceNetworkInterface]? = nil
        /// The AMI launch index, which can be used to find this instance in the launch group.
        var amiLaunchIndex: Int32? = nil
        /// The location where the instance launched, if applicable.
        var placement: Placement? = nil
        /// The virtualization type of the instance.
        var virtualizationType: String? = nil

        public init() {}

        public init(clientToken: String? = nil, rootDeviceName: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, sourceDestCheck: Bool? = nil, privateDnsName: String? = nil, instanceType: String? = nil, privateIpAddress: String? = nil, productCodes: [ProductCode]? = nil, keyName: String? = nil, instanceId: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil, publicDnsName: String? = nil, vpcId: String? = nil, rootDeviceType: String? = nil, ramdiskId: String? = nil, instanceLifecycle: String? = nil, blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil, subnetId: String? = nil, sriovNetSupport: String? = nil, platform: String? = nil, spotInstanceRequestId: String? = nil, tags: [Tag]? = nil, launchTime: Date? = nil, state: InstanceState? = nil, publicIpAddress: String? = nil, monitoring: Monitoring? = nil, stateTransitionReason: String? = nil, stateReason: StateReason? = nil, securityGroups: [GroupIdentifier]? = nil, hypervisor: String? = nil, architecture: String? = nil, imageId: String? = nil, enaSupport: Bool? = nil, networkInterfaces: [InstanceNetworkInterface]? = nil, amiLaunchIndex: Int32? = nil, placement: Placement? = nil, virtualizationType: String? = nil) {
            self.clientToken = clientToken
            self.rootDeviceName = rootDeviceName
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.sourceDestCheck = sourceDestCheck
            self.privateDnsName = privateDnsName
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.productCodes = productCodes
            self.keyName = keyName
            self.instanceId = instanceId
            self.iamInstanceProfile = iamInstanceProfile
            self.publicDnsName = publicDnsName
            self.vpcId = vpcId
            self.rootDeviceType = rootDeviceType
            self.ramdiskId = ramdiskId
            self.instanceLifecycle = instanceLifecycle
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.sriovNetSupport = sriovNetSupport
            self.platform = platform
            self.spotInstanceRequestId = spotInstanceRequestId
            self.tags = tags
            self.launchTime = launchTime
            self.state = state
            self.publicIpAddress = publicIpAddress
            self.monitoring = monitoring
            self.stateTransitionReason = stateTransitionReason
            self.stateReason = stateReason
            self.securityGroups = securityGroups
            self.hypervisor = hypervisor
            self.architecture = architecture
            self.imageId = imageId
            self.enaSupport = enaSupport
            self.networkInterfaces = networkInterfaces
            self.amiLaunchIndex = amiLaunchIndex
            self.placement = placement
            self.virtualizationType = virtualizationType
        }

    }

    public struct AttachVolumeRequest: Serializable, Initializable {
        /// The device name to expose to the instance (for example, /dev/sdh or xvdh).
        var device: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the instance.
        var instanceId: String = ""
        /// The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        var volumeId: String = ""

        public init() {}

        public init(device: String, dryRun: Bool? = nil, instanceId: String, volumeId: String) {
            self.device = device
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.volumeId = volumeId
        }

    }

    public struct DisableVpcClassicLinkResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct AcceptVpcPeeringConnectionRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String? = nil) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct DescribeFlowLogsRequest: Serializable, Initializable {
        /// One or more filters.    deliver-log-status - The status of the logs delivery (SUCCESS | FAILED).    flow-log-id - The ID of the flow log.    log-group-name - The name of the log group.    resource-id - The ID of the VPC, subnet, or network interface.    traffic-type - The type of traffic (ACCEPT | REJECT | ALL)  
        var filter: [Filter]? = nil
        /// One or more flow log IDs.
        var flowLogIds: [String]? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.
        var maxResults: Int32? = nil

        public init() {}

        public init(filter: [Filter]? = nil, flowLogIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.flowLogIds = flowLogIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct HostInstance: Serializable, Initializable {
        /// The instance type size (for example, m3.medium) of the running instance.
        var instanceType: String? = nil
        /// the IDs of instances that are running on the Dedicated Host.
        var instanceId: String? = nil

        public init() {}

        public init(instanceType: String? = nil, instanceId: String? = nil) {
            self.instanceType = instanceType
            self.instanceId = instanceId
        }

    }

    public struct DescribeSpotDatafeedSubscriptionResult: Serializable, Initializable {
        /// The Spot instance data feed subscription.
        var spotDatafeedSubscription: SpotDatafeedSubscription? = nil

        public init() {}

        public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
            self.spotDatafeedSubscription = spotDatafeedSubscription
        }

    }

    public struct SpotFleetMonitoring: Serializable, Initializable {
        /// Enables monitoring for the instance. Default: false 
        var enabled: Bool? = nil

        public init() {}

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

    }

    public struct Storage: Serializable, Initializable {
        /// An Amazon S3 storage location.
        var s3: S3Storage? = nil

        public init() {}

        public init(s3: S3Storage? = nil) {
            self.s3 = s3
        }

    }

    public struct ImportInstanceLaunchSpecification: Serializable, Initializable {
        /// [EC2-VPC] An available IP address from the IP address range of the subnet.
        var privateIpAddress: String? = nil
        /// [EC2-VPC] The ID of the subnet in which to launch the instance.
        var subnetId: String? = nil
        /// The user data to make available to the instance. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var userData: UserData? = nil
        /// One or more security group IDs.
        var groupIds: [String]? = nil
        /// The architecture of the instance.
        var architecture: String? = nil
        /// Reserved.
        var additionalInfo: String? = nil
        /// Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        var instanceInitiatedShutdownBehavior: String? = nil
        /// The placement information for the instance.
        var placement: Placement? = nil
        /// Indicates whether monitoring is enabled.
        var monitoring: Bool? = nil
        /// The instance type. For more information about the instance types that you can import, see Instance Types in the VM Import/Export User Guide.
        var instanceType: String? = nil
        /// One or more security group names.
        var groupNames: [String]? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, subnetId: String? = nil, userData: UserData? = nil, groupIds: [String]? = nil, architecture: String? = nil, additionalInfo: String? = nil, instanceInitiatedShutdownBehavior: String? = nil, placement: Placement? = nil, monitoring: Bool? = nil, instanceType: String? = nil, groupNames: [String]? = nil) {
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
            self.userData = userData
            self.groupIds = groupIds
            self.architecture = architecture
            self.additionalInfo = additionalInfo
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.placement = placement
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.groupNames = groupNames
        }

    }

    public struct SpotInstanceStatus: Serializable, Initializable {
        /// The description for the status code.
        var message: String? = nil
        /// The status code. For a list of status codes, see Spot Bid Status Codes in the Amazon Elastic Compute Cloud User Guide.
        var code: String? = nil
        /// The date and time of the most recent status update, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var updateTime: Date? = nil

        public init() {}

        public init(message: String? = nil, code: String? = nil, updateTime: Date? = nil) {
            self.message = message
            self.code = code
            self.updateTime = updateTime
        }

    }

    public struct InstanceIpv6Address: Serializable, Initializable {
        /// The IPv6 address.
        var ipv6Address: String? = nil

        public init() {}

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

    }

    public struct StaleIpPermission: Serializable, Initializable {
        /// One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.
        var prefixListIds: [String]? = nil
        /// One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.
        var userIdGroupPairs: [UserIdGroupPair]? = nil
        /// One or more IP ranges. Not applicable for stale security group rules.
        var ipRanges: [String]? = nil
        /// The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of -1 indicates all ICMP types. 
        var fromPort: Int32? = nil
        /// The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of -1 indicates all ICMP types. 
        var toPort: Int32? = nil
        /// The IP protocol name (for tcp, udp, and icmp) or number (see Protocol Numbers).
        var ipProtocol: String? = nil

        public init() {}

        public init(prefixListIds: [String]? = nil, userIdGroupPairs: [UserIdGroupPair]? = nil, ipRanges: [String]? = nil, fromPort: Int32? = nil, toPort: Int32? = nil, ipProtocol: String? = nil) {
            self.prefixListIds = prefixListIds
            self.userIdGroupPairs = userIdGroupPairs
            self.ipRanges = ipRanges
            self.fromPort = fromPort
            self.toPort = toPort
            self.ipProtocol = ipProtocol
        }

    }

    public struct IamInstanceProfile: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the instance profile.
        var arn: String? = nil
        /// The ID of the instance profile.
        var id: String? = nil

        public init() {}

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

    }

    public struct DescribeSecurityGroupsResult: Serializable, Initializable {
        /// Information about one or more security groups.
        var securityGroups: [SecurityGroup]? = nil

        public init() {}

        public init(securityGroups: [SecurityGroup]? = nil) {
            self.securityGroups = securityGroups
        }

    }

    public struct Purchase: Serializable, Initializable {
        /// The upfront price of the reservation.
        var upfrontPrice: String? = nil
        /// The IDs of the Dedicated Hosts associated with the reservation.
        var hostIdSet: [String]? = nil
        /// The payment option for the reservation.
        var paymentOption: String? = nil
        /// The hourly price of the reservation per hour.
        var hourlyPrice: String? = nil
        /// The currency in which the UpfrontPrice and HourlyPrice amounts are specified. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The ID of the reservation.
        var hostReservationId: String? = nil
        /// The duration of the reservation's term in seconds.
        var duration: Int32? = nil
        /// The instance family on the Dedicated Host that the reservation can be associated with.
        var instanceFamily: String? = nil

        public init() {}

        public init(upfrontPrice: String? = nil, hostIdSet: [String]? = nil, paymentOption: String? = nil, hourlyPrice: String? = nil, currencyCode: String? = nil, hostReservationId: String? = nil, duration: Int32? = nil, instanceFamily: String? = nil) {
            self.upfrontPrice = upfrontPrice
            self.hostIdSet = hostIdSet
            self.paymentOption = paymentOption
            self.hourlyPrice = hourlyPrice
            self.currencyCode = currencyCode
            self.hostReservationId = hostReservationId
            self.duration = duration
            self.instanceFamily = instanceFamily
        }

    }

    public struct RequestSpotFleetRequest: Serializable, Initializable {
        /// The configuration for the Spot fleet request.
        var spotFleetRequestConfig: SpotFleetRequestConfigData = SpotFleetRequestConfigData()
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(spotFleetRequestConfig: SpotFleetRequestConfigData, dryRun: Bool? = nil) {
            self.spotFleetRequestConfig = spotFleetRequestConfig
            self.dryRun = dryRun
        }

    }

    public struct ReservedInstancesOffering: Serializable, Initializable {
        /// The recurring charge tag assigned to the resource.
        var recurringCharges: [RecurringCharge]? = nil
        /// The usage price of the Reserved Instance, per hour.
        var usagePrice: Float? = nil
        /// The tenancy of the instance.
        var instanceTenancy: String? = nil
        /// The pricing details of the Reserved Instance offering.
        var pricingDetails: [PricingDetail]? = nil
        /// The instance type on which the Reserved Instance can be used.
        var instanceType: String? = nil
        /// The Reserved Instance offering type.
        var offeringType: String? = nil
        /// The Reserved Instance product platform description.
        var productDescription: String? = nil
        /// Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is true.
        var marketplace: Bool? = nil
        /// The Availability Zone in which the Reserved Instance can be used.
        var availabilityZone: String? = nil
        /// If convertible it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If standard, it is not possible to perform an exchange.
        var offeringClass: String? = nil
        /// The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The ID of the Reserved Instance offering. This is the offering ID used in GetReservedInstancesExchangeQuote to confirm that an exchange can be made.
        var reservedInstancesOfferingId: String? = nil
        /// The duration of the Reserved Instance, in seconds.
        var duration: Int64? = nil
        /// Whether the Reserved Instance is applied to instances in a region or an Availability Zone.
        var scope: String? = nil
        /// The purchase price of the Reserved Instance.
        var fixedPrice: Float? = nil

        public init() {}

        public init(recurringCharges: [RecurringCharge]? = nil, usagePrice: Float? = nil, instanceTenancy: String? = nil, pricingDetails: [PricingDetail]? = nil, instanceType: String? = nil, offeringType: String? = nil, productDescription: String? = nil, marketplace: Bool? = nil, availabilityZone: String? = nil, offeringClass: String? = nil, currencyCode: String? = nil, reservedInstancesOfferingId: String? = nil, duration: Int64? = nil, scope: String? = nil, fixedPrice: Float? = nil) {
            self.recurringCharges = recurringCharges
            self.usagePrice = usagePrice
            self.instanceTenancy = instanceTenancy
            self.pricingDetails = pricingDetails
            self.instanceType = instanceType
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.marketplace = marketplace
            self.availabilityZone = availabilityZone
            self.offeringClass = offeringClass
            self.currencyCode = currencyCode
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
            self.duration = duration
            self.scope = scope
            self.fixedPrice = fixedPrice
        }

    }

    public struct InstanceCount: Serializable, Initializable {
        /// The states of the listed Reserved Instances.
        var state: String? = nil
        /// The number of listed Reserved Instances in the state specified by the state.
        var instanceCount: Int32? = nil

        public init() {}

        public init(state: String? = nil, instanceCount: Int32? = nil) {
            self.state = state
            self.instanceCount = instanceCount
        }

    }

    public struct DescribeNetworkInterfacesRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more network interface IDs. Default: Describes all your network interfaces.
        var networkInterfaceIds: [String]? = nil
        /// One or more filters.    addresses.private-ip-address - The private IPv4 addresses associated with the network interface.    addresses.primary - Whether the private IPv4 address is the primary IP address associated with the network interface.     addresses.association.public-ip - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).    addresses.association.owner-id - The owner ID of the addresses associated with the network interface.    association.association-id - The association ID returned when the network interface was associated with an IPv4 address.    association.allocation-id - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.    association.ip-owner-id - The owner of the Elastic IP address (IPv4) associated with the network interface.    association.public-ip - The address of the Elastic IP address (IPv4) bound to the network interface.    association.public-dns-name - The public DNS name for the network interface (IPv4).    attachment.attachment-id - The ID of the interface attachment.    attachment.attach.time - The time that the network interface was attached to an instance.    attachment.delete-on-termination - Indicates whether the attachment is deleted when an instance is terminated.    attachment.device-index - The device index to which the network interface is attached.    attachment.instance-id - The ID of the instance to which the network interface is attached.    attachment.instance-owner-id - The owner ID of the instance to which the network interface is attached.    attachment.nat-gateway-id - The ID of the NAT gateway to which the network interface is attached.    attachment.status - The status of the attachment (attaching | attached | detaching | detached).    availability-zone - The Availability Zone of the network interface.    description - The description of the network interface.    group-id - The ID of a security group associated with the network interface.    group-name - The name of a security group associated with the network interface.    ipv6-addresses.ipv6-address - An IPv6 address associated with the network interface.    mac-address - The MAC address of the network interface.    network-interface-id - The ID of the network interface.    owner-id - The AWS account ID of the network interface owner.    private-ip-address - The private IPv4 address or addresses of the network interface.    private-dns-name - The private DNS name of the network interface (IPv4).    requester-id - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).    requester-managed - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).    source-desk-check - Indicates whether the network interface performs source/destination checking. A value of true means checking is enabled, and false means checking is disabled. The value must be false for the network interface to perform network address translation (NAT) in your VPC.     status - The status of the network interface. If the network interface is not attached to an instance, the status is available; if a network interface is attached to an instance the status is in-use.    subnet-id - The ID of the subnet for the network interface.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the network interface.  
        var filters: [Filter]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkInterfaceIds: [String]? = nil, filters: [Filter]? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceIds = networkInterfaceIds
            self.filters = filters
        }

    }

    public struct CreateNetworkAclResult: Serializable, Initializable {
        /// Information about the network ACL.
        var networkAcl: NetworkAcl? = nil

        public init() {}

        public init(networkAcl: NetworkAcl? = nil) {
            self.networkAcl = networkAcl
        }

    }

    public struct InstanceBlockDeviceMapping: Serializable, Initializable {
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        var ebs: EbsInstanceBlockDevice? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        var deviceName: String? = nil

        public init() {}

        public init(ebs: EbsInstanceBlockDevice? = nil, deviceName: String? = nil) {
            self.ebs = ebs
            self.deviceName = deviceName
        }

    }

    public struct VolumeStatusAction: Serializable, Initializable {
        /// The code identifying the operation, for example, enable-volume-io.
        var code: String? = nil
        /// The event type associated with this operation.
        var eventType: String? = nil
        /// The ID of the event associated with this operation.
        var eventId: String? = nil
        /// A description of the operation.
        var description: String? = nil

        public init() {}

        public init(code: String? = nil, eventType: String? = nil, eventId: String? = nil, description: String? = nil) {
            self.code = code
            self.eventType = eventType
            self.eventId = eventId
            self.description = description
        }

    }

    public struct CreateReservedInstancesListingRequest: Serializable, Initializable {
        /// A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.
        var priceSchedules: [PriceScheduleSpecification] = []
        /// The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.
        var instanceCount: Int32 = 0
        /// The ID of the active Standard Reserved Instance.
        var reservedInstancesId: String = ""
        /// Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see Ensuring Idempotency.
        var clientToken: String = ""

        public init() {}

        public init(priceSchedules: [PriceScheduleSpecification], instanceCount: Int32, reservedInstancesId: String, clientToken: String) {
            self.priceSchedules = priceSchedules
            self.instanceCount = instanceCount
            self.reservedInstancesId = reservedInstancesId
            self.clientToken = clientToken
        }

    }

    public struct DescribeRouteTablesResult: Serializable, Initializable {
        /// Information about one or more route tables.
        var routeTables: [RouteTable]? = nil

        public init() {}

        public init(routeTables: [RouteTable]? = nil) {
            self.routeTables = routeTables
        }

    }

    public struct AssociateIamInstanceProfileResult: Serializable, Initializable {
        /// Information about the IAM instance profile association.
        var iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil

        public init() {}

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

    }

    public struct DhcpOptions: Serializable, Initializable {
        /// The ID of the set of DHCP options.
        var dhcpOptionsId: String? = nil
        /// One or more DHCP options in the set.
        var dhcpConfigurations: [DhcpConfiguration]? = nil
        /// Any tags assigned to the DHCP options set.
        var tags: [Tag]? = nil

        public init() {}

        public init(dhcpOptionsId: String? = nil, dhcpConfigurations: [DhcpConfiguration]? = nil, tags: [Tag]? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
            self.dhcpConfigurations = dhcpConfigurations
            self.tags = tags
        }

    }

    public struct DescribeClassicLinkInstancesResult: Serializable, Initializable {
        /// Information about one or more linked EC2-Classic instances.
        var instances: [ClassicLinkInstance]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(instances: [ClassicLinkInstance]? = nil, nextToken: String? = nil) {
            self.instances = instances
            self.nextToken = nextToken
        }

    }

    public struct CopyImageRequest: Serializable, Initializable {
        /// The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when encrypting the snapshots of an image during a copy operation. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. The specified CMK must exist in the region that the snapshot is being copied to. If a KmsKeyId is specified, the Encrypted flag must also be set.
        var kmsKeyId: String? = nil
        /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see How to Ensure Idempotency in the Amazon Elastic Compute Cloud User Guide.
        var clientToken: String? = nil
        /// The name of the region that contains the AMI to copy.
        var sourceRegion: String = ""
        /// The name of the new AMI in the destination region.
        var name: String = ""
        /// Specifies whether the destination snapshots of the copied image should be encrypted. The default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        var encrypted: Bool? = nil
        /// The ID of the AMI to copy.
        var sourceImageId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A description for the new AMI in the destination region.
        var description: String? = nil

        public init() {}

        public init(kmsKeyId: String? = nil, clientToken: String? = nil, sourceRegion: String, name: String, encrypted: Bool? = nil, sourceImageId: String, dryRun: Bool? = nil, description: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.clientToken = clientToken
            self.sourceRegion = sourceRegion
            self.name = name
            self.encrypted = encrypted
            self.sourceImageId = sourceImageId
            self.dryRun = dryRun
            self.description = description
        }

    }

    public struct DescribeNetworkAclsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more network ACL IDs. Default: Describes all your network ACLs.
        var networkAclIds: [String]? = nil
        /// One or more filters.    association.association-id - The ID of an association ID for the ACL.    association.network-acl-id - The ID of the network ACL involved in the association.    association.subnet-id - The ID of the subnet involved in the association.    default - Indicates whether the ACL is the default network ACL for the VPC.    entry.cidr - The IPv4 CIDR range specified in the entry.    entry.egress - Indicates whether the entry applies to egress traffic.    entry.icmp.code - The ICMP code specified in the entry, if any.    entry.icmp.type - The ICMP type specified in the entry, if any.    entry.ipv6-cidr - The IPv6 CIDR range specified in the entry.    entry.port-range.from - The start of the port range specified in the entry.     entry.port-range.to - The end of the port range specified in the entry.     entry.protocol - The protocol specified in the entry (tcp | udp | icmp or a protocol number).    entry.rule-action - Allows or denies the matching traffic (allow | deny).    entry.rule-number - The number of an entry (in other words, rule) in the ACL's set of entries.    network-acl-id - The ID of the network ACL.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    vpc-id - The ID of the VPC for the network ACL.  
        var filters: [Filter]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkAclIds: [String]? = nil, filters: [Filter]? = nil) {
            self.dryRun = dryRun
            self.networkAclIds = networkAclIds
            self.filters = filters
        }

    }

    public struct TerminateInstancesResult: Serializable, Initializable {
        /// Information about one or more terminated instances.
        var terminatingInstances: [InstanceStateChange]? = nil

        public init() {}

        public init(terminatingInstances: [InstanceStateChange]? = nil) {
            self.terminatingInstances = terminatingInstances
        }

    }

    public struct CreateVolumeRequest: Serializable, Initializable {
        /// The volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes. Default: standard 
        var volumeType: String? = nil
        /// The size of the volume, in GiBs. Constraints: 1-16384 for gp2, 4-16384 for io1, 500-16384 for st1, 500-16384 for sc1, and 1-1024 for standard. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        var size: Int32? = nil
        /// Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        var encrypted: Bool? = nil
        /// The snapshot from which to create the volume.
        var snapshotId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Only valid for Provisioned IOPS SSD volumes. The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB. Constraint: Range is 100 to 20000 for Provisioned IOPS SSD volumes 
        var iops: Int32? = nil
        /// The Availability Zone in which to create the volume. Use DescribeAvailabilityZones to list the Availability Zones that are currently available to you.
        var availabilityZone: String = ""
        /// The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. If a KmsKeyId is specified, the Encrypted flag must also be set.
        var kmsKeyId: String? = nil

        public init() {}

        public init(volumeType: String? = nil, size: Int32? = nil, encrypted: Bool? = nil, snapshotId: String? = nil, dryRun: Bool? = nil, iops: Int32? = nil, availabilityZone: String, kmsKeyId: String? = nil) {
            self.volumeType = volumeType
            self.size = size
            self.encrypted = encrypted
            self.snapshotId = snapshotId
            self.dryRun = dryRun
            self.iops = iops
            self.availabilityZone = availabilityZone
            self.kmsKeyId = kmsKeyId
        }

    }

    public struct DescribeImportSnapshotTasksRequest: Serializable, Initializable {
        /// One or more filters.
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A list of import snapshot task IDs.
        var importTaskIds: [String]? = nil
        /// A token that indicates the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, importTaskIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.importTaskIds = importTaskIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DisassociateSubnetCidrBlockResult: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// Information about the IPv6 CIDR block association.
        var ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(subnetId: String? = nil, ipv6CidrBlockAssociation: SubnetIpv6CidrBlockAssociation? = nil) {
            self.subnetId = subnetId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

    }

    public struct AllocateAddressResult: Serializable, Initializable {
        /// [EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.
        var allocationId: String? = nil
        /// Indicates whether this Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).
        var domain: String? = nil
        /// The Elastic IP address.
        var publicIp: String? = nil

        public init() {}

        public init(allocationId: String? = nil, domain: String? = nil, publicIp: String? = nil) {
            self.allocationId = allocationId
            self.domain = domain
            self.publicIp = publicIp
        }

    }

    public struct VolumeModification: Serializable, Initializable {
        /// Modification start time 
        var startTime: Date? = nil
        /// Original IOPS rate of the volume being modified.
        var originalIops: Int32? = nil
        /// Current state of modification. Modification state is null for unmodified volumes. 
        var modificationState: String? = nil
        /// Original size of the volume being modified.
        var originalSize: Int32? = nil
        /// Modification progress from 0 to 100%.
        var progress: Int64? = nil
        /// ID of the volume being modified.
        var volumeId: String? = nil
        /// Modification completion or failure time.
        var endTime: Date? = nil
        /// Target EBS volume type of the volume being modified.
        var targetVolumeType: String? = nil
        /// Target IOPS rate of the volume being modified.
        var targetIops: Int32? = nil
        /// Original EBS volume type of the volume being modified.
        var originalVolumeType: String? = nil
        /// Target size of the volume being modified.
        var targetSize: Int32? = nil
        /// Generic status message on modification progress or failure.
        var statusMessage: String? = nil

        public init() {}

        public init(startTime: Date? = nil, originalIops: Int32? = nil, modificationState: String? = nil, originalSize: Int32? = nil, progress: Int64? = nil, volumeId: String? = nil, endTime: Date? = nil, targetVolumeType: String? = nil, targetIops: Int32? = nil, originalVolumeType: String? = nil, targetSize: Int32? = nil, statusMessage: String? = nil) {
            self.startTime = startTime
            self.originalIops = originalIops
            self.modificationState = modificationState
            self.originalSize = originalSize
            self.progress = progress
            self.volumeId = volumeId
            self.endTime = endTime
            self.targetVolumeType = targetVolumeType
            self.targetIops = targetIops
            self.originalVolumeType = originalVolumeType
            self.targetSize = targetSize
            self.statusMessage = statusMessage
        }

    }

    public struct UserBucket: Serializable, Initializable {
        /// The name of the S3 bucket where the disk image is located.
        var s3Bucket: String? = nil
        /// The file name of the disk image.
        var s3Key: String? = nil

        public init() {}

        public init(s3Bucket: String? = nil, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

    }

    public struct AssociateDhcpOptionsRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// The ID of the DHCP options set, or default to associate no DHCP options with the VPC.
        var dhcpOptionsId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dhcpOptionsId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dryRun
        }

    }

    public struct CreateSnapshotRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the EBS volume.
        var volumeId: String = ""
        /// A description for the snapshot.
        var description: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, volumeId: String, description: String? = nil) {
            self.dryRun = dryRun
            self.volumeId = volumeId
            self.description = description
        }

    }

    public struct DescribeIdFormatRequest: Serializable, Initializable {
        /// The type of resource: instance | reservation | snapshot | volume 
        var resource: String? = nil

        public init() {}

        public init(resource: String? = nil) {
            self.resource = resource
        }

    }

    public struct DescribeHostReservationsRequest: Serializable, Initializable {
        /// One or more host reservation IDs.
        var hostReservationIdSet: [String]? = nil
        /// One or more filters.    instance-family - The instance family (e.g., m4).    payment-option - The payment option (NoUpfront | PartialUpfront | AllUpfront).    state - The state of the reservation (payment-pending | payment-failed | active | retired).  
        var filter: [Filter]? = nil
        /// The token to use to retrieve the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value. This value can be between 5 and 500; if maxResults is given a larger value than 500, you will receive an error.
        var maxResults: Int32? = nil

        public init() {}

        public init(hostReservationIdSet: [String]? = nil, filter: [Filter]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.hostReservationIdSet = hostReservationIdSet
            self.filter = filter
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct GetHostReservationPurchasePreviewRequest: Serializable, Initializable {
        /// The ID/s of the Dedicated Host/s that the reservation will be associated with.
        var hostIdSet: [String] = []
        /// The offering ID of the reservation.
        var offeringId: String = ""

        public init() {}

        public init(hostIdSet: [String], offeringId: String) {
            self.hostIdSet = hostIdSet
            self.offeringId = offeringId
        }

    }

    public struct ActiveInstance: Serializable, Initializable {
        /// The instance type.
        var instanceType: String? = nil
        /// The health status of the instance. If the status of both the instance status check and the system status check is impaired, the health status of the instance is unhealthy. Otherwise, the health status is healthy.
        var instanceHealth: String? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The ID of the Spot instance request.
        var spotInstanceRequestId: String? = nil

        public init() {}

        public init(instanceType: String? = nil, instanceHealth: String? = nil, instanceId: String? = nil, spotInstanceRequestId: String? = nil) {
            self.instanceType = instanceType
            self.instanceHealth = instanceHealth
            self.instanceId = instanceId
            self.spotInstanceRequestId = spotInstanceRequestId
        }

    }

    public struct DescribeMovingAddressesResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The status for each Elastic IP address.
        var movingAddressStatuses: [MovingAddressStatus]? = nil

        public init() {}

        public init(nextToken: String? = nil, movingAddressStatuses: [MovingAddressStatus]? = nil) {
            self.nextToken = nextToken
            self.movingAddressStatuses = movingAddressStatuses
        }

    }

    public struct ExportToS3Task: Serializable, Initializable {
        /// The encryption key for your S3 bucket.
        var s3Key: String? = nil
        /// The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.
        var containerFormat: String? = nil
        /// The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account vm-import-export@amazon.com.
        var s3Bucket: String? = nil
        /// The format for the exported image.
        var diskImageFormat: String? = nil

        public init() {}

        public init(s3Key: String? = nil, containerFormat: String? = nil, s3Bucket: String? = nil, diskImageFormat: String? = nil) {
            self.s3Key = s3Key
            self.containerFormat = containerFormat
            self.s3Bucket = s3Bucket
            self.diskImageFormat = diskImageFormat
        }

    }

    public struct VpcAttachment: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// The current state of the attachment.
        var state: String? = nil

        public init() {}

        public init(vpcId: String? = nil, state: String? = nil) {
            self.vpcId = vpcId
            self.state = state
        }

    }

    public struct Ipv6Range: Serializable, Initializable {
        /// The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix.
        var cidrIpv6: String? = nil

        public init() {}

        public init(cidrIpv6: String? = nil) {
            self.cidrIpv6 = cidrIpv6
        }

    }

    public struct DisableVpcClassicLinkDnsSupportResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct CreateTagsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more tags. The value parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. 
        var tags: [Tag] = []
        /// The IDs of one or more resources to tag. For example, ami-1a2b3c4d.
        var resources: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, tags: [Tag], resources: [String]) {
            self.dryRun = dryRun
            self.tags = tags
            self.resources = resources
        }

    }

    public struct DescribeSnapshotsRequest: Serializable, Initializable {
        /// One or more AWS accounts IDs that can create volumes from the snapshot.
        var restorableByUserIds: [String]? = nil
        /// One or more snapshot IDs. Default: Describes snapshots for which you have launch permissions.
        var snapshotIds: [String]? = nil
        /// Returns the snapshots owned by the specified owner. Multiple owners can be specified.
        var ownerIds: [String]? = nil
        /// One or more filters.    description - A description of the snapshot.    owner-alias - Value from an Amazon-maintained list (amazon | aws-marketplace | microsoft) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM consolew.    owner-id - The ID of the AWS account that owns the snapshot.    progress - The progress of the snapshot, as a percentage (for example, 80%).    snapshot-id - The snapshot ID.    start-time - The time stamp when the snapshot was initiated.    status - The status of the snapshot (pending | completed | error).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    volume-id - The ID of the volume the snapshot is for.    volume-size - The size of the volume, in GiB.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The NextToken value returned from a previous paginated DescribeSnapshots request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The maximum number of snapshot results returned by DescribeSnapshots in paginated output. When this parameter is used, DescribeSnapshots only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another DescribeSnapshots request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then DescribeSnapshots returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.
        var maxResults: Int32? = nil

        public init() {}

        public init(restorableByUserIds: [String]? = nil, snapshotIds: [String]? = nil, ownerIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.restorableByUserIds = restorableByUserIds
            self.snapshotIds = snapshotIds
            self.ownerIds = ownerIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct CancelReservedInstancesListingRequest: Serializable, Initializable {
        /// The ID of the Reserved Instance listing.
        var reservedInstancesListingId: String = ""

        public init() {}

        public init(reservedInstancesListingId: String) {
            self.reservedInstancesListingId = reservedInstancesListingId
        }

    }

    public struct ScheduledInstancesMonitoring: Serializable, Initializable {
        /// Indicates whether monitoring is enabled.
        var enabled: Bool? = nil

        public init() {}

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

    }

    public struct CreateNetworkInterfaceRequest: Serializable, Initializable {
        /// The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in privateIpAddresses as primary (only one IP address can be designated as primary).
        var privateIpAddress: String? = nil
        /// The ID of the subnet to associate with the network interface.
        var subnetId: String = ""
        /// A description for the network interface.
        var description: String? = nil
        /// The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using privateIpAddresses. The number of IP addresses you can assign to a network interface varies by instance type. For more information, see IP Addresses Per ENI Per Instance Type in the Amazon Virtual Private Cloud User Guide.
        var secondaryPrivateIpAddressCount: Int32? = nil
        /// The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the AssignIpv6AddressOnCreation attribute set to true, you can specify 0 to override this setting.
        var ipv6AddressCount: Int32? = nil
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        var ipv6Addresses: [InstanceIpv6Address]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The IDs of one or more security groups.
        var groups: [String]? = nil
        /// One or more private IPv4 addresses.
        var privateIpAddresses: [PrivateIpAddressSpecification]? = nil

        public init() {}

        public init(privateIpAddress: String? = nil, subnetId: String, description: String? = nil, secondaryPrivateIpAddressCount: Int32? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: [InstanceIpv6Address]? = nil, dryRun: Bool? = nil, groups: [String]? = nil, privateIpAddresses: [PrivateIpAddressSpecification]? = nil) {
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
            self.description = description
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.dryRun = dryRun
            self.groups = groups
            self.privateIpAddresses = privateIpAddresses
        }

    }

    public struct ModifyReservedInstancesRequest: Serializable, Initializable {
        /// The IDs of the Reserved Instances to modify.
        var reservedInstancesIds: [String] = []
        /// The configuration settings for the Reserved Instances to modify.
        var targetConfigurations: [ReservedInstancesConfiguration] = []
        /// A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see Ensuring Idempotency.
        var clientToken: String? = nil

        public init() {}

        public init(reservedInstancesIds: [String], targetConfigurations: [ReservedInstancesConfiguration], clientToken: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.targetConfigurations = targetConfigurations
            self.clientToken = clientToken
        }

    }

    public struct CancelSpotFleetRequestsErrorItem: Serializable, Initializable {
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""
        /// The error.
        var error: CancelSpotFleetRequestsError = CancelSpotFleetRequestsError()

        public init() {}

        public init(spotFleetRequestId: String, error: CancelSpotFleetRequestsError) {
            self.spotFleetRequestId = spotFleetRequestId
            self.error = error
        }

    }

    public struct CreateInstanceExportTaskResult: Serializable, Initializable {
        /// Information about the instance export task.
        var exportTask: ExportTask? = nil

        public init() {}

        public init(exportTask: ExportTask? = nil) {
            self.exportTask = exportTask
        }

    }

    public struct DescribeVolumesRequest: Serializable, Initializable {
        /// One or more volume IDs.
        var volumeIds: [String]? = nil
        /// One or more filters.    attachment.attach-time - The time stamp when the attachment initiated.    attachment.delete-on-termination - Whether the volume is deleted on instance termination.    attachment.device - The device name that is exposed to the instance (for example, /dev/sda1).    attachment.instance-id - The ID of the instance the volume is attached to.    attachment.status - The attachment state (attaching | attached | detaching | detached).    availability-zone - The Availability Zone in which the volume was created.    create-time - The time stamp when the volume was created.    encrypted - The encryption status of the volume.    size - The size of the volume, in GiB.    snapshot-id - The snapshot from which the volume was created.    status - The status of the volume (creating | available | in-use | deleting | deleted | error).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    volume-id - The volume ID.    volume-type - The Amazon EBS volume type. This can be gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1 for Cold HDD, or standard for Magnetic volumes.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The NextToken value returned from a previous paginated DescribeVolumes request where MaxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the NextToken value. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The maximum number of volume results returned by DescribeVolumes in paginated output. When this parameter is used, DescribeVolumes only returns MaxResults results in a single page along with a NextToken response element. The remaining results of the initial request can be seen by sending another DescribeVolumes request with the returned NextToken value. This value can be between 5 and 500; if MaxResults is given a value larger than 500, only 500 results are returned. If this parameter is not used, then DescribeVolumes returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.
        var maxResults: Int32? = nil

        public init() {}

        public init(volumeIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.volumeIds = volumeIds
            self.filters = filters
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DeleteVpnGatewayRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the virtual private gateway.
        var vpnGatewayId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpnGatewayId: String) {
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

    }

    public struct DescribeReservedInstancesResult: Serializable, Initializable {
        /// A list of Reserved Instances.
        var reservedInstances: [ReservedInstances]? = nil

        public init() {}

        public init(reservedInstances: [ReservedInstances]? = nil) {
            self.reservedInstances = reservedInstances
        }

    }

    public struct EnableVpcClassicLinkDnsSupportRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil

        public init() {}

        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

    }

    public struct DescribeNetworkInterfaceAttributeRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// The attribute of the network interface.
        var attribute: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkInterfaceId: String, attribute: String? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceId = networkInterfaceId
            self.attribute = attribute
        }

    }

    public struct SlotDateTimeRangeRequest: Serializable, Initializable {
        /// The earliest date and time, in UTC, for the Scheduled Instance to start.
        var earliestTime: Date = Date()
        /// The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.
        var latestTime: Date = Date()

        public init() {}

        public init(earliestTime: Date, latestTime: Date) {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }

    }

    public struct DeleteVpcRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

    }

    public struct InstanceBlockDeviceMappingSpecification: Serializable, Initializable {
        /// suppress the specified device included in the block device mapping.
        var noDevice: String? = nil
        /// The virtual device name.
        var virtualName: String? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        var deviceName: String? = nil
        /// Parameters used to automatically set up EBS volumes when the instance is launched.
        var ebs: EbsInstanceBlockDeviceSpecification? = nil

        public init() {}

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: EbsInstanceBlockDeviceSpecification? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

    }

    public struct InstanceMonitoring: Serializable, Initializable {
        /// The monitoring for the instance.
        var monitoring: Monitoring? = nil
        /// The ID of the instance.
        var instanceId: String? = nil

        public init() {}

        public init(monitoring: Monitoring? = nil, instanceId: String? = nil) {
            self.monitoring = monitoring
            self.instanceId = instanceId
        }

    }

    public struct DescribeVpcEndpointsRequest: Serializable, Initializable {
        /// One or more filters.    service-name: The name of the AWS service.    vpc-id: The ID of the VPC in which the endpoint resides.    vpc-endpoint-id: The ID of the endpoint.    vpc-endpoint-state: The state of the endpoint. (pending | available | deleting | deleted)  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more endpoint IDs.
        var vpcEndpointIds: [String]? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results. Constraint: If the value is greater than 1000, we return only 1000 items.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, vpcEndpointIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.vpcEndpointIds = vpcEndpointIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DescribeFlowLogsResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Information about the flow logs.
        var flowLogs: [FlowLog]? = nil

        public init() {}

        public init(nextToken: String? = nil, flowLogs: [FlowLog]? = nil) {
            self.nextToken = nextToken
            self.flowLogs = flowLogs
        }

    }

    public struct EnableVpcClassicLinkResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct CreateVpnConnectionResult: Serializable, Initializable {
        /// Information about the VPN connection.
        var vpnConnection: VpnConnection? = nil

        public init() {}

        public init(vpnConnection: VpnConnection? = nil) {
            self.vpnConnection = vpnConnection
        }

    }

    public struct PropagatingVgw: Serializable, Initializable {
        /// The ID of the virtual private gateway (VGW).
        var gatewayId: String? = nil

        public init() {}

        public init(gatewayId: String? = nil) {
            self.gatewayId = gatewayId
        }

    }

    public struct StartInstancesResult: Serializable, Initializable {
        /// Information about one or more started instances.
        var startingInstances: [InstanceStateChange]? = nil

        public init() {}

        public init(startingInstances: [InstanceStateChange]? = nil) {
            self.startingInstances = startingInstances
        }

    }

    public struct RevokeSecurityGroupEgressRequest: Serializable, Initializable {
        /// The AWS account number for a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        var sourceSecurityGroupOwnerId: String? = nil
        /// A set of IP permissions. You can't specify a destination security group and a CIDR IP address range.
        var ipPermissions: [IpPermission]? = nil
        /// The CIDR IP address range. We recommend that you specify the CIDR range in a set of IP permissions instead.
        var cidrIp: String? = nil
        /// The name of a destination security group. To revoke outbound access to a destination security group, we recommend that you use a set of IP permissions instead.
        var sourceSecurityGroupName: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        var fromPort: Int32? = nil
        /// The IP protocol name or number. We recommend that you specify the protocol in a set of IP permissions instead.
        var ipProtocol: String? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP type number. We recommend that you specify the port range in a set of IP permissions instead.
        var toPort: Int32? = nil
        /// The ID of the security group.
        var groupId: String = ""

        public init() {}

        public init(sourceSecurityGroupOwnerId: String? = nil, ipPermissions: [IpPermission]? = nil, cidrIp: String? = nil, sourceSecurityGroupName: String? = nil, dryRun: Bool? = nil, fromPort: Int32? = nil, ipProtocol: String? = nil, toPort: Int32? = nil, groupId: String) {
            self.sourceSecurityGroupOwnerId = sourceSecurityGroupOwnerId
            self.ipPermissions = ipPermissions
            self.cidrIp = cidrIp
            self.sourceSecurityGroupName = sourceSecurityGroupName
            self.dryRun = dryRun
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.toPort = toPort
            self.groupId = groupId
        }

    }

    public struct DescribeImportImageTasksResult: Serializable, Initializable {
        /// The token to use to get the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.
        var importImageTasks: [ImportImageTask]? = nil

        public init() {}

        public init(nextToken: String? = nil, importImageTasks: [ImportImageTask]? = nil) {
            self.nextToken = nextToken
            self.importImageTasks = importImageTasks
        }

    }

    public struct InstanceStateChange: Serializable, Initializable {
        /// The previous state of the instance.
        var previousState: InstanceState? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The current state of the instance.
        var currentState: InstanceState? = nil

        public init() {}

        public init(previousState: InstanceState? = nil, instanceId: String? = nil, currentState: InstanceState? = nil) {
            self.previousState = previousState
            self.instanceId = instanceId
            self.currentState = currentState
        }

    }

    public struct GroupIdentifier: Serializable, Initializable {
        /// The ID of the security group.
        var groupId: String? = nil
        /// The name of the security group.
        var groupName: String? = nil

        public init() {}

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

    }

    public struct CreateSubnetRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the VPC.
        var vpcId: String = ""
        /// The Availability Zone for the subnet. Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.
        var availabilityZone: String? = nil
        /// The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.
        var ipv6CidrBlock: String? = nil
        /// The IPv4 network range for the subnet, in CIDR notation. For example, 10.0.0.0/24.
        var cidrBlock: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpcId: String, availabilityZone: String? = nil, ipv6CidrBlock: String? = nil, cidrBlock: String) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.availabilityZone = availabilityZone
            self.ipv6CidrBlock = ipv6CidrBlock
            self.cidrBlock = cidrBlock
        }

    }

    public struct ReservedInstancesId: Serializable, Initializable {
        /// The ID of the Reserved Instance.
        var reservedInstancesId: String? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

    }

    public struct ResetNetworkInterfaceAttributeRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// The source/destination checking attribute. Resets the value to true.
        var sourceDestCheck: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, networkInterfaceId: String, sourceDestCheck: String? = nil) {
            self.dryRun = dryRun
            self.networkInterfaceId = networkInterfaceId
            self.sourceDestCheck = sourceDestCheck
        }

    }

    public struct DescribeInternetGatewaysRequest: Serializable, Initializable {
        /// One or more Internet gateway IDs. Default: Describes all your Internet gateways.
        var internetGatewayIds: [String]? = nil
        /// One or more filters.    attachment.state - The current state of the attachment between the gateway and the VPC (available). Present only if a VPC is attached.    attachment.vpc-id - The ID of an attached VPC.    internet-gateway-id - The ID of the Internet gateway.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(internetGatewayIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.internetGatewayIds = internetGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct DescribeIdentityIdFormatRequest: Serializable, Initializable {
        /// The ARN of the principal, which can be an IAM role, IAM user, or the root user.
        var principalArn: String = ""
        /// The type of resource: instance | reservation | snapshot | volume 
        var resource: String? = nil

        public init() {}

        public init(principalArn: String, resource: String? = nil) {
            self.principalArn = principalArn
            self.resource = resource
        }

    }

    public struct Image: Serializable, Initializable {
        /// Any block device mapping entries.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The value is Windows for Windows AMIs; otherwise blank.
        var platform: String? = nil
        /// The device name of the root device (for example, /dev/sda1 or /dev/xvda).
        var rootDeviceName: String? = nil
        /// Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.
        var sriovNetSupport: String? = nil
        /// The AWS account alias (for example, amazon, self) or the AWS account ID of the AMI owner.
        var imageOwnerAlias: String? = nil
        /// Any tags assigned to the image.
        var tags: [Tag]? = nil
        /// The current state of the AMI. If the state is available, the image is successfully registered and can be used to launch an instance.
        var state: String? = nil
        /// The kernel associated with the image, if any. Only applicable for machine images.
        var kernelId: String? = nil
        /// The location of the AMI.
        var imageLocation: String? = nil
        /// The date and time the image was created.
        var creationDate: String? = nil
        /// The reason for the state change.
        var stateReason: StateReason? = nil
        /// The AWS account ID of the image owner.
        var ownerId: String? = nil
        /// Indicates whether the image has public launch permissions. The value is true if this image has public launch permissions or false if it has only implicit and explicit launch permissions.
        var `public`: Bool? = nil
        /// The description of the AMI that was provided during image creation.
        var description: String? = nil
        /// Any product codes associated with the AMI.
        var productCodes: [ProductCode]? = nil
        /// The hypervisor type of the image.
        var hypervisor: String? = nil
        /// Specifies whether enhanced networking with ENA is enabled.
        var enaSupport: Bool? = nil
        /// The name of the AMI that was provided during image creation.
        var name: String? = nil
        /// The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.
        var rootDeviceType: String? = nil
        /// The architecture of the image.
        var architecture: String? = nil
        /// The ID of the AMI.
        var imageId: String? = nil
        /// The type of image.
        var imageType: String? = nil
        /// The RAM disk associated with the image, if any. Only applicable for machine images.
        var ramdiskId: String? = nil
        /// The type of virtualization of the AMI.
        var virtualizationType: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, platform: String? = nil, rootDeviceName: String? = nil, sriovNetSupport: String? = nil, imageOwnerAlias: String? = nil, tags: [Tag]? = nil, state: String? = nil, kernelId: String? = nil, imageLocation: String? = nil, creationDate: String? = nil, stateReason: StateReason? = nil, ownerId: String? = nil, public: Bool? = nil, description: String? = nil, productCodes: [ProductCode]? = nil, hypervisor: String? = nil, enaSupport: Bool? = nil, name: String? = nil, rootDeviceType: String? = nil, architecture: String? = nil, imageId: String? = nil, imageType: String? = nil, ramdiskId: String? = nil, virtualizationType: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.platform = platform
            self.rootDeviceName = rootDeviceName
            self.sriovNetSupport = sriovNetSupport
            self.imageOwnerAlias = imageOwnerAlias
            self.tags = tags
            self.state = state
            self.kernelId = kernelId
            self.imageLocation = imageLocation
            self.creationDate = creationDate
            self.stateReason = stateReason
            self.ownerId = ownerId
            self.`public` = `public`
            self.description = description
            self.productCodes = productCodes
            self.hypervisor = hypervisor
            self.enaSupport = enaSupport
            self.name = name
            self.rootDeviceType = rootDeviceType
            self.architecture = architecture
            self.imageId = imageId
            self.imageType = imageType
            self.ramdiskId = ramdiskId
            self.virtualizationType = virtualizationType
        }

    }

    public struct VpnConnectionOptions: Serializable, Initializable {
        /// Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.
        var staticRoutesOnly: Bool? = nil

        public init() {}

        public init(staticRoutesOnly: Bool? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
        }

    }

    public struct DescribeImportImageTasksRequest: Serializable, Initializable {
        /// Filter tasks using the task-state filter and one of the following values: active, completed, deleting, deleted.
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A list of import image task IDs.
        var importTaskIds: [String]? = nil
        /// A token that indicates the next page of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(filters: [Filter]? = nil, dryRun: Bool? = nil, importTaskIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filters = filters
            self.dryRun = dryRun
            self.importTaskIds = importTaskIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct NatGateway: Serializable, Initializable {
        /// The ID of the subnet in which the NAT gateway is located.
        var subnetId: String? = nil
        /// The ID of the NAT gateway.
        var natGatewayId: String? = nil
        /// The date and time the NAT gateway was deleted, if applicable.
        var deleteTime: Date? = nil
        /// The ID of the VPC in which the NAT gateway is located.
        var vpcId: String? = nil
        /// The state of the NAT gateway.    pending: The NAT gateway is being created and is not ready to process traffic.    failed: The NAT gateway could not be created. Check the failureCode and failureMessage fields for the reason.    available: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.    deleting: The NAT gateway is in the process of being terminated and may still be processing traffic.    deleted: The NAT gateway has been terminated and is no longer processing traffic.  
        var state: String? = nil
        /// If the NAT gateway could not be created, specifies the error code for the failure. (InsufficientFreeAddressesInSubnet | Gateway.NotAttached | InvalidAllocationID.NotFound | Resource.AlreadyAssociated | InternalError | InvalidSubnetID.NotFound)
        var failureCode: String? = nil
        /// The date and time the NAT gateway was created.
        var createTime: Date? = nil
        /// If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.   For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"   For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"   For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"   For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"   For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."   For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."  
        var failureMessage: String? = nil
        /// Reserved. If you need to sustain traffic greater than the documented limits, contact us through the Support Center.
        var provisionedBandwidth: ProvisionedBandwidth? = nil
        /// Information about the IP addresses and network interface associated with the NAT gateway.
        var natGatewayAddresses: [NatGatewayAddress]? = nil

        public init() {}

        public init(subnetId: String? = nil, natGatewayId: String? = nil, deleteTime: Date? = nil, vpcId: String? = nil, state: String? = nil, failureCode: String? = nil, createTime: Date? = nil, failureMessage: String? = nil, provisionedBandwidth: ProvisionedBandwidth? = nil, natGatewayAddresses: [NatGatewayAddress]? = nil) {
            self.subnetId = subnetId
            self.natGatewayId = natGatewayId
            self.deleteTime = deleteTime
            self.vpcId = vpcId
            self.state = state
            self.failureCode = failureCode
            self.createTime = createTime
            self.failureMessage = failureMessage
            self.provisionedBandwidth = provisionedBandwidth
            self.natGatewayAddresses = natGatewayAddresses
        }

    }

    public struct InstanceCapacity: Serializable, Initializable {
        /// The instance type size supported by the Dedicated Host.
        var instanceType: String? = nil
        /// The total number of instances that can be launched onto the Dedicated Host.
        var totalCapacity: Int32? = nil
        /// The number of instances that can still be launched onto the Dedicated Host.
        var availableCapacity: Int32? = nil

        public init() {}

        public init(instanceType: String? = nil, totalCapacity: Int32? = nil, availableCapacity: Int32? = nil) {
            self.instanceType = instanceType
            self.totalCapacity = totalCapacity
            self.availableCapacity = availableCapacity
        }

    }

    public struct UnassignIpv6AddressesResult: Serializable, Initializable {
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The IPv6 addresses that have been unassigned from the network interface.
        var unassignedIpv6Addresses: [String]? = nil

        public init() {}

        public init(networkInterfaceId: String? = nil, unassignedIpv6Addresses: [String]? = nil) {
            self.networkInterfaceId = networkInterfaceId
            self.unassignedIpv6Addresses = unassignedIpv6Addresses
        }

    }

    public struct ClassicLinkDnsSupport: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// Indicates whether ClassicLink DNS support is enabled for the VPC.
        var classicLinkDnsSupported: Bool? = nil

        public init() {}

        public init(vpcId: String? = nil, classicLinkDnsSupported: Bool? = nil) {
            self.vpcId = vpcId
            self.classicLinkDnsSupported = classicLinkDnsSupported
        }

    }

    public struct CancelImportTaskResult: Serializable, Initializable {
        /// The current state of the task being canceled.
        var previousState: String? = nil
        /// The current state of the task being canceled.
        var state: String? = nil
        /// The ID of the task being canceled.
        var importTaskId: String? = nil

        public init() {}

        public init(previousState: String? = nil, state: String? = nil, importTaskId: String? = nil) {
            self.previousState = previousState
            self.state = state
            self.importTaskId = importTaskId
        }

    }

    public struct PriceScheduleSpecification: Serializable, Initializable {
        /// The fixed price for the term.
        var price: Double? = nil
        /// The currency for transacting the Reserved Instance resale. At this time, the only supported currency is USD.
        var currencyCode: String? = nil
        /// The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.
        var term: Int64? = nil

        public init() {}

        public init(price: Double? = nil, currencyCode: String? = nil, term: Int64? = nil) {
            self.price = price
            self.currencyCode = currencyCode
            self.term = term
        }

    }

    public struct DescribeIdentityIdFormatResult: Serializable, Initializable {
        /// Information about the ID format for the resources.
        var statuses: [IdFormat]? = nil

        public init() {}

        public init(statuses: [IdFormat]? = nil) {
            self.statuses = statuses
        }

    }

    public struct CreateVpnConnectionRouteRequest: Serializable, Initializable {
        /// The ID of the VPN connection.
        var vpnConnectionId: String = ""
        /// The CIDR block associated with the local subnet of the customer network.
        var destinationCidrBlock: String = ""

        public init() {}

        public init(vpnConnectionId: String, destinationCidrBlock: String) {
            self.vpnConnectionId = vpnConnectionId
            self.destinationCidrBlock = destinationCidrBlock
        }

    }

    public struct ImportVolumeResult: Serializable, Initializable {
        /// Information about the conversion task.
        var conversionTask: ConversionTask? = nil

        public init() {}

        public init(conversionTask: ConversionTask? = nil) {
            self.conversionTask = conversionTask
        }

    }

    public struct VpnConnection: Serializable, Initializable {
        /// The VPN connection options.
        var options: VpnConnectionOptions? = nil
        /// The ID of the customer gateway at your end of the VPN connection.
        var customerGatewayId: String? = nil
        /// The static routes associated with the VPN connection.
        var routes: [VpnStaticRoute]? = nil
        /// The ID of the VPN connection.
        var vpnConnectionId: String? = nil
        /// The current state of the VPN connection.
        var state: String? = nil
        /// Any tags assigned to the VPN connection.
        var tags: [Tag]? = nil
        /// Information about the VPN tunnel.
        var vgwTelemetry: [VgwTelemetry]? = nil
        /// The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the CreateVpnConnection response; however, it's present in the DescribeVpnConnections response only if the VPN connection is in the pending or available state.
        var customerGatewayConfiguration: String? = nil
        /// The type of VPN connection.
        var type: String? = nil
        /// The ID of the virtual private gateway at the AWS side of the VPN connection.
        var vpnGatewayId: String? = nil

        public init() {}

        public init(options: VpnConnectionOptions? = nil, customerGatewayId: String? = nil, routes: [VpnStaticRoute]? = nil, vpnConnectionId: String? = nil, state: String? = nil, tags: [Tag]? = nil, vgwTelemetry: [VgwTelemetry]? = nil, customerGatewayConfiguration: String? = nil, type: String? = nil, vpnGatewayId: String? = nil) {
            self.options = options
            self.customerGatewayId = customerGatewayId
            self.routes = routes
            self.vpnConnectionId = vpnConnectionId
            self.state = state
            self.tags = tags
            self.vgwTelemetry = vgwTelemetry
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.type = type
            self.vpnGatewayId = vpnGatewayId
        }

    }

    public struct Address: Serializable, Initializable {
        /// The ID of the AWS account that owns the network interface.
        var networkInterfaceOwnerId: String? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The ID representing the association of the address with an instance in a VPC.
        var associationId: String? = nil
        /// The ID of the instance that the address is associated with (if any).
        var instanceId: String? = nil
        /// The ID representing the allocation of the address for use with EC2-VPC.
        var allocationId: String? = nil
        /// The Elastic IP address.
        var publicIp: String? = nil
        /// Indicates whether this Elastic IP address is for use with instances in EC2-Classic (standard) or instances in a VPC (vpc).
        var domain: String? = nil
        /// The private IP address associated with the Elastic IP address.
        var privateIpAddress: String? = nil

        public init() {}

        public init(networkInterfaceOwnerId: String? = nil, networkInterfaceId: String? = nil, associationId: String? = nil, instanceId: String? = nil, allocationId: String? = nil, publicIp: String? = nil, domain: String? = nil, privateIpAddress: String? = nil) {
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.networkInterfaceId = networkInterfaceId
            self.associationId = associationId
            self.instanceId = instanceId
            self.allocationId = allocationId
            self.publicIp = publicIp
            self.domain = domain
            self.privateIpAddress = privateIpAddress
        }

    }

    public struct DescribeVpnGatewaysRequest: Serializable, Initializable {
        /// One or more virtual private gateway IDs. Default: Describes all your virtual private gateways.
        var vpnGatewayIds: [String]? = nil
        /// One or more filters.    attachment.state - The current state of the attachment between the gateway and the VPC (attaching | attached | detaching | detached).    attachment.vpc-id - The ID of an attached VPC.    availability-zone - The Availability Zone for the virtual private gateway (if applicable).    state - The state of the virtual private gateway (pending | available | deleting | deleted).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of virtual private gateway. Currently the only supported type is ipsec.1.    vpn-gateway-id - The ID of the virtual private gateway.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpnGatewayIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.vpnGatewayIds = vpnGatewayIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct TerminateInstancesRequest: Serializable, Initializable {
        /// One or more instance IDs. Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.
        var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

    }

    public struct PurchaseReservedInstancesOfferingResult: Serializable, Initializable {
        /// The IDs of the purchased Reserved Instances.
        var reservedInstancesId: String? = nil

        public init() {}

        public init(reservedInstancesId: String? = nil) {
            self.reservedInstancesId = reservedInstancesId
        }

    }

    public struct CreateNetworkAclRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.dryRun = dryRun
        }

    }

    public struct DescribeVpnConnectionsResult: Serializable, Initializable {
        /// Information about one or more VPN connections.
        var vpnConnections: [VpnConnection]? = nil

        public init() {}

        public init(vpnConnections: [VpnConnection]? = nil) {
            self.vpnConnections = vpnConnections
        }

    }

    public struct ImportInstanceTaskDetails: Serializable, Initializable {
        /// The instance operating system.
        var platform: String? = nil
        /// One or more volumes.
        var volumes: [ImportInstanceVolumeDetailItem] = []
        /// The ID of the instance.
        var instanceId: String? = nil
        /// A description of the task.
        var description: String? = nil

        public init() {}

        public init(platform: String? = nil, volumes: [ImportInstanceVolumeDetailItem], instanceId: String? = nil, description: String? = nil) {
            self.platform = platform
            self.volumes = volumes
            self.instanceId = instanceId
            self.description = description
        }

    }

    public struct BundleTaskError: Serializable, Initializable {
        /// The error code.
        var code: String? = nil
        /// The error message.
        var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

    }

    public struct AccountAttribute: Serializable, Initializable {
        /// The name of the account attribute.
        var attributeName: String? = nil
        /// One or more values for the account attribute.
        var attributeValues: [AccountAttributeValue]? = nil

        public init() {}

        public init(attributeName: String? = nil, attributeValues: [AccountAttributeValue]? = nil) {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }

    }

    public struct ModifyReservedInstancesResult: Serializable, Initializable {
        /// The ID for the modification.
        var reservedInstancesModificationId: String? = nil

        public init() {}

        public init(reservedInstancesModificationId: String? = nil) {
            self.reservedInstancesModificationId = reservedInstancesModificationId
        }

    }

    public struct CreateCustomerGatewayRequest: Serializable, Initializable {
        /// For devices that support BGP, the customer gateway's BGP ASN. Default: 65000
        var bgpAsn: Int32 = 0
        /// The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
        var publicIp: String = ""
        /// The type of VPN connection that this customer gateway supports (ipsec.1).
        var type: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(bgpAsn: Int32, publicIp: String, type: String, dryRun: Bool? = nil) {
            self.bgpAsn = bgpAsn
            self.publicIp = publicIp
            self.type = type
            self.dryRun = dryRun
        }

    }

    public struct CancelSpotInstanceRequestsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more Spot instance request IDs.
        var spotInstanceRequestIds: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, spotInstanceRequestIds: [String]) {
            self.dryRun = dryRun
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }

    }

    public struct DescribeEgressOnlyInternetGatewaysResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results.
        var nextToken: String? = nil
        /// Information about the egress-only Internet gateways.
        var egressOnlyInternetGateways: [EgressOnlyInternetGateway]? = nil

        public init() {}

        public init(nextToken: String? = nil, egressOnlyInternetGateways: [EgressOnlyInternetGateway]? = nil) {
            self.nextToken = nextToken
            self.egressOnlyInternetGateways = egressOnlyInternetGateways
        }

    }

    public struct CreateSecurityGroupRequest: Serializable, Initializable {
        /// The name of the security group. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*
        var groupName: String = ""
        /// [EC2-VPC] The ID of the VPC. Required for EC2-VPC.
        var vpcId: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// A description for the security group. This is informational only. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*
        var description: String = ""

        public init() {}

        public init(groupName: String, vpcId: String? = nil, dryRun: Bool? = nil, description: String) {
            self.groupName = groupName
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.description = description
        }

    }

    public struct MoveAddressToVpcRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The Elastic IP address.
        var publicIp: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, publicIp: String) {
            self.dryRun = dryRun
            self.publicIp = publicIp
        }

    }

    public struct DescribeSpotFleetRequestHistoryResponse: Serializable, Initializable {
        /// The last date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). All records up to this time were retrieved. If nextToken indicates that there are more results, this value is not present.
        var lastEvaluatedTime: Date = Date()
        /// The starting date and time for the events, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var startTime: Date = Date()
        /// Information about the events in the history of the Spot fleet request.
        var historyRecords: [HistoryRecord] = []
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""

        public init() {}

        public init(lastEvaluatedTime: Date, startTime: Date, historyRecords: [HistoryRecord], nextToken: String? = nil, spotFleetRequestId: String) {
            self.lastEvaluatedTime = lastEvaluatedTime
            self.startTime = startTime
            self.historyRecords = historyRecords
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
        }

    }

    public struct CreateInternetGatewayResult: Serializable, Initializable {
        /// Information about the Internet gateway.
        var internetGateway: InternetGateway? = nil

        public init() {}

        public init(internetGateway: InternetGateway? = nil) {
            self.internetGateway = internetGateway
        }

    }

    public struct DescribeImageAttributeRequest: Serializable, Initializable {
        /// The AMI attribute.  Note: Depending on your account privileges, the blockDeviceMapping attribute may return a Client.AuthFailure error. If this happens, use DescribeImages to get information about the block device mapping for the AMI.
        var attribute: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the AMI.
        var imageId: String = ""

        public init() {}

        public init(attribute: String, dryRun: Bool? = nil, imageId: String) {
            self.attribute = attribute
            self.dryRun = dryRun
            self.imageId = imageId
        }

    }

    public struct ReplaceNetworkAclEntryRequest: Serializable, Initializable {
        /// The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24).
        var cidrBlock: String? = nil
        /// ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP (1) protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.
        var icmpTypeCode: IcmpTypeCode? = nil
        /// The rule number of the entry to replace.
        var ruleNumber: Int32 = 0
        /// Indicates whether to allow or deny the traffic that matches the rule.
        var ruleAction: String = ""
        /// The IP protocol. You can specify all or -1 to mean all protocols. If you specify all, -1, or a protocol number other than tcp, udp, or icmp, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.
        var `protocol`: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the ACL.
        var networkAclId: String = ""
        /// Indicates whether to replace the egress rule. Default: If no value is specified, we replace the ingress rule.
        var egress: Bool = false
        /// The IPv6 network range to allow or deny, in CIDR notation (for example 2001:bd8:1234:1a00::/64).
        var ipv6CidrBlock: String? = nil
        /// TCP or UDP protocols: The range of ports the rule applies to. Required if specifying TCP (6) or UDP (17) for the protocol.
        var portRange: PortRange? = nil

        public init() {}

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32, ruleAction: String, protocol: String, dryRun: Bool? = nil, networkAclId: String, egress: Bool, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.ruleAction = ruleAction
            self.`protocol` = `protocol`
            self.dryRun = dryRun
            self.networkAclId = networkAclId
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

    }

    public struct DeleteKeyPairRequest: Serializable, Initializable {
        /// The name of the key pair.
        var keyName: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(keyName: String, dryRun: Bool? = nil) {
            self.keyName = keyName
            self.dryRun = dryRun
        }

    }

    public struct EbsBlockDevice: Serializable, Initializable {
        /// The ID of the snapshot.
        var snapshotId: String? = nil
        /// Indicates whether the EBS volume is deleted on instance termination.
        var deleteOnTermination: Bool? = nil
        /// The volume type: gp2, io1, st1, sc1, or standard. Default: standard 
        var volumeType: String? = nil
        /// The size of the volume, in GiB. Constraints: 1-16384 for General Purpose SSD (gp2), 4-16384 for Provisioned IOPS SSD (io1), 500-16384 for Throughput Optimized HDD (st1), 500-16384 for Cold HDD (sc1), and 1-1024 for Magnetic (standard) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        var volumeSize: Int32? = nil
        /// The number of I/O operations per second (IOPS) that the volume supports. For io1, this represents the number of IOPS that are provisioned for the volume. For gp2, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        var iops: Int32? = nil
        /// Indicates whether the EBS volume is encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption.
        var encrypted: Bool? = nil

        public init() {}

        public init(snapshotId: String? = nil, deleteOnTermination: Bool? = nil, volumeType: String? = nil, volumeSize: Int32? = nil, iops: Int32? = nil, encrypted: Bool? = nil) {
            self.snapshotId = snapshotId
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.volumeSize = volumeSize
            self.iops = iops
            self.encrypted = encrypted
        }

    }

    public struct DescribeExportTasksResult: Serializable, Initializable {
        /// Information about the export tasks.
        var exportTasks: [ExportTask]? = nil

        public init() {}

        public init(exportTasks: [ExportTask]? = nil) {
            self.exportTasks = exportTasks
        }

    }

    public struct CreateVpcPeeringConnectionResult: Serializable, Initializable {
        /// Information about the VPC peering connection.
        var vpcPeeringConnection: VpcPeeringConnection? = nil

        public init() {}

        public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
            self.vpcPeeringConnection = vpcPeeringConnection
        }

    }

    public struct IpRange: Serializable, Initializable {
        /// The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix.
        var cidrIp: String? = nil

        public init() {}

        public init(cidrIp: String? = nil) {
            self.cidrIp = cidrIp
        }

    }

    public struct DhcpConfiguration: Serializable, Initializable {
        /// The name of a DHCP option.
        var key: String? = nil
        /// One or more values for the DHCP option.
        var values: [AttributeValue]? = nil

        public init() {}

        public init(key: String? = nil, values: [AttributeValue]? = nil) {
            self.key = key
            self.values = values
        }

    }

    public struct CancelConversionRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the conversion task.
        var conversionTaskId: String = ""
        /// The reason for canceling the conversion task.
        var reasonMessage: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, conversionTaskId: String, reasonMessage: String? = nil) {
            self.dryRun = dryRun
            self.conversionTaskId = conversionTaskId
            self.reasonMessage = reasonMessage
        }

    }

    public struct ModifyInstancePlacementResult: Serializable, Initializable {
        /// Is true if the request succeeds, and an error otherwise.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct DescribeVpcAttributeRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The VPC attribute.
        var attribute: String = ""

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil, attribute: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.attribute = attribute
        }

    }

    public struct ReservedInstancesModification: Serializable, Initializable {
        /// The IDs of one or more Reserved Instances.
        var reservedInstancesIds: [ReservedInstancesId]? = nil
        /// The status of the Reserved Instances modification request.
        var status: String? = nil
        /// The time for the modification to become effective.
        var effectiveDate: Date? = nil
        /// A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see Ensuring Idempotency.
        var clientToken: String? = nil
        /// Contains target configurations along with their corresponding new Reserved Instance IDs.
        var modificationResults: [ReservedInstancesModificationResult]? = nil
        /// The time when the modification request was last updated.
        var updateDate: Date? = nil
        /// A unique ID for the Reserved Instance modification.
        var reservedInstancesModificationId: String? = nil
        /// The time when the modification request was created.
        var createDate: Date? = nil
        /// The reason for the status.
        var statusMessage: String? = nil

        public init() {}

        public init(reservedInstancesIds: [ReservedInstancesId]? = nil, status: String? = nil, effectiveDate: Date? = nil, clientToken: String? = nil, modificationResults: [ReservedInstancesModificationResult]? = nil, updateDate: Date? = nil, reservedInstancesModificationId: String? = nil, createDate: Date? = nil, statusMessage: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.status = status
            self.effectiveDate = effectiveDate
            self.clientToken = clientToken
            self.modificationResults = modificationResults
            self.updateDate = updateDate
            self.reservedInstancesModificationId = reservedInstancesModificationId
            self.createDate = createDate
            self.statusMessage = statusMessage
        }

    }

    public struct DescribeAvailabilityZonesResult: Serializable, Initializable {
        /// Information about one or more Availability Zones.
        var availabilityZones: [AvailabilityZone]? = nil

        public init() {}

        public init(availabilityZones: [AvailabilityZone]? = nil) {
            self.availabilityZones = availabilityZones
        }

    }

    public struct RejectVpcPeeringConnectionRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct ReplaceIamInstanceProfileAssociationResult: Serializable, Initializable {
        /// Information about the IAM instance profile association.
        var iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil

        public init() {}

        public init(iamInstanceProfileAssociation: IamInstanceProfileAssociation? = nil) {
            self.iamInstanceProfileAssociation = iamInstanceProfileAssociation
        }

    }

    public struct CreateImageResult: Serializable, Initializable {
        /// The ID of the new AMI.
        var imageId: String? = nil

        public init() {}

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

    }

    public struct ImportVolumeTaskDetails: Serializable, Initializable {
        /// The image.
        var image: DiskImageDescription = DiskImageDescription()
        /// The number of bytes converted so far.
        var bytesConverted: Int64 = 0
        /// The volume.
        var volume: DiskImageVolumeDescription = DiskImageVolumeDescription()
        /// The Availability Zone where the resulting volume will reside.
        var availabilityZone: String = ""
        /// The description you provided when starting the import volume task.
        var description: String? = nil

        public init() {}

        public init(image: DiskImageDescription, bytesConverted: Int64, volume: DiskImageVolumeDescription, availabilityZone: String, description: String? = nil) {
            self.image = image
            self.bytesConverted = bytesConverted
            self.volume = volume
            self.availabilityZone = availabilityZone
            self.description = description
        }

    }

    public struct NetworkInterfaceAssociation: Serializable, Initializable {
        /// The association ID.
        var associationId: String? = nil
        /// The address of the Elastic IP address bound to the network interface.
        var publicIp: String? = nil
        /// The ID of the Elastic IP address owner.
        var ipOwnerId: String? = nil
        /// The allocation ID.
        var allocationId: String? = nil
        /// The public DNS name.
        var publicDnsName: String? = nil

        public init() {}

        public init(associationId: String? = nil, publicIp: String? = nil, ipOwnerId: String? = nil, allocationId: String? = nil, publicDnsName: String? = nil) {
            self.associationId = associationId
            self.publicIp = publicIp
            self.ipOwnerId = ipOwnerId
            self.allocationId = allocationId
            self.publicDnsName = publicDnsName
        }

    }

    public struct ScheduledInstanceRecurrenceRequest: Serializable, Initializable {
        /// The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.
        var occurrenceDays: [Int32]? = nil
        /// The frequency (Daily, Weekly, or Monthly).
        var frequency: String? = nil
        /// The unit for OccurrenceDays (DayOfWeek or DayOfMonth). This value is required for a monthly schedule. You can't specify DayOfWeek with a weekly schedule. You can't specify this value with a daily schedule.
        var occurrenceUnit: String? = nil
        /// Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.
        var occurrenceRelativeToEnd: Bool? = nil
        /// The interval quantity. The interval unit depends on the value of Frequency. For example, every 2 weeks or every 2 months.
        var interval: Int32? = nil

        public init() {}

        public init(occurrenceDays: [Int32]? = nil, frequency: String? = nil, occurrenceUnit: String? = nil, occurrenceRelativeToEnd: Bool? = nil, interval: Int32? = nil) {
            self.occurrenceDays = occurrenceDays
            self.frequency = frequency
            self.occurrenceUnit = occurrenceUnit
            self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
            self.interval = interval
        }

    }

    public struct Filter: Serializable, Initializable {
        /// The name of the filter. Filter names are case-sensitive.
        var name: String? = nil
        /// One or more filter values. Filter values are case-sensitive.
        var values: [String]? = nil

        public init() {}

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

    }

    public struct MonitorInstancesRequest: Serializable, Initializable {
        /// One or more instance IDs.
        var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

    }

    public struct LaunchSpecification: Serializable, Initializable {
        /// One or more block device mapping entries. Although you can specify encrypted EBS volumes in this block device mapping for your Spot Instances, these volumes are not encrypted.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instance.
        var subnetId: String? = nil
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var userData: String? = nil
        /// Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        var ebsOptimized: Bool? = nil
        /// The ID of the kernel.
        var kernelId: String? = nil
        var monitoring: RunInstancesMonitoringEnabled? = nil
        /// The instance type.
        var instanceType: String? = nil
        /// One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
        var securityGroups: [GroupIdentifier]? = nil
        /// The name of the key pair.
        var keyName: String? = nil
        /// Deprecated.
        var addressingType: String? = nil
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// The ID of the AMI.
        var imageId: String? = nil
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The placement information for the instance.
        var placement: SpotPlacement? = nil
        /// The ID of the RAM disk.
        var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, kernelId: String? = nil, monitoring: RunInstancesMonitoringEnabled? = nil, instanceType: String? = nil, securityGroups: [GroupIdentifier]? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.kernelId = kernelId
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

    }

    public struct RequestSpotInstancesResult: Serializable, Initializable {
        /// One or more Spot instance requests.
        var spotInstanceRequests: [SpotInstanceRequest]? = nil

        public init() {}

        public init(spotInstanceRequests: [SpotInstanceRequest]? = nil) {
            self.spotInstanceRequests = spotInstanceRequests
        }

    }

    public struct CreateNetworkAclEntryRequest: Serializable, Initializable {
        /// The IPv4 network range to allow or deny, in CIDR notation (for example 172.16.0.0/24).
        var cidrBlock: String? = nil
        /// ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying the ICMP protocol, or protocol 58 (ICMPv6) with an IPv6 CIDR block.
        var icmpTypeCode: IcmpTypeCode? = nil
        /// The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number. Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.
        var ruleNumber: Int32 = 0
        /// Indicates whether to allow or deny the traffic that matches the rule.
        var ruleAction: String = ""
        /// The protocol. A value of -1 or all means all protocols. If you specify all, -1, or a protocol number other than tcp, udp, or icmp, traffic on all ports is allowed, regardless of any ports or ICMP types or codes you specify. If you specify protocol 58 (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol 58 (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.
        var `protocol`: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the network ACL.
        var networkAclId: String = ""
        /// Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).
        var egress: Bool = false
        /// The IPv6 network range to allow or deny, in CIDR notation (for example 2001:db8:1234:1a00::/64).
        var ipv6CidrBlock: String? = nil
        /// TCP or UDP protocols: The range of ports the rule applies to.
        var portRange: PortRange? = nil

        public init() {}

        public init(cidrBlock: String? = nil, icmpTypeCode: IcmpTypeCode? = nil, ruleNumber: Int32, ruleAction: String, protocol: String, dryRun: Bool? = nil, networkAclId: String, egress: Bool, ipv6CidrBlock: String? = nil, portRange: PortRange? = nil) {
            self.cidrBlock = cidrBlock
            self.icmpTypeCode = icmpTypeCode
            self.ruleNumber = ruleNumber
            self.ruleAction = ruleAction
            self.`protocol` = `protocol`
            self.dryRun = dryRun
            self.networkAclId = networkAclId
            self.egress = egress
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
        }

    }

    public struct CancelBundleTaskResult: Serializable, Initializable {
        /// Information about the bundle task.
        var bundleTask: BundleTask? = nil

        public init() {}

        public init(bundleTask: BundleTask? = nil) {
            self.bundleTask = bundleTask
        }

    }

    public struct VpcPeeringConnection: Serializable, Initializable {
        /// Information about the requester VPC.
        var requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil
        /// Information about the accepter VPC. CIDR block information is not returned when creating a VPC peering connection, or when describing a VPC peering connection that's in the initiating-request or pending-acceptance state.
        var accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil
        /// The status of the VPC peering connection.
        var status: VpcPeeringConnectionStateReason? = nil
        /// The time that an unaccepted VPC peering connection will expire.
        var expirationTime: Date? = nil
        /// Any tags assigned to the resource.
        var tags: [Tag]? = nil
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(requesterVpcInfo: VpcPeeringConnectionVpcInfo? = nil, accepterVpcInfo: VpcPeeringConnectionVpcInfo? = nil, status: VpcPeeringConnectionStateReason? = nil, expirationTime: Date? = nil, tags: [Tag]? = nil, vpcPeeringConnectionId: String? = nil) {
            self.requesterVpcInfo = requesterVpcInfo
            self.accepterVpcInfo = accepterVpcInfo
            self.status = status
            self.expirationTime = expirationTime
            self.tags = tags
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct RegisterImageResult: Serializable, Initializable {
        /// The ID of the newly registered AMI.
        var imageId: String? = nil

        public init() {}

        public init(imageId: String? = nil) {
            self.imageId = imageId
        }

    }

    public struct ClientData: Serializable, Initializable {
        /// A user-defined comment about the disk upload.
        var comment: String? = nil
        /// The time that the disk upload starts.
        var uploadStart: Date? = nil
        /// The time that the disk upload ends.
        var uploadEnd: Date? = nil
        /// The size of the uploaded disk image, in GiB.
        var uploadSize: Double? = nil

        public init() {}

        public init(comment: String? = nil, uploadStart: Date? = nil, uploadEnd: Date? = nil, uploadSize: Double? = nil) {
            self.comment = comment
            self.uploadStart = uploadStart
            self.uploadEnd = uploadEnd
            self.uploadSize = uploadSize
        }

    }

    public struct RejectVpcPeeringConnectionResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct DiskImageDescription: Serializable, Initializable {
        /// The disk image format.
        var format: String = ""
        /// The checksum computed for the disk image.
        var checksum: String? = nil
        /// The size of the disk image, in GiB.
        var size: Int64 = 0
        /// A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the Authenticating REST Requests topic in the Amazon Simple Storage Service Developer Guide. For information about the import manifest referenced by this API action, see VM Import Manifest.
        var importManifestUrl: String = ""

        public init() {}

        public init(format: String, checksum: String? = nil, size: Int64, importManifestUrl: String) {
            self.format = format
            self.checksum = checksum
            self.size = size
            self.importManifestUrl = importManifestUrl
        }

    }

    public struct CreateSubnetResult: Serializable, Initializable {
        /// Information about the subnet.
        var subnet: Subnet? = nil

        public init() {}

        public init(subnet: Subnet? = nil) {
            self.subnet = subnet
        }

    }

    public struct GetConsoleOutputResult: Serializable, Initializable {
        /// The time the output was last updated.
        var timestamp: Date? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The console output, Base64-encoded. If using a command line tool, the tool decodes the output for you.
        var output: String? = nil

        public init() {}

        public init(timestamp: Date? = nil, instanceId: String? = nil, output: String? = nil) {
            self.timestamp = timestamp
            self.instanceId = instanceId
            self.output = output
        }

    }

    public struct DisassociateRouteTableRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The association ID representing the current association between the route table and subnet.
        var associationId: String = ""

        public init() {}

        public init(dryRun: Bool? = nil, associationId: String) {
            self.dryRun = dryRun
            self.associationId = associationId
        }

    }

    public struct AssignIpv6AddressesRequest: Serializable, Initializable {
        /// The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        var ipv6AddressCount: Int32? = nil
        /// One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.
        var ipv6Addresses: [String]? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String = ""

        public init() {}

        public init(ipv6AddressCount: Int32? = nil, ipv6Addresses: [String]? = nil, networkInterfaceId: String) {
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
        }

    }

    public struct DescribeImportSnapshotTasksResult: Serializable, Initializable {
        /// The token to use to get the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.
        var importSnapshotTasks: [ImportSnapshotTask]? = nil

        public init() {}

        public init(nextToken: String? = nil, importSnapshotTasks: [ImportSnapshotTask]? = nil) {
            self.nextToken = nextToken
            self.importSnapshotTasks = importSnapshotTasks
        }

    }

    public struct VolumeStatusInfo: Serializable, Initializable {
        /// The details of the volume status.
        var details: [VolumeStatusDetails]? = nil
        /// The status of the volume.
        var status: String? = nil

        public init() {}

        public init(details: [VolumeStatusDetails]? = nil, status: String? = nil) {
            self.details = details
            self.status = status
        }

    }

    public struct DisableVpcClassicLinkDnsSupportRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil

        public init() {}

        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

    }

    public struct DescribeSubnetsResult: Serializable, Initializable {
        /// Information about one or more subnets.
        var subnets: [Subnet]? = nil

        public init() {}

        public init(subnets: [Subnet]? = nil) {
            self.subnets = subnets
        }

    }

    public struct DeleteVpcPeeringConnectionResult: Serializable, Initializable {
        /// Returns true if the request succeeds; otherwise, it returns an error.
        var `return`: Bool? = nil

        public init() {}

        public init(return: Bool? = nil) {
            self.`return` = `return`
        }

    }

    public struct UserBucketDetails: Serializable, Initializable {
        /// The S3 bucket from which the disk image was created.
        var s3Bucket: String? = nil
        /// The file name of the disk image.
        var s3Key: String? = nil

        public init() {}

        public init(s3Bucket: String? = nil, s3Key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }

    }

    public struct RequestSpotFleetResponse: Serializable, Initializable {
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""

        public init() {}

        public init(spotFleetRequestId: String) {
            self.spotFleetRequestId = spotFleetRequestId
        }

    }

    public struct DeleteVpcEndpointsResult: Serializable, Initializable {
        /// Information about the endpoints that were not successfully deleted.
        var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(unsuccessful: [UnsuccessfulItem]? = nil) {
            self.unsuccessful = unsuccessful
        }

    }

    public struct DescribeEgressOnlyInternetGatewaysRequest: Serializable, Initializable {
        /// The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned NextToken value. This value can be between 5 and 1000; if MaxResults is given a value larger than 1000, only 1000 results are returned.
        var maxResults: Int32? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token to retrieve the next page of results.
        var nextToken: String? = nil
        /// One or more egress-only Internet gateway IDs.
        var egressOnlyInternetGatewayIds: [String]? = nil

        public init() {}

        public init(maxResults: Int32? = nil, dryRun: Bool? = nil, nextToken: String? = nil, egressOnlyInternetGatewayIds: [String]? = nil) {
            self.maxResults = maxResults
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.egressOnlyInternetGatewayIds = egressOnlyInternetGatewayIds
        }

    }

    public struct AttachInternetGatewayRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// The ID of the Internet gateway.
        var internetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, internetGatewayId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

    }

    public struct CopySnapshotResult: Serializable, Initializable {
        /// The ID of the new snapshot.
        var snapshotId: String? = nil

        public init() {}

        public init(snapshotId: String? = nil) {
            self.snapshotId = snapshotId
        }

    }

    public struct VpcIpv6CidrBlockAssociation: Serializable, Initializable {
        /// Information about the state of the CIDR block.
        var ipv6CidrBlockState: VpcCidrBlockState? = nil
        /// The IPv6 CIDR block.
        var ipv6CidrBlock: String? = nil
        /// The association ID for the IPv6 CIDR block.
        var associationId: String? = nil

        public init() {}

        public init(ipv6CidrBlockState: VpcCidrBlockState? = nil, ipv6CidrBlock: String? = nil, associationId: String? = nil) {
            self.ipv6CidrBlockState = ipv6CidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
            self.associationId = associationId
        }

    }

    public struct ScheduledInstancesIamInstanceProfile: Serializable, Initializable {
        /// The name.
        var name: String? = nil
        /// The Amazon Resource Name (ARN).
        var arn: String? = nil

        public init() {}

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

    }

    public struct AcceptVpcPeeringConnectionResult: Serializable, Initializable {
        /// Information about the VPC peering connection.
        var vpcPeeringConnection: VpcPeeringConnection? = nil

        public init() {}

        public init(vpcPeeringConnection: VpcPeeringConnection? = nil) {
            self.vpcPeeringConnection = vpcPeeringConnection
        }

    }

    public struct ImportSnapshotResult: Serializable, Initializable {
        /// A description of the import snapshot task.
        var description: String? = nil
        /// Information about the import snapshot task.
        var snapshotTaskDetail: SnapshotTaskDetail? = nil
        /// The ID of the import snapshot task.
        var importTaskId: String? = nil

        public init() {}

        public init(description: String? = nil, snapshotTaskDetail: SnapshotTaskDetail? = nil, importTaskId: String? = nil) {
            self.description = description
            self.snapshotTaskDetail = snapshotTaskDetail
            self.importTaskId = importTaskId
        }

    }

    public struct SnapshotDiskContainer: Serializable, Initializable {
        /// The S3 bucket for the disk image.
        var userBucket: UserBucket? = nil
        /// The format of the disk image being imported. Valid values: RAW | VHD | VMDK | OVA 
        var format: String? = nil
        /// The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).
        var url: String? = nil
        /// The description of the disk image being imported.
        var description: String? = nil

        public init() {}

        public init(userBucket: UserBucket? = nil, format: String? = nil, url: String? = nil, description: String? = nil) {
            self.userBucket = userBucket
            self.format = format
            self.url = url
            self.description = description
        }

    }

    public struct DeleteFlowLogsResult: Serializable, Initializable {
        /// Information about the flow logs that could not be deleted successfully.
        var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(unsuccessful: [UnsuccessfulItem]? = nil) {
            self.unsuccessful = unsuccessful
        }

    }

    public struct DescribeDhcpOptionsResult: Serializable, Initializable {
        /// Information about one or more DHCP options sets.
        var dhcpOptions: [DhcpOptions]? = nil

        public init() {}

        public init(dhcpOptions: [DhcpOptions]? = nil) {
            self.dhcpOptions = dhcpOptions
        }

    }

    public struct DeleteRouteRequest: Serializable, Initializable {
        /// The ID of the route table.
        var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        var destinationCidrBlock: String? = nil
        /// The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        var destinationIpv6CidrBlock: String? = nil

        public init() {}

        public init(routeTableId: String, dryRun: Bool? = nil, destinationCidrBlock: String? = nil, destinationIpv6CidrBlock: String? = nil) {
            self.routeTableId = routeTableId
            self.dryRun = dryRun
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
        }

    }

    public struct IamInstanceProfileAssociation: Serializable, Initializable {
        /// The time the IAM instance profile was associated with the instance.
        var timestamp: Date? = nil
        /// The ID of the association.
        var associationId: String? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The state of the association.
        var state: String? = nil
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfile? = nil

        public init() {}

        public init(timestamp: Date? = nil, associationId: String? = nil, instanceId: String? = nil, state: String? = nil, iamInstanceProfile: IamInstanceProfile? = nil) {
            self.timestamp = timestamp
            self.associationId = associationId
            self.instanceId = instanceId
            self.state = state
            self.iamInstanceProfile = iamInstanceProfile
        }

    }

    public struct PeeringConnectionOptions: Serializable, Initializable {
        /// If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC via ClassicLink.
        var allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil
        /// If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.
        var allowDnsResolutionFromRemoteVpc: Bool? = nil
        /// If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC via ClassicLink to instances in a peer VPC.
        var allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil

        public init() {}

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

    }

    public struct DetachVpnGatewayRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the virtual private gateway.
        var vpnGatewayId: String = ""

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil, vpnGatewayId: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

    }

    public struct RouteTableAssociation: Serializable, Initializable {
        /// The ID of the subnet. A subnet ID is not returned for an implicit association.
        var subnetId: String? = nil
        /// The ID of the route table.
        var routeTableId: String? = nil
        /// The ID of the association between a route table and a subnet.
        var routeTableAssociationId: String? = nil
        /// Indicates whether this is the main route table.
        var main: Bool? = nil

        public init() {}

        public init(subnetId: String? = nil, routeTableId: String? = nil, routeTableAssociationId: String? = nil, main: Bool? = nil) {
            self.subnetId = subnetId
            self.routeTableId = routeTableId
            self.routeTableAssociationId = routeTableAssociationId
            self.main = main
        }

    }

    public struct UnmonitorInstancesRequest: Serializable, Initializable {
        /// One or more instance IDs.
        var instanceIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceIds: [String], dryRun: Bool? = nil) {
            self.instanceIds = instanceIds
            self.dryRun = dryRun
        }

    }

    public struct DescribeExportTasksRequest: Serializable, Initializable {
        /// One or more export task IDs.
        var exportTaskIds: [String]? = nil

        public init() {}

        public init(exportTaskIds: [String]? = nil) {
            self.exportTaskIds = exportTaskIds
        }

    }

    public struct PricingDetail: Serializable, Initializable {
        /// The price per instance.
        var price: Double? = nil
        /// The number of reservations available for the price.
        var count: Int32? = nil

        public init() {}

        public init(price: Double? = nil, count: Int32? = nil) {
            self.price = price
            self.count = count
        }

    }

    public struct GetConsoleScreenshotResult: Serializable, Initializable {
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The data that comprises the image.
        var imageData: String? = nil

        public init() {}

        public init(instanceId: String? = nil, imageData: String? = nil) {
            self.instanceId = instanceId
            self.imageData = imageData
        }

    }

    public struct DescribeReservedInstancesRequest: Serializable, Initializable {
        /// One or more Reserved Instance IDs. Default: Describes all your Reserved Instances, or only those otherwise specified.
        var reservedInstancesIds: [String]? = nil
        /// One or more filters.    availability-zone - The Availability Zone where the Reserved Instance can be used.    duration - The duration of the Reserved Instance (one year or three years), in seconds (31536000 | 94608000).    end - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).    fixed-price - The purchase price of the Reserved Instance (for example, 9800.0).    instance-type - The instance type that is covered by the reservation.    scope - The scope of the Reserved Instance (Region or Availability Zone).    product-description - The Reserved Instance product platform description. Instances that include (Amazon VPC) in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (Linux/UNIX | Linux/UNIX (Amazon VPC) | SUSE Linux | SUSE Linux (Amazon VPC) | Red Hat Enterprise Linux | Red Hat Enterprise Linux (Amazon VPC) | Windows | Windows (Amazon VPC) | Windows with SQL Server Standard | Windows with SQL Server Standard (Amazon VPC) | Windows with SQL Server Web | Windows with SQL Server Web (Amazon VPC) | Windows with SQL Server Enterprise | Windows with SQL Server Enterprise (Amazon VPC)).    reserved-instances-id - The ID of the Reserved Instance.    start - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).    state - The state of the Reserved Instance (payment-pending | active | payment-failed | retired).    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    usage-price - The usage price of the Reserved Instance, per hour (for example, 0.84).  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the Medium Utilization Reserved Instance offering type.
        var offeringType: String? = nil
        /// Describes whether the Reserved Instance is Standard or Convertible.
        var offeringClass: String? = nil

        public init() {}

        public init(reservedInstancesIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, offeringType: String? = nil, offeringClass: String? = nil) {
            self.reservedInstancesIds = reservedInstancesIds
            self.filters = filters
            self.dryRun = dryRun
            self.offeringType = offeringType
            self.offeringClass = offeringClass
        }

    }

    public struct Placement: Serializable, Initializable {
        /// The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the ImportInstance command.
        var affinity: String? = nil
        /// The name of the placement group the instance is in (for cluster compute instances).
        var groupName: String? = nil
        /// The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the ImportInstance command.
        var hostId: String? = nil
        /// The Availability Zone of the instance.
        var availabilityZone: String? = nil
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the ImportInstance command.
        var tenancy: String? = nil

        public init() {}

        public init(affinity: String? = nil, groupName: String? = nil, hostId: String? = nil, availabilityZone: String? = nil, tenancy: String? = nil) {
            self.affinity = affinity
            self.groupName = groupName
            self.hostId = hostId
            self.availabilityZone = availabilityZone
            self.tenancy = tenancy
        }

    }

    public struct DescribeStaleSecurityGroupsResult: Serializable, Initializable {
        /// Information about the stale security groups.
        var staleSecurityGroupSet: [StaleSecurityGroup]? = nil
        /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
        var nextToken: String? = nil

        public init() {}

        public init(staleSecurityGroupSet: [StaleSecurityGroup]? = nil, nextToken: String? = nil) {
            self.staleSecurityGroupSet = staleSecurityGroupSet
            self.nextToken = nextToken
        }

    }

    public struct ScheduledInstancesNetworkInterface: Serializable, Initializable {
        /// The index of the device for the network interface attachment.
        var deviceIndex: Int32? = nil
        /// The ID of the subnet.
        var subnetId: String? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String? = nil
        /// The IPv4 address of the network interface within the subnet.
        var privateIpAddress: String? = nil
        /// The private IPv4 addresses.
        var privateIpAddressConfigs: [ScheduledInstancesPrivateIpAddressConfig]? = nil
        /// The number of secondary private IPv4 addresses.
        var secondaryPrivateIpAddressCount: Int32? = nil
        /// The description.
        var description: String? = nil
        /// The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.
        var ipv6AddressCount: Int32? = nil
        /// One or more specific IPv6 addresses from the subnet range.
        var ipv6Addresses: [ScheduledInstancesIpv6Address]? = nil
        /// Indicates whether to delete the interface when the instance is terminated.
        var deleteOnTermination: Bool? = nil
        /// The IDs of one or more security groups.
        var groups: [String]? = nil
        /// Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
        var associatePublicIpAddress: Bool? = nil

        public init() {}

        public init(deviceIndex: Int32? = nil, subnetId: String? = nil, networkInterfaceId: String? = nil, privateIpAddress: String? = nil, privateIpAddressConfigs: [ScheduledInstancesPrivateIpAddressConfig]? = nil, secondaryPrivateIpAddressCount: Int32? = nil, description: String? = nil, ipv6AddressCount: Int32? = nil, ipv6Addresses: [ScheduledInstancesIpv6Address]? = nil, deleteOnTermination: Bool? = nil, groups: [String]? = nil, associatePublicIpAddress: Bool? = nil) {
            self.deviceIndex = deviceIndex
            self.subnetId = subnetId
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddressConfigs = privateIpAddressConfigs
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.description = description
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.deleteOnTermination = deleteOnTermination
            self.groups = groups
            self.associatePublicIpAddress = associatePublicIpAddress
        }

    }

    public struct UserIdGroupPair: Serializable, Initializable {
        /// The ID of an AWS account. For a referenced security group in another VPC, the account ID of the referenced security group is returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.
        var userId: String? = nil
        /// The status of a VPC peering connection, if applicable.
        var peeringStatus: String? = nil
        /// The ID of the VPC for the referenced security group, if applicable.
        var vpcId: String? = nil
        /// The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID.
        var groupName: String? = nil
        /// The ID of the security group.
        var groupId: String? = nil
        /// The ID of the VPC peering connection, if applicable.
        var vpcPeeringConnectionId: String? = nil

        public init() {}

        public init(userId: String? = nil, peeringStatus: String? = nil, vpcId: String? = nil, groupName: String? = nil, groupId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.userId = userId
            self.peeringStatus = peeringStatus
            self.vpcId = vpcId
            self.groupName = groupName
            self.groupId = groupId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct DescribeConversionTasksRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more conversion task IDs.
        var conversionTaskIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, conversionTaskIds: [String]? = nil) {
            self.dryRun = dryRun
            self.conversionTaskIds = conversionTaskIds
        }

    }

    public struct ModifySubnetAttributeRequest: Serializable, Initializable {
        /// Specify true to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).
        var mapPublicIpOnLaunch: AttributeBooleanValue? = nil
        /// The ID of the subnet.
        var subnetId: String = ""
        /// Specify true to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address).  If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version 2016-11-15 or later of the Amazon EC2 API.
        var assignIpv6AddressOnCreation: AttributeBooleanValue? = nil

        public init() {}

        public init(mapPublicIpOnLaunch: AttributeBooleanValue? = nil, subnetId: String, assignIpv6AddressOnCreation: AttributeBooleanValue? = nil) {
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.subnetId = subnetId
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
        }

    }

    public struct PlacementGroup: Serializable, Initializable {
        /// The state of the placement group.
        var state: String? = nil
        /// The placement strategy.
        var strategy: String? = nil
        /// The name of the placement group.
        var groupName: String? = nil

        public init() {}

        public init(state: String? = nil, strategy: String? = nil, groupName: String? = nil) {
            self.state = state
            self.strategy = strategy
            self.groupName = groupName
        }

    }

    public struct AssociateAddressResult: Serializable, Initializable {
        /// [EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.
        var associationId: String? = nil

        public init() {}

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

    }

    public struct Reservation: Serializable, Initializable {
        /// The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).
        var requesterId: String? = nil
        /// One or more instances.
        var instances: [Instance]? = nil
        /// The ID of the reservation.
        var reservationId: String? = nil
        /// The ID of the AWS account that owns the reservation.
        var ownerId: String? = nil
        /// [EC2-Classic only] One or more security groups.
        var groups: [GroupIdentifier]? = nil

        public init() {}

        public init(requesterId: String? = nil, instances: [Instance]? = nil, reservationId: String? = nil, ownerId: String? = nil, groups: [GroupIdentifier]? = nil) {
            self.requesterId = requesterId
            self.instances = instances
            self.reservationId = reservationId
            self.ownerId = ownerId
            self.groups = groups
        }

    }

    public struct SpotFleetRequestConfigData: Serializable, Initializable {
        /// The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O.
        var targetCapacity: Int32 = 0
        /// A unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see Ensuring Idempotency.
        var clientToken: String? = nil
        /// Grants the Spot fleet permission to terminate Spot instances on your behalf when you cancel its Spot fleet request using CancelSpotFleetRequests or when the Spot fleet request expires, if you set terminateInstancesWithExpiration.
        var iamFleetRole: String = ""
        /// The bid price per unit hour.
        var spotPrice: String = ""
        /// The end date and time of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). At this point, no new Spot instance requests are placed or enabled to fulfill the request.
        var validUntil: Date? = nil
        /// Indicates how to allocate the target capacity across the Spot pools specified by the Spot fleet request. The default is lowestPrice.
        var allocationStrategy: String? = nil
        /// Indicates whether running Spot instances should be terminated if the target capacity of the Spot fleet request is decreased below the current size of the Spot fleet.
        var excessCapacityTerminationPolicy: String? = nil
        /// Information about the launch specifications for the Spot fleet request.
        var launchSpecifications: [SpotFleetLaunchSpecification] = []
        /// The start date and time of the request, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). The default is to start fulfilling the request immediately.
        var validFrom: Date? = nil
        /// Indicates whether running Spot instances should be terminated when the Spot fleet request expires.
        var terminateInstancesWithExpiration: Bool? = nil
        /// Indicates whether Spot fleet should replace unhealthy instances.
        var replaceUnhealthyInstances: Bool? = nil
        /// The number of units fulfilled by this request compared to the set target capacity.
        var fulfilledCapacity: Double? = nil
        /// The type of request. Indicates whether the fleet will only request the target capacity or also attempt to maintain it. When you request a certain target capacity, the fleet will only place the required bids. It will not attempt to replenish Spot instances if capacity is diminished, nor will it submit bids in alternative Spot pools if capacity is not available. When you want to maintain a certain target capacity, fleet will place the required bids to meet this target capacity. It will also automatically replenish any interrupted instances. Default: maintain.
        var type: String? = nil

        public init() {}

        public init(targetCapacity: Int32, clientToken: String? = nil, iamFleetRole: String, spotPrice: String, validUntil: Date? = nil, allocationStrategy: String? = nil, excessCapacityTerminationPolicy: String? = nil, launchSpecifications: [SpotFleetLaunchSpecification], validFrom: Date? = nil, terminateInstancesWithExpiration: Bool? = nil, replaceUnhealthyInstances: Bool? = nil, fulfilledCapacity: Double? = nil, type: String? = nil) {
            self.targetCapacity = targetCapacity
            self.clientToken = clientToken
            self.iamFleetRole = iamFleetRole
            self.spotPrice = spotPrice
            self.validUntil = validUntil
            self.allocationStrategy = allocationStrategy
            self.excessCapacityTerminationPolicy = excessCapacityTerminationPolicy
            self.launchSpecifications = launchSpecifications
            self.validFrom = validFrom
            self.terminateInstancesWithExpiration = terminateInstancesWithExpiration
            self.replaceUnhealthyInstances = replaceUnhealthyInstances
            self.fulfilledCapacity = fulfilledCapacity
            self.type = type
        }

    }

    public struct DeleteInternetGatewayRequest: Serializable, Initializable {
        /// The ID of the Internet gateway.
        var internetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(internetGatewayId: String, dryRun: Bool? = nil) {
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

    }

    public struct ScheduledInstancesBlockDeviceMapping: Serializable, Initializable {
        /// Suppresses the specified device included in the block device mapping of the AMI.
        var noDevice: String? = nil
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for ephemeral0 and ephemeral1.The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        var virtualName: String? = nil
        /// The device name exposed to the instance (for example, /dev/sdh or xvdh).
        var deviceName: String? = nil
        /// Parameters used to set up EBS volumes automatically when the instance is launched.
        var ebs: ScheduledInstancesEbs? = nil

        public init() {}

        public init(noDevice: String? = nil, virtualName: String? = nil, deviceName: String? = nil, ebs: ScheduledInstancesEbs? = nil) {
            self.noDevice = noDevice
            self.virtualName = virtualName
            self.deviceName = deviceName
            self.ebs = ebs
        }

    }

    public struct StateReason: Serializable, Initializable {
        /// The reason code for the state change.
        var code: String? = nil
        /// The message for the state change.    Server.InsufficientInstanceCapacity: There was insufficient instance capacity to satisfy the launch request.    Server.InternalError: An internal error occurred during instance launch, resulting in termination.    Server.ScheduledStop: The instance was stopped due to a scheduled retirement.    Server.SpotInstanceTermination: A Spot instance was terminated due to an increase in the market price.    Client.InternalError: A client error caused the instance to terminate on launch.    Client.InstanceInitiatedShutdown: The instance was shut down using the shutdown -h command from the instance.    Client.UserInitiatedShutdown: The instance was shut down using the Amazon EC2 API.    Client.VolumeLimitExceeded: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your limits.    Client.InvalidSnapshot.NotFound: The specified snapshot was not found.  
        var message: String? = nil

        public init() {}

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

    }

    public struct DeleteTagsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more tags to delete. If you omit the value parameter, we delete the tag regardless of its value. If you specify this parameter with an empty string as the value, we delete the key only if its value is an empty string.
        var tags: [Tag]? = nil
        /// The ID of the resource. For example, ami-1a2b3c4d. You can specify more than one resource ID.
        var resources: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, tags: [Tag]? = nil, resources: [String]) {
            self.dryRun = dryRun
            self.tags = tags
            self.resources = resources
        }

    }

    public struct DescribeSpotInstanceRequestsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    availability-zone-group - The Availability Zone group.    create-time - The time stamp when the Spot instance request was created.    fault-code - The fault code related to the request.    fault-message - The fault message related to the request.    instance-id - The ID of the instance that fulfilled the request.    launch-group - The Spot instance launch group.    launch.block-device-mapping.delete-on-termination - Indicates whether the Amazon EBS volume is deleted on instance termination.    launch.block-device-mapping.device-name - The device name for the Amazon EBS volume (for example, /dev/sdh).    launch.block-device-mapping.snapshot-id - The ID of the snapshot used for the Amazon EBS volume.    launch.block-device-mapping.volume-size - The size of the Amazon EBS volume, in GiB.    launch.block-device-mapping.volume-type - The type of the Amazon EBS volume: gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, st1 for Throughput Optimized HDD, sc1for Cold HDD, or standard for Magnetic.    launch.group-id - The security group for the instance.    launch.image-id - The ID of the AMI.    launch.instance-type - The type of instance (for example, m3.medium).    launch.kernel-id - The kernel ID.    launch.key-name - The name of the key pair the instance launched with.    launch.monitoring-enabled - Whether monitoring is enabled for the Spot instance.    launch.ramdisk-id - The RAM disk ID.    network-interface.network-interface-id - The ID of the network interface.    network-interface.device-index - The index of the device for the network interface attachment on the instance.    network-interface.subnet-id - The ID of the subnet for the instance.    network-interface.description - A description of the network interface.    network-interface.private-ip-address - The primary private IP address of the network interface.    network-interface.delete-on-termination - Indicates whether the network interface is deleted when the instance is terminated.    network-interface.group-id - The ID of the security group associated with the network interface.    network-interface.group-name - The name of the security group associated with the network interface.    network-interface.addresses.primary - Indicates whether the IP address is the primary private IP address.    product-description - The product description associated with the instance (Linux/UNIX | Windows).    spot-instance-request-id - The Spot instance request ID.    spot-price - The maximum hourly price for any Spot instance launched to fulfill the request.    state - The state of the Spot instance request (open | active | closed | cancelled | failed). Spot bid status information can help you track your Amazon EC2 Spot instance requests. For more information, see Spot Bid Status in the Amazon Elastic Compute Cloud User Guide.    status-code - The short code describing the most recent evaluation of your Spot instance request.    status-message - The message explaining the status of the Spot instance request.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.    type - The type of Spot instance request (one-time | persistent).    launched-availability-zone - The Availability Zone in which the bid is launched.    valid-from - The start date of the request.    valid-until - The end date of the request.  
        var filters: [Filter]? = nil
        /// One or more Spot instance request IDs.
        var spotInstanceRequestIds: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, spotInstanceRequestIds: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.spotInstanceRequestIds = spotInstanceRequestIds
        }

    }

    public struct AttachClassicLinkVpcRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of a ClassicLink-enabled VPC.
        var vpcId: String = ""
        /// The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.
        var instanceId: String = ""
        /// The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.
        var groups: [String] = []

        public init() {}

        public init(dryRun: Bool? = nil, vpcId: String, instanceId: String, groups: [String]) {
            self.dryRun = dryRun
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.groups = groups
        }

    }

    public struct ReleaseHostsResult: Serializable, Initializable {
        /// The IDs of the Dedicated Hosts that were successfully released.
        var successful: [String]? = nil
        /// The IDs of the Dedicated Hosts that could not be released, including an error message.
        var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(successful: [String]? = nil, unsuccessful: [UnsuccessfulItem]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

    }

    public struct ExportToS3TaskSpecification: Serializable, Initializable {
        /// The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.
        var s3Prefix: String? = nil
        /// The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.
        var containerFormat: String? = nil
        /// The format for the exported image.
        var diskImageFormat: String? = nil
        /// The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account vm-import-export@amazon.com.
        var s3Bucket: String? = nil

        public init() {}

        public init(s3Prefix: String? = nil, containerFormat: String? = nil, diskImageFormat: String? = nil, s3Bucket: String? = nil) {
            self.s3Prefix = s3Prefix
            self.containerFormat = containerFormat
            self.diskImageFormat = diskImageFormat
            self.s3Bucket = s3Bucket
        }

    }

    public struct CancelSpotFleetRequestsError: Serializable, Initializable {
        /// The error code.
        var code: String = ""
        /// The description for the error code.
        var message: String = ""

        public init() {}

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

    }

    public struct DescribeKeyPairsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    fingerprint - The fingerprint of the key pair.    key-name - The name of the key pair.  
        var filters: [Filter]? = nil
        /// One or more key pair names. Default: Describes all your key pairs.
        var keyNames: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, keyNames: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.keyNames = keyNames
        }

    }

    public struct DescribeReservedInstancesOfferingsResult: Serializable, Initializable {
        /// A list of Reserved Instances offerings.
        var reservedInstancesOfferings: [ReservedInstancesOffering]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(reservedInstancesOfferings: [ReservedInstancesOffering]? = nil, nextToken: String? = nil) {
            self.reservedInstancesOfferings = reservedInstancesOfferings
            self.nextToken = nextToken
        }

    }

    public struct VpnStaticRoute: Serializable, Initializable {
        /// The CIDR block associated with the local subnet of the customer data center.
        var destinationCidrBlock: String? = nil
        /// The current state of the static route.
        var state: String? = nil
        /// Indicates how the routes were provided.
        var source: String? = nil

        public init() {}

        public init(destinationCidrBlock: String? = nil, state: String? = nil, source: String? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
            self.source = source
        }

    }

    public struct CopySnapshotRequest: Serializable, Initializable {
        /// The ID of the EBS snapshot to copy.
        var sourceSnapshotId: String = ""
        /// The full ARN of the AWS Key Management Service (AWS KMS) CMK to use when creating the snapshot copy. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. The ARN contains the arn:aws:kms namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the key namespace, and then the CMK ID. For example, arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. The specified CMK must exist in the region that the snapshot is being copied to. If a KmsKeyId is specified, the Encrypted flag must also be set.
        var kmsKeyId: String? = nil
        /// The ID of the region that contains the snapshot to be copied.
        var sourceRegion: String = ""
        /// Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot using this flag, but you cannot use it to create an unencrypted copy from an encrypted snapshot. Your default CMK for EBS is used unless a non-default AWS Key Management Service (AWS KMS) CMK is specified with KmsKeyId. For more information, see Amazon EBS Encryption in the Amazon Elastic Compute Cloud User Guide.
        var encrypted: Bool? = nil
        /// The destination region to use in the PresignedUrl parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a PresignedUrl parameter, where it is required.   CopySnapshot sends the snapshot copy to the regional endpoint that you send the HTTP request to, such as ec2.us-east-1.amazonaws.com (in the AWS CLI, this is specified with the --region parameter or the default region in your AWS configuration file). 
        var destinationRegion: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The pre-signed URL that facilitates copying an encrypted snapshot. This parameter is only required when copying an encrypted snapshot with the Amazon EC2 Query API; it is available as an optional parameter in all other cases. The PresignedUrl should use the snapshot source endpoint, the CopySnapshot action, and include the SourceRegion, SourceSnapshotId, and DestinationRegion parameters. The PresignedUrl must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in Authenticating Requests by Using Query Parameters (AWS Signature Version 4) in the Amazon Simple Storage Service API Reference. An invalid or improperly signed PresignedUrl will cause the copy operation to fail asynchronously, and the snapshot will move to an error state.
        var presignedUrl: String? = nil
        /// A description for the EBS snapshot.
        var description: String? = nil

        public init() {}

        public init(sourceSnapshotId: String, kmsKeyId: String? = nil, sourceRegion: String, encrypted: Bool? = nil, destinationRegion: String? = nil, dryRun: Bool? = nil, presignedUrl: String? = nil, description: String? = nil) {
            self.sourceSnapshotId = sourceSnapshotId
            self.kmsKeyId = kmsKeyId
            self.sourceRegion = sourceRegion
            self.encrypted = encrypted
            self.destinationRegion = destinationRegion
            self.dryRun = dryRun
            self.presignedUrl = presignedUrl
            self.description = description
        }

    }

    public struct DescribePlacementGroupsResult: Serializable, Initializable {
        /// One or more placement groups.
        var placementGroups: [PlacementGroup]? = nil

        public init() {}

        public init(placementGroups: [PlacementGroup]? = nil) {
            self.placementGroups = placementGroups
        }

    }

    public struct DetachVolumeRequest: Serializable, Initializable {
        /// The device name.
        var device: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The ID of the volume.
        var volumeId: String = ""
        /// Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.
        var force: Bool? = nil

        public init() {}

        public init(device: String? = nil, dryRun: Bool? = nil, instanceId: String? = nil, volumeId: String, force: Bool? = nil) {
            self.device = device
            self.dryRun = dryRun
            self.instanceId = instanceId
            self.volumeId = volumeId
            self.force = force
        }

    }

    public struct EgressOnlyInternetGateway: Serializable, Initializable {
        /// The ID of the egress-only Internet gateway.
        var egressOnlyInternetGatewayId: String? = nil
        /// Information about the attachment of the egress-only Internet gateway.
        var attachments: [InternetGatewayAttachment]? = nil

        public init() {}

        public init(egressOnlyInternetGatewayId: String? = nil, attachments: [InternetGatewayAttachment]? = nil) {
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.attachments = attachments
        }

    }

    public struct EnableVgwRoutePropagationRequest: Serializable, Initializable {
        /// The ID of the virtual private gateway.
        var gatewayId: String = ""
        /// The ID of the route table.
        var routeTableId: String = ""

        public init() {}

        public init(gatewayId: String, routeTableId: String) {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }

    }

    public struct GetReservedInstancesExchangeQuoteRequest: Serializable, Initializable {
        /// The IDs of the Convertible Reserved Instances to exchange.
        var reservedInstanceIds: [String] = []
        /// The configuration requirements of the Convertible Reserved Instances to exchange for your current Convertible Reserved Instances.
        var targetConfigurations: [TargetConfigurationRequest]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(reservedInstanceIds: [String], targetConfigurations: [TargetConfigurationRequest]? = nil, dryRun: Bool? = nil) {
            self.reservedInstanceIds = reservedInstanceIds
            self.targetConfigurations = targetConfigurations
            self.dryRun = dryRun
        }

    }

    public struct SpotFleetLaunchSpecification: Serializable, Initializable {
        /// One or more block device mapping entries.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".
        var subnetId: String? = nil
        /// The user data to make available to the instances. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var userData: String? = nil
        /// Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: false 
        var ebsOptimized: Bool? = nil
        /// The bid price per unit hour for the specified instance type. If this value is not specified, the default is the Spot bid price specified for the fleet. To determine the bid price per unit hour, divide the Spot bid price by the value of WeightedCapacity.
        var spotPrice: String? = nil
        /// The ID of the kernel.
        var kernelId: String? = nil
        /// Enable or disable monitoring for the instances.
        var monitoring: SpotFleetMonitoring? = nil
        /// The instance type. Note that T2 and HS1 instance types are not supported.
        var instanceType: String? = nil
        /// The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O). If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.
        var weightedCapacity: Double? = nil
        /// One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
        var securityGroups: [GroupIdentifier]? = nil
        /// The name of the key pair.
        var keyName: String? = nil
        /// Deprecated.
        var addressingType: String? = nil
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfileSpecification? = nil
        /// The ID of the AMI.
        var imageId: String? = nil
        /// One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
        var networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil
        /// The placement information.
        var placement: SpotPlacement? = nil
        /// The ID of the RAM disk.
        var ramdiskId: String? = nil

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, subnetId: String? = nil, userData: String? = nil, ebsOptimized: Bool? = nil, spotPrice: String? = nil, kernelId: String? = nil, monitoring: SpotFleetMonitoring? = nil, instanceType: String? = nil, weightedCapacity: Double? = nil, securityGroups: [GroupIdentifier]? = nil, keyName: String? = nil, addressingType: String? = nil, iamInstanceProfile: IamInstanceProfileSpecification? = nil, imageId: String? = nil, networkInterfaces: [InstanceNetworkInterfaceSpecification]? = nil, placement: SpotPlacement? = nil, ramdiskId: String? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.subnetId = subnetId
            self.userData = userData
            self.ebsOptimized = ebsOptimized
            self.spotPrice = spotPrice
            self.kernelId = kernelId
            self.monitoring = monitoring
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
            self.securityGroups = securityGroups
            self.keyName = keyName
            self.addressingType = addressingType
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.networkInterfaces = networkInterfaces
            self.placement = placement
            self.ramdiskId = ramdiskId
        }

    }

    public struct Region: Serializable, Initializable {
        /// The region service endpoint.
        var endpoint: String? = nil
        /// The name of the region.
        var regionName: String? = nil

        public init() {}

        public init(endpoint: String? = nil, regionName: String? = nil) {
            self.endpoint = endpoint
            self.regionName = regionName
        }

    }

    public struct PurchaseRequest: Serializable, Initializable {
        /// The purchase token.
        var purchaseToken: String = ""
        /// The number of instances.
        var instanceCount: Int32 = 0

        public init() {}

        public init(purchaseToken: String, instanceCount: Int32) {
            self.purchaseToken = purchaseToken
            self.instanceCount = instanceCount
        }

    }

    public struct DetachInternetGatewayRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// The ID of the Internet gateway.
        var internetGatewayId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcId: String, internetGatewayId: String, dryRun: Bool? = nil) {
            self.vpcId = vpcId
            self.internetGatewayId = internetGatewayId
            self.dryRun = dryRun
        }

    }

    public struct DescribeVpcClassicLinkDnsSupportResult: Serializable, Initializable {
        /// Information about the ClassicLink DNS support status of the VPCs.
        var vpcs: [ClassicLinkDnsSupport]? = nil
        /// The token to use when requesting the next set of items.
        var nextToken: String? = nil

        public init() {}

        public init(vpcs: [ClassicLinkDnsSupport]? = nil, nextToken: String? = nil) {
            self.vpcs = vpcs
            self.nextToken = nextToken
        }

    }

    public struct CreateInternetGatewayRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(dryRun: Bool? = nil) {
            self.dryRun = dryRun
        }

    }

    public struct VpnConnectionOptionsSpecification: Serializable, Initializable {
        /// Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.
        var staticRoutesOnly: Bool? = nil

        public init() {}

        public init(staticRoutesOnly: Bool? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
        }

    }

    public struct HistoryRecord: Serializable, Initializable {
        /// The event type.    error - Indicates an error with the Spot fleet request.    fleetRequestChange - Indicates a change in the status or configuration of the Spot fleet request.    instanceChange - Indicates that an instance was launched or terminated.  
        var eventType: String = ""
        /// The date and time of the event, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var timestamp: Date = Date()
        /// Information about the event.
        var eventInformation: EventInformation = EventInformation()

        public init() {}

        public init(eventType: String, timestamp: Date, eventInformation: EventInformation) {
            self.eventType = eventType
            self.timestamp = timestamp
            self.eventInformation = eventInformation
        }

    }

    public struct DescribeSpotFleetRequestsResponse: Serializable, Initializable {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// Information about the configuration of your Spot fleet.
        var spotFleetRequestConfigs: [SpotFleetRequestConfig] = []

        public init() {}

        public init(nextToken: String? = nil, spotFleetRequestConfigs: [SpotFleetRequestConfig]) {
            self.nextToken = nextToken
            self.spotFleetRequestConfigs = spotFleetRequestConfigs
        }

    }

    public struct VpcPeeringConnectionOptionsDescription: Serializable, Initializable {
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        var allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        var allowDnsResolutionFromRemoteVpc: Bool? = nil
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        var allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil

        public init() {}

        public init(allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil, allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil) {
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
        }

    }

    public struct InstanceStatus: Serializable, Initializable {
        /// The intended state of the instance. DescribeInstanceStatus requires that an instance be in the running state.
        var instanceState: InstanceState? = nil
        /// Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.
        var systemStatus: InstanceStatusSummary? = nil
        /// Any scheduled events associated with the instance.
        var events: [InstanceStatusEvent]? = nil
        /// Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.
        var instanceStatus: InstanceStatusSummary? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// The Availability Zone of the instance.
        var availabilityZone: String? = nil

        public init() {}

        public init(instanceState: InstanceState? = nil, systemStatus: InstanceStatusSummary? = nil, events: [InstanceStatusEvent]? = nil, instanceStatus: InstanceStatusSummary? = nil, instanceId: String? = nil, availabilityZone: String? = nil) {
            self.instanceState = instanceState
            self.systemStatus = systemStatus
            self.events = events
            self.instanceStatus = instanceStatus
            self.instanceId = instanceId
            self.availabilityZone = availabilityZone
        }

    }

    public struct VpcPeeringConnectionVpcInfo: Serializable, Initializable {
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        var peeringOptions: VpcPeeringConnectionOptionsDescription? = nil
        /// The IPv6 CIDR block for the VPC.
        var ipv6CidrBlockSet: [Ipv6CidrBlock]? = nil
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// The AWS account ID of the VPC owner.
        var ownerId: String? = nil
        /// The IPv4 CIDR block for the VPC.
        var cidrBlock: String? = nil

        public init() {}

        public init(peeringOptions: VpcPeeringConnectionOptionsDescription? = nil, ipv6CidrBlockSet: [Ipv6CidrBlock]? = nil, vpcId: String? = nil, ownerId: String? = nil, cidrBlock: String? = nil) {
            self.peeringOptions = peeringOptions
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.vpcId = vpcId
            self.ownerId = ownerId
            self.cidrBlock = cidrBlock
        }

    }

    public struct SnapshotTaskDetail: Serializable, Initializable {
        /// A brief status for the import snapshot task.
        var status: String? = nil
        /// The percentage of completion for the import snapshot task.
        var progress: String? = nil
        /// The URL of the disk image from which the snapshot is created.
        var url: String? = nil
        /// The size of the disk in the snapshot, in GiB.
        var diskImageSize: Double? = nil
        /// The format of the disk image from which the snapshot is created.
        var format: String? = nil
        /// The snapshot ID of the disk being imported.
        var snapshotId: String? = nil
        /// The S3 bucket for the disk image.
        var userBucket: UserBucketDetails? = nil
        /// A detailed status message for the import snapshot task.
        var statusMessage: String? = nil
        /// The description of the snapshot.
        var description: String? = nil

        public init() {}

        public init(status: String? = nil, progress: String? = nil, url: String? = nil, diskImageSize: Double? = nil, format: String? = nil, snapshotId: String? = nil, userBucket: UserBucketDetails? = nil, statusMessage: String? = nil, description: String? = nil) {
            self.status = status
            self.progress = progress
            self.url = url
            self.diskImageSize = diskImageSize
            self.format = format
            self.snapshotId = snapshotId
            self.userBucket = userBucket
            self.statusMessage = statusMessage
            self.description = description
        }

    }

    public struct CreateSpotDatafeedSubscriptionResult: Serializable, Initializable {
        /// The Spot instance data feed subscription.
        var spotDatafeedSubscription: SpotDatafeedSubscription? = nil

        public init() {}

        public init(spotDatafeedSubscription: SpotDatafeedSubscription? = nil) {
            self.spotDatafeedSubscription = spotDatafeedSubscription
        }

    }

    public struct DescribeSpotInstanceRequestsResult: Serializable, Initializable {
        /// One or more Spot instance requests.
        var spotInstanceRequests: [SpotInstanceRequest]? = nil

        public init() {}

        public init(spotInstanceRequests: [SpotInstanceRequest]? = nil) {
            self.spotInstanceRequests = spotInstanceRequests
        }

    }

    public struct ModifyVpcPeeringConnectionOptionsRequest: Serializable, Initializable {
        /// The VPC peering connection options for the accepter VPC.
        var accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil
        /// The VPC peering connection options for the requester VPC.
        var requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil
        /// Checks whether you have the required permissions for the operation, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the VPC peering connection.
        var vpcPeeringConnectionId: String = ""

        public init() {}

        public init(accepterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil, requesterPeeringConnectionOptions: PeeringConnectionOptionsRequest? = nil, dryRun: Bool? = nil, vpcPeeringConnectionId: String) {
            self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
            self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
            self.dryRun = dryRun
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

    }

    public struct IamInstanceProfileSpecification: Serializable, Initializable {
        /// The name of the instance profile.
        var name: String? = nil
        /// The Amazon Resource Name (ARN) of the instance profile.
        var arn: String? = nil

        public init() {}

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

    }

    public struct ConfirmProductInstanceRequest: Serializable, Initializable {
        /// The ID of the instance.
        var instanceId: String = ""
        /// The product code. This must be a product code that you own.
        var productCode: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(instanceId: String, productCode: String, dryRun: Bool? = nil) {
            self.instanceId = instanceId
            self.productCode = productCode
            self.dryRun = dryRun
        }

    }

    public struct DisableVgwRoutePropagationRequest: Serializable, Initializable {
        /// The ID of the virtual private gateway.
        var gatewayId: String = ""
        /// The ID of the route table.
        var routeTableId: String = ""

        public init() {}

        public init(gatewayId: String, routeTableId: String) {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }

    }

    public struct DescribeSpotPriceHistoryRequest: Serializable, Initializable {
        /// The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var startTime: Date? = nil
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil
        /// Filters the results by the specified basic product descriptions.
        var productDescriptions: [String]? = nil
        /// The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ).
        var endTime: Date? = nil
        /// One or more filters.    availability-zone - The Availability Zone for which prices should be returned.    instance-type - The type of instance (for example, m3.medium).    product-description - The product description for the Spot price (Linux/UNIX | SUSE Linux | Windows | Linux/UNIX (Amazon VPC) | SUSE Linux (Amazon VPC) | Windows (Amazon VPC)).    spot-price - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).    timestamp - The timestamp of the Spot price history, in UTC format (for example, YYYY-MM-DDTHH:MM:SSZ). You can use wildcards (* and ?). Greater than or less than comparison is not supported.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Filters the results by the specified Availability Zone.
        var availabilityZone: String? = nil
        /// The token for the next set of results.
        var nextToken: String? = nil
        /// Filters the results by the specified instance types. Note that T2 and HS1 instance types are not supported.
        var instanceTypes: [String]? = nil

        public init() {}

        public init(startTime: Date? = nil, maxResults: Int32? = nil, productDescriptions: [String]? = nil, endTime: Date? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil, availabilityZone: String? = nil, nextToken: String? = nil, instanceTypes: [String]? = nil) {
            self.startTime = startTime
            self.maxResults = maxResults
            self.productDescriptions = productDescriptions
            self.endTime = endTime
            self.filters = filters
            self.dryRun = dryRun
            self.availabilityZone = availabilityZone
            self.nextToken = nextToken
            self.instanceTypes = instanceTypes
        }

    }

    public struct ConversionTask: Serializable, Initializable {
        /// If the task is for importing an instance, this contains information about the import instance task.
        var importInstance: ImportInstanceTaskDetails? = nil
        /// The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.
        var expirationTime: String? = nil
        /// Any tags assigned to the task.
        var tags: [Tag]? = nil
        /// The state of the conversion task.
        var state: String = ""
        /// The ID of the conversion task.
        var conversionTaskId: String = ""
        /// The status message related to the conversion task.
        var statusMessage: String? = nil
        /// If the task is for importing a volume, this contains information about the import volume task.
        var importVolume: ImportVolumeTaskDetails? = nil

        public init() {}

        public init(importInstance: ImportInstanceTaskDetails? = nil, expirationTime: String? = nil, tags: [Tag]? = nil, state: String, conversionTaskId: String, statusMessage: String? = nil, importVolume: ImportVolumeTaskDetails? = nil) {
            self.importInstance = importInstance
            self.expirationTime = expirationTime
            self.tags = tags
            self.state = state
            self.conversionTaskId = conversionTaskId
            self.statusMessage = statusMessage
            self.importVolume = importVolume
        }

    }

    public struct ReplaceRouteTableAssociationResult: Serializable, Initializable {
        /// The ID of the new association.
        var newAssociationId: String? = nil

        public init() {}

        public init(newAssociationId: String? = nil) {
            self.newAssociationId = newAssociationId
        }

    }

    public struct ModifyVolumeResult: Serializable, Initializable {
        /// A VolumeModification object.
        var volumeModification: VolumeModification? = nil

        public init() {}

        public init(volumeModification: VolumeModification? = nil) {
            self.volumeModification = volumeModification
        }

    }

    public struct KeyPair: Serializable, Initializable {
        /// The name of the key pair.
        var keyName: String? = nil
        /// The SHA-1 digest of the DER encoded private key.
        var keyFingerprint: String? = nil
        /// An unencrypted PEM encoded RSA private key.
        var keyMaterial: String? = nil

        public init() {}

        public init(keyName: String? = nil, keyFingerprint: String? = nil, keyMaterial: String? = nil) {
            self.keyName = keyName
            self.keyFingerprint = keyFingerprint
            self.keyMaterial = keyMaterial
        }

    }

    public struct DescribeVpnGatewaysResult: Serializable, Initializable {
        /// Information about one or more virtual private gateways.
        var vpnGateways: [VpnGateway]? = nil

        public init() {}

        public init(vpnGateways: [VpnGateway]? = nil) {
            self.vpnGateways = vpnGateways
        }

    }

    public struct DescribeSpotFleetInstancesRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The token for the next set of results.
        var nextToken: String? = nil
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, nextToken: String? = nil, spotFleetRequestId: String, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.nextToken = nextToken
            self.spotFleetRequestId = spotFleetRequestId
            self.maxResults = maxResults
        }

    }

    public struct DeleteVpcEndpointsRequest: Serializable, Initializable {
        /// One or more endpoint IDs.
        var vpcEndpointIds: [String] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(vpcEndpointIds: [String], dryRun: Bool? = nil) {
            self.vpcEndpointIds = vpcEndpointIds
            self.dryRun = dryRun
        }

    }

    public struct DescribeReservedInstancesModificationsResult: Serializable, Initializable {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil
        /// The Reserved Instance modification information.
        var reservedInstancesModifications: [ReservedInstancesModification]? = nil

        public init() {}

        public init(nextToken: String? = nil, reservedInstancesModifications: [ReservedInstancesModification]? = nil) {
            self.nextToken = nextToken
            self.reservedInstancesModifications = reservedInstancesModifications
        }

    }

    public struct AssociateSubnetCidrBlockRequest: Serializable, Initializable {
        /// The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.
        var ipv6CidrBlock: String = ""
        /// The ID of your subnet.
        var subnetId: String = ""

        public init() {}

        public init(ipv6CidrBlock: String, subnetId: String) {
            self.ipv6CidrBlock = ipv6CidrBlock
            self.subnetId = subnetId
        }

    }

    public struct DescribeDhcpOptionsRequest: Serializable, Initializable {
        /// The IDs of one or more DHCP options sets. Default: Describes all your DHCP options sets.
        var dhcpOptionsIds: [String]? = nil
        /// One or more filters.    dhcp-options-id - The ID of a set of DHCP options.    key - The key for one of the options (for example, domain-name).    value - The value for one of the options.    tag:key=value - The key/value combination of a tag assigned to the resource. Specify the key of the tag in the filter name and the value of the tag in the filter value. For example, for the tag Purpose=X, specify tag:Purpose for the filter name and X for the filter value.    tag-key - The key of a tag assigned to the resource. This filter is independent of the tag-value filter. For example, if you use both the filter "tag-key=Purpose" and the filter "tag-value=X", you get any resources assigned both the tag key Purpose (regardless of what the tag's value is), and the tag value X (regardless of what the tag's key is). If you want to list only resources where Purpose is X, see the tag:key=value filter.    tag-value - The value of a tag assigned to the resource. This filter is independent of the tag-key filter.  
        var filters: [Filter]? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(dhcpOptionsIds: [String]? = nil, filters: [Filter]? = nil, dryRun: Bool? = nil) {
            self.dhcpOptionsIds = dhcpOptionsIds
            self.filters = filters
            self.dryRun = dryRun
        }

    }

    public struct LaunchPermissionModifications: Serializable, Initializable {
        /// The AWS account ID to remove from the list of launch permissions for the AMI.
        var remove: [LaunchPermission]? = nil
        /// The AWS account ID to add to the list of launch permissions for the AMI.
        var add: [LaunchPermission]? = nil

        public init() {}

        public init(remove: [LaunchPermission]? = nil, add: [LaunchPermission]? = nil) {
            self.remove = remove
            self.add = add
        }

    }

    public struct ModifyHostsRequest: Serializable, Initializable {
        /// The host IDs of the Dedicated Hosts you want to modify.
        var hostIds: [String] = []
        /// Specify whether to enable or disable auto-placement.
        var autoPlacement: String = ""

        public init() {}

        public init(hostIds: [String], autoPlacement: String) {
            self.hostIds = hostIds
            self.autoPlacement = autoPlacement
        }

    }

    public struct ReleaseAddressRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// [EC2-VPC] The allocation ID. Required for EC2-VPC.
        var allocationId: String? = nil
        /// [EC2-Classic] The Elastic IP address. Required for EC2-Classic.
        var publicIp: String? = nil

        public init() {}

        public init(dryRun: Bool? = nil, allocationId: String? = nil, publicIp: String? = nil) {
            self.dryRun = dryRun
            self.allocationId = allocationId
            self.publicIp = publicIp
        }

    }

    public struct VpcEndpoint: Serializable, Initializable {
        /// The date and time the VPC endpoint was created.
        var creationTimestamp: Date? = nil
        /// The ID of the VPC to which the endpoint is associated.
        var vpcId: String? = nil
        /// The state of the VPC endpoint.
        var state: String? = nil
        /// The name of the AWS service to which the endpoint is associated.
        var serviceName: String? = nil
        /// The ID of the VPC endpoint.
        var vpcEndpointId: String? = nil
        /// The policy document associated with the endpoint.
        var policyDocument: String? = nil
        /// One or more route tables associated with the endpoint.
        var routeTableIds: [String]? = nil

        public init() {}

        public init(creationTimestamp: Date? = nil, vpcId: String? = nil, state: String? = nil, serviceName: String? = nil, vpcEndpointId: String? = nil, policyDocument: String? = nil, routeTableIds: [String]? = nil) {
            self.creationTimestamp = creationTimestamp
            self.vpcId = vpcId
            self.state = state
            self.serviceName = serviceName
            self.vpcEndpointId = vpcEndpointId
            self.policyDocument = policyDocument
            self.routeTableIds = routeTableIds
        }

    }

    public struct AssociateIamInstanceProfileRequest: Serializable, Initializable {
        /// The ID of the instance.
        var instanceId: String = ""
        /// The IAM instance profile.
        var iamInstanceProfile: IamInstanceProfileSpecification = IamInstanceProfileSpecification()

        public init() {}

        public init(instanceId: String, iamInstanceProfile: IamInstanceProfileSpecification) {
            self.instanceId = instanceId
            self.iamInstanceProfile = iamInstanceProfile
        }

    }

    public struct DisassociateVpcCidrBlockResult: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// Information about the IPv6 CIDR block association.
        var ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil

        public init() {}

        public init(vpcId: String? = nil, ipv6CidrBlockAssociation: VpcIpv6CidrBlockAssociation? = nil) {
            self.vpcId = vpcId
            self.ipv6CidrBlockAssociation = ipv6CidrBlockAssociation
        }

    }

    public struct DeleteDhcpOptionsRequest: Serializable, Initializable {
        /// The ID of the DHCP options set.
        var dhcpOptionsId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(dhcpOptionsId: String, dryRun: Bool? = nil) {
            self.dhcpOptionsId = dhcpOptionsId
            self.dryRun = dryRun
        }

    }

    public struct DescribeHostReservationsResult: Serializable, Initializable {
        /// Details about the reservation's configuration.
        var hostReservationSet: [HostReservation]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(hostReservationSet: [HostReservation]? = nil, nextToken: String? = nil) {
            self.hostReservationSet = hostReservationSet
            self.nextToken = nextToken
        }

    }

    public struct ModifyNetworkInterfaceAttributeRequest: Serializable, Initializable {
        /// A description for the network interface.
        var description: AttributeValue? = nil
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.
        var attachment: NetworkInterfaceAttachmentChanges? = nil
        /// Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.
        var groups: [String]? = nil
        /// Indicates whether source/destination checking is enabled. A value of true means checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT. For more information, see NAT Instances in the Amazon Virtual Private Cloud User Guide.
        var sourceDestCheck: AttributeBooleanValue? = nil

        public init() {}

        public init(description: AttributeValue? = nil, networkInterfaceId: String, dryRun: Bool? = nil, attachment: NetworkInterfaceAttachmentChanges? = nil, groups: [String]? = nil, sourceDestCheck: AttributeBooleanValue? = nil) {
            self.description = description
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
            self.attachment = attachment
            self.groups = groups
            self.sourceDestCheck = sourceDestCheck
        }

    }

    public struct AttributeBooleanValue: Serializable, Initializable {
        /// The attribute value. The valid values are true or false.
        var value: Bool? = nil

        public init() {}

        public init(value: Bool? = nil) {
            self.value = value
        }

    }

    public struct AttachVpnGatewayRequest: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the virtual private gateway.
        var vpnGatewayId: String = ""

        public init() {}

        public init(vpcId: String, dryRun: Bool? = nil, vpnGatewayId: String) {
            self.vpcId = vpcId
            self.dryRun = dryRun
            self.vpnGatewayId = vpnGatewayId
        }

    }

    public struct CreateEgressOnlyInternetGatewayResult: Serializable, Initializable {
        /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        var clientToken: String? = nil
        /// Information about the egress-only Internet gateway.
        var egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil

        public init() {}

        public init(clientToken: String? = nil, egressOnlyInternetGateway: EgressOnlyInternetGateway? = nil) {
            self.clientToken = clientToken
            self.egressOnlyInternetGateway = egressOnlyInternetGateway
        }

    }

    public struct NetworkInterfaceAttachmentChanges: Serializable, Initializable {
        /// Indicates whether the network interface is deleted when the instance is terminated.
        var deleteOnTermination: Bool? = nil
        /// The ID of the network interface attachment.
        var attachmentId: String? = nil

        public init() {}

        public init(deleteOnTermination: Bool? = nil, attachmentId: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.attachmentId = attachmentId
        }

    }

    public struct CancelExportTaskRequest: Serializable, Initializable {
        /// The ID of the export task. This is the ID returned by CreateInstanceExportTask.
        var exportTaskId: String = ""

        public init() {}

        public init(exportTaskId: String) {
            self.exportTaskId = exportTaskId
        }

    }

    public struct ResetImageAttributeRequest: Serializable, Initializable {
        /// The attribute to reset (currently you can only reset the launch permission attribute).
        var attribute: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the AMI.
        var imageId: String = ""

        public init() {}

        public init(attribute: String, dryRun: Bool? = nil, imageId: String) {
            self.attribute = attribute
            self.dryRun = dryRun
            self.imageId = imageId
        }

    }

    public struct AssociateRouteTableRequest: Serializable, Initializable {
        /// The ID of the subnet.
        var subnetId: String = ""
        /// The ID of the route table.
        var routeTableId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(subnetId: String, routeTableId: String, dryRun: Bool? = nil) {
            self.subnetId = subnetId
            self.routeTableId = routeTableId
            self.dryRun = dryRun
        }

    }

    public struct PrivateIpAddressSpecification: Serializable, Initializable {
        /// Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        var primary: Bool? = nil
        /// The private IPv4 addresses.
        var privateIpAddress: String = ""

        public init() {}

        public init(primary: Bool? = nil, privateIpAddress: String) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

    }

    public struct ClassicLinkInstance: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// The ID of the instance.
        var instanceId: String? = nil
        /// A list of security groups.
        var groups: [GroupIdentifier]? = nil
        /// Any tags assigned to the instance.
        var tags: [Tag]? = nil

        public init() {}

        public init(vpcId: String? = nil, instanceId: String? = nil, groups: [GroupIdentifier]? = nil, tags: [Tag]? = nil) {
            self.vpcId = vpcId
            self.instanceId = instanceId
            self.groups = groups
            self.tags = tags
        }

    }

    public struct DescribePlacementGroupsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// One or more filters.    group-name - The name of the placement group.    state - The state of the placement group (pending | available | deleting | deleted).    strategy - The strategy of the placement group (cluster).  
        var filters: [Filter]? = nil
        /// One or more placement group names. Default: Describes all your placement groups, or only those otherwise specified.
        var groupNames: [String]? = nil

        public init() {}

        public init(dryRun: Bool? = nil, filters: [Filter]? = nil, groupNames: [String]? = nil) {
            self.dryRun = dryRun
            self.filters = filters
            self.groupNames = groupNames
        }

    }

    public struct ReplaceNetworkAclAssociationRequest: Serializable, Initializable {
        /// The ID of the current association between the original network ACL and the subnet.
        var associationId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the new network ACL to associate with the subnet.
        var networkAclId: String = ""

        public init() {}

        public init(associationId: String, dryRun: Bool? = nil, networkAclId: String) {
            self.associationId = associationId
            self.dryRun = dryRun
            self.networkAclId = networkAclId
        }

    }

    public struct CreateImageRequest: Serializable, Initializable {
        /// Information about one or more block device mappings.
        var blockDeviceMappings: [BlockDeviceMapping]? = nil
        /// A description for the new image.
        var description: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.
        var noReboot: Bool? = nil
        /// A name for the new image. Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)
        var name: String = ""
        /// The ID of the instance.
        var instanceId: String = ""

        public init() {}

        public init(blockDeviceMappings: [BlockDeviceMapping]? = nil, description: String? = nil, dryRun: Bool? = nil, noReboot: Bool? = nil, name: String, instanceId: String) {
            self.blockDeviceMappings = blockDeviceMappings
            self.description = description
            self.dryRun = dryRun
            self.noReboot = noReboot
            self.name = name
            self.instanceId = instanceId
        }

    }

    public struct ModifyVpcPeeringConnectionOptionsResult: Serializable, Initializable {
        /// Information about the VPC peering connection options for the accepter VPC.
        var accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil
        /// Information about the VPC peering connection options for the requester VPC.
        var requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil

        public init() {}

        public init(accepterPeeringConnectionOptions: PeeringConnectionOptions? = nil, requesterPeeringConnectionOptions: PeeringConnectionOptions? = nil) {
            self.accepterPeeringConnectionOptions = accepterPeeringConnectionOptions
            self.requesterPeeringConnectionOptions = requesterPeeringConnectionOptions
        }

    }

    public struct DescribeVpcAttributeResult: Serializable, Initializable {
        /// The ID of the VPC.
        var vpcId: String? = nil
        /// Indicates whether DNS resolution is enabled for the VPC. If this attribute is true, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.
        var enableDnsSupport: AttributeBooleanValue? = nil
        /// Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is true, instances in the VPC get DNS hostnames; otherwise, they do not.
        var enableDnsHostnames: AttributeBooleanValue? = nil

        public init() {}

        public init(vpcId: String? = nil, enableDnsSupport: AttributeBooleanValue? = nil, enableDnsHostnames: AttributeBooleanValue? = nil) {
            self.vpcId = vpcId
            self.enableDnsSupport = enableDnsSupport
            self.enableDnsHostnames = enableDnsHostnames
        }

    }

    public struct ModifyVolumeRequest: Serializable, Initializable {
        /// Target EBS volume type of the volume to be modified  The API does not support modifications for volume type standard. You also cannot change the type of a volume to standard.  Default: If no type is specified, the existing type is retained. 
        var volumeType: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Target IOPS rate of the volume to be modified. Only valid for Provisioned IOPS SSD (io1) volumes. For more information about io1 IOPS configuration, see http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops. Default: If no IOPS value is specified, the existing value is retained. 
        var iops: Int32? = nil
        var volumeId: String = ""
        /// Target size in GiB of the volume to be modified. Target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html. Default: If no size is specified, the existing size is retained. 
        var size: Int32? = nil

        public init() {}

        public init(volumeType: String? = nil, dryRun: Bool? = nil, iops: Int32? = nil, volumeId: String, size: Int32? = nil) {
            self.volumeType = volumeType
            self.dryRun = dryRun
            self.iops = iops
            self.volumeId = volumeId
            self.size = size
        }

    }

    public struct DescribeCustomerGatewaysResult: Serializable, Initializable {
        /// Information about one or more customer gateways.
        var customerGateways: [CustomerGateway]? = nil

        public init() {}

        public init(customerGateways: [CustomerGateway]? = nil) {
            self.customerGateways = customerGateways
        }

    }

    public struct ModifyInstanceAttributeRequest: Serializable, Initializable {
        /// Modifies the DeleteOnTermination attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for DeleteOnTermination, the default is true and the volume is deleted when the instance is terminated. To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see Updating the Block Device Mapping when Launching an Instance in the Amazon Elastic Compute Cloud User Guide.
        var blockDeviceMappings: [InstanceBlockDeviceMappingSpecification]? = nil
        /// If the value is true, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this paramater for Spot Instances.
        var disableApiTermination: AttributeBooleanValue? = nil
        /// Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.
        var userData: BlobAttributeValue? = nil
        /// Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance. There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.
        var sriovNetSupport: AttributeValue? = nil
        /// Specifies whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
        var ebsOptimized: AttributeBooleanValue? = nil
        /// Specifies whether source/destination checking is enabled. A value of true means that checking is enabled, and false means checking is disabled. This value must be false for a NAT instance to perform NAT.
        var sourceDestCheck: AttributeBooleanValue? = nil
        /// The name of the attribute.
        var attribute: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// Changes the instance type to the specified value. For more information, see Instance Types. If the instance type is not valid, the error returned is InvalidInstanceAttributeValue.
        var instanceType: AttributeValue? = nil
        /// Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB.
        var ramdisk: AttributeValue? = nil
        /// A new value for the attribute. Use only with the kernel, ramdisk, userData, disableApiTermination, or instanceInitiatedShutdownBehavior attribute.
        var value: String? = nil
        /// Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see PV-GRUB.
        var kernel: AttributeValue? = nil
        /// The ID of the instance.
        var instanceId: String = ""
        /// Set to true to enable enhanced networking with ENA for the instance. This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.
        var enaSupport: AttributeBooleanValue? = nil
        /// Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        var instanceInitiatedShutdownBehavior: AttributeValue? = nil
        /// [EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.
        var groups: [String]? = nil

        public init() {}

        public init(blockDeviceMappings: [InstanceBlockDeviceMappingSpecification]? = nil, disableApiTermination: AttributeBooleanValue? = nil, userData: BlobAttributeValue? = nil, sriovNetSupport: AttributeValue? = nil, ebsOptimized: AttributeBooleanValue? = nil, sourceDestCheck: AttributeBooleanValue? = nil, attribute: String? = nil, dryRun: Bool? = nil, instanceType: AttributeValue? = nil, ramdisk: AttributeValue? = nil, value: String? = nil, kernel: AttributeValue? = nil, instanceId: String, enaSupport: AttributeBooleanValue? = nil, instanceInitiatedShutdownBehavior: AttributeValue? = nil, groups: [String]? = nil) {
            self.blockDeviceMappings = blockDeviceMappings
            self.disableApiTermination = disableApiTermination
            self.userData = userData
            self.sriovNetSupport = sriovNetSupport
            self.ebsOptimized = ebsOptimized
            self.sourceDestCheck = sourceDestCheck
            self.attribute = attribute
            self.dryRun = dryRun
            self.instanceType = instanceType
            self.ramdisk = ramdisk
            self.value = value
            self.kernel = kernel
            self.instanceId = instanceId
            self.enaSupport = enaSupport
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.groups = groups
        }

    }

    public struct ScheduledInstanceRecurrence: Serializable, Initializable {
        /// The frequency (Daily, Weekly, or Monthly).
        var frequency: String? = nil
        /// The unit for occurrenceDaySet (DayOfWeek or DayOfMonth).
        var occurrenceUnit: String? = nil
        /// Indicates whether the occurrence is relative to the end of the specified week or month.
        var occurrenceRelativeToEnd: Bool? = nil
        /// The interval quantity. The interval unit depends on the value of frequency. For example, every 2 weeks or every 2 months.
        var interval: Int32? = nil
        /// The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).
        var occurrenceDaySet: [Int32]? = nil

        public init() {}

        public init(frequency: String? = nil, occurrenceUnit: String? = nil, occurrenceRelativeToEnd: Bool? = nil, interval: Int32? = nil, occurrenceDaySet: [Int32]? = nil) {
            self.frequency = frequency
            self.occurrenceUnit = occurrenceUnit
            self.occurrenceRelativeToEnd = occurrenceRelativeToEnd
            self.interval = interval
            self.occurrenceDaySet = occurrenceDaySet
        }

    }

    public struct CreateVpnGatewayResult: Serializable, Initializable {
        /// Information about the virtual private gateway.
        var vpnGateway: VpnGateway? = nil

        public init() {}

        public init(vpnGateway: VpnGateway? = nil) {
            self.vpnGateway = vpnGateway
        }

    }

    public struct SnapshotDetail: Serializable, Initializable {
        /// A brief status of the snapshot creation.
        var status: String? = nil
        /// The percentage of progress for the task.
        var progress: String? = nil
        /// The URL used to access the disk image.
        var url: String? = nil
        /// The size of the disk in the snapshot, in GiB.
        var diskImageSize: Double? = nil
        /// The format of the disk image from which the snapshot is created.
        var format: String? = nil
        /// The snapshot ID of the disk being imported.
        var snapshotId: String? = nil
        /// The S3 bucket for the disk image.
        var userBucket: UserBucketDetails? = nil
        /// A detailed status message for the snapshot creation.
        var statusMessage: String? = nil
        /// The block device mapping for the snapshot.
        var deviceName: String? = nil
        /// A description for the snapshot.
        var description: String? = nil

        public init() {}

        public init(status: String? = nil, progress: String? = nil, url: String? = nil, diskImageSize: Double? = nil, format: String? = nil, snapshotId: String? = nil, userBucket: UserBucketDetails? = nil, statusMessage: String? = nil, deviceName: String? = nil, description: String? = nil) {
            self.status = status
            self.progress = progress
            self.url = url
            self.diskImageSize = diskImageSize
            self.format = format
            self.snapshotId = snapshotId
            self.userBucket = userBucket
            self.statusMessage = statusMessage
            self.deviceName = deviceName
            self.description = description
        }

    }

    public struct DescribeVpcClassicLinkDnsSupportRequest: Serializable, Initializable {
        /// One or more VPC IDs.
        var vpcIds: [String]? = nil
        /// The token for the next set of items to return. (You received this token from a prior call.)
        var nextToken: String? = nil
        /// The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.
        var maxResults: Int32? = nil

        public init() {}

        public init(vpcIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.vpcIds = vpcIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DeleteNatGatewayResult: Serializable, Initializable {
        /// The ID of the NAT gateway.
        var natGatewayId: String? = nil

        public init() {}

        public init(natGatewayId: String? = nil) {
            self.natGatewayId = natGatewayId
        }

    }

    public struct AttachNetworkInterfaceRequest: Serializable, Initializable {
        /// The index of the device for the network interface attachment.
        var deviceIndex: Int32 = 0
        /// The ID of the network interface.
        var networkInterfaceId: String = ""
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The ID of the instance.
        var instanceId: String = ""

        public init() {}

        public init(deviceIndex: Int32, networkInterfaceId: String, dryRun: Bool? = nil, instanceId: String) {
            self.deviceIndex = deviceIndex
            self.networkInterfaceId = networkInterfaceId
            self.dryRun = dryRun
            self.instanceId = instanceId
        }

    }

    public struct IpPermission: Serializable, Initializable {
        /// One or more security group and AWS account ID pairs.
        var userIdGroupPairs: [UserIdGroupPair]? = nil
        /// One or more IPv4 ranges.
        var ipRanges: [IpRange]? = nil
        /// [EC2-VPC only] One or more IPv6 ranges.
        var ipv6Ranges: [Ipv6Range]? = nil
        /// (Valid for AuthorizeSecurityGroupEgress, RevokeSecurityGroupEgress and DescribeSecurityGroups only) One or more prefix list IDs for an AWS service. In an AuthorizeSecurityGroupEgress request, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
        var prefixListIds: [PrefixListId]? = nil
        /// The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes for the specified ICMP type.
        var toPort: Int32? = nil
        /// The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers).  [EC2-VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. 
        var ipProtocol: String? = nil
        /// The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.
        var fromPort: Int32? = nil

        public init() {}

        public init(userIdGroupPairs: [UserIdGroupPair]? = nil, ipRanges: [IpRange]? = nil, ipv6Ranges: [Ipv6Range]? = nil, prefixListIds: [PrefixListId]? = nil, toPort: Int32? = nil, ipProtocol: String? = nil, fromPort: Int32? = nil) {
            self.userIdGroupPairs = userIdGroupPairs
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.ipProtocol = ipProtocol
            self.fromPort = fromPort
        }

    }

    public struct VgwTelemetry: Serializable, Initializable {
        /// The status of the VPN tunnel.
        var status: String? = nil
        /// The date and time of the last change in status.
        var lastStatusChange: Date? = nil
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        var outsideIpAddress: String? = nil
        /// If an error occurs, a description of the error.
        var statusMessage: String? = nil
        /// The number of accepted routes.
        var acceptedRouteCount: Int32? = nil

        public init() {}

        public init(status: String? = nil, lastStatusChange: Date? = nil, outsideIpAddress: String? = nil, statusMessage: String? = nil, acceptedRouteCount: Int32? = nil) {
            self.status = status
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.statusMessage = statusMessage
            self.acceptedRouteCount = acceptedRouteCount
        }

    }

    public struct ReplaceNetworkAclAssociationResult: Serializable, Initializable {
        /// The ID of the new association.
        var newAssociationId: String? = nil

        public init() {}

        public init(newAssociationId: String? = nil) {
            self.newAssociationId = newAssociationId
        }

    }

    public struct DiskImageVolumeDescription: Serializable, Initializable {
        /// The size of the volume, in GiB.
        var size: Int64? = nil
        /// The volume identifier.
        var id: String = ""

        public init() {}

        public init(size: Int64? = nil, id: String) {
            self.size = size
            self.id = id
        }

    }

    public struct AttributeValue: Serializable, Initializable {
        /// The attribute value. Note that the value is case-sensitive.
        var value: String? = nil

        public init() {}

        public init(value: String? = nil) {
            self.value = value
        }

    }

    public struct ImportInstanceResult: Serializable, Initializable {
        /// Information about the conversion task.
        var conversionTask: ConversionTask? = nil

        public init() {}

        public init(conversionTask: ConversionTask? = nil) {
            self.conversionTask = conversionTask
        }

    }

    public struct CreateDhcpOptionsRequest: Serializable, Initializable {
        /// A DHCP configuration option.
        var dhcpConfigurations: [NewDhcpConfiguration] = []
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil

        public init() {}

        public init(dhcpConfigurations: [NewDhcpConfiguration], dryRun: Bool? = nil) {
            self.dhcpConfigurations = dhcpConfigurations
            self.dryRun = dryRun
        }

    }

    public struct ModifyIdentityIdFormatRequest: Serializable, Initializable {
        /// The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify all to modify the ID format for all IAM users, IAM roles, and the root user of the account.
        var principalArn: String = ""
        /// The type of resource: instance | reservation | snapshot | volume 
        var resource: String = ""
        /// Indicates whether the resource should use longer IDs (17-character IDs)
        var useLongIds: Bool = false

        public init() {}

        public init(principalArn: String, resource: String, useLongIds: Bool) {
            self.principalArn = principalArn
            self.resource = resource
            self.useLongIds = useLongIds
        }

    }

    public struct SpotFleetRequestConfig: Serializable, Initializable {
        /// The state of the Spot fleet request.
        var spotFleetRequestState: String = ""
        /// The progress of the Spot fleet request. If there is an error, the status is error. After all bids are placed, the status is pending_fulfillment. If the size of the fleet is equal to or greater than its target capacity, the status is fulfilled. If the size of the fleet is decreased, the status is pending_termination while Spot instances are terminating.
        var activityStatus: String? = nil
        /// The creation date and time of the request.
        var createTime: Date = Date()
        /// Information about the configuration of the Spot fleet request.
        var spotFleetRequestConfig: SpotFleetRequestConfigData = SpotFleetRequestConfigData()
        /// The ID of the Spot fleet request.
        var spotFleetRequestId: String = ""

        public init() {}

        public init(spotFleetRequestState: String, activityStatus: String? = nil, createTime: Date, spotFleetRequestConfig: SpotFleetRequestConfigData, spotFleetRequestId: String) {
            self.spotFleetRequestState = spotFleetRequestState
            self.activityStatus = activityStatus
            self.createTime = createTime
            self.spotFleetRequestConfig = spotFleetRequestConfig
            self.spotFleetRequestId = spotFleetRequestId
        }

    }

    public struct ModifyHostsResult: Serializable, Initializable {
        /// The IDs of the Dedicated Hosts that were successfully modified.
        var successful: [String]? = nil
        /// The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.
        var unsuccessful: [UnsuccessfulItem]? = nil

        public init() {}

        public init(successful: [String]? = nil, unsuccessful: [UnsuccessfulItem]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

    }

    public struct DisassociateAddressRequest: Serializable, Initializable {
        /// [EC2-Classic] The Elastic IP address. Required for EC2-Classic.
        var publicIp: String? = nil
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// [EC2-VPC] The association ID. Required for EC2-VPC.
        var associationId: String? = nil

        public init() {}

        public init(publicIp: String? = nil, dryRun: Bool? = nil, associationId: String? = nil) {
            self.publicIp = publicIp
            self.dryRun = dryRun
            self.associationId = associationId
        }

    }

    public struct ScheduledInstancesEbs: Serializable, Initializable {
        /// The ID of the snapshot.
        var snapshotId: String? = nil
        /// Indicates whether the volume is deleted on instance termination.
        var deleteOnTermination: Bool? = nil
        /// The volume type. gp2 for General Purpose SSD, io1 for Provisioned IOPS SSD, Throughput Optimized HDD for st1, Cold HDD for sc1, or standard for Magnetic. Default: standard 
        var volumeType: String? = nil
        /// The size of the volume, in GiB. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        var volumeSize: Int32? = nil
        /// The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about gp2 baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide. Constraint: Range is 100-20000 IOPS for io1 volumes and 100-10000 IOPS for gp2 volumes. Condition: This parameter is required for requests to create io1volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.
        var iops: Int32? = nil
        /// Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.
        var encrypted: Bool? = nil

        public init() {}

        public init(snapshotId: String? = nil, deleteOnTermination: Bool? = nil, volumeType: String? = nil, volumeSize: Int32? = nil, iops: Int32? = nil, encrypted: Bool? = nil) {
            self.snapshotId = snapshotId
            self.deleteOnTermination = deleteOnTermination
            self.volumeType = volumeType
            self.volumeSize = volumeSize
            self.iops = iops
            self.encrypted = encrypted
        }

    }

    public struct UnmonitorInstancesResult: Serializable, Initializable {
        /// The monitoring information.
        var instanceMonitorings: [InstanceMonitoring]? = nil

        public init() {}

        public init(instanceMonitorings: [InstanceMonitoring]? = nil) {
            self.instanceMonitorings = instanceMonitorings
        }

    }

    public struct InternetGateway: Serializable, Initializable {
        /// Any tags assigned to the Internet gateway.
        var tags: [Tag]? = nil
        /// The ID of the Internet gateway.
        var internetGatewayId: String? = nil
        /// Any VPCs attached to the Internet gateway.
        var attachments: [InternetGatewayAttachment]? = nil

        public init() {}

        public init(tags: [Tag]? = nil, internetGatewayId: String? = nil, attachments: [InternetGatewayAttachment]? = nil) {
            self.tags = tags
            self.internetGatewayId = internetGatewayId
            self.attachments = attachments
        }

    }

    public struct CreateVolumePermissionModifications: Serializable, Initializable {
        /// Removes a specific AWS account ID or group from a volume's list of create volume permissions.
        var remove: [CreateVolumePermission]? = nil
        /// Adds a specific AWS account ID or group to a volume's list of create volume permissions.
        var add: [CreateVolumePermission]? = nil

        public init() {}

        public init(remove: [CreateVolumePermission]? = nil, add: [CreateVolumePermission]? = nil) {
            self.remove = remove
            self.add = add
        }

    }

    public struct DescribeSpotFleetRequestsRequest: Serializable, Initializable {
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        var dryRun: Bool? = nil
        /// The IDs of the Spot fleet requests.
        var spotFleetRequestIds: [String]? = nil
        /// The token for the next set of results.
        var nextToken: String? = nil
        /// The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned NextToken value.
        var maxResults: Int32? = nil

        public init() {}

        public init(dryRun: Bool? = nil, spotFleetRequestIds: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dryRun = dryRun
            self.spotFleetRequestIds = spotFleetRequestIds
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct DescribeNetworkInterfacesResult: Serializable, Initializable {
        /// Information about one or more network interfaces.
        var networkInterfaces: [NetworkInterface]? = nil

        public init() {}

        public init(networkInterfaces: [NetworkInterface]? = nil) {
            self.networkInterfaces = networkInterfaces
        }

    }

    public struct TargetConfigurationRequest: Serializable, Initializable {
        /// The Convertible Reserved Instance offering ID.
        var offeringId: String = ""
        /// The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request
        var instanceCount: Int32? = nil

        public init() {}

        public init(offeringId: String, instanceCount: Int32? = nil) {
            self.offeringId = offeringId
            self.instanceCount = instanceCount
        }

    }

    public struct DescribeInstanceStatusResult: Serializable, Initializable {
        /// One or more instance status descriptions.
        var instanceStatuses: [InstanceStatus]? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        var nextToken: String? = nil

        public init() {}

        public init(instanceStatuses: [InstanceStatus]? = nil, nextToken: String? = nil) {
            self.instanceStatuses = instanceStatuses
            self.nextToken = nextToken
        }

    }

}