// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaStoreData {

    public struct ListItemsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "NextToken"), required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "MaxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Path", location: .querystring(locationName: "Path"), required: false, type: .string)
        ]
        /// The NextToken received in the ListItemsResponse for the same container and path. Tokens expire after 15 minutes.
        public let nextToken: String?
        /// The maximum results to return. The service might return fewer results.
        public let maxResults: Int32?
        /// The path in the container from which to retrieve items. Format: &lt;folder name&gt;/&lt;folder name&gt;/&lt;file name&gt;
        public let path: String?

        public init(nextToken: String? = nil, maxResults: Int32? = nil, path: String? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
            case path = "Path"
        }
    }

    public struct DeleteObjectResponse: AWSShape {

    }

    public struct DescribeObjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Path", location: .uri(locationName: "Path"), required: true, type: .string)
        ]
        /// The path (including the file name) where the object is stored in the container. Format: &lt;folder name&gt;/&lt;folder name&gt;/&lt;file name&gt;
        public let path: String

        public init(path: String) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct PutObjectRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "Body"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Path", location: .uri(locationName: "Path"), required: true, type: .string), 
            AWSShapeMember(label: "StorageClass", location: .header(locationName: "x-amz-storage-class"), required: false, type: .enum), 
            AWSShapeMember(label: "CacheControl", location: .header(locationName: "Cache-Control"), required: false, type: .string), 
            AWSShapeMember(label: "ContentType", location: .header(locationName: "Content-Type"), required: false, type: .string), 
            AWSShapeMember(label: "Body", required: true, type: .blob)
        ]
        /// The path (including the file name) where the object is stored in the container. Format: &lt;folder name&gt;/&lt;folder name&gt;/&lt;file name&gt; For example, to upload the file mlaw.avi to the folder path premium\canada in the container movies, enter the path premium/canada/mlaw.avi. Do not include the container name in this path. If the path includes any folders that don't exist yet, the service creates them. For example, suppose you have an existing premium/usa subfolder. If you specify premium/canada, the service creates a canada subfolder in the premium folder. You then have two subfolders, usa and canada, in the premium folder.  There is no correlation between the path to the source and the path (folders) in the container in AWS Elemental MediaStore. For more information about folders and how they exist in a container, see the AWS Elemental MediaStore User Guide. The file name is the name that is assigned to the file that you upload. The file can have the same name inside and outside of AWS Elemental MediaStore, or it can have the same name. The file name can include or omit an extension. 
        public let path: String
        /// Indicates the storage class of a Put request. Defaults to high-performance temporal storage class, and objects are persisted into durable storage shortly after being received.
        public let storageClass: StorageClass?
        /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP at https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9. Headers with a custom user-defined value are also accepted.
        public let cacheControl: String?
        /// The content type of the object.
        public let contentType: String?
        /// The bytes to be stored. 
        public let body: Data

        public init(path: String, storageClass: StorageClass? = nil, cacheControl: String? = nil, contentType: String? = nil, body: Data) {
            self.path = path
            self.storageClass = storageClass
            self.cacheControl = cacheControl
            self.contentType = contentType
            self.body = body
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
            case storageClass = "x-amz-storage-class"
            case cacheControl = "Cache-Control"
            case contentType = "Content-Type"
            case body = "Body"
        }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable {
        case temporal = "TEMPORAL"
        public var description: String { return self.rawValue }
    }

    public struct ListItemsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Items", required: false, type: .list)
        ]
        /// The NextToken used to request the next page of results using ListItems.
        public let nextToken: String?
        /// Metadata entries for the folders and objects at the requested path.
        public let items: [Item]?

        public init(nextToken: String? = nil, items: [Item]? = nil) {
            self.nextToken = nextToken
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case items = "Items"
        }
    }

    public enum ItemType: String, CustomStringConvertible, Codable {
        case object = "OBJECT"
        case folder = "FOLDER"
        public var description: String { return self.rawValue }
    }

    public struct DeleteObjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Path", location: .uri(locationName: "Path"), required: true, type: .string)
        ]
        /// The path (including the file name) where the object is stored in the container. Format: &lt;folder name&gt;/&lt;folder name&gt;/&lt;file name&gt;
        public let path: String

        public init(path: String) {
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
        }
    }

    public struct GetObjectRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Range", location: .header(locationName: "Range"), required: false, type: .string), 
            AWSShapeMember(label: "Path", location: .uri(locationName: "Path"), required: true, type: .string)
        ]
        /// The range bytes of an object to retrieve. For more information about the Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
        public let range: String?
        /// The path (including the file name) where the object is stored in the container. Format: &lt;folder name&gt;/&lt;folder name&gt;/&lt;file name&gt; For example, to upload the file mlaw.avi to the folder path premium\canada in the container movies, enter the path premium/canada/mlaw.avi. Do not include the container name in this path. If the path includes any folders that don't exist yet, the service creates them. For example, suppose you have an existing premium/usa subfolder. If you specify premium/canada, the service creates a canada subfolder in the premium folder. You then have two subfolders, usa and canada, in the premium folder.  There is no correlation between the path to the source and the path (folders) in the container in AWS Elemental MediaStore. For more information about folders and how they exist in a container, see the AWS Elemental MediaStore User Guide. The file name is the name that is assigned to the file that you upload. The file can have the same name inside and outside of AWS Elemental MediaStore, or it can have the same name. The file name can include or omit an extension. 
        public let path: String

        public init(range: String? = nil, path: String) {
            self.range = range
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case range = "Range"
            case path = "Path"
        }
    }

    public struct GetObjectResponse: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "Body"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Body", required: false, type: .blob), 
            AWSShapeMember(label: "StatusCode", required: true, type: .integer), 
            AWSShapeMember(label: "ContentType", location: .header(locationName: "Content-Type"), required: false, type: .string), 
            AWSShapeMember(label: "CacheControl", location: .header(locationName: "Cache-Control"), required: false, type: .string), 
            AWSShapeMember(label: "ETag", location: .header(locationName: "ETag"), required: false, type: .string), 
            AWSShapeMember(label: "ContentRange", location: .header(locationName: "Content-Range"), required: false, type: .string), 
            AWSShapeMember(label: "ContentLength", location: .header(locationName: "Content-Length"), required: false, type: .long), 
            AWSShapeMember(label: "LastModified", location: .header(locationName: "Last-Modified"), required: false, type: .timestamp)
        ]
        /// The bytes of the object. 
        public let body: Data?
        /// The HTML status code of the request. Status codes ranging from 200 to 299 indicate success. All other status codes indicate the type of error that occurred.
        public let statusCode: Int32
        /// The content type of the object.
        public let contentType: String?
        /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP spec at https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9. Headers with a custom user-defined value are also accepted.
        public let cacheControl: String?
        /// The ETag that represents a unique instance of the object.
        public let eTag: String?
        /// The range of bytes to retrieve.
        public let contentRange: String?
        /// The length of the object in bytes.
        public let contentLength: Int64?
        /// The date and time that the object was last modified.
        public let lastModified: TimeStamp?

        public init(body: Data? = nil, statusCode: Int32, contentType: String? = nil, cacheControl: String? = nil, eTag: String? = nil, contentRange: String? = nil, contentLength: Int64? = nil, lastModified: TimeStamp? = nil) {
            self.body = body
            self.statusCode = statusCode
            self.contentType = contentType
            self.cacheControl = cacheControl
            self.eTag = eTag
            self.contentRange = contentRange
            self.contentLength = contentLength
            self.lastModified = lastModified
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case statusCode = "StatusCode"
            case contentType = "Content-Type"
            case cacheControl = "Cache-Control"
            case eTag = "ETag"
            case contentRange = "Content-Range"
            case contentLength = "Content-Length"
            case lastModified = "Last-Modified"
        }
    }

    public struct DescribeObjectResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContentLength", location: .header(locationName: "Content-Length"), required: false, type: .long), 
            AWSShapeMember(label: "CacheControl", location: .header(locationName: "Cache-Control"), required: false, type: .string), 
            AWSShapeMember(label: "LastModified", location: .header(locationName: "Last-Modified"), required: false, type: .timestamp), 
            AWSShapeMember(label: "ETag", location: .header(locationName: "ETag"), required: false, type: .string), 
            AWSShapeMember(label: "ContentType", location: .header(locationName: "Content-Type"), required: false, type: .string)
        ]
        /// The length of the object in bytes.
        public let contentLength: Int64?
        /// An optional CacheControl header that allows the caller to control the object's cache behavior. Headers can be passed in as specified in the HTTP at https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9. Headers with a custom user-defined value are also accepted.
        public let cacheControl: String?
        /// The date and time that the object was last modified.
        public let lastModified: TimeStamp?
        /// The ETag that represents a unique instance of the object.
        public let eTag: String?
        /// The content type of the object.
        public let contentType: String?

        public init(contentLength: Int64? = nil, cacheControl: String? = nil, lastModified: TimeStamp? = nil, eTag: String? = nil, contentType: String? = nil) {
            self.contentLength = contentLength
            self.cacheControl = cacheControl
            self.lastModified = lastModified
            self.eTag = eTag
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case contentLength = "Content-Length"
            case cacheControl = "Cache-Control"
            case lastModified = "Last-Modified"
            case eTag = "ETag"
            case contentType = "Content-Type"
        }
    }

    public struct Item: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ContentLength", required: false, type: .long), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "LastModified", required: false, type: .timestamp), 
            AWSShapeMember(label: "ETag", required: false, type: .string), 
            AWSShapeMember(label: "ContentType", required: false, type: .string)
        ]
        /// The name of the item.
        public let name: String?
        /// The length of the item in bytes.
        public let contentLength: Int64?
        /// The item type (folder or object).
        public let `type`: ItemType?
        /// The date and time that the item was last modified.
        public let lastModified: TimeStamp?
        /// The ETag that represents a unique instance of the item.
        public let eTag: String?
        /// The content type of the item.
        public let contentType: String?

        public init(name: String? = nil, contentLength: Int64? = nil, type: ItemType? = nil, lastModified: TimeStamp? = nil, eTag: String? = nil, contentType: String? = nil) {
            self.name = name
            self.contentLength = contentLength
            self.`type` = `type`
            self.lastModified = lastModified
            self.eTag = eTag
            self.contentType = contentType
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case contentLength = "ContentLength"
            case `type` = "Type"
            case lastModified = "LastModified"
            case eTag = "ETag"
            case contentType = "ContentType"
        }
    }

    public struct PutObjectResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StorageClass", required: false, type: .enum), 
            AWSShapeMember(label: "ContentSHA256", required: false, type: .string), 
            AWSShapeMember(label: "ETag", required: false, type: .string)
        ]
        /// The storage class where the object was persisted. Should be “Temporal”.
        public let storageClass: StorageClass?
        /// The SHA256 digest of the object that is persisted.
        public let contentSHA256: String?
        /// Unique identifier of the object in the container.
        public let eTag: String?

        public init(storageClass: StorageClass? = nil, contentSHA256: String? = nil, eTag: String? = nil) {
            self.storageClass = storageClass
            self.contentSHA256 = contentSHA256
            self.eTag = eTag
        }

        private enum CodingKeys: String, CodingKey {
            case storageClass = "StorageClass"
            case contentSHA256 = "ContentSHA256"
            case eTag = "ETag"
        }
    }

}