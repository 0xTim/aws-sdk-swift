// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension AppStream {

    public struct DescribeUserStackAssociationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "StackName", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "UserName", required: false, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: false, type: .enum)
        ]
        /// The maximum size of each page of results.
        public let maxResults: Int32?
        /// The name of the stack that is associated with the user.
        public let stackName: String?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The email address of the user who is associated with the stack.
        public let userName: String?
        /// The authentication type for the user who is associated with the stack. You must specify USERPOOL.
        public let authenticationType: AuthenticationType?

        public init(authenticationType: AuthenticationType? = nil, maxResults: Int32? = nil, nextToken: String? = nil, stackName: String? = nil, userName: String? = nil) {
            self.maxResults = maxResults
            self.stackName = stackName
            self.nextToken = nextToken
            self.userName = userName
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case stackName = "StackName"
            case nextToken = "NextToken"
            case userName = "UserName"
            case authenticationType = "AuthenticationType"
        }
    }

    public struct UserStackAssociation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum), 
            AWSShapeMember(label: "UserName", required: true, type: .string), 
            AWSShapeMember(label: "SendEmailNotification", required: false, type: .boolean), 
            AWSShapeMember(label: "StackName", required: true, type: .string)
        ]
        /// The authentication type for the user.
        public let authenticationType: AuthenticationType
        /// The email address of the user who is associated with the stack.
        public let userName: String
        /// Specifies whether a welcome email is sent to a user after the user is created in the user pool.
        public let sendEmailNotification: Bool?
        /// The name of the stack that is associated with the user.
        public let stackName: String

        public init(authenticationType: AuthenticationType, sendEmailNotification: Bool? = nil, stackName: String, userName: String) {
            self.authenticationType = authenticationType
            self.userName = userName
            self.sendEmailNotification = sendEmailNotification
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case userName = "UserName"
            case sendEmailNotification = "SendEmailNotification"
            case stackName = "StackName"
        }
    }

    public struct CreateFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "MaxUserDurationInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "DomainJoinInfo", required: false, type: .structure), 
            AWSShapeMember(label: "ComputeCapacity", required: true, type: .structure), 
            AWSShapeMember(label: "ImageArn", required: false, type: .string), 
            AWSShapeMember(label: "ImageName", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "DisconnectTimeoutInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "InstanceType", required: true, type: .string), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "FleetType", required: false, type: .enum)
        ]
        /// Enables or disables default internet access for the fleet.
        public let enableDefaultInternetAccess: Bool?
        /// The maximum time that a streaming session can run, in seconds. Specify a value between 600 and 57600.
        public let maxUserDurationInSeconds: Int32?
        /// The information needed to join a Microsoft Active Directory domain.
        public let domainJoinInfo: DomainJoinInfo?
        /// The desired capacity for the fleet.
        public let computeCapacity: ComputeCapacity
        /// The ARN of the public, private, or shared image to use.
        public let imageArn: String?
        /// The name of the image used to create the fleet.
        public let imageName: String?
        /// The fleet name for display.
        public let displayName: String?
        /// The time after disconnection when a session is considered to have ended, in seconds. If a user who was disconnected reconnects within this time interval, the user is connected to their previous session. Specify a value between 60 and 57600.
        public let disconnectTimeoutInSeconds: Int32?
        /// A unique name for the fleet.
        public let name: String
        /// The instance type to use when launching fleet instances. The following instance types are available:   stream.standard.medium   stream.standard.large   stream.compute.large   stream.compute.xlarge   stream.compute.2xlarge   stream.compute.4xlarge   stream.compute.8xlarge   stream.memory.large   stream.memory.xlarge   stream.memory.2xlarge   stream.memory.4xlarge   stream.memory.8xlarge   stream.graphics-design.large   stream.graphics-design.xlarge   stream.graphics-design.2xlarge   stream.graphics-design.4xlarge   stream.graphics-desktop.2xlarge   stream.graphics-pro.4xlarge   stream.graphics-pro.8xlarge   stream.graphics-pro.16xlarge  
        public let instanceType: String
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The description for display.
        public let description: String?
        /// The fleet type.  ALWAYS_ON  Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps.  ON_DEMAND  Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.  
        public let fleetType: FleetType?

        public init(computeCapacity: ComputeCapacity, description: String? = nil, disconnectTimeoutInSeconds: Int32? = nil, displayName: String? = nil, domainJoinInfo: DomainJoinInfo? = nil, enableDefaultInternetAccess: Bool? = nil, fleetType: FleetType? = nil, imageArn: String? = nil, imageName: String? = nil, instanceType: String, maxUserDurationInSeconds: Int32? = nil, name: String, vpcConfig: VpcConfig? = nil) {
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.domainJoinInfo = domainJoinInfo
            self.computeCapacity = computeCapacity
            self.imageArn = imageArn
            self.imageName = imageName
            self.displayName = displayName
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.name = name
            self.instanceType = instanceType
            self.vpcConfig = vpcConfig
            self.description = description
            self.fleetType = fleetType
        }

        private enum CodingKeys: String, CodingKey {
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
            case domainJoinInfo = "DomainJoinInfo"
            case computeCapacity = "ComputeCapacity"
            case imageArn = "ImageArn"
            case imageName = "ImageName"
            case displayName = "DisplayName"
            case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
            case name = "Name"
            case instanceType = "InstanceType"
            case vpcConfig = "VpcConfig"
            case description = "Description"
            case fleetType = "FleetType"
        }
    }

    public enum VisibilityType: String, CustomStringConvertible, Codable {
        case `public` = "PUBLIC"
        case `private` = "PRIVATE"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public struct UpdateImagePermissionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "ImagePermissions", required: true, type: .structure), 
            AWSShapeMember(label: "SharedAccountId", required: true, type: .string)
        ]
        /// The name of the private image.
        public let name: String
        /// The permissions for the image.
        public let imagePermissions: ImagePermissions
        /// The 12-digit ID of the AWS account for which you want add or update image permissions.
        public let sharedAccountId: String

        public init(imagePermissions: ImagePermissions, name: String, sharedAccountId: String) {
            self.name = name
            self.imagePermissions = imagePermissions
            self.sharedAccountId = sharedAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case imagePermissions = "ImagePermissions"
            case sharedAccountId = "SharedAccountId"
        }
    }

    public struct ImageBuilder: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "ImageBuilderErrors", required: false, type: .list), 
            AWSShapeMember(label: "DomainJoinInfo", required: false, type: .structure), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "StateChangeReason", required: false, type: .structure), 
            AWSShapeMember(label: "ImageArn", required: false, type: .string), 
            AWSShapeMember(label: "Platform", required: false, type: .enum), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "AppstreamAgentVersion", required: false, type: .string)
        ]
        /// The state of the image builder.
        public let state: ImageBuilderState?
        /// The name of the image builder.
        public let name: String
        /// The ARN for the image builder.
        public let arn: String?
        /// The instance type for the image builder.
        public let instanceType: String?
        /// The image builder name for display.
        public let displayName: String?
        /// Enables or disables default internet access for the image builder.
        public let enableDefaultInternetAccess: Bool?
        /// The image builder errors.
        public let imageBuilderErrors: [ResourceError]?
        /// The information needed to join a Microsoft Active Directory domain.
        public let domainJoinInfo: DomainJoinInfo?
        /// The time stamp when the image builder was created.
        public let createdTime: TimeStamp?
        /// The VPC configuration of the image builder.
        public let vpcConfig: VpcConfig?
        /// The reason why the last state change occurred.
        public let stateChangeReason: ImageBuilderStateChangeReason?
        /// The ARN of the image from which this builder was created.
        public let imageArn: String?
        /// The operating system platform of the image builder.
        public let platform: PlatformType?
        /// The description for display.
        public let description: String?
        /// The version of the AppStream 2.0 agent that is currently being used by this image builder. 
        public let appstreamAgentVersion: String?

        public init(appstreamAgentVersion: String? = nil, arn: String? = nil, createdTime: TimeStamp? = nil, description: String? = nil, displayName: String? = nil, domainJoinInfo: DomainJoinInfo? = nil, enableDefaultInternetAccess: Bool? = nil, imageArn: String? = nil, imageBuilderErrors: [ResourceError]? = nil, instanceType: String? = nil, name: String, platform: PlatformType? = nil, state: ImageBuilderState? = nil, stateChangeReason: ImageBuilderStateChangeReason? = nil, vpcConfig: VpcConfig? = nil) {
            self.state = state
            self.name = name
            self.arn = arn
            self.instanceType = instanceType
            self.displayName = displayName
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.imageBuilderErrors = imageBuilderErrors
            self.domainJoinInfo = domainJoinInfo
            self.createdTime = createdTime
            self.vpcConfig = vpcConfig
            self.stateChangeReason = stateChangeReason
            self.imageArn = imageArn
            self.platform = platform
            self.description = description
            self.appstreamAgentVersion = appstreamAgentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case name = "Name"
            case arn = "Arn"
            case instanceType = "InstanceType"
            case displayName = "DisplayName"
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case imageBuilderErrors = "ImageBuilderErrors"
            case domainJoinInfo = "DomainJoinInfo"
            case createdTime = "CreatedTime"
            case vpcConfig = "VpcConfig"
            case stateChangeReason = "StateChangeReason"
            case imageArn = "ImageArn"
            case platform = "Platform"
            case description = "Description"
            case appstreamAgentVersion = "AppstreamAgentVersion"
        }
    }

    public struct DeleteUserResult: AWSShape {

        public init() {
        }

    }

    public enum ImageBuilderStateChangeReasonCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case imageUnavailable = "IMAGE_UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public struct ListAssociatedFleetsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The name of the fleet.
        public let names: [String]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(names: [String]? = nil, nextToken: String? = nil) {
            self.names = names
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
            case nextToken = "NextToken"
        }
    }

    public struct DeleteDirectoryConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DirectoryName", required: true, type: .string)
        ]
        /// The name of the directory configuration.
        public let directoryName: String

        public init(directoryName: String) {
            self.directoryName = directoryName
        }

        private enum CodingKeys: String, CodingKey {
            case directoryName = "DirectoryName"
        }
    }

    public struct UserStackAssociationError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .enum), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "UserStackAssociation", required: false, type: .structure)
        ]
        /// The error code for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public let errorCode: UserStackAssociationErrorCode?
        /// The error message for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public let errorMessage: String?
        /// Information about the user and associated stack.
        public let userStackAssociation: UserStackAssociation?

        public init(errorCode: UserStackAssociationErrorCode? = nil, errorMessage: String? = nil, userStackAssociation: UserStackAssociation? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userStackAssociation = userStackAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case userStackAssociation = "UserStackAssociation"
        }
    }

    public struct CreateUserResult: AWSShape {

        public init() {
        }

    }

    public struct ListAssociatedStacksRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The name of the fleet.
        public let fleetName: String

        public init(fleetName: String, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case fleetName = "FleetName"
        }
    }

    public struct Image: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Applications", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "AppstreamAgentVersion", required: false, type: .string), 
            AWSShapeMember(label: "ImageBuilderSupported", required: false, type: .boolean), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "StateChangeReason", required: false, type: .structure), 
            AWSShapeMember(label: "PublicBaseImageReleasedDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "BaseImageArn", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "ImagePermissions", required: false, type: .structure), 
            AWSShapeMember(label: "Visibility", required: false, type: .enum), 
            AWSShapeMember(label: "Platform", required: false, type: .enum)
        ]
        /// The ARN of the image.
        public let arn: String?
        /// The image starts in the PENDING state. If image creation succeeds, the state is AVAILABLE. If image creation fails, the state is FAILED.
        public let state: ImageState?
        /// The applications associated with the image.
        public let applications: [Application]?
        /// The name of the image.
        public let name: String
        /// The version of the AppStream 2.0 agent to use for instances that are launched from this image. 
        public let appstreamAgentVersion: String?
        /// Indicates whether an image builder can be launched from this image.
        public let imageBuilderSupported: Bool?
        /// The time the image was created.
        public let createdTime: TimeStamp?
        /// The reason why the last state change occurred.
        public let stateChangeReason: ImageStateChangeReason?
        /// The release date of the public base image. For private images, this date is the release date of the base image from which the image was created.
        public let publicBaseImageReleasedDate: TimeStamp?
        /// The description for display.
        public let description: String?
        /// The ARN of the image from which this image was created.
        public let baseImageArn: String?
        /// The image name for display.
        public let displayName: String?
        /// The permissions to provide to the destination AWS account for the specified image.
        public let imagePermissions: ImagePermissions?
        /// Indicates whether the image is public or private.
        public let visibility: VisibilityType?
        /// The operating system platform of the image.
        public let platform: PlatformType?

        public init(applications: [Application]? = nil, appstreamAgentVersion: String? = nil, arn: String? = nil, baseImageArn: String? = nil, createdTime: TimeStamp? = nil, description: String? = nil, displayName: String? = nil, imageBuilderSupported: Bool? = nil, imagePermissions: ImagePermissions? = nil, name: String, platform: PlatformType? = nil, publicBaseImageReleasedDate: TimeStamp? = nil, state: ImageState? = nil, stateChangeReason: ImageStateChangeReason? = nil, visibility: VisibilityType? = nil) {
            self.arn = arn
            self.state = state
            self.applications = applications
            self.name = name
            self.appstreamAgentVersion = appstreamAgentVersion
            self.imageBuilderSupported = imageBuilderSupported
            self.createdTime = createdTime
            self.stateChangeReason = stateChangeReason
            self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
            self.description = description
            self.baseImageArn = baseImageArn
            self.displayName = displayName
            self.imagePermissions = imagePermissions
            self.visibility = visibility
            self.platform = platform
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case state = "State"
            case applications = "Applications"
            case name = "Name"
            case appstreamAgentVersion = "AppstreamAgentVersion"
            case imageBuilderSupported = "ImageBuilderSupported"
            case createdTime = "CreatedTime"
            case stateChangeReason = "StateChangeReason"
            case publicBaseImageReleasedDate = "PublicBaseImageReleasedDate"
            case description = "Description"
            case baseImageArn = "BaseImageArn"
            case displayName = "DisplayName"
            case imagePermissions = "ImagePermissions"
            case visibility = "Visibility"
            case platform = "Platform"
        }
    }

    public struct DescribeImagePermissionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SharedAwsAccountIds", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The 12-digit ID of one or more AWS accounts with which the image is shared.
        public let sharedAwsAccountIds: [String]?
        /// The name of the private image for which to describe permissions. The image must be one that you own. 
        public let name: String
        /// The maximum size of each page of results.
        public let maxResults: Int32?

        public init(maxResults: Int32? = nil, name: String, nextToken: String? = nil, sharedAwsAccountIds: [String]? = nil) {
            self.nextToken = nextToken
            self.sharedAwsAccountIds = sharedAwsAccountIds
            self.name = name
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sharedAwsAccountIds = "SharedAwsAccountIds"
            case name = "Name"
            case maxResults = "MaxResults"
        }
    }

    public struct StackError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .enum), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string)
        ]
        /// The error code.
        public let errorCode: StackErrorCode?
        /// The error message.
        public let errorMessage: String?

        public init(errorCode: StackErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct UpdateStackResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Stack", required: false, type: .structure)
        ]
        /// Information about the stack.
        public let stack: Stack?

        public init(stack: Stack? = nil) {
            self.stack = stack
        }

        private enum CodingKeys: String, CodingKey {
            case stack = "Stack"
        }
    }

    public struct CreateStackResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Stack", required: false, type: .structure)
        ]
        /// Information about the stack.
        public let stack: Stack?

        public init(stack: Stack? = nil) {
            self.stack = stack
        }

        private enum CodingKeys: String, CodingKey {
            case stack = "Stack"
        }
    }

    public struct ServiceAccountCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountPassword", required: true, type: .string), 
            AWSShapeMember(label: "AccountName", required: true, type: .string)
        ]
        /// The password for the account.
        public let accountPassword: String
        /// The user name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
        public let accountName: String

        public init(accountName: String, accountPassword: String) {
            self.accountPassword = accountPassword
            self.accountName = accountName
        }

        private enum CodingKeys: String, CodingKey {
            case accountPassword = "AccountPassword"
            case accountName = "AccountName"
        }
    }

    public enum MessageAction: String, CustomStringConvertible, Codable {
        case suppress = "SUPPRESS"
        case resend = "RESEND"
        public var description: String { return self.rawValue }
    }

    public struct NetworkAccessConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EniId", required: false, type: .string), 
            AWSShapeMember(label: "EniPrivateIpAddress", required: false, type: .string)
        ]
        /// The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.
        public let eniId: String?
        /// The private IP address of the elastic network interface that is attached to instances in your VPC.
        public let eniPrivateIpAddress: String?

        public init(eniId: String? = nil, eniPrivateIpAddress: String? = nil) {
            self.eniId = eniId
            self.eniPrivateIpAddress = eniPrivateIpAddress
        }

        private enum CodingKeys: String, CodingKey {
            case eniId = "EniId"
            case eniPrivateIpAddress = "EniPrivateIpAddress"
        }
    }

    public struct ListAssociatedStacksResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The name of the stack.
        public let names: [String]?

        public init(names: [String]? = nil, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case names = "Names"
        }
    }

    public struct UntagResourceResponse: AWSShape {

        public init() {
        }

    }

    public struct CopyImageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationImageDescription", required: false, type: .string), 
            AWSShapeMember(label: "SourceImageName", required: true, type: .string), 
            AWSShapeMember(label: "DestinationImageName", required: true, type: .string), 
            AWSShapeMember(label: "DestinationRegion", required: true, type: .string)
        ]
        /// The description that the image will have when it is copied to the destination.
        public let destinationImageDescription: String?
        /// The name of the image to copy.
        public let sourceImageName: String
        /// The name that the image will have when it is copied to the destination.
        public let destinationImageName: String
        /// The destination region to which the image will be copied. This parameter is required, even if you are copying an image within the same region.
        public let destinationRegion: String

        public init(destinationImageDescription: String? = nil, destinationImageName: String, destinationRegion: String, sourceImageName: String) {
            self.destinationImageDescription = destinationImageDescription
            self.sourceImageName = sourceImageName
            self.destinationImageName = destinationImageName
            self.destinationRegion = destinationRegion
        }

        private enum CodingKeys: String, CodingKey {
            case destinationImageDescription = "DestinationImageDescription"
            case sourceImageName = "SourceImageName"
            case destinationImageName = "DestinationImageName"
            case destinationRegion = "DestinationRegion"
        }
    }

    public enum UserStackAssociationErrorCode: String, CustomStringConvertible, Codable {
        case stackNotFound = "STACK_NOT_FOUND"
        case userNameNotFound = "USER_NAME_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public struct BatchAssociateUserStackResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "errors", required: false, type: .list)
        ]
        /// The list of UserStackAssociationError objects.
        public let errors: [UserStackAssociationError]?

        public init(errors: [UserStackAssociationError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct DeleteUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum), 
            AWSShapeMember(label: "UserName", required: true, type: .string)
        ]
        /// The authentication type for the user. You must specify USERPOOL.
        public let authenticationType: AuthenticationType
        /// The email address of the user.
        public let userName: String

        public init(authenticationType: AuthenticationType, userName: String) {
            self.authenticationType = authenticationType
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case userName = "UserName"
        }
    }

    public struct CreateUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MessageAction", required: false, type: .enum), 
            AWSShapeMember(label: "UserName", required: true, type: .string), 
            AWSShapeMember(label: "LastName", required: false, type: .string), 
            AWSShapeMember(label: "FirstName", required: false, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum)
        ]
        /// The action to take for the welcome email that is sent to a user after the user is created in the user pool. If you specify SUPPRESS, no email is sent. If you specify RESEND, do not specify the first name or last name of the user. If the value is null, the email is sent.   The temporary password in the welcome email is valid for only 7 days. If users don’t set their passwords within 7 days, you must send them a new welcome email. 
        public let messageAction: MessageAction?
        /// The email address of the user.
        public let userName: String
        /// The last name, or surname, of the user.
        public let lastName: String?
        /// The first name, or given name, of the user.
        public let firstName: String?
        /// The authentication type for the user. You must specify USERPOOL. 
        public let authenticationType: AuthenticationType

        public init(authenticationType: AuthenticationType, firstName: String? = nil, lastName: String? = nil, messageAction: MessageAction? = nil, userName: String) {
            self.messageAction = messageAction
            self.userName = userName
            self.lastName = lastName
            self.firstName = firstName
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case messageAction = "MessageAction"
            case userName = "UserName"
            case lastName = "LastName"
            case firstName = "FirstName"
            case authenticationType = "AuthenticationType"
        }
    }

    public struct CreateStackRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FeedbackURL", required: false, type: .string), 
            AWSShapeMember(label: "UserSettings", required: false, type: .list), 
            AWSShapeMember(label: "RedirectURL", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "StorageConnectors", required: false, type: .list), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ApplicationSettings", required: false, type: .structure)
        ]
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public let feedbackURL: String?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled. 
        public let userSettings: [UserSetting]?
        /// The URL that users are redirected to after their streaming session ends.
        public let redirectURL: String?
        /// The name of the stack.
        public let name: String
        /// The storage connectors to enable.
        public let storageConnectors: [StorageConnector]?
        /// The stack name for display.
        public let displayName: String?
        /// The description for display.
        public let description: String?
        /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
        public let applicationSettings: ApplicationSettings?

        public init(applicationSettings: ApplicationSettings? = nil, description: String? = nil, displayName: String? = nil, feedbackURL: String? = nil, name: String, redirectURL: String? = nil, storageConnectors: [StorageConnector]? = nil, userSettings: [UserSetting]? = nil) {
            self.feedbackURL = feedbackURL
            self.userSettings = userSettings
            self.redirectURL = redirectURL
            self.name = name
            self.storageConnectors = storageConnectors
            self.displayName = displayName
            self.description = description
            self.applicationSettings = applicationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case feedbackURL = "FeedbackURL"
            case userSettings = "UserSettings"
            case redirectURL = "RedirectURL"
            case name = "Name"
            case storageConnectors = "StorageConnectors"
            case displayName = "DisplayName"
            case description = "Description"
            case applicationSettings = "ApplicationSettings"
        }
    }

    public struct DescribeStacksResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Stacks", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// Information about the stacks.
        public let stacks: [Stack]?

        public init(nextToken: String? = nil, stacks: [Stack]? = nil) {
            self.nextToken = nextToken
            self.stacks = stacks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case stacks = "Stacks"
        }
    }

    public struct UpdateImagePermissionsResult: AWSShape {

        public init() {
        }

    }

    public struct DisableUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum), 
            AWSShapeMember(label: "UserName", required: true, type: .string)
        ]
        /// The authentication type for the user. You must specify USERPOOL.
        public let authenticationType: AuthenticationType
        /// The email address of the user.
        public let userName: String

        public init(authenticationType: AuthenticationType, userName: String) {
            self.authenticationType = authenticationType
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case userName = "UserName"
        }
    }

    public struct DescribeFleetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The names of the fleets to describe.
        public let names: [String]?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(names: [String]? = nil, nextToken: String? = nil) {
            self.names = names
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
            case nextToken = "NextToken"
        }
    }

    public struct DeleteDirectoryConfigResult: AWSShape {

        public init() {
        }

    }

    public struct EnableUserResult: AWSShape {

        public init() {
        }

    }

    public struct CreateStreamingURLRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserId", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string), 
            AWSShapeMember(label: "Validity", required: false, type: .long), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "SessionContext", required: false, type: .string)
        ]
        /// The ID of the user.
        public let userId: String
        /// The name of the fleet.
        public let fleetName: String
        /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 60 seconds.
        public let validity: Int64?
        /// The name of the application to launch after the session starts. This is the name that you specified as Name in the Image Assistant.
        public let applicationId: String?
        /// The name of the stack.
        public let stackName: String
        /// The session context. For more information, see Session Context in the Amazon AppStream 2.0 Developer Guide.
        public let sessionContext: String?

        public init(applicationId: String? = nil, fleetName: String, sessionContext: String? = nil, stackName: String, userId: String, validity: Int64? = nil) {
            self.userId = userId
            self.fleetName = fleetName
            self.validity = validity
            self.applicationId = applicationId
            self.stackName = stackName
            self.sessionContext = sessionContext
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "UserId"
            case fleetName = "FleetName"
            case validity = "Validity"
            case applicationId = "ApplicationId"
            case stackName = "StackName"
            case sessionContext = "SessionContext"
        }
    }

    public struct Fleet: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "DisconnectTimeoutInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "Arn", required: true, type: .string), 
            AWSShapeMember(label: "DomainJoinInfo", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "MaxUserDurationInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "InstanceType", required: true, type: .string), 
            AWSShapeMember(label: "ImageArn", required: false, type: .string), 
            AWSShapeMember(label: "FleetErrors", required: false, type: .list), 
            AWSShapeMember(label: "ComputeCapacityStatus", required: true, type: .structure), 
            AWSShapeMember(label: "ImageName", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "FleetType", required: false, type: .enum), 
            AWSShapeMember(label: "State", required: true, type: .enum)
        ]
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The time after disconnection when a session is considered to have ended, in seconds. If a user who was disconnected reconnects within this time interval, the user is connected to their previous session. Specify a value between 60 and 57600.
        public let disconnectTimeoutInSeconds: Int32?
        /// The ARN for the fleet.
        public let arn: String
        /// The information needed to join a Microsoft Active Directory domain.
        public let domainJoinInfo: DomainJoinInfo?
        /// The name of the fleet.
        public let name: String
        /// The description for display.
        public let description: String?
        /// The fleet name for display.
        public let displayName: String?
        /// The maximum time that a streaming session can run, in seconds. Specify a value between 600 and 57600.
        public let maxUserDurationInSeconds: Int32?
        /// The instance type to use when launching fleet instances.
        public let instanceType: String
        /// The ARN for the public, private, or shared image.
        public let imageArn: String?
        /// The fleet errors.
        public let fleetErrors: [FleetError]?
        /// The capacity status for the fleet.
        public let computeCapacityStatus: ComputeCapacityStatus
        /// The name of the image used to create the fleet.
        public let imageName: String?
        /// The time the fleet was created.
        public let createdTime: TimeStamp?
        /// Indicates whether default internet access is enabled for the fleet.
        public let enableDefaultInternetAccess: Bool?
        /// The fleet type.  ALWAYS_ON  Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps.  ON_DEMAND  Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.  
        public let fleetType: FleetType?
        /// The current state for the fleet.
        public let state: FleetState

        public init(arn: String, computeCapacityStatus: ComputeCapacityStatus, createdTime: TimeStamp? = nil, description: String? = nil, disconnectTimeoutInSeconds: Int32? = nil, displayName: String? = nil, domainJoinInfo: DomainJoinInfo? = nil, enableDefaultInternetAccess: Bool? = nil, fleetErrors: [FleetError]? = nil, fleetType: FleetType? = nil, imageArn: String? = nil, imageName: String? = nil, instanceType: String, maxUserDurationInSeconds: Int32? = nil, name: String, state: FleetState, vpcConfig: VpcConfig? = nil) {
            self.vpcConfig = vpcConfig
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.arn = arn
            self.domainJoinInfo = domainJoinInfo
            self.name = name
            self.description = description
            self.displayName = displayName
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.instanceType = instanceType
            self.imageArn = imageArn
            self.fleetErrors = fleetErrors
            self.computeCapacityStatus = computeCapacityStatus
            self.imageName = imageName
            self.createdTime = createdTime
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.fleetType = fleetType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConfig = "VpcConfig"
            case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
            case arn = "Arn"
            case domainJoinInfo = "DomainJoinInfo"
            case name = "Name"
            case description = "Description"
            case displayName = "DisplayName"
            case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
            case instanceType = "InstanceType"
            case imageArn = "ImageArn"
            case fleetErrors = "FleetErrors"
            case computeCapacityStatus = "ComputeCapacityStatus"
            case imageName = "ImageName"
            case createdTime = "CreatedTime"
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case fleetType = "FleetType"
            case state = "State"
        }
    }

    public struct CreateImageBuilderRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "AppstreamAgentVersion", required: false, type: .string), 
            AWSShapeMember(label: "InstanceType", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ImageName", required: false, type: .string), 
            AWSShapeMember(label: "ImageArn", required: false, type: .string), 
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "DomainJoinInfo", required: false, type: .structure)
        ]
        /// A unique name for the image builder.
        public let name: String
        /// The VPC configuration for the image builder. You can specify only one subnet.
        public let vpcConfig: VpcConfig?
        /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST]. 
        public let appstreamAgentVersion: String?
        /// The instance type to use when launching the image builder.
        public let instanceType: String
        /// The description for display.
        public let description: String?
        /// The name of the image used to create the builder.
        public let imageName: String?
        /// The ARN of the public, private, or shared image to use.
        public let imageArn: String?
        /// Enables or disables default internet access for the image builder.
        public let enableDefaultInternetAccess: Bool?
        /// The image builder name for display.
        public let displayName: String?
        /// The information needed to join a Microsoft Active Directory domain.
        public let domainJoinInfo: DomainJoinInfo?

        public init(appstreamAgentVersion: String? = nil, description: String? = nil, displayName: String? = nil, domainJoinInfo: DomainJoinInfo? = nil, enableDefaultInternetAccess: Bool? = nil, imageArn: String? = nil, imageName: String? = nil, instanceType: String, name: String, vpcConfig: VpcConfig? = nil) {
            self.name = name
            self.vpcConfig = vpcConfig
            self.appstreamAgentVersion = appstreamAgentVersion
            self.instanceType = instanceType
            self.description = description
            self.imageName = imageName
            self.imageArn = imageArn
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case vpcConfig = "VpcConfig"
            case appstreamAgentVersion = "AppstreamAgentVersion"
            case instanceType = "InstanceType"
            case description = "Description"
            case imageName = "ImageName"
            case imageArn = "ImageArn"
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case displayName = "DisplayName"
            case domainJoinInfo = "DomainJoinInfo"
        }
    }

    public enum StorageConnectorType: String, CustomStringConvertible, Codable {
        case homefolders = "HOMEFOLDERS"
        case googleDrive = "GOOGLE_DRIVE"
        case oneDrive = "ONE_DRIVE"
        public var description: String { return self.rawValue }
    }

    public struct DescribeImageBuildersResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ImageBuilders", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// Information about the image builders.
        public let imageBuilders: [ImageBuilder]?

        public init(imageBuilders: [ImageBuilder]? = nil, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.imageBuilders = imageBuilders
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case imageBuilders = "ImageBuilders"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct DisassociateFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The name of the stack.
        public let stackName: String
        /// The name of the fleet.
        public let fleetName: String

        public init(fleetName: String, stackName: String) {
            self.stackName = stackName
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case stackName = "StackName"
            case fleetName = "FleetName"
        }
    }

    public struct UpdateDirectoryConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceAccountCredentials", required: false, type: .structure), 
            AWSShapeMember(label: "OrganizationalUnitDistinguishedNames", required: false, type: .list), 
            AWSShapeMember(label: "DirectoryName", required: true, type: .string)
        ]
        /// The credentials for the service account used by the streaming instance to connect to the directory.
        public let serviceAccountCredentials: ServiceAccountCredentials?
        /// The distinguished names of the organizational units for computer accounts.
        public let organizationalUnitDistinguishedNames: [String]?
        /// The name of the Directory Config object.
        public let directoryName: String

        public init(directoryName: String, organizationalUnitDistinguishedNames: [String]? = nil, serviceAccountCredentials: ServiceAccountCredentials? = nil) {
            self.serviceAccountCredentials = serviceAccountCredentials
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
            self.directoryName = directoryName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceAccountCredentials = "ServiceAccountCredentials"
            case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
            case directoryName = "DirectoryName"
        }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable {
        case api = "API"
        case saml = "SAML"
        case userpool = "USERPOOL"
        public var description: String { return self.rawValue }
    }

    public struct User: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "FirstName", required: false, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum), 
            AWSShapeMember(label: "UserName", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "LastName", required: false, type: .string)
        ]
        /// The date and time the user was created in the user pool.
        public let createdTime: TimeStamp?
        /// Specifies whether the user in the user pool is enabled.
        public let enabled: Bool?
        /// The ARN of the user.
        public let arn: String?
        /// The first name, or given name, of the user.
        public let firstName: String?
        /// The authentication type for the user.
        public let authenticationType: AuthenticationType
        /// The email address of the user.
        public let userName: String?
        /// The status of the user in the user pool. The status can be one of the following:   UNCONFIRMED – The user is created but not confirmed.   CONFIRMED – The user is confirmed.   ARCHIVED – The user is no longer active.   COMPROMISED – The user is disabled because of a potential security threat.   UNKNOWN – The user status is not known.  
        public let status: String?
        /// The last name, or surname, of the user.
        public let lastName: String?

        public init(arn: String? = nil, authenticationType: AuthenticationType, createdTime: TimeStamp? = nil, enabled: Bool? = nil, firstName: String? = nil, lastName: String? = nil, status: String? = nil, userName: String? = nil) {
            self.createdTime = createdTime
            self.enabled = enabled
            self.arn = arn
            self.firstName = firstName
            self.authenticationType = authenticationType
            self.userName = userName
            self.status = status
            self.lastName = lastName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case enabled = "Enabled"
            case arn = "Arn"
            case firstName = "FirstName"
            case authenticationType = "AuthenticationType"
            case userName = "UserName"
            case status = "Status"
            case lastName = "LastName"
        }
    }

    public struct DomainJoinInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OrganizationalUnitDistinguishedName", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryName", required: false, type: .string)
        ]
        /// The distinguished name of the organizational unit for computer accounts.
        public let organizationalUnitDistinguishedName: String?
        /// The fully qualified name of the directory (for example, corp.example.com).
        public let directoryName: String?

        public init(directoryName: String? = nil, organizationalUnitDistinguishedName: String? = nil) {
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.directoryName = directoryName
        }

        private enum CodingKeys: String, CodingKey {
            case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
            case directoryName = "DirectoryName"
        }
    }

    public struct StopImageBuilderRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the image builder.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct TagResourceResponse: AWSShape {

        public init() {
        }

    }

    public enum SessionState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case pending = "PENDING"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public struct StartImageBuilderResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImageBuilder", required: false, type: .structure)
        ]
        /// Information about the image builder.
        public let imageBuilder: ImageBuilder?

        public init(imageBuilder: ImageBuilder? = nil) {
            self.imageBuilder = imageBuilder
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuilder = "ImageBuilder"
        }
    }

    public struct AssociateFleetResult: AWSShape {

        public init() {
        }

    }

    public struct DescribeDirectoryConfigsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryConfigs", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// Information about the directory configurations. Note that although the response syntax in this topic includes the account password, this password is not returned in the actual response. 
        public let directoryConfigs: [DirectoryConfig]?

        public init(directoryConfigs: [DirectoryConfig]? = nil, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.directoryConfigs = directoryConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case directoryConfigs = "DirectoryConfigs"
        }
    }

    public struct DescribeUsersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The authentication type for the users in the user pool to describe. You must specify USERPOOL.
        public let authenticationType: AuthenticationType
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The maximum size of each page of results.
        public let maxResults: Int32?

        public init(authenticationType: AuthenticationType, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.authenticationType = authenticationType
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct Stack: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "FeedbackURL", required: false, type: .string), 
            AWSShapeMember(label: "UserSettings", required: false, type: .list), 
            AWSShapeMember(label: "StackErrors", required: false, type: .list), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "ApplicationSettings", required: false, type: .structure), 
            AWSShapeMember(label: "RedirectURL", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "StorageConnectors", required: false, type: .list)
        ]
        /// The ARN of the stack.
        public let arn: String?
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public let feedbackURL: String?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default these actions are enabled.
        public let userSettings: [UserSetting]?
        /// The errors for the stack.
        public let stackErrors: [StackError]?
        /// The stack name for display.
        public let displayName: String?
        /// The description for display.
        public let description: String?
        /// The name of the stack.
        public let name: String
        /// The persistent application settings for users of the stack.
        public let applicationSettings: ApplicationSettingsResponse?
        /// The URL that users are redirected to after their streaming session ends.
        public let redirectURL: String?
        /// The time the stack was created.
        public let createdTime: TimeStamp?
        /// The storage connectors to enable.
        public let storageConnectors: [StorageConnector]?

        public init(applicationSettings: ApplicationSettingsResponse? = nil, arn: String? = nil, createdTime: TimeStamp? = nil, description: String? = nil, displayName: String? = nil, feedbackURL: String? = nil, name: String, redirectURL: String? = nil, stackErrors: [StackError]? = nil, storageConnectors: [StorageConnector]? = nil, userSettings: [UserSetting]? = nil) {
            self.arn = arn
            self.feedbackURL = feedbackURL
            self.userSettings = userSettings
            self.stackErrors = stackErrors
            self.displayName = displayName
            self.description = description
            self.name = name
            self.applicationSettings = applicationSettings
            self.redirectURL = redirectURL
            self.createdTime = createdTime
            self.storageConnectors = storageConnectors
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case feedbackURL = "FeedbackURL"
            case userSettings = "UserSettings"
            case stackErrors = "StackErrors"
            case displayName = "DisplayName"
            case description = "Description"
            case name = "Name"
            case applicationSettings = "ApplicationSettings"
            case redirectURL = "RedirectURL"
            case createdTime = "CreatedTime"
            case storageConnectors = "StorageConnectors"
        }
    }

    public struct DescribeImageBuildersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The names of the image builders to describe.
        public let names: [String]?
        /// The maximum size of each page of results.
        public let maxResults: Int32?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(maxResults: Int32? = nil, names: [String]? = nil, nextToken: String? = nil) {
            self.names = names
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct StartImageBuilderRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppstreamAgentVersion", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST]. 
        public let appstreamAgentVersion: String?
        /// The name of the image builder.
        public let name: String

        public init(appstreamAgentVersion: String? = nil, name: String) {
            self.appstreamAgentVersion = appstreamAgentVersion
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case appstreamAgentVersion = "AppstreamAgentVersion"
            case name = "Name"
        }
    }

    public enum Permission: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct DescribeImagesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Images", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Information about the images.
        public let images: [Image]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(images: [Image]? = nil, nextToken: String? = nil) {
            self.images = images
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case images = "Images"
            case nextToken = "NextToken"
        }
    }

    public struct UserSetting: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Permission", required: true, type: .enum), 
            AWSShapeMember(label: "Action", required: true, type: .enum)
        ]
        /// Indicates whether the action is enabled or disabled.
        public let permission: Permission
        /// The action that is enabled or disabled.
        public let action: Action

        public init(action: Action, permission: Permission) {
            self.permission = permission
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case permission = "Permission"
            case action = "Action"
        }
    }

    public struct ApplicationSettingsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3BucketName", required: false, type: .string), 
            AWSShapeMember(label: "SettingsGroup", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        /// The S3 bucket where users’ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an AWS Region, an S3 bucket is created. The bucket is unique to the AWS account and the Region. 
        public let s3BucketName: String?
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored.
        public let settingsGroup: String?
        /// Specifies whether persistent application settings are enabled for users during their streaming sessions.
        public let enabled: Bool?

        public init(enabled: Bool? = nil, s3BucketName: String? = nil, settingsGroup: String? = nil) {
            self.s3BucketName = s3BucketName
            self.settingsGroup = settingsGroup
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case settingsGroup = "SettingsGroup"
            case enabled = "Enabled"
        }
    }

    public struct ExpireSessionResult: AWSShape {

        public init() {
        }

    }

    public struct BatchDisassociateUserStackResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "errors", required: false, type: .list)
        ]
        /// The list of UserStackAssociationError objects.
        public let errors: [UserStackAssociationError]?

        public init(errors: [UserStackAssociationError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct StopFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the fleet.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ComputeCapacityStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Desired", required: true, type: .integer), 
            AWSShapeMember(label: "Available", required: false, type: .integer), 
            AWSShapeMember(label: "InUse", required: false, type: .integer), 
            AWSShapeMember(label: "Running", required: false, type: .integer)
        ]
        /// The desired number of streaming instances.
        public let desired: Int32
        /// The number of currently available instances that can be used to stream sessions.
        public let available: Int32?
        /// The number of instances in use for streaming.
        public let inUse: Int32?
        /// The total number of simultaneous streaming instances that are running.
        public let running: Int32?

        public init(available: Int32? = nil, desired: Int32, inUse: Int32? = nil, running: Int32? = nil) {
            self.desired = desired
            self.available = available
            self.inUse = inUse
            self.running = running
        }

        private enum CodingKeys: String, CodingKey {
            case desired = "Desired"
            case available = "Available"
            case inUse = "InUse"
            case running = "Running"
        }
    }

    public struct DeleteStackResult: AWSShape {

        public init() {
        }

    }

    public struct StopFleetResult: AWSShape {

        public init() {
        }

    }

    public struct AssociateFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FleetName", required: true, type: .string), 
            AWSShapeMember(label: "StackName", required: true, type: .string)
        ]
        /// The name of the fleet. 
        public let fleetName: String
        /// The name of the stack.
        public let stackName: String

        public init(fleetName: String, stackName: String) {
            self.fleetName = fleetName
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case fleetName = "FleetName"
            case stackName = "StackName"
        }
    }

    public enum Action: String, CustomStringConvertible, Codable {
        case clipboardCopyFromLocalDevice = "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
        case clipboardCopyToLocalDevice = "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
        case fileUpload = "FILE_UPLOAD"
        case fileDownload = "FILE_DOWNLOAD"
        case printingToLocalDevice = "PRINTING_TO_LOCAL_DEVICE"
        public var description: String { return self.rawValue }
    }

    public enum ImageBuilderState: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case updatingAgent = "UPDATING_AGENT"
        case running = "RUNNING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        case rebooting = "REBOOTING"
        case snapshotting = "SNAPSHOTTING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct DirectoryConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OrganizationalUnitDistinguishedNames", required: false, type: .list), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DirectoryName", required: true, type: .string), 
            AWSShapeMember(label: "ServiceAccountCredentials", required: false, type: .structure)
        ]
        /// The distinguished names of the organizational units for computer accounts.
        public let organizationalUnitDistinguishedNames: [String]?
        /// The time the directory configuration was created.
        public let createdTime: TimeStamp?
        /// The fully qualified name of the directory (for example, corp.example.com).
        public let directoryName: String
        /// The credentials for the service account used by the streaming instance to connect to the directory.
        public let serviceAccountCredentials: ServiceAccountCredentials?

        public init(createdTime: TimeStamp? = nil, directoryName: String, organizationalUnitDistinguishedNames: [String]? = nil, serviceAccountCredentials: ServiceAccountCredentials? = nil) {
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
            self.createdTime = createdTime
            self.directoryName = directoryName
            self.serviceAccountCredentials = serviceAccountCredentials
        }

        private enum CodingKeys: String, CodingKey {
            case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
            case createdTime = "CreatedTime"
            case directoryName = "DirectoryName"
            case serviceAccountCredentials = "ServiceAccountCredentials"
        }
    }

    public struct DeleteImageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the image.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ListAssociatedFleetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The name of the stack.
        public let stackName: String
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(nextToken: String? = nil, stackName: String) {
            self.stackName = stackName
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case stackName = "StackName"
            case nextToken = "NextToken"
        }
    }

    public struct SharedImagePermissions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "imagePermissions", required: true, type: .structure), 
            AWSShapeMember(label: "sharedAccountId", required: true, type: .string)
        ]
        /// Describes the permissions for a shared image.
        public let imagePermissions: ImagePermissions
        /// The 12-digit ID of the AWS account with which the image is shared.
        public let sharedAccountId: String

        public init(imagePermissions: ImagePermissions, sharedAccountId: String) {
            self.imagePermissions = imagePermissions
            self.sharedAccountId = sharedAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case imagePermissions = "imagePermissions"
            case sharedAccountId = "sharedAccountId"
        }
    }

    public struct ApplicationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: true, type: .boolean), 
            AWSShapeMember(label: "SettingsGroup", required: false, type: .string)
        ]
        /// Enables or disables persistent application settings for users during their streaming sessions. 
        public let enabled: Bool
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple stacks by specifying the same settings group for each stack. 
        public let settingsGroup: String?

        public init(enabled: Bool, settingsGroup: String? = nil) {
            self.enabled = enabled
            self.settingsGroup = settingsGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case settingsGroup = "SettingsGroup"
        }
    }

    public enum ImageState: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case available = "AVAILABLE"
        case failed = "FAILED"
        case copying = "COPYING"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public struct FleetError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .enum)
        ]
        /// The error message.
        public let errorMessage: String?
        /// The error code.
        public let errorCode: FleetErrorCode?

        public init(errorCode: FleetErrorCode? = nil, errorMessage: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorCode = "ErrorCode"
        }
    }

    public struct DisableUserResult: AWSShape {

        public init() {
        }

    }

    public struct BatchDisassociateUserStackRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserStackAssociations", required: true, type: .list)
        ]
        /// The list of UserStackAssociation objects.
        public let userStackAssociations: [UserStackAssociation]

        public init(userStackAssociations: [UserStackAssociation]) {
            self.userStackAssociations = userStackAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case userStackAssociations = "UserStackAssociations"
        }
    }

    public struct DeleteImageBuilderRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the image builder.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ExpireSessionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SessionId", required: true, type: .string)
        ]
        /// The ID of the streaming session.
        public let sessionId: String

        public init(sessionId: String) {
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "SessionId"
        }
    }

    public struct ImageBuilderStateChangeReason: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", required: false, type: .enum), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]
        /// The state change reason code.
        public let code: ImageBuilderStateChangeReasonCode?
        /// The state change reason message.
        public let message: String?

        public init(code: ImageBuilderStateChangeReasonCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct DeleteFleetResult: AWSShape {

        public init() {
        }

    }

    public struct CreateDirectoryConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DirectoryConfig", required: false, type: .structure)
        ]
        /// Information about the directory configuration.
        public let directoryConfig: DirectoryConfig?

        public init(directoryConfig: DirectoryConfig? = nil) {
            self.directoryConfig = directoryConfig
        }

        private enum CodingKeys: String, CodingKey {
            case directoryConfig = "DirectoryConfig"
        }
    }

    public struct DeleteImagePermissionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SharedAccountId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The 12-digit ID of the AWS account for which to delete image permissions.
        public let sharedAccountId: String
        /// The name of the private image.
        public let name: String

        public init(name: String, sharedAccountId: String) {
            self.sharedAccountId = sharedAccountId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case sharedAccountId = "SharedAccountId"
            case name = "Name"
        }
    }

    public struct CreateImageBuilderResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImageBuilder", required: false, type: .structure)
        ]
        /// Information about the image builder.
        public let imageBuilder: ImageBuilder?

        public init(imageBuilder: ImageBuilder? = nil) {
            self.imageBuilder = imageBuilder
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuilder = "ImageBuilder"
        }
    }

    public enum FleetAttribute: String, CustomStringConvertible, Codable {
        case vpcConfiguration = "VPC_CONFIGURATION"
        case vpcConfigurationSecurityGroupIds = "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
        case domainJoinInfo = "DOMAIN_JOIN_INFO"
        public var description: String { return self.rawValue }
    }

    public enum FleetType: String, CustomStringConvertible, Codable {
        case alwaysOn = "ALWAYS_ON"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public struct DeleteStackRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the stack.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateStreamingURLResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamingURL", required: false, type: .string), 
            AWSShapeMember(label: "Expires", required: false, type: .timestamp)
        ]
        /// The URL to start the AppStream 2.0 streaming session.
        public let streamingURL: String?
        /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
        public let expires: TimeStamp?

        public init(expires: TimeStamp? = nil, streamingURL: String? = nil) {
            self.streamingURL = streamingURL
            self.expires = expires
        }

        private enum CodingKeys: String, CodingKey {
            case streamingURL = "StreamingURL"
            case expires = "Expires"
        }
    }

    public struct StartFleetResult: AWSShape {

        public init() {
        }

    }

    public enum StackAttribute: String, CustomStringConvertible, Codable {
        case storageConnectors = "STORAGE_CONNECTORS"
        case storageConnectorHomefolders = "STORAGE_CONNECTOR_HOMEFOLDERS"
        case storageConnectorGoogleDrive = "STORAGE_CONNECTOR_GOOGLE_DRIVE"
        case storageConnectorOneDrive = "STORAGE_CONNECTOR_ONE_DRIVE"
        case redirectUrl = "REDIRECT_URL"
        case feedbackUrl = "FEEDBACK_URL"
        case themeName = "THEME_NAME"
        case userSettings = "USER_SETTINGS"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSessionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Sessions", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Information about the streaming sessions.
        public let sessions: [Session]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(nextToken: String? = nil, sessions: [Session]? = nil) {
            self.sessions = sessions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case sessions = "Sessions"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeImagePermissionsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SharedImagePermissionsList", required: false, type: .list)
        ]
        /// The name of the private image.
        public let name: String?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The permissions for a private image that you own. 
        public let sharedImagePermissionsList: [SharedImagePermissions]?

        public init(name: String? = nil, nextToken: String? = nil, sharedImagePermissionsList: [SharedImagePermissions]? = nil) {
            self.name = name
            self.nextToken = nextToken
            self.sharedImagePermissionsList = sharedImagePermissionsList
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case nextToken = "NextToken"
            case sharedImagePermissionsList = "SharedImagePermissionsList"
        }
    }

    public struct Session: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FleetName", required: true, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "NetworkAccessConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "State", required: true, type: .enum), 
            AWSShapeMember(label: "UserId", required: true, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: false, type: .enum), 
            AWSShapeMember(label: "StackName", required: true, type: .string)
        ]
        /// The name of the fleet for the streaming session.
        public let fleetName: String
        /// The ID of the streaming session.
        public let id: String
        /// The network details for the streaming session.
        public let networkAccessConfiguration: NetworkAccessConfiguration?
        /// The current state of the streaming session.
        public let state: SessionState
        /// The identifier of the user for whom the session was created.
        public let userId: String
        /// The authentication method. The user is authenticated using a streaming URL (API) or SAML federation (SAML).
        public let authenticationType: AuthenticationType?
        /// The name of the stack for the streaming session.
        public let stackName: String

        public init(authenticationType: AuthenticationType? = nil, fleetName: String, id: String, networkAccessConfiguration: NetworkAccessConfiguration? = nil, stackName: String, state: SessionState, userId: String) {
            self.fleetName = fleetName
            self.id = id
            self.networkAccessConfiguration = networkAccessConfiguration
            self.state = state
            self.userId = userId
            self.authenticationType = authenticationType
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case fleetName = "FleetName"
            case id = "Id"
            case networkAccessConfiguration = "NetworkAccessConfiguration"
            case state = "State"
            case userId = "UserId"
            case authenticationType = "AuthenticationType"
            case stackName = "StackName"
        }
    }

    public struct CreateDirectoryConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DirectoryName", required: true, type: .string), 
            AWSShapeMember(label: "ServiceAccountCredentials", required: true, type: .structure), 
            AWSShapeMember(label: "OrganizationalUnitDistinguishedNames", required: true, type: .list)
        ]
        /// The fully qualified name of the directory (for example, corp.example.com).
        public let directoryName: String
        /// The credentials for the service account used by the streaming instance to connect to the directory.
        public let serviceAccountCredentials: ServiceAccountCredentials
        /// The distinguished names of the organizational units for computer accounts.
        public let organizationalUnitDistinguishedNames: [String]

        public init(directoryName: String, organizationalUnitDistinguishedNames: [String], serviceAccountCredentials: ServiceAccountCredentials) {
            self.directoryName = directoryName
            self.serviceAccountCredentials = serviceAccountCredentials
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        }

        private enum CodingKeys: String, CodingKey {
            case directoryName = "DirectoryName"
            case serviceAccountCredentials = "ServiceAccountCredentials"
            case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        }
    }

    public struct CopyImageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DestinationImageName", required: false, type: .string)
        ]
        /// The name of the destination image.
        public let destinationImageName: String?

        public init(destinationImageName: String? = nil) {
            self.destinationImageName = destinationImageName
        }

        private enum CodingKeys: String, CodingKey {
            case destinationImageName = "DestinationImageName"
        }
    }

    public struct DeleteFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the fleet.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ImagePermissions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "allowFleet", required: false, type: .boolean), 
            AWSShapeMember(label: "allowImageBuilder", required: false, type: .boolean)
        ]
        /// Indicates whether the image can be used for a fleet.
        public let allowFleet: Bool?
        /// Indicates whether the image can be used for an image builder.
        public let allowImageBuilder: Bool?

        public init(allowFleet: Bool? = nil, allowImageBuilder: Bool? = nil) {
            self.allowFleet = allowFleet
            self.allowImageBuilder = allowImageBuilder
        }

        private enum CodingKeys: String, CodingKey {
            case allowFleet = "allowFleet"
            case allowImageBuilder = "allowImageBuilder"
        }
    }

    public struct Application: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LaunchParameters", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Metadata", required: false, type: .map), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "LaunchPath", required: false, type: .string), 
            AWSShapeMember(label: "IconURL", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string)
        ]
        /// The arguments that are passed to the application at launch.
        public let launchParameters: String?
        /// The name of the application.
        public let name: String?
        /// Additional attributes that describe the application.
        public let metadata: [String: String]?
        /// If there is a problem, the application can be disabled after image creation.
        public let enabled: Bool?
        /// The path to the application executable in the instance.
        public let launchPath: String?
        /// The URL for the application icon. This URL might be time-limited.
        public let iconURL: String?
        /// The application name for display.
        public let displayName: String?

        public init(displayName: String? = nil, enabled: Bool? = nil, iconURL: String? = nil, launchParameters: String? = nil, launchPath: String? = nil, metadata: [String: String]? = nil, name: String? = nil) {
            self.launchParameters = launchParameters
            self.name = name
            self.metadata = metadata
            self.enabled = enabled
            self.launchPath = launchPath
            self.iconURL = iconURL
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case launchParameters = "LaunchParameters"
            case name = "Name"
            case metadata = "Metadata"
            case enabled = "Enabled"
            case launchPath = "LaunchPath"
            case iconURL = "IconURL"
            case displayName = "DisplayName"
        }
    }

    public struct StorageConnector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Domains", required: false, type: .list), 
            AWSShapeMember(label: "ConnectorType", required: true, type: .enum)
        ]
        /// The ARN of the storage connector.
        public let resourceIdentifier: String?
        /// The names of the domains for the G Suite account.
        public let domains: [String]?
        /// The type of storage connector.
        public let connectorType: StorageConnectorType

        public init(connectorType: StorageConnectorType, domains: [String]? = nil, resourceIdentifier: String? = nil) {
            self.resourceIdentifier = resourceIdentifier
            self.domains = domains
            self.connectorType = connectorType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdentifier = "ResourceIdentifier"
            case domains = "Domains"
            case connectorType = "ConnectorType"
        }
    }

    public struct ComputeCapacity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DesiredInstances", required: true, type: .integer)
        ]
        /// The desired number of streaming instances.
        public let desiredInstances: Int32

        public init(desiredInstances: Int32) {
            self.desiredInstances = desiredInstances
        }

        private enum CodingKeys: String, CodingKey {
            case desiredInstances = "DesiredInstances"
        }
    }

    public struct UpdateFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "DisconnectTimeoutInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "DeleteVpcConfig", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ImageArn", required: false, type: .string), 
            AWSShapeMember(label: "ComputeCapacity", required: false, type: .structure), 
            AWSShapeMember(label: "MaxUserDurationInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "DomainJoinInfo", required: false, type: .structure), 
            AWSShapeMember(label: "InstanceType", required: false, type: .string), 
            AWSShapeMember(label: "ImageName", required: false, type: .string), 
            AWSShapeMember(label: "AttributesToDelete", required: false, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string)
        ]
        /// Enables or disables default internet access for the fleet.
        public let enableDefaultInternetAccess: Bool?
        /// The time after disconnection when a session is considered to have ended, in seconds. If a user who was disconnected reconnects within this time interval, the user is connected to their previous session. Specify a value between 60 and 57600.
        public let disconnectTimeoutInSeconds: Int32?
        /// Deletes the VPC association for the specified fleet.
        public let deleteVpcConfig: Bool?
        /// A unique name for the fleet.
        public let name: String?
        /// The ARN of the public, private, or shared image to use.
        public let imageArn: String?
        /// The desired capacity for the fleet.
        public let computeCapacity: ComputeCapacity?
        /// The maximum time that a streaming session can run, in seconds. Specify a value between 600 and 57600.
        public let maxUserDurationInSeconds: Int32?
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The information needed to join a Microsoft Active Directory domain.
        public let domainJoinInfo: DomainJoinInfo?
        /// The instance type to use when launching fleet instances. The following instance types are available:   stream.standard.medium   stream.standard.large   stream.compute.large   stream.compute.xlarge   stream.compute.2xlarge   stream.compute.4xlarge   stream.compute.8xlarge   stream.memory.large   stream.memory.xlarge   stream.memory.2xlarge   stream.memory.4xlarge   stream.memory.8xlarge   stream.graphics-design.large   stream.graphics-design.xlarge   stream.graphics-design.2xlarge   stream.graphics-design.4xlarge   stream.graphics-desktop.2xlarge   stream.graphics-pro.4xlarge   stream.graphics-pro.8xlarge   stream.graphics-pro.16xlarge  
        public let instanceType: String?
        /// The name of the image used to create the fleet.
        public let imageName: String?
        /// The fleet attributes to delete.
        public let attributesToDelete: [FleetAttribute]?
        /// The description for display.
        public let description: String?
        /// The fleet name for display.
        public let displayName: String?

        public init(attributesToDelete: [FleetAttribute]? = nil, computeCapacity: ComputeCapacity? = nil, deleteVpcConfig: Bool? = nil, description: String? = nil, disconnectTimeoutInSeconds: Int32? = nil, displayName: String? = nil, domainJoinInfo: DomainJoinInfo? = nil, enableDefaultInternetAccess: Bool? = nil, imageArn: String? = nil, imageName: String? = nil, instanceType: String? = nil, maxUserDurationInSeconds: Int32? = nil, name: String? = nil, vpcConfig: VpcConfig? = nil) {
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.deleteVpcConfig = deleteVpcConfig
            self.name = name
            self.imageArn = imageArn
            self.computeCapacity = computeCapacity
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.vpcConfig = vpcConfig
            self.domainJoinInfo = domainJoinInfo
            self.instanceType = instanceType
            self.imageName = imageName
            self.attributesToDelete = attributesToDelete
            self.description = description
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
            case deleteVpcConfig = "DeleteVpcConfig"
            case name = "Name"
            case imageArn = "ImageArn"
            case computeCapacity = "ComputeCapacity"
            case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
            case vpcConfig = "VpcConfig"
            case domainJoinInfo = "DomainJoinInfo"
            case instanceType = "InstanceType"
            case imageName = "ImageName"
            case attributesToDelete = "AttributesToDelete"
            case description = "Description"
            case displayName = "DisplayName"
        }
    }

    public enum PlatformType: String, CustomStringConvertible, Codable {
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public struct VpcConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "SubnetIds", required: false, type: .list)
        ]
        /// The security groups for the fleet.
        public let securityGroupIds: [String]?
        /// The subnets to which a network interface is established from the fleet instance.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: true, type: .map), 
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// The tags to associate. A tag is a key-value pair (the value is optional). For example, Environment=Test, or, if you do not specify a value, Environment=.  If you do not specify a value, we set the value to an empty string.
        public let tags: [String: String]
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String, tags: [String: String]) {
            self.tags = tags
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case resourceArn = "ResourceArn"
        }
    }

    public struct UpdateFleetResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fleet", required: false, type: .structure)
        ]
        /// Information about the fleet.
        public let fleet: Fleet?

        public init(fleet: Fleet? = nil) {
            self.fleet = fleet
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "Fleet"
        }
    }

    public enum FleetErrorCode: String, CustomStringConvertible, Codable {
        case iamServiceRoleMissingEniDescribeAction = "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
        case iamServiceRoleMissingEniCreateAction = "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
        case iamServiceRoleMissingEniDeleteAction = "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
        case networkInterfaceLimitExceeded = "NETWORK_INTERFACE_LIMIT_EXCEEDED"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case iamServiceRoleIsMissing = "IAM_SERVICE_ROLE_IS_MISSING"
        case subnetHasInsufficientIpAddresses = "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
        case iamServiceRoleMissingDescribeSubnetAction = "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
        case subnetNotFound = "SUBNET_NOT_FOUND"
        case imageNotFound = "IMAGE_NOT_FOUND"
        case invalidSubnetConfiguration = "INVALID_SUBNET_CONFIGURATION"
        case securityGroupsNotFound = "SECURITY_GROUPS_NOT_FOUND"
        case igwNotAttached = "IGW_NOT_ATTACHED"
        case iamServiceRoleMissingDescribeSecurityGroupsAction = "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
        case domainJoinErrorFileNotFound = "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
        case domainJoinErrorAccessDenied = "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
        case domainJoinErrorLogonFailure = "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
        case domainJoinErrorInvalidParameter = "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
        case domainJoinErrorMoreData = "DOMAIN_JOIN_ERROR_MORE_DATA"
        case domainJoinErrorNoSuchDomain = "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
        case domainJoinErrorNotSupported = "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
        case domainJoinNerrInvalidWorkgroupName = "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
        case domainJoinNerrWorkstationNotStarted = "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
        case domainJoinErrorDsMachineAccountQuotaExceeded = "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
        case domainJoinNerrPasswordExpired = "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
        case domainJoinInternalServiceError = "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
        public var description: String { return self.rawValue }
    }

    public struct DeleteImageResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Image", required: false, type: .structure)
        ]
        /// Information about the image.
        public let image: Image?

        public init(image: Image? = nil) {
            self.image = image
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
        }
    }

    public struct UpdateStackRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "StorageConnectors", required: false, type: .list), 
            AWSShapeMember(label: "FeedbackURL", required: false, type: .string), 
            AWSShapeMember(label: "UserSettings", required: false, type: .list), 
            AWSShapeMember(label: "RedirectURL", required: false, type: .string), 
            AWSShapeMember(label: "DeleteStorageConnectors", required: false, type: .boolean), 
            AWSShapeMember(label: "ApplicationSettings", required: false, type: .structure), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "AttributesToDelete", required: false, type: .list)
        ]
        /// The name of the stack.
        public let name: String
        /// The storage connectors to enable.
        public let storageConnectors: [StorageConnector]?
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public let feedbackURL: String?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
        public let userSettings: [UserSetting]?
        /// The URL that users are redirected to after their streaming session ends.
        public let redirectURL: String?
        /// Deletes the storage connectors currently enabled for the stack.
        public let deleteStorageConnectors: Bool?
        /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
        public let applicationSettings: ApplicationSettings?
        /// The stack name for display.
        public let displayName: String?
        /// The description for display.
        public let description: String?
        /// The stack attributes to delete.
        public let attributesToDelete: [StackAttribute]?

        public init(applicationSettings: ApplicationSettings? = nil, attributesToDelete: [StackAttribute]? = nil, deleteStorageConnectors: Bool? = nil, description: String? = nil, displayName: String? = nil, feedbackURL: String? = nil, name: String, redirectURL: String? = nil, storageConnectors: [StorageConnector]? = nil, userSettings: [UserSetting]? = nil) {
            self.name = name
            self.storageConnectors = storageConnectors
            self.feedbackURL = feedbackURL
            self.userSettings = userSettings
            self.redirectURL = redirectURL
            self.deleteStorageConnectors = deleteStorageConnectors
            self.applicationSettings = applicationSettings
            self.displayName = displayName
            self.description = description
            self.attributesToDelete = attributesToDelete
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case storageConnectors = "StorageConnectors"
            case feedbackURL = "FeedbackURL"
            case userSettings = "UserSettings"
            case redirectURL = "RedirectURL"
            case deleteStorageConnectors = "DeleteStorageConnectors"
            case applicationSettings = "ApplicationSettings"
            case displayName = "DisplayName"
            case description = "Description"
            case attributesToDelete = "AttributesToDelete"
        }
    }

    public struct ResourceError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .enum)
        ]
        /// The time the error occurred.
        public let errorTimestamp: TimeStamp?
        /// The error message.
        public let errorMessage: String?
        /// The error code.
        public let errorCode: FleetErrorCode?

        public init(errorCode: FleetErrorCode? = nil, errorMessage: String? = nil, errorTimestamp: TimeStamp? = nil) {
            self.errorTimestamp = errorTimestamp
            self.errorMessage = errorMessage
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorTimestamp = "ErrorTimestamp"
            case errorMessage = "ErrorMessage"
            case errorCode = "ErrorCode"
        }
    }

    public struct DeleteImageBuilderResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImageBuilder", required: false, type: .structure)
        ]
        /// Information about the image builder.
        public let imageBuilder: ImageBuilder?

        public init(imageBuilder: ImageBuilder? = nil) {
            self.imageBuilder = imageBuilder
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuilder = "ImageBuilder"
        }
    }

    public struct StopImageBuilderResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImageBuilder", required: false, type: .structure)
        ]
        /// Information about the image builder.
        public let imageBuilder: ImageBuilder?

        public init(imageBuilder: ImageBuilder? = nil) {
            self.imageBuilder = imageBuilder
        }

        private enum CodingKeys: String, CodingKey {
            case imageBuilder = "ImageBuilder"
        }
    }

    public struct DescribeStacksRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The names of the stacks to describe.
        public let names: [String]?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(names: [String]? = nil, nextToken: String? = nil) {
            self.names = names
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
            case nextToken = "NextToken"
        }
    }

    public struct CreateFleetResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fleet", required: false, type: .structure)
        ]
        /// Information about the fleet.
        public let fleet: Fleet?

        public init(fleet: Fleet? = nil) {
            self.fleet = fleet
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "Fleet"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagKeys", required: true, type: .list), 
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// The tag keys for the tags to disassociate.
        public let tagKeys: [String]
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String, tagKeys: [String]) {
            self.tagKeys = tagKeys
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
            case resourceArn = "ResourceArn"
        }
    }

    public enum FleetState: String, CustomStringConvertible, Codable {
        case starting = "STARTING"
        case running = "RUNNING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public struct DeleteImagePermissionsResult: AWSShape {

        public init() {
        }

    }

    public enum StackErrorCode: String, CustomStringConvertible, Codable {
        case storageConnectorError = "STORAGE_CONNECTOR_ERROR"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        public var description: String { return self.rawValue }
    }

    public struct CreateImageBuilderStreamingURLRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Validity", required: false, type: .long), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
        public let validity: Int64?
        /// The name of the image builder.
        public let name: String

        public init(name: String, validity: Int64? = nil) {
            self.validity = validity
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case validity = "Validity"
            case name = "Name"
        }
    }

    public enum ImageStateChangeReasonCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case imageBuilderNotAvailable = "IMAGE_BUILDER_NOT_AVAILABLE"
        case imageCopyFailure = "IMAGE_COPY_FAILURE"
        public var description: String { return self.rawValue }
    }

    public struct DescribeFleetsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Fleets", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// Information about the fleets.
        public let fleets: [Fleet]?

        public init(fleets: [Fleet]? = nil, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.fleets = fleets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case fleets = "Fleets"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", required: false, type: .map)
        ]
        /// The information about the tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct DescribeUsersResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Users", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Information about users in the user pool.
        public let users: [User]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(nextToken: String? = nil, users: [User]? = nil) {
            self.users = users
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case users = "Users"
            case nextToken = "NextToken"
        }
    }

    public struct CreateImageBuilderStreamingURLResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Expires", required: false, type: .timestamp), 
            AWSShapeMember(label: "StreamingURL", required: false, type: .string)
        ]
        /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
        public let expires: TimeStamp?
        /// The URL to start the AppStream 2.0 streaming session.
        public let streamingURL: String?

        public init(expires: TimeStamp? = nil, streamingURL: String? = nil) {
            self.expires = expires
            self.streamingURL = streamingURL
        }

        private enum CodingKeys: String, CodingKey {
            case expires = "Expires"
            case streamingURL = "StreamingURL"
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arns", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The ARNs of the public, private, and shared images to describe.
        public let arns: [String]?
        /// The type of image (public, private, or shared) to describe. 
        public let `type`: VisibilityType?
        /// The maximum size of each page of results.
        public let maxResults: Int32?
        /// The names of the public or private images to describe.
        public let names: [String]?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(arns: [String]? = nil, maxResults: Int32? = nil, names: [String]? = nil, nextToken: String? = nil, type: VisibilityType? = nil) {
            self.arns = arns
            self.`type` = `type`
            self.maxResults = maxResults
            self.names = names
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case arns = "Arns"
            case `type` = "Type"
            case maxResults = "MaxResults"
            case names = "Names"
            case nextToken = "NextToken"
        }
    }

    public struct ImageStateChangeReason: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", required: false, type: .enum), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]
        /// The state change reason code.
        public let code: ImageStateChangeReasonCode?
        /// The state change reason message.
        public let message: String?

        public init(code: ImageStateChangeReasonCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct StartFleetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the fleet.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DescribeDirectoryConfigsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryNames", required: false, type: .list)
        ]
        /// The maximum size of each page of results.
        public let maxResults: Int32?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The directory names.
        public let directoryNames: [String]?

        public init(directoryNames: [String]? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.directoryNames = directoryNames
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case directoryNames = "DirectoryNames"
        }
    }

    public struct UpdateDirectoryConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DirectoryConfig", required: false, type: .structure)
        ]
        /// Information about the Directory Config object.
        public let directoryConfig: DirectoryConfig?

        public init(directoryConfig: DirectoryConfig? = nil) {
            self.directoryConfig = directoryConfig
        }

        private enum CodingKeys: String, CodingKey {
            case directoryConfig = "DirectoryConfig"
        }
    }

    public struct BatchAssociateUserStackRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserStackAssociations", required: true, type: .list)
        ]
        /// The list of UserStackAssociation objects.
        public let userStackAssociations: [UserStackAssociation]

        public init(userStackAssociations: [UserStackAssociation]) {
            self.userStackAssociations = userStackAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case userStackAssociations = "UserStackAssociations"
        }
    }

    public struct DescribeSessionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserId", required: false, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: false, type: .enum), 
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string), 
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The user ID.
        public let userId: String?
        /// The authentication method. Specify API for a user authenticated using a streaming URL or SAML for a SAML federated user. The default is to authenticate users using a streaming URL.
        public let authenticationType: AuthenticationType?
        /// The name of the stack. This value is case-sensitive.
        public let stackName: String
        /// The name of the fleet. This value is case-sensitive.
        public let fleetName: String
        /// The size of each page of results. The default value is 20 and the maximum value is 50.
        public let limit: Int32?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(authenticationType: AuthenticationType? = nil, fleetName: String, limit: Int32? = nil, nextToken: String? = nil, stackName: String, userId: String? = nil) {
            self.userId = userId
            self.authenticationType = authenticationType
            self.stackName = stackName
            self.fleetName = fleetName
            self.limit = limit
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "UserId"
            case authenticationType = "AuthenticationType"
            case stackName = "StackName"
            case fleetName = "FleetName"
            case limit = "Limit"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeUserStackAssociationsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "UserStackAssociations", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The UserStackAssociation objects.
        public let userStackAssociations: [UserStackAssociation]?

        public init(nextToken: String? = nil, userStackAssociations: [UserStackAssociation]? = nil) {
            self.nextToken = nextToken
            self.userStackAssociations = userStackAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userStackAssociations = "UserStackAssociations"
        }
    }

    public struct EnableUserRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserName", required: true, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: true, type: .enum)
        ]
        /// The email address of the user.
        public let userName: String
        /// The authentication type for the user. You must specify USERPOOL.
        public let authenticationType: AuthenticationType

        public init(authenticationType: AuthenticationType, userName: String) {
            self.userName = userName
            self.authenticationType = authenticationType
        }

        private enum CodingKeys: String, CodingKey {
            case userName = "UserName"
            case authenticationType = "AuthenticationType"
        }
    }

    public struct DisassociateFleetResult: AWSShape {

        public init() {
        }

    }

}