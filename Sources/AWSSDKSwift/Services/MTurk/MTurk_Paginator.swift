// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import NIO

extension MTurk {

    ///   The ListAssignmentsForHIT operation retrieves completed assignments for a HIT. You can use this operation to retrieve the results for a HIT.   You can get assignments for a HIT at any time, even if the HIT is not yet Reviewable. If a HIT requested multiple assignments, and has received some results but has not yet become Reviewable, you can still retrieve the partial results with this operation.   Use the AssignmentStatus parameter to control which set of assignments for a HIT are returned. The ListAssignmentsForHIT operation can return submitted assignments awaiting approval, or it can return assignments that have already been approved or rejected. You can set AssignmentStatus=Approved,Rejected to get assignments that have already been approved and rejected together in one result set.   Only the Requester who created the HIT can retrieve the assignments for that HIT.   Results are sorted and divided into numbered pages and the operation returns a single page of results. You can use the parameters of the operation to control sorting and pagination. 
    public func listAssignmentsForHITPaginator(_ input: ListAssignmentsForHITRequest, onPage: @escaping ([Assignment], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listAssignmentsForHIT, resultKey: \ListAssignmentsForHITResponse.assignments, tokenKey: \ListAssignmentsForHITResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListBonusPayments operation retrieves the amounts of bonuses you have paid to Workers for a given HIT or assignment. 
    public func listBonusPaymentsPaginator(_ input: ListBonusPaymentsRequest, onPage: @escaping ([BonusPayment], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listBonusPayments, resultKey: \ListBonusPaymentsResponse.bonusPayments, tokenKey: \ListBonusPaymentsResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListHITs operation returns all of a Requester's HITs. The operation returns HITs of any status, except for HITs that have been deleted of with the DeleteHIT operation or that have been auto-deleted. 
    public func listHITsPaginator(_ input: ListHITsRequest, onPage: @escaping ([HIT], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listHITs, resultKey: \ListHITsResponse.hITs, tokenKey: \ListHITsResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListHITsForQualificationType operation returns the HITs that use the given Qualification type for a Qualification requirement. The operation returns HITs of any status, except for HITs that have been deleted with the DeleteHIT operation or that have been auto-deleted. 
    public func listHITsForQualificationTypePaginator(_ input: ListHITsForQualificationTypeRequest, onPage: @escaping ([HIT], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listHITsForQualificationType, resultKey: \ListHITsForQualificationTypeResponse.hITs, tokenKey: \ListHITsForQualificationTypeResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListQualificationRequests operation retrieves requests for Qualifications of a particular Qualification type. The owner of the Qualification type calls this operation to poll for pending requests, and accepts them using the AcceptQualification operation. 
    public func listQualificationRequestsPaginator(_ input: ListQualificationRequestsRequest, onPage: @escaping ([QualificationRequest], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listQualificationRequests, resultKey: \ListQualificationRequestsResponse.qualificationRequests, tokenKey: \ListQualificationRequestsResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListQualificationTypes operation returns a list of Qualification types, filtered by an optional search term. 
    public func listQualificationTypesPaginator(_ input: ListQualificationTypesRequest, onPage: @escaping ([QualificationType], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listQualificationTypes, resultKey: \ListQualificationTypesResponse.qualificationTypes, tokenKey: \ListQualificationTypesResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListReviewableHITs operation retrieves the HITs with Status equal to Reviewable or Status equal to Reviewing that belong to the Requester calling the operation. 
    public func listReviewableHITsPaginator(_ input: ListReviewableHITsRequest, onPage: @escaping ([HIT], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listReviewableHITs, resultKey: \ListReviewableHITsResponse.hITs, tokenKey: \ListReviewableHITsResponse.nextToken, onPage: onPage)
    }
    
    ///  The ListWorkersBlocks operation retrieves a list of Workers who are blocked from working on your HITs.
    public func listWorkerBlocksPaginator(_ input: ListWorkerBlocksRequest, onPage: @escaping ([WorkerBlock], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listWorkerBlocks, resultKey: \ListWorkerBlocksResponse.workerBlocks, tokenKey: \ListWorkerBlocksResponse.nextToken, onPage: onPage)
    }
    
    ///   The ListWorkersWithQualificationType operation returns all of the Workers that have been associated with a given Qualification type. 
    public func listWorkersWithQualificationTypePaginator(_ input: ListWorkersWithQualificationTypeRequest, onPage: @escaping ([Qualification], EventLoop)->EventLoopFuture<Bool>) -> EventLoopFuture<Void> {
        return client.paginate(input: input, command: listWorkersWithQualificationType, resultKey: \ListWorkersWithQualificationTypeResponse.qualifications, tokenKey: \ListWorkersWithQualificationTypeResponse.nextToken, onPage: onPage)
    }
    
}

extension MTurk.ListAssignmentsForHITRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListAssignmentsForHITRequest, token: String) {
        self.init(
            assignmentStatuses: original.assignmentStatuses, 
            hITId: original.hITId, 
            maxResults: original.maxResults, 
            nextToken: token
        )
    }
}

extension MTurk.ListBonusPaymentsRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListBonusPaymentsRequest, token: String) {
        self.init(
            assignmentId: original.assignmentId, 
            hITId: original.hITId, 
            maxResults: original.maxResults, 
            nextToken: token
        )
    }
}

extension MTurk.ListHITsRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListHITsRequest, token: String) {
        self.init(
            maxResults: original.maxResults, 
            nextToken: token
        )
    }
}

extension MTurk.ListHITsForQualificationTypeRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListHITsForQualificationTypeRequest, token: String) {
        self.init(
            maxResults: original.maxResults, 
            nextToken: token, 
            qualificationTypeId: original.qualificationTypeId
        )
    }
}

extension MTurk.ListQualificationRequestsRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListQualificationRequestsRequest, token: String) {
        self.init(
            maxResults: original.maxResults, 
            nextToken: token, 
            qualificationTypeId: original.qualificationTypeId
        )
    }
}

extension MTurk.ListQualificationTypesRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListQualificationTypesRequest, token: String) {
        self.init(
            maxResults: original.maxResults, 
            mustBeOwnedByCaller: original.mustBeOwnedByCaller, 
            mustBeRequestable: original.mustBeRequestable, 
            nextToken: token, 
            query: original.query
        )
    }
}

extension MTurk.ListReviewableHITsRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListReviewableHITsRequest, token: String) {
        self.init(
            hITTypeId: original.hITTypeId, 
            maxResults: original.maxResults, 
            nextToken: token, 
            status: original.status
        )
    }
}

extension MTurk.ListWorkerBlocksRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListWorkerBlocksRequest, token: String) {
        self.init(
            maxResults: original.maxResults, 
            nextToken: token
        )
    }
}

extension MTurk.ListWorkersWithQualificationTypeRequest: AWSPaginateStringToken {
    public init(_ original: MTurk.ListWorkersWithQualificationTypeRequest, token: String) {
        self.init(
            maxResults: original.maxResults, 
            nextToken: token, 
            qualificationTypeId: original.qualificationTypeId, 
            status: original.status
        )
    }
}


