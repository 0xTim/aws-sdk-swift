// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Ecr {

    public struct DescribeRepositoriesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable.
        public var maxResults: Int32? = nil
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public var repositoryNames: [String]? = nil
        /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes. 
        public var nextToken: String? = nil
        /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, repositoryNames: [String]? = nil, nextToken: String? = nil, registryId: String? = nil) {
            self.maxResults = maxResults
            self.repositoryNames = repositoryNames
            self.nextToken = nextToken
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let repositoryNames = dictionary["repositoryNames"] as? [String] {
                self.repositoryNames = repositoryNames
            }
            self.nextToken = dictionary["nextToken"] as? String
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct ListImagesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The nextToken value to include in a future ListImages request. When the results of a ListImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The list of image IDs for the requested repository.
        public var imageIds: [ImageIdentifier]? = nil

        public init() {}

        public init(nextToken: String? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.nextToken = nextToken
            self.imageIds = imageIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let imageIds = dictionary["imageIds"] as? [[String: Any]] {
                self.imageIds = try imageIds.map({ try ImageIdentifier(dictionary: $0) })
            }
        }
    }

    public struct AuthorizationData: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A base64-encoded string that contains authorization data for the specified Amazon ECR registry. When the string is decoded, it is presented in the format user:password for private registry authentication using docker login.
        public var authorizationToken: String? = nil
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public var expiresAt: Date? = nil
        /// The registry URL to use for this authorization token in a docker login command. The Amazon ECR registry URL format is https://aws_account_id.dkr.ecr.region.amazonaws.com. For example, https://012345678910.dkr.ecr.us-east-1.amazonaws.com.. 
        public var proxyEndpoint: String? = nil

        public init() {}

        public init(authorizationToken: String? = nil, expiresAt: Date? = nil, proxyEndpoint: String? = nil) {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
            self.proxyEndpoint = proxyEndpoint
        }

        public init(dictionary: [String: Any]) throws {
            self.authorizationToken = dictionary["authorizationToken"] as? String
            self.expiresAt = dictionary["expiresAt"] as? Date
            self.proxyEndpoint = dictionary["proxyEndpoint"] as? String
        }
    }

    public struct BatchDeleteImageResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Any failures associated with the call.
        public var failures: [ImageFailure]? = nil
        /// The image IDs of the deleted images.
        public var imageIds: [ImageIdentifier]? = nil

        public init() {}

        public init(failures: [ImageFailure]? = nil, imageIds: [ImageIdentifier]? = nil) {
            self.failures = failures
            self.imageIds = imageIds
        }

        public init(dictionary: [String: Any]) throws {
            if let failures = dictionary["failures"] as? [[String: Any]] {
                self.failures = try failures.map({ try ImageFailure(dictionary: $0) })
            }
            if let imageIds = dictionary["imageIds"] as? [[String: Any]] {
                self.imageIds = try imageIds.map({ try ImageIdentifier(dictionary: $0) })
            }
        }
    }

    public struct DescribeImagesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// A list of ImageDetail objects that contain data about the image.
        public var imageDetails: [ImageDetail]? = nil

        public init() {}

        public init(nextToken: String? = nil, imageDetails: [ImageDetail]? = nil) {
            self.nextToken = nextToken
            self.imageDetails = imageDetails
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let imageDetails = dictionary["imageDetails"] as? [[String: Any]] {
                self.imageDetails = try imageDetails.map({ try ImageDetail(dictionary: $0) })
            }
        }
    }

    public struct DeleteRepositoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The repository that was deleted.
        public var repository: Repository? = nil

        public init() {}

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        public init(dictionary: [String: Any]) throws {
            if let repository = dictionary["repository"] as? [String: Any] { self.repository = try Ecr.Repository(dictionary: repository) }
        }
    }

    public struct Layer: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The size, in bytes, of the image layer.
        public var layerSize: Int64? = nil
        /// The availability status of the image layer.
        public var layerAvailability: String? = nil
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public var mediaType: String? = nil
        /// The sha256 digest of the image layer.
        public var layerDigest: String? = nil

        public init() {}

        public init(layerSize: Int64? = nil, layerAvailability: String? = nil, mediaType: String? = nil, layerDigest: String? = nil) {
            self.layerSize = layerSize
            self.layerAvailability = layerAvailability
            self.mediaType = mediaType
            self.layerDigest = layerDigest
        }

        public init(dictionary: [String: Any]) throws {
            self.layerSize = dictionary["layerSize"] as? Int64
            self.layerAvailability = dictionary["layerAvailability"] as? String
            self.mediaType = dictionary["mediaType"] as? String
            self.layerDigest = dictionary["layerDigest"] as? String
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable.
        public var maxResults: Int32? = nil
        /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// The list of image IDs for the requested repository.
        public var imageIds: [ImageIdentifier]? = nil
        /// The filter key and value with which to filter your DescribeImages results.
        public var filter: DescribeImagesFilter? = nil
        /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
        public var repositoryName: String = ""
        /// The AWS account ID associated with the registry that contains the repository in which to describe images. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil, imageIds: [ImageIdentifier]? = nil, filter: DescribeImagesFilter? = nil, repositoryName: String, registryId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.imageIds = imageIds
            self.filter = filter
            self.repositoryName = repositoryName
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
            if let imageIds = dictionary["imageIds"] as? [[String: Any]] {
                self.imageIds = try imageIds.map({ try ImageIdentifier(dictionary: $0) })
            }
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Ecr.DescribeImagesFilter(dictionary: filter) }
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct ImageIdentifier: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The tag used for the image.
        public var imageTag: String? = nil
        /// The sha256 digest of the image manifest.
        public var imageDigest: String? = nil

        public init() {}

        public init(imageTag: String? = nil, imageDigest: String? = nil) {
            self.imageTag = imageTag
            self.imageDigest = imageDigest
        }

        public init(dictionary: [String: Any]) throws {
            self.imageTag = dictionary["imageTag"] as? String
            self.imageDigest = dictionary["imageDigest"] as? String
        }
    }

    public struct DeleteRepositoryPolicyResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON repository policy that was deleted from the repository.
        public var policyText: String? = nil
        /// The registry ID associated with the request.
        public var registryId: String? = nil
        /// The repository name associated with the request.
        public var repositoryName: String? = nil

        public init() {}

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.policyText = dictionary["policyText"] as? String
            self.registryId = dictionary["registryId"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
        }
    }

    public struct LayerFailure: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The layer digest associated with the failure.
        public var layerDigest: String? = nil
        /// The failure code associated with the failure.
        public var failureCode: String? = nil
        /// The reason for the failure.
        public var failureReason: String? = nil

        public init() {}

        public init(layerDigest: String? = nil, failureCode: String? = nil, failureReason: String? = nil) {
            self.layerDigest = layerDigest
            self.failureCode = failureCode
            self.failureReason = failureReason
        }

        public init(dictionary: [String: Any]) throws {
            self.layerDigest = dictionary["layerDigest"] as? String
            self.failureCode = dictionary["failureCode"] as? String
            self.failureReason = dictionary["failureReason"] as? String
        }
    }

    public struct ImageFailure: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The image ID associated with the failure.
        public var imageId: ImageIdentifier? = nil
        /// The code associated with the failure.
        public var failureCode: String? = nil
        /// The reason for the failure.
        public var failureReason: String? = nil

        public init() {}

        public init(imageId: ImageIdentifier? = nil, failureCode: String? = nil, failureReason: String? = nil) {
            self.imageId = imageId
            self.failureCode = failureCode
            self.failureReason = failureReason
        }

        public init(dictionary: [String: Any]) throws {
            if let imageId = dictionary["imageId"] as? [String: Any] { self.imageId = try Ecr.ImageIdentifier(dictionary: imageId) }
            self.failureCode = dictionary["failureCode"] as? String
            self.failureReason = dictionary["failureReason"] as? String
        }
    }

    public struct BatchGetImageResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Any failures associated with the call.
        public var failures: [ImageFailure]? = nil
        /// A list of image objects corresponding to the image references in the request.
        public var images: [Image]? = nil

        public init() {}

        public init(failures: [ImageFailure]? = nil, images: [Image]? = nil) {
            self.failures = failures
            self.images = images
        }

        public init(dictionary: [String: Any]) throws {
            if let failures = dictionary["failures"] as? [[String: Any]] {
                self.failures = try failures.map({ try ImageFailure(dictionary: $0) })
            }
            if let images = dictionary["images"] as? [[String: Any]] {
                self.images = try images.map({ try Image(dictionary: $0) })
            }
        }
    }

    public struct SetRepositoryPolicyResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON repository policy text applied to the repository.
        public var policyText: String? = nil
        /// The registry ID associated with the request.
        public var registryId: String? = nil
        /// The repository name associated with the request.
        public var repositoryName: String? = nil

        public init() {}

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.policyText = dictionary["policyText"] as? String
            self.registryId = dictionary["registryId"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
        }
    }

    public struct GetAuthorizationTokenRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of AWS account IDs that are associated with the registries for which to get authorization tokens. If you do not specify a registry, the default registry is assumed.
        public var registryIds: [String]? = nil

        public init() {}

        public init(registryIds: [String]? = nil) {
            self.registryIds = registryIds
        }

        public init(dictionary: [String: Any]) throws {
            if let registryIds = dictionary["registryIds"] as? [String] {
                self.registryIds = registryIds
            }
        }
    }

    public struct ImageDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The size, in bytes, of the image in the repository.  Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by DescribeImages. 
        public var imageSizeInBytes: Int64? = nil
        /// The name of the repository to which this image belongs.
        public var repositoryName: String? = nil
        /// The sha256 digest of the image manifest.
        public var imageDigest: String? = nil
        /// The list of tags associated with this image.
        public var imageTags: [String]? = nil
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository. 
        public var imagePushedAt: Date? = nil
        /// The AWS account ID associated with the registry to which this image belongs.
        public var registryId: String? = nil

        public init() {}

        public init(imageSizeInBytes: Int64? = nil, repositoryName: String? = nil, imageDigest: String? = nil, imageTags: [String]? = nil, imagePushedAt: Date? = nil, registryId: String? = nil) {
            self.imageSizeInBytes = imageSizeInBytes
            self.repositoryName = repositoryName
            self.imageDigest = imageDigest
            self.imageTags = imageTags
            self.imagePushedAt = imagePushedAt
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageSizeInBytes = dictionary["imageSizeInBytes"] as? Int64
            self.repositoryName = dictionary["repositoryName"] as? String
            self.imageDigest = dictionary["imageDigest"] as? String
            if let imageTags = dictionary["imageTags"] as? [String] {
                self.imageTags = imageTags
            }
            self.imagePushedAt = dictionary["imagePushedAt"] as? Date
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct GetAuthorizationTokenResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of authorization token data objects that correspond to the registryIds values in the request.
        public var authorizationData: [AuthorizationData]? = nil

        public init() {}

        public init(authorizationData: [AuthorizationData]? = nil) {
            self.authorizationData = authorizationData
        }

        public init(dictionary: [String: Any]) throws {
            if let authorizationData = dictionary["authorizationData"] as? [[String: Any]] {
                self.authorizationData = try authorizationData.map({ try AuthorizationData(dictionary: $0) })
            }
        }
    }

    public struct InitiateLayerUploadResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload operations.
        public var uploadId: String? = nil
        /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
        public var partSize: Int64? = nil

        public init() {}

        public init(uploadId: String? = nil, partSize: Int64? = nil) {
            self.uploadId = uploadId
            self.partSize = partSize
        }

        public init(dictionary: [String: Any]) throws {
            self.uploadId = dictionary["uploadId"] as? String
            self.partSize = dictionary["partSize"] as? Int64
        }
    }

    public struct BatchGetImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The accepted media types for the request. Valid values: application/vnd.docker.distribution.manifest.v1+json | application/vnd.docker.distribution.manifest.v2+json | application/vnd.oci.image.manifest.v1+json 
        public var acceptedMediaTypes: [String]? = nil
        /// A list of image ID references that correspond to images to describe. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public var imageIds: [ImageIdentifier] = []
        /// The repository that contains the images to describe.
        public var repositoryName: String = ""
        /// The AWS account ID associated with the registry that contains the images to describe. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil

        public init() {}

        public init(acceptedMediaTypes: [String]? = nil, imageIds: [ImageIdentifier], repositoryName: String, registryId: String? = nil) {
            self.acceptedMediaTypes = acceptedMediaTypes
            self.imageIds = imageIds
            self.repositoryName = repositoryName
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            if let acceptedMediaTypes = dictionary["acceptedMediaTypes"] as? [String] {
                self.acceptedMediaTypes = acceptedMediaTypes
            }
            guard let imageIds = dictionary["imageIds"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("imageIds") }
            self.imageIds = try imageIds.map({ try ImageIdentifier(dictionary: $0) })
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct DeleteRepositoryPolicyRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID associated with the registry that contains the repository policy to delete. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The name of the repository that is associated with the repository policy to delete.
        public var repositoryName: String = ""

        public init() {}

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.registryId = dictionary["registryId"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct GetDownloadUrlForLayerResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The digest of the image layer to download.
        public var layerDigest: String? = nil
        /// The pre-signed Amazon S3 download URL for the requested layer.
        public var downloadUrl: String? = nil

        public init() {}

        public init(layerDigest: String? = nil, downloadUrl: String? = nil) {
            self.layerDigest = layerDigest
            self.downloadUrl = downloadUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.layerDigest = dictionary["layerDigest"] as? String
            self.downloadUrl = dictionary["downloadUrl"] as? String
        }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The image manifest associated with the image.
        public var imageManifest: String? = nil
        /// An object containing the image tag and image digest associated with an image.
        public var imageId: ImageIdentifier? = nil
        /// The name of the repository associated with the image.
        public var repositoryName: String? = nil
        /// The AWS account ID associated with the registry containing the image.
        public var registryId: String? = nil

        public init() {}

        public init(imageManifest: String? = nil, imageId: ImageIdentifier? = nil, repositoryName: String? = nil, registryId: String? = nil) {
            self.imageManifest = imageManifest
            self.imageId = imageId
            self.repositoryName = repositoryName
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageManifest = dictionary["imageManifest"] as? String
            if let imageId = dictionary["imageId"] as? [String: Any] { self.imageId = try Ecr.ImageIdentifier(dictionary: imageId) }
            self.repositoryName = dictionary["repositoryName"] as? String
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct CreateRepositoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name to use for the repository. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app).
        public var repositoryName: String = ""

        public init() {}

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct GetRepositoryPolicyResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON repository policy text associated with the repository.
        public var policyText: String? = nil
        /// The registry ID associated with the request.
        public var registryId: String? = nil
        /// The repository name associated with the request.
        public var repositoryName: String? = nil

        public init() {}

        public init(policyText: String? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.policyText = policyText
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.policyText = dictionary["policyText"] as? String
            self.registryId = dictionary["registryId"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
        }
    }

    public struct GetDownloadUrlForLayerRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The digest of the image layer to download.
        public var layerDigest: String = ""
        /// The AWS account ID associated with the registry that contains the image layer to download. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The name of the repository that is associated with the image layer to download.
        public var repositoryName: String = ""

        public init() {}

        public init(layerDigest: String, registryId: String? = nil, repositoryName: String) {
            self.layerDigest = layerDigest
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerDigest = dictionary["layerDigest"] as? String else { throw InitializableError.missingRequiredParam("layerDigest") }
            self.layerDigest = layerDigest
            self.registryId = dictionary["registryId"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct ListImagesFilter: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The tag status with which to filter your ListImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public var tagStatus: String? = nil

        public init() {}

        public init(tagStatus: String? = nil) {
            self.tagStatus = tagStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.tagStatus = dictionary["tagStatus"] as? String
        }
    }

    public struct SetRepositoryPolicyRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental repository lock outs.
        public var force: Bool? = nil
        /// The JSON repository policy text to apply to the repository.
        public var policyText: String = ""
        /// The name of the repository to receive the policy.
        public var repositoryName: String = ""
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil

        public init() {}

        public init(force: Bool? = nil, policyText: String, repositoryName: String, registryId: String? = nil) {
            self.force = force
            self.policyText = policyText
            self.repositoryName = repositoryName
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            self.force = dictionary["force"] as? Bool
            guard let policyText = dictionary["policyText"] as? String else { throw InitializableError.missingRequiredParam("policyText") }
            self.policyText = policyText
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct CreateRepositoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The repository that was created.
        public var repository: Repository? = nil

        public init() {}

        public init(repository: Repository? = nil) {
            self.repository = repository
        }

        public init(dictionary: [String: Any]) throws {
            if let repository = dictionary["repository"] as? [String: Any] { self.repository = try Ecr.Repository(dictionary: repository) }
        }
    }

    public struct BatchCheckLayerAvailabilityRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The digests of the image layers to check.
        public var layerDigests: [String] = []
        /// The AWS account ID associated with the registry that contains the image layers to check. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The name of the repository that is associated with the image layers to check.
        public var repositoryName: String = ""

        public init() {}

        public init(layerDigests: [String], registryId: String? = nil, repositoryName: String) {
            self.layerDigests = layerDigests
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            guard let layerDigests = dictionary["layerDigests"] as? [String] else { throw InitializableError.missingRequiredParam("layerDigests") }
            self.layerDigests = layerDigests
            self.registryId = dictionary["registryId"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct GetRepositoryPolicyRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The name of the repository whose policy you want to retrieve.
        public var repositoryName: String = ""

        public init() {}

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.registryId = dictionary["registryId"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct UploadLayerPartResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upload ID associated with the request.
        public var uploadId: String? = nil
        /// The repository name associated with the request.
        public var repositoryName: String? = nil
        /// The registry ID associated with the request.
        public var registryId: String? = nil
        /// The integer value of the last byte received in the request.
        public var lastByteReceived: Int64? = nil

        public init() {}

        public init(uploadId: String? = nil, repositoryName: String? = nil, registryId: String? = nil, lastByteReceived: Int64? = nil) {
            self.uploadId = uploadId
            self.repositoryName = repositoryName
            self.registryId = registryId
            self.lastByteReceived = lastByteReceived
        }

        public init(dictionary: [String: Any]) throws {
            self.uploadId = dictionary["uploadId"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
            self.registryId = dictionary["registryId"] as? String
            self.lastByteReceived = dictionary["lastByteReceived"] as? Int64
        }
    }

    public struct BatchCheckLayerAvailabilityResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Any failures associated with the call.
        public var failures: [LayerFailure]? = nil
        /// A list of image layer objects corresponding to the image layer references in the request.
        public var layers: [Layer]? = nil

        public init() {}

        public init(failures: [LayerFailure]? = nil, layers: [Layer]? = nil) {
            self.failures = failures
            self.layers = layers
        }

        public init(dictionary: [String: Any]) throws {
            if let failures = dictionary["failures"] as? [[String: Any]] {
                self.failures = try failures.map({ try LayerFailure(dictionary: $0) })
            }
            if let layers = dictionary["layers"] as? [[String: Any]] {
                self.layers = try layers.map({ try Layer(dictionary: $0) })
            }
        }
    }

    public struct PutImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or OCI formats.
        public var imageTag: String? = nil
        /// The image manifest corresponding to the image to be uploaded.
        public var imageManifest: String = ""
        /// The name of the repository in which to put the image.
        public var repositoryName: String = ""
        /// The AWS account ID associated with the registry that contains the repository in which to put the image. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil

        public init() {}

        public init(imageTag: String? = nil, imageManifest: String, repositoryName: String, registryId: String? = nil) {
            self.imageTag = imageTag
            self.imageManifest = imageManifest
            self.repositoryName = repositoryName
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            self.imageTag = dictionary["imageTag"] as? String
            guard let imageManifest = dictionary["imageManifest"] as? String else { throw InitializableError.missingRequiredParam("imageManifest") }
            self.imageManifest = imageManifest
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.registryId = dictionary["registryId"] as? String
        }
    }

    public struct DescribeRepositoriesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of repository objects corresponding to valid repositories.
        public var repositories: [Repository]? = nil
        /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil

        public init() {}

        public init(repositories: [Repository]? = nil, nextToken: String? = nil) {
            self.repositories = repositories
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let repositories = dictionary["repositories"] as? [[String: Any]] {
                self.repositories = try repositories.map({ try Repository(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct InitiateLayerUploadRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID associated with the registry that you intend to upload layers to. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The name of the repository that you intend to upload layers to.
        public var repositoryName: String = ""

        public init() {}

        public init(registryId: String? = nil, repositoryName: String) {
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.registryId = dictionary["registryId"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct DeleteRepositoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Force the deletion of the repository if it contains images.
        public var force: Bool? = nil
        /// The AWS account ID associated with the registry that contains the repository to delete. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The name of the repository to delete.
        public var repositoryName: String = ""

        public init() {}

        public init(force: Bool? = nil, registryId: String? = nil, repositoryName: String) {
            self.force = force
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.force = dictionary["force"] as? Bool
            self.registryId = dictionary["registryId"] as? String
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct PutImageResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Details of the image uploaded.
        public var image: Image? = nil

        public init() {}

        public init(image: Image? = nil) {
            self.image = image
        }

        public init(dictionary: [String: Any]) throws {
            if let image = dictionary["image"] as? [String: Any] { self.image = try Ecr.Image(dictionary: image) }
        }
    }

    public struct Repository: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the repository.
        public var repositoryName: String? = nil
        /// The URI for the repository. You can use this URI for Docker push and pull operations.
        public var repositoryUri: String? = nil
        /// The AWS account ID associated with the registry that contains the repository.
        public var registryId: String? = nil
        /// The date and time, in JavaScript date/time format, when the repository was created.
        public var createdAt: Date? = nil
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, the AWS account ID of the repository owner, the repository namespace, and then the repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public var repositoryArn: String? = nil

        public init() {}

        public init(repositoryName: String? = nil, repositoryUri: String? = nil, registryId: String? = nil, createdAt: Date? = nil, repositoryArn: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
            self.registryId = registryId
            self.createdAt = createdAt
            self.repositoryArn = repositoryArn
        }

        public init(dictionary: [String: Any]) throws {
            self.repositoryName = dictionary["repositoryName"] as? String
            self.repositoryUri = dictionary["repositoryUri"] as? String
            self.registryId = dictionary["registryId"] as? String
            self.createdAt = dictionary["createdAt"] as? Date
            self.repositoryArn = dictionary["repositoryArn"] as? String
        }
    }

    public struct BatchDeleteImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The AWS account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
        public var imageIds: [ImageIdentifier] = []
        /// The repository that contains the image to delete.
        public var repositoryName: String = ""

        public init() {}

        public init(registryId: String? = nil, imageIds: [ImageIdentifier], repositoryName: String) {
            self.registryId = registryId
            self.imageIds = imageIds
            self.repositoryName = repositoryName
        }

        public init(dictionary: [String: Any]) throws {
            self.registryId = dictionary["registryId"] as? String
            guard let imageIds = dictionary["imageIds"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("imageIds") }
            self.imageIds = try imageIds.map({ try ImageIdentifier(dictionary: $0) })
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
        }
    }

    public struct CompleteLayerUploadResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upload ID associated with the layer.
        public var uploadId: String? = nil
        /// The repository name associated with the request.
        public var repositoryName: String? = nil
        /// The registry ID associated with the request.
        public var registryId: String? = nil
        /// The sha256 digest of the image layer.
        public var layerDigest: String? = nil

        public init() {}

        public init(uploadId: String? = nil, repositoryName: String? = nil, registryId: String? = nil, layerDigest: String? = nil) {
            self.uploadId = uploadId
            self.repositoryName = repositoryName
            self.registryId = registryId
            self.layerDigest = layerDigest
        }

        public init(dictionary: [String: Any]) throws {
            self.uploadId = dictionary["uploadId"] as? String
            self.repositoryName = dictionary["repositoryName"] as? String
            self.registryId = dictionary["registryId"] as? String
            self.layerDigest = dictionary["layerDigest"] as? String
        }
    }

    public struct UploadLayerPartRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the layer part upload.
        public var uploadId: String = ""
        /// The base64-encoded layer part payload.
        public var layerPartBlob: Data = Data()
        /// The name of the repository that you are uploading layer parts to.
        public var repositoryName: String = ""
        /// The integer value of the last byte of the layer part.
        public var partLastByte: Int64 = 0
        /// The AWS account ID associated with the registry that you are uploading layer parts to. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The integer value of the first byte of the layer part.
        public var partFirstByte: Int64 = 0

        public init() {}

        public init(uploadId: String, layerPartBlob: Data, repositoryName: String, partLastByte: Int64, registryId: String? = nil, partFirstByte: Int64) {
            self.uploadId = uploadId
            self.layerPartBlob = layerPartBlob
            self.repositoryName = repositoryName
            self.partLastByte = partLastByte
            self.registryId = registryId
            self.partFirstByte = partFirstByte
        }

        public init(dictionary: [String: Any]) throws {
            guard let uploadId = dictionary["uploadId"] as? String else { throw InitializableError.missingRequiredParam("uploadId") }
            self.uploadId = uploadId
            guard let layerPartBlob = dictionary["layerPartBlob"] as? Data else { throw InitializableError.missingRequiredParam("layerPartBlob") }
            self.layerPartBlob = layerPartBlob
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            guard let partLastByte = dictionary["partLastByte"] as? Int64 else { throw InitializableError.missingRequiredParam("partLastByte") }
            self.partLastByte = partLastByte
            self.registryId = dictionary["registryId"] as? String
            guard let partFirstByte = dictionary["partFirstByte"] as? Int64 else { throw InitializableError.missingRequiredParam("partFirstByte") }
            self.partFirstByte = partFirstByte
        }
    }

    public struct CompleteLayerUploadRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The upload ID from a previous InitiateLayerUpload operation to associate with the image layer.
        public var uploadId: String = ""
        /// The name of the repository to associate with the image layer.
        public var repositoryName: String = ""
        /// The AWS account ID associated with the registry to which to upload layers. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil
        /// The sha256 digest of the image layer.
        public var layerDigests: [String] = []

        public init() {}

        public init(uploadId: String, repositoryName: String, registryId: String? = nil, layerDigests: [String]) {
            self.uploadId = uploadId
            self.repositoryName = repositoryName
            self.registryId = registryId
            self.layerDigests = layerDigests
        }

        public init(dictionary: [String: Any]) throws {
            guard let uploadId = dictionary["uploadId"] as? String else { throw InitializableError.missingRequiredParam("uploadId") }
            self.uploadId = uploadId
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.registryId = dictionary["registryId"] as? String
            guard let layerDigests = dictionary["layerDigests"] as? [String] else { throw InitializableError.missingRequiredParam("layerDigests") }
            self.layerDigests = layerDigests
        }
    }

    public struct DescribeImagesFilter: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The tag status with which to filter your DescribeImages results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public var tagStatus: String? = nil

        public init() {}

        public init(tagStatus: String? = nil) {
            self.tagStatus = tagStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.tagStatus = dictionary["tagStatus"] as? String
        }
    }

    public struct ListImagesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The filter key and value with which to filter your ListImages results.
        public var filter: ListImagesFilter? = nil
        /// The nextToken value returned from a previous paginated ListImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.  This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes. 
        public var nextToken: String? = nil
        /// The maximum number of image results returned by ListImages in paginated output. When this parameter is used, ListImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListImages request with the returned nextToken value. This value can be between 1 and 100. If this parameter is not used, then ListImages returns up to 100 results and a nextToken value, if applicable.
        public var maxResults: Int32? = nil
        /// The repository whose image IDs are to be listed.
        public var repositoryName: String = ""
        /// The AWS account ID associated with the registry that contains the repository to list images in. If you do not specify a registry, the default registry is assumed.
        public var registryId: String? = nil

        public init() {}

        public init(filter: ListImagesFilter? = nil, nextToken: String? = nil, maxResults: Int32? = nil, repositoryName: String, registryId: String? = nil) {
            self.filter = filter
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.repositoryName = repositoryName
            self.registryId = registryId
        }

        public init(dictionary: [String: Any]) throws {
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Ecr.ListImagesFilter(dictionary: filter) }
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
            guard let repositoryName = dictionary["repositoryName"] as? String else { throw InitializableError.missingRequiredParam("repositoryName") }
            self.repositoryName = repositoryName
            self.registryId = dictionary["registryId"] as? String
        }
    }

}