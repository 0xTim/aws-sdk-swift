// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Iot {

    public struct DynamoDBv2Action: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "putItem", required: false, type: .structure)
        ]
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        public let roleArn: String?
        /// Specifies the DynamoDB table to which the message data will be written. For example:  { "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }  Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        public let putItem: PutItemInput?

        public init(roleArn: String? = nil, putItem: PutItemInput? = nil) {
            self.roleArn = roleArn
            self.putItem = putItem
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case putItem = "putItem"
        }
    }

    public struct CreatePolicyResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyVersionId", required: false, type: .string), 
            AWSShapeMember(label: "policyName", required: false, type: .string), 
            AWSShapeMember(label: "policyArn", required: false, type: .string), 
            AWSShapeMember(label: "policyDocument", required: false, type: .string)
        ]
        /// The policy version ID.
        public let policyVersionId: String?
        /// The policy name.
        public let policyName: String?
        /// The policy ARN.
        public let policyArn: String?
        /// The JSON document that describes the policy.
        public let policyDocument: String?

        public init(policyVersionId: String? = nil, policyName: String? = nil, policyArn: String? = nil, policyDocument: String? = nil) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
            self.policyArn = policyArn
            self.policyDocument = policyDocument
        }

        private enum CodingKeys: String, CodingKey {
            case policyVersionId = "policyVersionId"
            case policyName = "policyName"
            case policyArn = "policyArn"
            case policyDocument = "policyDocument"
        }
    }

    public struct TransferCertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string), 
            AWSShapeMember(label: "transferMessage", required: false, type: .string), 
            AWSShapeMember(label: "targetAwsAccount", location: .querystring(locationName: "targetAwsAccount"), required: true, type: .string)
        ]
        /// The ID of the certificate.
        public let certificateId: String
        /// The transfer message.
        public let transferMessage: String?
        /// The AWS account.
        public let targetAwsAccount: String

        public init(certificateId: String, transferMessage: String? = nil, targetAwsAccount: String) {
            self.certificateId = certificateId
            self.transferMessage = transferMessage
            self.targetAwsAccount = targetAwsAccount
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case transferMessage = "transferMessage"
            case targetAwsAccount = "targetAwsAccount"
        }
    }

    public struct GetRegistrationCodeRequest: AWSShape {
        /// The key for the payload

    }

    public struct ListCertificatesByCARequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "caCertificateId", location: .uri(locationName: "caCertificateId"), required: true, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean)
        ]
        /// The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.
        public let caCertificateId: String
        /// The result page size.
        public let pageSize: Int32?
        /// The marker for the next set of results.
        public let marker: String?
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public let ascendingOrder: Bool?

        public init(caCertificateId: String, pageSize: Int32? = nil, marker: String? = nil, ascendingOrder: Bool? = nil) {
            self.caCertificateId = caCertificateId
            self.pageSize = pageSize
            self.marker = marker
            self.ascendingOrder = ascendingOrder
        }

        private enum CodingKeys: String, CodingKey {
            case caCertificateId = "caCertificateId"
            case pageSize = "pageSize"
            case marker = "marker"
            case ascendingOrder = "isAscendingOrder"
        }
    }

    public struct Policy: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyArn", required: false, type: .string), 
            AWSShapeMember(label: "policyName", required: false, type: .string)
        ]
        /// The policy ARN.
        public let policyArn: String?
        /// The policy name.
        public let policyName: String?

        public init(policyArn: String? = nil, policyName: String? = nil) {
            self.policyArn = policyArn
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyArn = "policyArn"
            case policyName = "policyName"
        }
    }

    public struct SetLoggingOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "loggingOptionsPayload"
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "loggingOptionsPayload", required: true, type: .structure)
        ]
        /// The logging options payload.
        public let loggingOptionsPayload: LoggingOptionsPayload

        public init(loggingOptionsPayload: LoggingOptionsPayload) {
            self.loggingOptionsPayload = loggingOptionsPayload
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptionsPayload = "loggingOptionsPayload"
        }
    }

    public struct ListThingTypesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypes", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The thing types.
        public let thingTypes: [ThingTypeDefinition]?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(thingTypes: [ThingTypeDefinition]? = nil, nextToken: String? = nil) {
            self.thingTypes = thingTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypes = "thingTypes"
            case nextToken = "nextToken"
        }
    }

    public struct Action: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "elasticsearch", required: false, type: .structure), 
            AWSShapeMember(label: "s3", required: false, type: .structure), 
            AWSShapeMember(label: "lambda", required: false, type: .structure), 
            AWSShapeMember(label: "republish", required: false, type: .structure), 
            AWSShapeMember(label: "dynamoDB", required: false, type: .structure), 
            AWSShapeMember(label: "salesforce", required: false, type: .structure), 
            AWSShapeMember(label: "sqs", required: false, type: .structure), 
            AWSShapeMember(label: "sns", required: false, type: .structure), 
            AWSShapeMember(label: "cloudwatchMetric", required: false, type: .structure), 
            AWSShapeMember(label: "cloudwatchAlarm", required: false, type: .structure), 
            AWSShapeMember(label: "firehose", required: false, type: .structure), 
            AWSShapeMember(label: "dynamoDBv2", required: false, type: .structure), 
            AWSShapeMember(label: "kinesis", required: false, type: .structure)
        ]
        /// Write data to an Amazon Elasticsearch Service domain.
        public let elasticsearch: ElasticsearchAction?
        /// Write to an Amazon S3 bucket.
        public let s3: S3Action?
        /// Invoke a Lambda function.
        public let lambda: LambdaAction?
        /// Publish to another MQTT topic.
        public let republish: RepublishAction?
        /// Write to a DynamoDB table.
        public let dynamoDB: DynamoDBAction?
        /// Send a message to a Salesforce IoT Cloud Input Stream.
        public let salesforce: SalesforceAction?
        /// Publish to an Amazon SQS queue.
        public let sqs: SqsAction?
        /// Publish to an Amazon SNS topic.
        public let sns: SnsAction?
        /// Capture a CloudWatch metric.
        public let cloudwatchMetric: CloudwatchMetricAction?
        /// Change the state of a CloudWatch alarm.
        public let cloudwatchAlarm: CloudwatchAlarmAction?
        /// Write to an Amazon Kinesis Firehose stream.
        public let firehose: FirehoseAction?
        /// Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        public let dynamoDBv2: DynamoDBv2Action?
        /// Write data to an Amazon Kinesis stream.
        public let kinesis: KinesisAction?

        public init(elasticsearch: ElasticsearchAction? = nil, s3: S3Action? = nil, lambda: LambdaAction? = nil, republish: RepublishAction? = nil, dynamoDB: DynamoDBAction? = nil, salesforce: SalesforceAction? = nil, sqs: SqsAction? = nil, sns: SnsAction? = nil, cloudwatchMetric: CloudwatchMetricAction? = nil, cloudwatchAlarm: CloudwatchAlarmAction? = nil, firehose: FirehoseAction? = nil, dynamoDBv2: DynamoDBv2Action? = nil, kinesis: KinesisAction? = nil) {
            self.elasticsearch = elasticsearch
            self.s3 = s3
            self.lambda = lambda
            self.republish = republish
            self.dynamoDB = dynamoDB
            self.salesforce = salesforce
            self.sqs = sqs
            self.sns = sns
            self.cloudwatchMetric = cloudwatchMetric
            self.cloudwatchAlarm = cloudwatchAlarm
            self.firehose = firehose
            self.dynamoDBv2 = dynamoDBv2
            self.kinesis = kinesis
        }

        private enum CodingKeys: String, CodingKey {
            case elasticsearch = "elasticsearch"
            case s3 = "s3"
            case lambda = "lambda"
            case republish = "republish"
            case dynamoDB = "dynamoDB"
            case salesforce = "salesforce"
            case sqs = "sqs"
            case sns = "sns"
            case cloudwatchMetric = "cloudwatchMetric"
            case cloudwatchAlarm = "cloudwatchAlarm"
            case firehose = "firehose"
            case dynamoDBv2 = "dynamoDBv2"
            case kinesis = "kinesis"
        }
    }

    public struct DescribeCACertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateDescription", required: false, type: .structure)
        ]
        /// The CA certificate description.
        public let certificateDescription: CACertificateDescription?

        public init(certificateDescription: CACertificateDescription? = nil) {
            self.certificateDescription = certificateDescription
        }

        private enum CodingKeys: String, CodingKey {
            case certificateDescription = "certificateDescription"
        }
    }

    public struct RepublishAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "topic", required: true, type: .string)
        ]
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The name of the MQTT topic.
        public let topic: String

        public init(roleArn: String, topic: String) {
            self.roleArn = roleArn
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case topic = "topic"
        }
    }

    public struct GetTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleName", location: .uri(locationName: "ruleName"), required: true, type: .string)
        ]
        /// The name of the rule.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "ruleName"
        }
    }

    public struct ListPolicyPrincipalsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "principals", required: false, type: .list), 
            AWSShapeMember(label: "nextMarker", required: false, type: .string)
        ]
        /// The descriptions of the principals.
        public let principals: [String]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(principals: [String]? = nil, nextMarker: String? = nil) {
            self.principals = principals
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case principals = "principals"
            case nextMarker = "nextMarker"
        }
    }

    public struct ListCertificatesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificates", required: false, type: .list), 
            AWSShapeMember(label: "nextMarker", required: false, type: .string)
        ]
        /// The descriptions of the certificates.
        public let certificates: [Certificate]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(certificates: [Certificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "certificates"
            case nextMarker = "nextMarker"
        }
    }

    public struct RegisterCACertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "allowAutoRegistration", location: .querystring(locationName: "allowAutoRegistration"), required: false, type: .boolean), 
            AWSShapeMember(label: "verificationCertificate", required: true, type: .string), 
            AWSShapeMember(label: "caCertificate", required: true, type: .string), 
            AWSShapeMember(label: "setAsActive", location: .querystring(locationName: "setAsActive"), required: false, type: .boolean)
        ]
        /// Allows this CA certificate to be used for auto registration of device certificates.
        public let allowAutoRegistration: Bool?
        /// The private key verification certificate.
        public let verificationCertificate: String
        /// The CA certificate.
        public let caCertificate: String
        /// A boolean value that specifies if the CA certificate is set to active.
        public let setAsActive: Bool?

        public init(allowAutoRegistration: Bool? = nil, verificationCertificate: String, caCertificate: String, setAsActive: Bool? = nil) {
            self.allowAutoRegistration = allowAutoRegistration
            self.verificationCertificate = verificationCertificate
            self.caCertificate = caCertificate
            self.setAsActive = setAsActive
        }

        private enum CodingKeys: String, CodingKey {
            case allowAutoRegistration = "allowAutoRegistration"
            case verificationCertificate = "verificationCertificate"
            case caCertificate = "caCertificate"
            case setAsActive = "setAsActive"
        }
    }

    public struct DetachThingPrincipalRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string), 
            AWSShapeMember(label: "principal", location: .header(locationName: "x-amzn-principal"), required: true, type: .string)
        ]
        /// The name of the thing.
        public let thingName: String
        /// If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
        public let principal: String

        public init(thingName: String, principal: String) {
            self.thingName = thingName
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case thingName = "thingName"
            case principal = "x-amzn-principal"
        }
    }

    public struct CreateThingResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingName", required: false, type: .string), 
            AWSShapeMember(label: "thingArn", required: false, type: .string)
        ]
        /// The name of the new thing.
        public let thingName: String?
        /// The ARN of the new thing.
        public let thingArn: String?

        public init(thingName: String? = nil, thingArn: String? = nil) {
            self.thingName = thingName
            self.thingArn = thingArn
        }

        private enum CodingKeys: String, CodingKey {
            case thingName = "thingName"
            case thingArn = "thingArn"
        }
    }

    public enum CACertificateStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct ListPrincipalThingsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "things", required: false, type: .list)
        ]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The things.
        public let things: [String]?

        public init(nextToken: String? = nil, things: [String]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case things = "things"
        }
    }

    public struct LoggingOptionsPayload: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "logLevel", required: false, type: .enum)
        ]
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The logging level.
        public let logLevel: LogLevel?

        public init(roleArn: String, logLevel: LogLevel? = nil) {
            self.roleArn = roleArn
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case logLevel = "logLevel"
        }
    }

    public struct ListThingsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "attributeValue", location: .querystring(locationName: "attributeValue"), required: false, type: .string), 
            AWSShapeMember(label: "thingTypeName", location: .querystring(locationName: "thingTypeName"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "attributeName", location: .querystring(locationName: "attributeName"), required: false, type: .string)
        ]
        /// The attribute value used to search for things.
        public let attributeValue: String?
        /// The name of the thing type used to search for things.
        public let thingTypeName: String?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The maximum number of results to return in this operation.
        public let maxResults: Int32?
        /// The attribute name used to search for things.
        public let attributeName: String?

        public init(attributeValue: String? = nil, thingTypeName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil, attributeName: String? = nil) {
            self.attributeValue = attributeValue
            self.thingTypeName = thingTypeName
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.attributeName = attributeName
        }

        private enum CodingKeys: String, CodingKey {
            case attributeValue = "attributeValue"
            case thingTypeName = "thingTypeName"
            case nextToken = "nextToken"
            case maxResults = "maxResults"
            case attributeName = "attributeName"
        }
    }

    public struct ThingTypeDefinition: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "thingTypeProperties", required: false, type: .structure)
        ]
        /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.
        public let thingTypeMetadata: ThingTypeMetadata?
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The ThingTypeProperties for the thing type.
        public let thingTypeProperties: ThingTypeProperties?

        public init(thingTypeMetadata: ThingTypeMetadata? = nil, thingTypeName: String? = nil, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeMetadata = "thingTypeMetadata"
            case thingTypeName = "thingTypeName"
            case thingTypeProperties = "thingTypeProperties"
        }
    }

    public struct CreateKeysAndCertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "keyPair", required: false, type: .structure), 
            AWSShapeMember(label: "certificatePem", required: false, type: .string), 
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string)
        ]
        /// The generated key pair.
        public let keyPair: KeyPair?
        /// The certificate data, in PEM format.
        public let certificatePem: String?
        /// The ID of the certificate. AWS IoT issues a default subject name for the certificate (for example, AWS IoT Certificate).
        public let certificateId: String?
        /// The ARN of the certificate.
        public let certificateArn: String?

        public init(keyPair: KeyPair? = nil, certificatePem: String? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.keyPair = keyPair
            self.certificatePem = certificatePem
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case keyPair = "keyPair"
            case certificatePem = "certificatePem"
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
        }
    }

    public struct GetTopicRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleArn", required: false, type: .string), 
            AWSShapeMember(label: "rule", required: false, type: .structure)
        ]
        /// The rule ARN.
        public let ruleArn: String?
        /// The rule.
        public let rule: TopicRule?

        public init(ruleArn: String? = nil, rule: TopicRule? = nil) {
            self.ruleArn = ruleArn
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "ruleArn"
            case rule = "rule"
        }
    }

    public struct CreateThingTypeRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", location: .uri(locationName: "thingTypeName"), required: true, type: .string), 
            AWSShapeMember(label: "thingTypeProperties", required: false, type: .structure)
        ]
        /// The name of the thing type.
        public let thingTypeName: String
        /// The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.
        public let thingTypeProperties: ThingTypeProperties?

        public init(thingTypeName: String, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
            case thingTypeProperties = "thingTypeProperties"
        }
    }

    public struct DescribeCACertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "caCertificateId"), required: true, type: .string)
        ]
        /// The CA certificate identifier.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "caCertificateId"
        }
    }

    public struct DescribeCertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string)
        ]
        /// The ID of the certificate.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
        }
    }

    public struct CreateCertificateFromCsrRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateSigningRequest", required: true, type: .string), 
            AWSShapeMember(label: "setAsActive", location: .querystring(locationName: "setAsActive"), required: false, type: .boolean)
        ]
        /// The certificate signing request (CSR).
        public let certificateSigningRequest: String
        /// Specifies whether the certificate is active.
        public let setAsActive: Bool?

        public init(certificateSigningRequest: String, setAsActive: Bool? = nil) {
            self.certificateSigningRequest = certificateSigningRequest
            self.setAsActive = setAsActive
        }

        private enum CodingKeys: String, CodingKey {
            case certificateSigningRequest = "certificateSigningRequest"
            case setAsActive = "setAsActive"
        }
    }

    public struct DescribeCertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateDescription", required: false, type: .structure)
        ]
        /// The description of the certificate.
        public let certificateDescription: CertificateDescription?

        public init(certificateDescription: CertificateDescription? = nil) {
            self.certificateDescription = certificateDescription
        }

        private enum CodingKeys: String, CodingKey {
            case certificateDescription = "certificateDescription"
        }
    }

    public struct CreateKeysAndCertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "setAsActive", location: .querystring(locationName: "setAsActive"), required: false, type: .boolean)
        ]
        /// Specifies whether the certificate is active.
        public let setAsActive: Bool?

        public init(setAsActive: Bool? = nil) {
            self.setAsActive = setAsActive
        }

        private enum CodingKeys: String, CodingKey {
            case setAsActive = "setAsActive"
        }
    }

    public struct ListPrincipalPoliciesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policies", required: false, type: .list), 
            AWSShapeMember(label: "nextMarker", required: false, type: .string)
        ]
        /// The policies.
        public let policies: [Policy]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(policies: [Policy]? = nil, nextMarker: String? = nil) {
            self.policies = policies
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case policies = "policies"
            case nextMarker = "nextMarker"
        }
    }

    public struct DetachPrincipalPolicyRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string), 
            AWSShapeMember(label: "principal", location: .header(locationName: "x-amzn-iot-principal"), required: true, type: .string)
        ]
        /// The name of the policy to detach.
        public let policyName: String
        /// The principal. If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.
        public let principal: String

        public init(policyName: String, principal: String) {
            self.policyName = policyName
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
            case principal = "x-amzn-iot-principal"
        }
    }

    public struct ThingTypeMetadata: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "deprecated", required: false, type: .boolean), 
            AWSShapeMember(label: "deprecationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp)
        ]
        /// Whether the thing type is deprecated. If true, no new things could be associated with this type.
        public let deprecated: Bool?
        /// The date and time when the thing type was deprecated.
        public let deprecationDate: TimeStamp?
        /// The date and time when the thing type was created.
        public let creationDate: TimeStamp?

        public init(deprecated: Bool? = nil, deprecationDate: TimeStamp? = nil, creationDate: TimeStamp? = nil) {
            self.deprecated = deprecated
            self.deprecationDate = deprecationDate
            self.creationDate = creationDate
        }

        private enum CodingKeys: String, CodingKey {
            case deprecated = "deprecated"
            case deprecationDate = "deprecationDate"
            case creationDate = "creationDate"
        }
    }

    public struct EnableTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleName", location: .uri(locationName: "ruleName"), required: true, type: .string)
        ]
        /// The name of the topic rule to enable.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "ruleName"
        }
    }

    public struct CreatePolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string), 
            AWSShapeMember(label: "setAsDefault", location: .querystring(locationName: "setAsDefault"), required: false, type: .boolean), 
            AWSShapeMember(label: "policyDocument", required: true, type: .string)
        ]
        /// The policy name.
        public let policyName: String
        /// Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
        public let setAsDefault: Bool?
        /// The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespaces
        public let policyDocument: String

        public init(policyName: String, setAsDefault: Bool? = nil, policyDocument: String) {
            self.policyName = policyName
            self.setAsDefault = setAsDefault
            self.policyDocument = policyDocument
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
            case setAsDefault = "setAsDefault"
            case policyDocument = "policyDocument"
        }
    }

    public struct KinesisAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "streamName", required: true, type: .string), 
            AWSShapeMember(label: "partitionKey", required: false, type: .string)
        ]
        /// The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        public let roleArn: String
        /// The name of the Amazon Kinesis stream.
        public let streamName: String
        /// The partition key.
        public let partitionKey: String?

        public init(roleArn: String, streamName: String, partitionKey: String? = nil) {
            self.roleArn = roleArn
            self.streamName = streamName
            self.partitionKey = partitionKey
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case streamName = "streamName"
            case partitionKey = "partitionKey"
        }
    }

    public struct SqsAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "useBase64", required: false, type: .boolean), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "queueUrl", required: true, type: .string)
        ]
        /// Specifies whether to use Base64 encoding.
        public let useBase64: Bool?
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The URL of the Amazon SQS queue.
        public let queueUrl: String

        public init(useBase64: Bool? = nil, roleArn: String, queueUrl: String) {
            self.useBase64 = useBase64
            self.roleArn = roleArn
            self.queueUrl = queueUrl
        }

        private enum CodingKeys: String, CodingKey {
            case useBase64 = "useBase64"
            case roleArn = "roleArn"
            case queueUrl = "queueUrl"
        }
    }

    public struct UpdateThingResponse: AWSShape {
        /// The key for the payload

    }

    public struct ListThingPrincipalsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string)
        ]
        /// The name of the thing.
        public let thingName: String

        public init(thingName: String) {
            self.thingName = thingName
        }

        private enum CodingKeys: String, CodingKey {
            case thingName = "thingName"
        }
    }

    public struct SetDefaultPolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyVersionId", location: .uri(locationName: "policyVersionId"), required: true, type: .string), 
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The policy version ID.
        public let policyVersionId: String
        /// The policy name.
        public let policyName: String

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyVersionId = "policyVersionId"
            case policyName = "policyName"
        }
    }

    public struct UpdateCACertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "caCertificateId"), required: true, type: .string), 
            AWSShapeMember(label: "newStatus", location: .querystring(locationName: "newStatus"), required: false, type: .enum), 
            AWSShapeMember(label: "newAutoRegistrationStatus", location: .querystring(locationName: "newAutoRegistrationStatus"), required: false, type: .enum)
        ]
        /// The CA certificate identifier.
        public let certificateId: String
        /// The updated status of the CA certificate.  Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let newStatus: CACertificateStatus?
        /// The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
        public let newAutoRegistrationStatus: AutoRegistrationStatus?

        public init(certificateId: String, newStatus: CACertificateStatus? = nil, newAutoRegistrationStatus: AutoRegistrationStatus? = nil) {
            self.certificateId = certificateId
            self.newStatus = newStatus
            self.newAutoRegistrationStatus = newAutoRegistrationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "caCertificateId"
            case newStatus = "newStatus"
            case newAutoRegistrationStatus = "newAutoRegistrationStatus"
        }
    }

    public struct ListPoliciesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policies", required: false, type: .list), 
            AWSShapeMember(label: "nextMarker", required: false, type: .string)
        ]
        /// The descriptions of the policies.
        public let policies: [Policy]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(policies: [Policy]? = nil, nextMarker: String? = nil) {
            self.policies = policies
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case policies = "policies"
            case nextMarker = "nextMarker"
        }
    }

    public struct ElasticsearchAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "endpoint", required: true, type: .string), 
            AWSShapeMember(label: "id", required: true, type: .string), 
            AWSShapeMember(label: "type", required: true, type: .string), 
            AWSShapeMember(label: "index", required: true, type: .string)
        ]
        /// The IAM role ARN that has access to Elasticsearch.
        public let roleArn: String
        /// The endpoint of your Elasticsearch domain.
        public let endpoint: String
        /// The unique identifier for the document you are storing.
        public let id: String
        /// The type of document you are storing.
        public let `type`: String
        /// The Elasticsearch index where you want to store your data.
        public let index: String

        public init(roleArn: String, endpoint: String, id: String, type: String, index: String) {
            self.roleArn = roleArn
            self.endpoint = endpoint
            self.id = id
            self.`type` = `type`
            self.index = index
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case endpoint = "endpoint"
            case id = "id"
            case `type` = "type"
            case index = "index"
        }
    }

    public struct ListOutgoingCertificatesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextMarker", required: false, type: .string), 
            AWSShapeMember(label: "outgoingCertificates", required: false, type: .list)
        ]
        /// The marker for the next set of results.
        public let nextMarker: String?
        /// The certificates that are being transfered but not yet accepted.
        public let outgoingCertificates: [OutgoingCertificate]?

        public init(nextMarker: String? = nil, outgoingCertificates: [OutgoingCertificate]? = nil) {
            self.nextMarker = nextMarker
            self.outgoingCertificates = outgoingCertificates
        }

        private enum CodingKeys: String, CodingKey {
            case nextMarker = "nextMarker"
            case outgoingCertificates = "outgoingCertificates"
        }
    }

    public struct UpdateCertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string), 
            AWSShapeMember(label: "newStatus", location: .querystring(locationName: "newStatus"), required: true, type: .enum)
        ]
        /// The ID of the certificate.
        public let certificateId: String
        /// The new status.  Note: Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.  Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let newStatus: CertificateStatus

        public init(certificateId: String, newStatus: CertificateStatus) {
            self.certificateId = certificateId
            self.newStatus = newStatus
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case newStatus = "newStatus"
        }
    }

    public enum MessageFormat: String, CustomStringConvertible, Codable {
        case raw = "RAW"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public struct TopicRuleListItem: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleDisabled", required: false, type: .boolean), 
            AWSShapeMember(label: "topicPattern", required: false, type: .string), 
            AWSShapeMember(label: "ruleName", required: false, type: .string), 
            AWSShapeMember(label: "ruleArn", required: false, type: .string), 
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp)
        ]
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The pattern for the topic names that apply.
        public let topicPattern: String?
        /// The name of the rule.
        public let ruleName: String?
        /// The rule ARN.
        public let ruleArn: String?
        /// The date and time the rule was created.
        public let createdAt: TimeStamp?

        public init(ruleDisabled: Bool? = nil, topicPattern: String? = nil, ruleName: String? = nil, ruleArn: String? = nil, createdAt: TimeStamp? = nil) {
            self.ruleDisabled = ruleDisabled
            self.topicPattern = topicPattern
            self.ruleName = ruleName
            self.ruleArn = ruleArn
            self.createdAt = createdAt
        }

        private enum CodingKeys: String, CodingKey {
            case ruleDisabled = "ruleDisabled"
            case topicPattern = "topicPattern"
            case ruleName = "ruleName"
            case ruleArn = "ruleArn"
            case createdAt = "createdAt"
        }
    }

    public struct DeleteThingTypeRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", location: .uri(locationName: "thingTypeName"), required: true, type: .string)
        ]
        /// The name of the thing type.
        public let thingTypeName: String

        public init(thingTypeName: String) {
            self.thingTypeName = thingTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
        }
    }

    public struct RegisterCertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string)
        ]
        /// The certificate identifier.
        public let certificateId: String?
        /// The certificate ARN.
        public let certificateArn: String?

        public init(certificateId: String? = nil, certificateArn: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
        }
    }

    public struct PutItemInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "tableName", required: true, type: .string)
        ]
        /// The table where the message data will be written
        public let tableName: String

        public init(tableName: String) {
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case tableName = "tableName"
        }
    }

    public struct AttributePayload: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "merge", required: false, type: .boolean), 
            AWSShapeMember(label: "attributes", required: false, type: .map)
        ]
        /// Specifies whether the list of attributes provided in the AttributePayload is merged with the attributes stored in the registry, instead of overwriting them. To remove an attribute, call UpdateThing with an empty attribute value.  The merge attribute is only valid when calling UpdateThing. 
        public let merge: Bool?
        /// A JSON string containing up to three key-value pair in JSON format. For example:  {\"attributes\":{\"string1\":\"string2\"}} 
        public let attributes: [String: String]?

        public init(merge: Bool? = nil, attributes: [String: String]? = nil) {
            self.merge = merge
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case merge = "merge"
            case attributes = "attributes"
        }
    }

    public struct CreatePolicyRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyDocument", required: true, type: .string), 
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The JSON document that describes the policy. policyDocument must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.
        public let policyDocument: String
        /// The policy name.
        public let policyName: String

        public init(policyDocument: String, policyName: String) {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "policyDocument"
            case policyName = "policyName"
        }
    }

    public struct DeletePolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyVersionId", location: .uri(locationName: "policyVersionId"), required: true, type: .string), 
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The policy version ID.
        public let policyVersionId: String
        /// The name of the policy.
        public let policyName: String

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyVersionId = "policyVersionId"
            case policyName = "policyName"
        }
    }

    public struct DeleteThingTypeResponse: AWSShape {
        /// The key for the payload

    }

    public struct DeleteRegistrationCodeRequest: AWSShape {
        /// The key for the payload

    }

    public struct GetLoggingOptionsRequest: AWSShape {
        /// The key for the payload

    }

    public struct LambdaAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "functionArn", required: true, type: .string)
        ]
        /// The ARN of the Lambda function.
        public let functionArn: String

        public init(functionArn: String) {
            self.functionArn = functionArn
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "functionArn"
        }
    }

    public struct TopicRule: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleDisabled", required: false, type: .boolean), 
            AWSShapeMember(label: "ruleName", required: false, type: .string), 
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "awsIotSqlVersion", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "actions", required: false, type: .list), 
            AWSShapeMember(label: "sql", required: false, type: .string)
        ]
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The name of the rule.
        public let ruleName: String?
        /// The date and time the rule was created.
        public let createdAt: TimeStamp?
        /// The version of the SQL rules engine to use when evaluating the rule.
        public let awsIotSqlVersion: String?
        /// The description of the rule.
        public let description: String?
        /// The actions associated with the rule.
        public let actions: [Action]?
        /// The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.
        public let sql: String?

        public init(ruleDisabled: Bool? = nil, ruleName: String? = nil, createdAt: TimeStamp? = nil, awsIotSqlVersion: String? = nil, description: String? = nil, actions: [Action]? = nil, sql: String? = nil) {
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.createdAt = createdAt
            self.awsIotSqlVersion = awsIotSqlVersion
            self.description = description
            self.actions = actions
            self.sql = sql
        }

        private enum CodingKeys: String, CodingKey {
            case ruleDisabled = "ruleDisabled"
            case ruleName = "ruleName"
            case createdAt = "createdAt"
            case awsIotSqlVersion = "awsIotSqlVersion"
            case description = "description"
            case actions = "actions"
            case sql = "sql"
        }
    }

    public struct CreateThingRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "attributePayload", required: false, type: .structure), 
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string)
        ]
        /// The name of the thing type associated with the new thing.
        public let thingTypeName: String?
        /// The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:  {\"attributes\":{\"string1\":\"string2\"}} 
        public let attributePayload: AttributePayload?
        /// The name of the thing to create.
        public let thingName: String

        public init(thingTypeName: String? = nil, attributePayload: AttributePayload? = nil, thingName: String) {
            self.thingTypeName = thingTypeName
            self.attributePayload = attributePayload
            self.thingName = thingName
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
            case attributePayload = "attributePayload"
            case thingName = "thingName"
        }
    }

    public struct CertificateDescription: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "caCertificateId", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificatePem", required: false, type: .string), 
            AWSShapeMember(label: "previousOwnedBy", required: false, type: .string), 
            AWSShapeMember(label: "transferData", required: false, type: .structure), 
            AWSShapeMember(label: "ownedBy", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string), 
            AWSShapeMember(label: "lastModifiedDate", required: false, type: .timestamp)
        ]
        /// The certificate ID of the CA certificate used to sign this certificate.
        public let caCertificateId: String?
        /// The status of the certificate.
        public let status: CertificateStatus?
        /// The date and time the certificate was created.
        public let creationDate: TimeStamp?
        /// The ID of the certificate.
        public let certificateId: String?
        /// The certificate data, in PEM format.
        public let certificatePem: String?
        /// The ID of the AWS account of the previous owner of the certificate.
        public let previousOwnedBy: String?
        /// The transfer data.
        public let transferData: TransferData?
        /// The ID of the AWS account that owns the certificate.
        public let ownedBy: String?
        /// The ARN of the certificate.
        public let certificateArn: String?
        /// The date and time the certificate was last modified.
        public let lastModifiedDate: TimeStamp?

        public init(caCertificateId: String? = nil, status: CertificateStatus? = nil, creationDate: TimeStamp? = nil, certificateId: String? = nil, certificatePem: String? = nil, previousOwnedBy: String? = nil, transferData: TransferData? = nil, ownedBy: String? = nil, certificateArn: String? = nil, lastModifiedDate: TimeStamp? = nil) {
            self.caCertificateId = caCertificateId
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificatePem = certificatePem
            self.previousOwnedBy = previousOwnedBy
            self.transferData = transferData
            self.ownedBy = ownedBy
            self.certificateArn = certificateArn
            self.lastModifiedDate = lastModifiedDate
        }

        private enum CodingKeys: String, CodingKey {
            case caCertificateId = "caCertificateId"
            case status = "status"
            case creationDate = "creationDate"
            case certificateId = "certificateId"
            case certificatePem = "certificatePem"
            case previousOwnedBy = "previousOwnedBy"
            case transferData = "transferData"
            case ownedBy = "ownedBy"
            case certificateArn = "certificateArn"
            case lastModifiedDate = "lastModifiedDate"
        }
    }

    public struct CloudwatchAlarmAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "stateReason", required: true, type: .string), 
            AWSShapeMember(label: "alarmName", required: true, type: .string), 
            AWSShapeMember(label: "stateValue", required: true, type: .string)
        ]
        /// The IAM role that allows access to the CloudWatch alarm.
        public let roleArn: String
        /// The reason for the alarm change.
        public let stateReason: String
        /// The CloudWatch alarm name.
        public let alarmName: String
        /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        public let stateValue: String

        public init(roleArn: String, stateReason: String, alarmName: String, stateValue: String) {
            self.roleArn = roleArn
            self.stateReason = stateReason
            self.alarmName = alarmName
            self.stateValue = stateValue
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case stateReason = "stateReason"
            case alarmName = "alarmName"
            case stateValue = "stateValue"
        }
    }

    public struct DisableTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleName", location: .uri(locationName: "ruleName"), required: true, type: .string)
        ]
        /// The name of the rule to disable.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "ruleName"
        }
    }

    public struct ListPrincipalThingsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "principal", location: .header(locationName: "x-amzn-principal"), required: true, type: .string)
        ]
        /// The maximum number of results to return in this operation.
        public let maxResults: Int32?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The principal.
        public let principal: String

        public init(maxResults: Int32? = nil, nextToken: String? = nil, principal: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case principal = "x-amzn-principal"
        }
    }

    public struct CreateTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "topicRulePayload"
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleName", location: .uri(locationName: "ruleName"), required: true, type: .string), 
            AWSShapeMember(label: "topicRulePayload", required: true, type: .structure)
        ]
        /// The name of the rule.
        public let ruleName: String
        /// The rule payload.
        public let topicRulePayload: TopicRulePayload

        public init(ruleName: String, topicRulePayload: TopicRulePayload) {
            self.ruleName = ruleName
            self.topicRulePayload = topicRulePayload
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "ruleName"
            case topicRulePayload = "topicRulePayload"
        }
    }

    public struct DeleteCACertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "caCertificateId"), required: true, type: .string)
        ]
        /// The ID of the certificate to delete.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "caCertificateId"
        }
    }

    public struct CACertificate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string)
        ]
        /// The status of the CA certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let status: CACertificateStatus?
        /// The date the CA certificate was created.
        public let creationDate: TimeStamp?
        /// The ID of the CA certificate.
        public let certificateId: String?
        /// The ARN of the CA certificate.
        public let certificateArn: String?

        public init(status: CACertificateStatus? = nil, creationDate: TimeStamp? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case creationDate = "creationDate"
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
        }
    }

    public struct ListPolicyVersionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The policy name.
        public let policyName: String

        public init(policyName: String) {
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
        }
    }

    public struct ListPolicyPrincipalsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "policyName", location: .header(locationName: "x-amzn-iot-policy"), required: true, type: .string), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean)
        ]
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// The policy name.
        public let policyName: String
        /// Specifies the order for results. If true, the results are returned in ascending creation order.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, policyName: String, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.policyName = policyName
            self.ascendingOrder = ascendingOrder
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "marker"
            case pageSize = "pageSize"
            case policyName = "x-amzn-iot-policy"
            case ascendingOrder = "isAscendingOrder"
        }
    }

    public struct PolicyVersion: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "createDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "versionId", required: false, type: .string), 
            AWSShapeMember(label: "isDefaultVersion", required: false, type: .boolean)
        ]
        /// The date and time the policy was created.
        public let createDate: TimeStamp?
        /// The policy version ID.
        public let versionId: String?
        /// Specifies whether the policy version is the default.
        public let isDefaultVersion: Bool?

        public init(createDate: TimeStamp? = nil, versionId: String? = nil, isDefaultVersion: Bool? = nil) {
            self.createDate = createDate
            self.versionId = versionId
            self.isDefaultVersion = isDefaultVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "createDate"
            case versionId = "versionId"
            case isDefaultVersion = "isDefaultVersion"
        }
    }

    public struct AttachThingPrincipalRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string), 
            AWSShapeMember(label: "principal", location: .header(locationName: "x-amzn-principal"), required: true, type: .string)
        ]
        /// The name of the thing.
        public let thingName: String
        /// The principal, such as a certificate or other credential.
        public let principal: String

        public init(thingName: String, principal: String) {
            self.thingName = thingName
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case thingName = "thingName"
            case principal = "x-amzn-principal"
        }
    }

    public struct DeleteCACertificateResponse: AWSShape {
        /// The key for the payload

    }

    public struct GetRegistrationCodeResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "registrationCode", required: false, type: .string)
        ]
        /// The CA certificate registration code.
        public let registrationCode: String?

        public init(registrationCode: String? = nil) {
            self.registrationCode = registrationCode
        }

        private enum CodingKeys: String, CodingKey {
            case registrationCode = "registrationCode"
        }
    }

    public struct ListCertificatesByCAResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificates", required: false, type: .list), 
            AWSShapeMember(label: "nextMarker", required: false, type: .string)
        ]
        /// The device certificates signed by the specified CA certificate.
        public let certificates: [Certificate]?
        /// The marker for the next set of results, or null if there are no additional results.
        public let nextMarker: String?

        public init(certificates: [Certificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "certificates"
            case nextMarker = "nextMarker"
        }
    }

    public struct ListPoliciesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean)
        ]
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If true, the results are returned in ascending creation order.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "marker"
            case pageSize = "pageSize"
            case ascendingOrder = "isAscendingOrder"
        }
    }

    public struct ListCACertificatesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean)
        ]
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Determines the order of the results.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "marker"
            case pageSize = "pageSize"
            case ascendingOrder = "isAscendingOrder"
        }
    }

    public struct DeprecateThingTypeRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", location: .uri(locationName: "thingTypeName"), required: true, type: .string), 
            AWSShapeMember(label: "undoDeprecate", required: false, type: .boolean)
        ]
        /// The name of the thing type to deprecate.
        public let thingTypeName: String
        /// Whether to undeprecate a deprecated thing type. If true, the thing type will not be deprecated anymore and you can associate it with things.
        public let undoDeprecate: Bool?

        public init(thingTypeName: String, undoDeprecate: Bool? = nil) {
            self.thingTypeName = thingTypeName
            self.undoDeprecate = undoDeprecate
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
            case undoDeprecate = "undoDeprecate"
        }
    }

    public struct TopicRulePayload: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "awsIotSqlVersion", required: false, type: .string), 
            AWSShapeMember(label: "ruleDisabled", required: false, type: .boolean), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "actions", required: true, type: .list), 
            AWSShapeMember(label: "sql", required: true, type: .string)
        ]
        /// The version of the SQL rules engine to use when evaluating the rule.
        public let awsIotSqlVersion: String?
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The description of the rule.
        public let description: String?
        /// The actions associated with the rule.
        public let actions: [Action]
        /// The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference in the AWS IoT Developer Guide.
        public let sql: String

        public init(awsIotSqlVersion: String? = nil, ruleDisabled: Bool? = nil, description: String? = nil, actions: [Action], sql: String) {
            self.awsIotSqlVersion = awsIotSqlVersion
            self.ruleDisabled = ruleDisabled
            self.description = description
            self.actions = actions
            self.sql = sql
        }

        private enum CodingKeys: String, CodingKey {
            case awsIotSqlVersion = "awsIotSqlVersion"
            case ruleDisabled = "ruleDisabled"
            case description = "description"
            case actions = "actions"
            case sql = "sql"
        }
    }

    public struct SnsAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "messageFormat", required: false, type: .enum), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "targetArn", required: true, type: .string)
        ]
        /// The message format of the message to publish. Optional. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see http://docs.aws.amazon.com/sns/latest/dg/json-formats.html refer to their official documentation.
        public let messageFormat: MessageFormat?
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The ARN of the SNS topic.
        public let targetArn: String

        public init(messageFormat: MessageFormat? = nil, roleArn: String, targetArn: String) {
            self.messageFormat = messageFormat
            self.roleArn = roleArn
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case messageFormat = "messageFormat"
            case roleArn = "roleArn"
            case targetArn = "targetArn"
        }
    }

    public struct KeyPair: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "PublicKey", required: false, type: .string), 
            AWSShapeMember(label: "PrivateKey", required: false, type: .string)
        ]
        /// The public key.
        public let publicKey: String?
        /// The private key.
        public let privateKey: String?

        public init(publicKey: String? = nil, privateKey: String? = nil) {
            self.publicKey = publicKey
            self.privateKey = privateKey
        }

        private enum CodingKeys: String, CodingKey {
            case publicKey = "PublicKey"
            case privateKey = "PrivateKey"
        }
    }

    public struct DeleteRegistrationCodeResponse: AWSShape {
        /// The key for the payload

    }

    public struct ListPolicyVersionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyVersions", required: false, type: .list)
        ]
        /// The policy versions.
        public let policyVersions: [PolicyVersion]?

        public init(policyVersions: [PolicyVersion]? = nil) {
            self.policyVersions = policyVersions
        }

        private enum CodingKeys: String, CodingKey {
            case policyVersions = "policyVersions"
        }
    }

    public struct GetPolicyVersionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyDocument", required: false, type: .string), 
            AWSShapeMember(label: "policyVersionId", required: false, type: .string), 
            AWSShapeMember(label: "policyName", required: false, type: .string), 
            AWSShapeMember(label: "isDefaultVersion", required: false, type: .boolean), 
            AWSShapeMember(label: "policyArn", required: false, type: .string)
        ]
        /// The JSON document that describes the policy.
        public let policyDocument: String?
        /// The policy version ID.
        public let policyVersionId: String?
        /// The policy name.
        public let policyName: String?
        /// Specifies whether the policy version is the default.
        public let isDefaultVersion: Bool?
        /// The policy ARN.
        public let policyArn: String?

        public init(policyDocument: String? = nil, policyVersionId: String? = nil, policyName: String? = nil, isDefaultVersion: Bool? = nil, policyArn: String? = nil) {
            self.policyDocument = policyDocument
            self.policyVersionId = policyVersionId
            self.policyName = policyName
            self.isDefaultVersion = isDefaultVersion
            self.policyArn = policyArn
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "policyDocument"
            case policyVersionId = "policyVersionId"
            case policyName = "policyName"
            case isDefaultVersion = "isDefaultVersion"
            case policyArn = "policyArn"
        }
    }

    public struct ListThingTypesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", location: .querystring(locationName: "thingTypeName"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The maximum number of results to return in this operation.
        public let maxResults: Int32?

        public init(thingTypeName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.thingTypeName = thingTypeName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public struct CreateThingTypeResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "thingTypeArn", required: false, type: .string)
        ]
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The Amazon Resource Name (ARN) of the thing type.
        public let thingTypeArn: String?

        public init(thingTypeName: String? = nil, thingTypeArn: String? = nil) {
            self.thingTypeName = thingTypeName
            self.thingTypeArn = thingTypeArn
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
            case thingTypeArn = "thingTypeArn"
        }
    }

    public struct DeleteTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleName", location: .uri(locationName: "ruleName"), required: true, type: .string)
        ]
        /// The name of the rule.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "ruleName"
        }
    }

    public struct GetPolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyVersionId", location: .uri(locationName: "policyVersionId"), required: true, type: .string), 
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The policy version ID.
        public let policyVersionId: String
        /// The name of the policy.
        public let policyName: String

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyVersionId = "policyVersionId"
            case policyName = "policyName"
        }
    }

    public struct ListTopicRulesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "rules", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The rules.
        public let rules: [TopicRuleListItem]?
        /// A token used to retrieve the next value.
        public let nextToken: String?

        public init(rules: [TopicRuleListItem]? = nil, nextToken: String? = nil) {
            self.rules = rules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
            case nextToken = "nextToken"
        }
    }

    public struct S3Action: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "cannedAcl", required: false, type: .enum), 
            AWSShapeMember(label: "key", required: true, type: .string)
        ]
        /// The Amazon S3 bucket.
        public let bucketName: String
        /// The ARN of the IAM role that grants access.
        public let roleArn: String
        /// The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see S3 canned ACLs.
        public let cannedAcl: CannedAccessControlList?
        /// The object key.
        public let key: String

        public init(bucketName: String, roleArn: String, cannedAcl: CannedAccessControlList? = nil, key: String) {
            self.bucketName = bucketName
            self.roleArn = roleArn
            self.cannedAcl = cannedAcl
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case roleArn = "roleArn"
            case cannedAcl = "cannedAcl"
            case key = "key"
        }
    }

    public struct OutgoingCertificate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "transferMessage", required: false, type: .string), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string), 
            AWSShapeMember(label: "transferredTo", required: false, type: .string), 
            AWSShapeMember(label: "transferDate", required: false, type: .timestamp)
        ]
        /// The transfer message.
        public let transferMessage: String?
        /// The certificate creation date.
        public let creationDate: TimeStamp?
        /// The certificate ID.
        public let certificateId: String?
        /// The certificate ARN.
        public let certificateArn: String?
        /// The AWS account to which the transfer was made.
        public let transferredTo: String?
        /// The date the transfer was initiated.
        public let transferDate: TimeStamp?

        public init(transferMessage: String? = nil, creationDate: TimeStamp? = nil, certificateId: String? = nil, certificateArn: String? = nil, transferredTo: String? = nil, transferDate: TimeStamp? = nil) {
            self.transferMessage = transferMessage
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
            self.transferredTo = transferredTo
            self.transferDate = transferDate
        }

        private enum CodingKeys: String, CodingKey {
            case transferMessage = "transferMessage"
            case creationDate = "creationDate"
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
            case transferredTo = "transferredTo"
            case transferDate = "transferDate"
        }
    }

    public struct CreateCertificateFromCsrResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string), 
            AWSShapeMember(label: "certificatePem", required: false, type: .string)
        ]
        /// The ID of the certificate. Certificate management operations only take a certificateId.
        public let certificateId: String?
        /// The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.
        public let certificateArn: String?
        /// The certificate data, in PEM format.
        public let certificatePem: String?

        public init(certificateId: String? = nil, certificateArn: String? = nil, certificatePem: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
            self.certificatePem = certificatePem
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
            case certificatePem = "certificatePem"
        }
    }

    public struct TransferCertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "transferredCertificateArn", required: false, type: .string)
        ]
        /// The ARN of the certificate.
        public let transferredCertificateArn: String?

        public init(transferredCertificateArn: String? = nil) {
            self.transferredCertificateArn = transferredCertificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case transferredCertificateArn = "transferredCertificateArn"
        }
    }

    public struct FirehoseAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "deliveryStreamName", required: true, type: .string), 
            AWSShapeMember(label: "separator", required: false, type: .string)
        ]
        /// The IAM role that grants access to the Amazon Kinesis Firehost stream.
        public let roleArn: String
        /// The delivery stream name.
        public let deliveryStreamName: String
        /// A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public let separator: String?

        public init(roleArn: String, deliveryStreamName: String, separator: String? = nil) {
            self.roleArn = roleArn
            self.deliveryStreamName = deliveryStreamName
            self.separator = separator
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case deliveryStreamName = "deliveryStreamName"
            case separator = "separator"
        }
    }

    public struct CreatePolicyVersionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyArn", required: false, type: .string), 
            AWSShapeMember(label: "policyVersionId", required: false, type: .string), 
            AWSShapeMember(label: "isDefaultVersion", required: false, type: .boolean), 
            AWSShapeMember(label: "policyDocument", required: false, type: .string)
        ]
        /// The policy ARN.
        public let policyArn: String?
        /// The policy version ID.
        public let policyVersionId: String?
        /// Specifies whether the policy version is the default.
        public let isDefaultVersion: Bool?
        /// The JSON document that describes the policy.
        public let policyDocument: String?

        public init(policyArn: String? = nil, policyVersionId: String? = nil, isDefaultVersion: Bool? = nil, policyDocument: String? = nil) {
            self.policyArn = policyArn
            self.policyVersionId = policyVersionId
            self.isDefaultVersion = isDefaultVersion
            self.policyDocument = policyDocument
        }

        private enum CodingKeys: String, CodingKey {
            case policyArn = "policyArn"
            case policyVersionId = "policyVersionId"
            case isDefaultVersion = "isDefaultVersion"
            case policyDocument = "policyDocument"
        }
    }

    public struct AcceptCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string), 
            AWSShapeMember(label: "setAsActive", location: .querystring(locationName: "setAsActive"), required: false, type: .boolean)
        ]
        /// The ID of the certificate.
        public let certificateId: String
        /// Specifies whether the certificate is active.
        public let setAsActive: Bool?

        public init(certificateId: String, setAsActive: Bool? = nil) {
            self.certificateId = certificateId
            self.setAsActive = setAsActive
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case setAsActive = "setAsActive"
        }
    }

    public struct CancelCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string)
        ]
        /// The ID of the certificate.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
        }
    }

    public struct SalesforceAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "token", required: true, type: .string), 
            AWSShapeMember(label: "url", required: true, type: .string)
        ]
        /// The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The token is available from the Salesforce IoT Cloud platform after creation of the Input Stream.
        public let token: String
        /// The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from the Salesforce IoT Cloud platform after creation of the Input Stream.
        public let url: String

        public init(token: String, url: String) {
            self.token = token
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case token = "token"
            case url = "url"
        }
    }

    public struct DeleteCertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string)
        ]
        /// The ID of the certificate.
        public let certificateId: String

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
        }
    }

    public struct DetachThingPrincipalResponse: AWSShape {
        /// The key for the payload

    }

    public struct DescribeEndpointResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "endpointAddress", required: false, type: .string)
        ]
        /// The endpoint. The format of the endpoint is as follows: identifier.iot.region.amazonaws.com.
        public let endpointAddress: String?

        public init(endpointAddress: String? = nil) {
            self.endpointAddress = endpointAddress
        }

        private enum CodingKeys: String, CodingKey {
            case endpointAddress = "endpointAddress"
        }
    }

    public struct RejectCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", location: .uri(locationName: "certificateId"), required: true, type: .string), 
            AWSShapeMember(label: "rejectReason", required: false, type: .string)
        ]
        /// The ID of the certificate.
        public let certificateId: String
        /// The reason the certificate transfer was rejected.
        public let rejectReason: String?

        public init(certificateId: String, rejectReason: String? = nil) {
            self.certificateId = certificateId
            self.rejectReason = rejectReason
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case rejectReason = "rejectReason"
        }
    }

    public struct TransferData: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "rejectDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "acceptDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "transferMessage", required: false, type: .string), 
            AWSShapeMember(label: "transferDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "rejectReason", required: false, type: .string)
        ]
        /// The date the transfer was rejected.
        public let rejectDate: TimeStamp?
        /// The date the transfer was accepted.
        public let acceptDate: TimeStamp?
        /// The transfer message.
        public let transferMessage: String?
        /// The date the transfer took place.
        public let transferDate: TimeStamp?
        /// The reason why the transfer was rejected.
        public let rejectReason: String?

        public init(rejectDate: TimeStamp? = nil, acceptDate: TimeStamp? = nil, transferMessage: String? = nil, transferDate: TimeStamp? = nil, rejectReason: String? = nil) {
            self.rejectDate = rejectDate
            self.acceptDate = acceptDate
            self.transferMessage = transferMessage
            self.transferDate = transferDate
            self.rejectReason = rejectReason
        }

        private enum CodingKeys: String, CodingKey {
            case rejectDate = "rejectDate"
            case acceptDate = "acceptDate"
            case transferMessage = "transferMessage"
            case transferDate = "transferDate"
            case rejectReason = "rejectReason"
        }
    }

    public struct GetPolicyRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The name of the policy.
        public let policyName: String

        public init(policyName: String) {
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
        }
    }

    public enum AutoRegistrationStatus: String, CustomStringConvertible, Codable {
        case enable = "ENABLE"
        case disable = "DISABLE"
        public var description: String { return self.rawValue }
    }

    public struct Certificate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string)
        ]
        /// The status of the certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public let status: CertificateStatus?
        /// The date and time the certificate was created.
        public let creationDate: TimeStamp?
        /// The ID of the certificate.
        public let certificateId: String?
        /// The ARN of the certificate.
        public let certificateArn: String?

        public init(status: CertificateStatus? = nil, creationDate: TimeStamp? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case creationDate = "creationDate"
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
        }
    }

    public struct RegisterCertificateRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "caCertificatePem", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "certificatePem", required: true, type: .string), 
            AWSShapeMember(label: "setAsActive", location: .querystring(locationName: "setAsActive"), required: false, type: .boolean)
        ]
        /// The CA certificate used to sign the device certificate being registered.
        public let caCertificatePem: String?
        /// The status of the register certificate request.
        public let status: CertificateStatus?
        /// The certificate data, in PEM format.
        public let certificatePem: String
        /// A boolean value that specifies if the CA certificate is set to active.
        public let setAsActive: Bool?

        public init(caCertificatePem: String? = nil, status: CertificateStatus? = nil, certificatePem: String, setAsActive: Bool? = nil) {
            self.caCertificatePem = caCertificatePem
            self.status = status
            self.certificatePem = certificatePem
            self.setAsActive = setAsActive
        }

        private enum CodingKeys: String, CodingKey {
            case caCertificatePem = "caCertificatePem"
            case status = "status"
            case certificatePem = "certificatePem"
            case setAsActive = "setAsActive"
        }
    }

    public struct ListThingPrincipalsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "principals", required: false, type: .list)
        ]
        /// The principals associated with the thing.
        public let principals: [String]?

        public init(principals: [String]? = nil) {
            self.principals = principals
        }

        private enum CodingKeys: String, CodingKey {
            case principals = "principals"
        }
    }

    public struct GetLoggingOptionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "logLevel", required: false, type: .enum)
        ]
        /// The ARN of the IAM role that grants access.
        public let roleArn: String?
        /// The logging level.
        public let logLevel: LogLevel?

        public init(roleArn: String? = nil, logLevel: LogLevel? = nil) {
            self.roleArn = roleArn
            self.logLevel = logLevel
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case logLevel = "logLevel"
        }
    }

    public struct ListOutgoingCertificatesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean)
        ]
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "marker"
            case pageSize = "pageSize"
            case ascendingOrder = "isAscendingOrder"
        }
    }

    public struct ListCACertificatesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificates", required: false, type: .list), 
            AWSShapeMember(label: "nextMarker", required: false, type: .string)
        ]
        /// The CA certificates registered in your AWS account.
        public let certificates: [CACertificate]?
        /// The current position within the list of CA certificates.
        public let nextMarker: String?

        public init(certificates: [CACertificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "certificates"
            case nextMarker = "nextMarker"
        }
    }

    public struct ThingTypeProperties: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeDescription", required: false, type: .string), 
            AWSShapeMember(label: "searchableAttributes", required: false, type: .list)
        ]
        /// The description of the thing type.
        public let thingTypeDescription: String?
        /// A list of searchable thing attribute names.
        public let searchableAttributes: [String]?

        public init(thingTypeDescription: String? = nil, searchableAttributes: [String]? = nil) {
            self.thingTypeDescription = thingTypeDescription
            self.searchableAttributes = searchableAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeDescription = "thingTypeDescription"
            case searchableAttributes = "searchableAttributes"
        }
    }

    public struct GetPolicyResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", required: false, type: .string), 
            AWSShapeMember(label: "defaultVersionId", required: false, type: .string), 
            AWSShapeMember(label: "policyArn", required: false, type: .string), 
            AWSShapeMember(label: "policyDocument", required: false, type: .string)
        ]
        /// The policy name.
        public let policyName: String?
        /// The default policy version ID.
        public let defaultVersionId: String?
        /// The policy ARN.
        public let policyArn: String?
        /// The JSON document that describes the policy.
        public let policyDocument: String?

        public init(policyName: String? = nil, defaultVersionId: String? = nil, policyArn: String? = nil, policyDocument: String? = nil) {
            self.policyName = policyName
            self.defaultVersionId = defaultVersionId
            self.policyArn = policyArn
            self.policyDocument = policyDocument
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
            case defaultVersionId = "defaultVersionId"
            case policyArn = "policyArn"
            case policyDocument = "policyDocument"
        }
    }

    public struct ListThingsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "things", required: false, type: .list)
        ]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// The things.
        public let things: [ThingAttribute]?

        public init(nextToken: String? = nil, things: [ThingAttribute]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case things = "things"
        }
    }

    public struct ListPrincipalPoliciesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean), 
            AWSShapeMember(label: "principal", location: .header(locationName: "x-amzn-iot-principal"), required: true, type: .string)
        ]
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If true, results are returned in ascending creation order.
        public let ascendingOrder: Bool?
        /// The principal.
        public let principal: String

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil, principal: String) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "marker"
            case pageSize = "pageSize"
            case ascendingOrder = "isAscendingOrder"
            case principal = "x-amzn-iot-principal"
        }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable {
        case debug = "DEBUG"
        case info = "INFO"
        case error = "ERROR"
        case warn = "WARN"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct ThingAttribute: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingName", required: false, type: .string), 
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "attributes", required: false, type: .map), 
            AWSShapeMember(label: "version", required: false, type: .long)
        ]
        /// The name of the thing.
        public let thingName: String?
        /// The name of the thing type, if the thing has been associated with a type.
        public let thingTypeName: String?
        /// A list of thing attributes which are name-value pairs.
        public let attributes: [String: String]?
        /// The version of the thing record in the registry.
        public let version: Int64?

        public init(thingName: String? = nil, thingTypeName: String? = nil, attributes: [String: String]? = nil, version: Int64? = nil) {
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.attributes = attributes
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case thingName = "thingName"
            case thingTypeName = "thingTypeName"
            case attributes = "attributes"
            case version = "version"
        }
    }

    public struct DeletePolicyRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string)
        ]
        /// The name of the policy to delete.
        public let policyName: String

        public init(policyName: String) {
            self.policyName = policyName
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
        }
    }

    public struct DescribeThingRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string)
        ]
        /// The name of the thing.
        public let thingName: String

        public init(thingName: String) {
            self.thingName = thingName
        }

        private enum CodingKeys: String, CodingKey {
            case thingName = "thingName"
        }
    }

    public struct CACertificateDescription: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "autoRegistrationStatus", required: false, type: .enum), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificatePem", required: false, type: .string), 
            AWSShapeMember(label: "ownedBy", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string)
        ]
        /// The status of a CA certificate.
        public let status: CACertificateStatus?
        /// Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"
        public let autoRegistrationStatus: AutoRegistrationStatus?
        /// The date the CA certificate was created.
        public let creationDate: TimeStamp?
        /// The CA certificate ID.
        public let certificateId: String?
        /// The CA certificate data, in PEM format.
        public let certificatePem: String?
        /// The owner of the CA certificate.
        public let ownedBy: String?
        /// The CA certificate ARN.
        public let certificateArn: String?

        public init(status: CACertificateStatus? = nil, autoRegistrationStatus: AutoRegistrationStatus? = nil, creationDate: TimeStamp? = nil, certificateId: String? = nil, certificatePem: String? = nil, ownedBy: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.autoRegistrationStatus = autoRegistrationStatus
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificatePem = certificatePem
            self.ownedBy = ownedBy
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case autoRegistrationStatus = "autoRegistrationStatus"
            case creationDate = "creationDate"
            case certificateId = "certificateId"
            case certificatePem = "certificatePem"
            case ownedBy = "ownedBy"
            case certificateArn = "certificateArn"
        }
    }

    public struct ListTopicRulesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleDisabled", location: .querystring(locationName: "ruleDisabled"), required: false, type: .boolean), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "topic", location: .querystring(locationName: "topic"), required: false, type: .string)
        ]
        /// Specifies whether the rule is disabled.
        public let ruleDisabled: Bool?
        /// The maximum number of results to return.
        public let maxResults: Int32?
        /// A token used to retrieve the next value.
        public let nextToken: String?
        /// The topic.
        public let topic: String?

        public init(ruleDisabled: Bool? = nil, maxResults: Int32? = nil, nextToken: String? = nil, topic: String? = nil) {
            self.ruleDisabled = ruleDisabled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case ruleDisabled = "ruleDisabled"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case topic = "topic"
        }
    }

    public enum CertificateStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        case revoked = "REVOKED"
        case pendingTransfer = "PENDING_TRANSFER"
        case registerInactive = "REGISTER_INACTIVE"
        case pendingActivation = "PENDING_ACTIVATION"
        public var description: String { return self.rawValue }
    }

    public struct DescribeThingResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultClientId", required: false, type: .string), 
            AWSShapeMember(label: "thingName", required: false, type: .string), 
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "attributes", required: false, type: .map), 
            AWSShapeMember(label: "version", required: false, type: .long)
        ]
        /// The default client ID.
        public let defaultClientId: String?
        /// The name of the thing.
        public let thingName: String?
        /// The thing type name.
        public let thingTypeName: String?
        /// The thing attributes.
        public let attributes: [String: String]?
        /// The current version of the thing record in the registry.  To avoid unintentional changes to the information in the registry, you can pass the version information in the expectedVersion parameter of the UpdateThing and DeleteThing calls. 
        public let version: Int64?

        public init(defaultClientId: String? = nil, thingName: String? = nil, thingTypeName: String? = nil, attributes: [String: String]? = nil, version: Int64? = nil) {
            self.defaultClientId = defaultClientId
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.attributes = attributes
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case defaultClientId = "defaultClientId"
            case thingName = "thingName"
            case thingTypeName = "thingTypeName"
            case attributes = "attributes"
            case version = "version"
        }
    }

    public struct DescribeThingTypeRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeName", location: .uri(locationName: "thingTypeName"), required: true, type: .string)
        ]
        /// The name of the thing type.
        public let thingTypeName: String

        public init(thingTypeName: String) {
            self.thingTypeName = thingTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeName = "thingTypeName"
        }
    }

    public struct AttachPrincipalPolicyRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "policyName", location: .uri(locationName: "policyName"), required: true, type: .string), 
            AWSShapeMember(label: "principal", location: .header(locationName: "x-amzn-iot-principal"), required: true, type: .string)
        ]
        /// The policy name.
        public let policyName: String
        /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
        public let principal: String

        public init(policyName: String, principal: String) {
            self.policyName = policyName
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "policyName"
            case principal = "x-amzn-iot-principal"
        }
    }

    public struct UpdateThingRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "removeThingType", required: false, type: .boolean), 
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string), 
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "expectedVersion", required: false, type: .long), 
            AWSShapeMember(label: "attributePayload", required: false, type: .structure)
        ]
        /// Remove a thing type association. If true, the assocation is removed.
        public let removeThingType: Bool?
        /// The name of the thing to update.
        public let thingName: String
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the UpdateThing request is rejected with a VersionConflictException.
        public let expectedVersion: Int64?
        /// A list of thing attributes, a JSON string containing name-value pairs. For example:  {\"attributes\":{\"name1\":\"value2\"}}  This data is used to add new attributes or update existing attributes.
        public let attributePayload: AttributePayload?

        public init(removeThingType: Bool? = nil, thingName: String, thingTypeName: String? = nil, expectedVersion: Int64? = nil, attributePayload: AttributePayload? = nil) {
            self.removeThingType = removeThingType
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.expectedVersion = expectedVersion
            self.attributePayload = attributePayload
        }

        private enum CodingKeys: String, CodingKey {
            case removeThingType = "removeThingType"
            case thingName = "thingName"
            case thingTypeName = "thingTypeName"
            case expectedVersion = "expectedVersion"
            case attributePayload = "attributePayload"
        }
    }

    public struct DeprecateThingTypeResponse: AWSShape {
        /// The key for the payload

    }

    public enum DynamoKeyType: String, CustomStringConvertible, Codable {
        case string = "STRING"
        case number = "NUMBER"
        public var description: String { return self.rawValue }
    }

    public struct ListCertificatesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "marker", location: .querystring(locationName: "marker"), required: false, type: .string), 
            AWSShapeMember(label: "pageSize", location: .querystring(locationName: "pageSize"), required: false, type: .integer), 
            AWSShapeMember(label: "ascendingOrder", location: .querystring(locationName: "isAscendingOrder"), required: false, type: .boolean)
        ]
        /// The marker for the next set of results.
        public let marker: String?
        /// The result page size.
        public let pageSize: Int32?
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public let ascendingOrder: Bool?

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "marker"
            case pageSize = "pageSize"
            case ascendingOrder = "isAscendingOrder"
        }
    }

    public enum CannedAccessControlList: String, CustomStringConvertible, Codable {
        case `private` = "private"
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        case awsExecRead = "aws-exec-read"
        case authenticatedRead = "authenticated-read"
        case bucketOwnerRead = "bucket-owner-read"
        case bucketOwnerFullControl = "bucket-owner-full-control"
        case logDeliveryWrite = "log-delivery-write"
        public var description: String { return self.rawValue }
    }

    public struct ReplaceTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "topicRulePayload"
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ruleName", location: .uri(locationName: "ruleName"), required: true, type: .string), 
            AWSShapeMember(label: "topicRulePayload", required: true, type: .structure)
        ]
        /// The name of the rule.
        public let ruleName: String
        /// The rule payload.
        public let topicRulePayload: TopicRulePayload

        public init(ruleName: String, topicRulePayload: TopicRulePayload) {
            self.ruleName = ruleName
            self.topicRulePayload = topicRulePayload
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "ruleName"
            case topicRulePayload = "topicRulePayload"
        }
    }

    public struct CloudwatchMetricAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "metricValue", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "metricTimestamp", required: false, type: .string), 
            AWSShapeMember(label: "metricNamespace", required: true, type: .string), 
            AWSShapeMember(label: "metricName", required: true, type: .string), 
            AWSShapeMember(label: "metricUnit", required: true, type: .string)
        ]
        /// The CloudWatch metric value.
        public let metricValue: String
        /// The IAM role that allows access to the CloudWatch metric.
        public let roleArn: String
        /// An optional Unix timestamp.
        public let metricTimestamp: String?
        /// The CloudWatch metric namespace name.
        public let metricNamespace: String
        /// The CloudWatch metric name.
        public let metricName: String
        /// The metric unit supported by CloudWatch.
        public let metricUnit: String

        public init(metricValue: String, roleArn: String, metricTimestamp: String? = nil, metricNamespace: String, metricName: String, metricUnit: String) {
            self.metricValue = metricValue
            self.roleArn = roleArn
            self.metricTimestamp = metricTimestamp
            self.metricNamespace = metricNamespace
            self.metricName = metricName
            self.metricUnit = metricUnit
        }

        private enum CodingKeys: String, CodingKey {
            case metricValue = "metricValue"
            case roleArn = "roleArn"
            case metricTimestamp = "metricTimestamp"
            case metricNamespace = "metricNamespace"
            case metricName = "metricName"
            case metricUnit = "metricUnit"
        }
    }

    public struct RegisterCACertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateId", required: false, type: .string), 
            AWSShapeMember(label: "certificateArn", required: false, type: .string)
        ]
        /// The CA certificate identifier.
        public let certificateId: String?
        /// The CA certificate ARN.
        public let certificateArn: String?

        public init(certificateId: String? = nil, certificateArn: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateId = "certificateId"
            case certificateArn = "certificateArn"
        }
    }

    public struct DescribeThingTypeResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "thingTypeMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "thingTypeName", required: false, type: .string), 
            AWSShapeMember(label: "thingTypeProperties", required: false, type: .structure)
        ]
        /// The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.
        public let thingTypeMetadata: ThingTypeMetadata?
        /// The name of the thing type.
        public let thingTypeName: String?
        /// The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.
        public let thingTypeProperties: ThingTypeProperties?

        public init(thingTypeMetadata: ThingTypeMetadata? = nil, thingTypeName: String? = nil, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        private enum CodingKeys: String, CodingKey {
            case thingTypeMetadata = "thingTypeMetadata"
            case thingTypeName = "thingTypeName"
            case thingTypeProperties = "thingTypeProperties"
        }
    }

    public struct DynamoDBAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "rangeKeyType", required: false, type: .enum), 
            AWSShapeMember(label: "rangeKeyValue", required: false, type: .string), 
            AWSShapeMember(label: "hashKeyValue", required: true, type: .string), 
            AWSShapeMember(label: "operation", required: false, type: .string), 
            AWSShapeMember(label: "payloadField", required: false, type: .string), 
            AWSShapeMember(label: "rangeKeyField", required: false, type: .string), 
            AWSShapeMember(label: "tableName", required: true, type: .string), 
            AWSShapeMember(label: "hashKeyField", required: true, type: .string), 
            AWSShapeMember(label: "hashKeyType", required: false, type: .enum)
        ]
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        public let roleArn: String
        /// The range key type. Valid values are "STRING" or "NUMBER"
        public let rangeKeyType: DynamoKeyType?
        /// The range key value.
        public let rangeKeyValue: String?
        /// The hash key value.
        public let hashKeyValue: String
        /// The type of operation to be performed. This follows the substitution template, so it can be ${operation}, but the substitution must result in one of the following: INSERT, UPDATE, or DELETE.
        public let operation: String?
        /// The action payload. This name can be customized.
        public let payloadField: String?
        /// The range key name.
        public let rangeKeyField: String?
        /// The name of the DynamoDB table.
        public let tableName: String
        /// The hash key name.
        public let hashKeyField: String
        /// The hash key type. Valid values are "STRING" or "NUMBER"
        public let hashKeyType: DynamoKeyType?

        public init(roleArn: String, rangeKeyType: DynamoKeyType? = nil, rangeKeyValue: String? = nil, hashKeyValue: String, operation: String? = nil, payloadField: String? = nil, rangeKeyField: String? = nil, tableName: String, hashKeyField: String, hashKeyType: DynamoKeyType? = nil) {
            self.roleArn = roleArn
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.tableName = tableName
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case rangeKeyType = "rangeKeyType"
            case rangeKeyValue = "rangeKeyValue"
            case hashKeyValue = "hashKeyValue"
            case operation = "operation"
            case payloadField = "payloadField"
            case rangeKeyField = "rangeKeyField"
            case tableName = "tableName"
            case hashKeyField = "hashKeyField"
            case hashKeyType = "hashKeyType"
        }
    }

    public struct AttachThingPrincipalResponse: AWSShape {
        /// The key for the payload

    }

    public struct DeleteThingResponse: AWSShape {
        /// The key for the payload

    }

    public struct DescribeEndpointRequest: AWSShape {
        /// The key for the payload

    }

    public struct DeleteThingRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "expectedVersion", location: .querystring(locationName: "expectedVersion"), required: false, type: .long), 
            AWSShapeMember(label: "thingName", location: .uri(locationName: "thingName"), required: true, type: .string)
        ]
        /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the DeleteThing request is rejected with a VersionConflictException.
        public let expectedVersion: Int64?
        /// The name of the thing to delete.
        public let thingName: String

        public init(expectedVersion: Int64? = nil, thingName: String) {
            self.expectedVersion = expectedVersion
            self.thingName = thingName
        }

        private enum CodingKeys: String, CodingKey {
            case expectedVersion = "expectedVersion"
            case thingName = "thingName"
        }
    }

}