// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Iot {

    public struct DynamoDBv2Action: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        public var roleArn: String? = nil
        /// Specifies the DynamoDB table to which the message data will be written. For example: { "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } } Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        public var putItem: PutItemInput? = nil

        public init() {}

        public init(roleArn: String? = nil, putItem: PutItemInput? = nil) {
            self.roleArn = roleArn
            self.putItem = putItem
        }

        public init(dictionary: [String: Any]) throws {
            self.roleArn = dictionary["roleArn"] as? String
            if let putItem = dictionary["putItem"] as? [String: Any] { self.putItem = try Iot.PutItemInput(dictionary: putItem) }
        }
    }

    public struct CreatePolicyResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy version ID.
        public var policyVersionId: String? = nil
        /// The policy name.
        public var policyName: String? = nil
        /// The policy ARN.
        public var policyArn: String? = nil
        /// The JSON document that describes the policy.
        public var policyDocument: String? = nil

        public init() {}

        public init(policyVersionId: String? = nil, policyName: String? = nil, policyArn: String? = nil, policyDocument: String? = nil) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
            self.policyArn = policyArn
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            self.policyVersionId = dictionary["policyVersionId"] as? String
            self.policyName = dictionary["policyName"] as? String
            self.policyArn = dictionary["policyArn"] as? String
            self.policyDocument = dictionary["policyDocument"] as? String
        }
    }

    public struct TransferCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["targetAwsAccount": "targetAwsAccount"]
        }
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""
        /// The transfer message.
        public var transferMessage: String? = nil
        /// The AWS account.
        public var targetAwsAccount: String = ""

        public init() {}

        public init(certificateId: String, transferMessage: String? = nil, targetAwsAccount: String) {
            self.certificateId = certificateId
            self.transferMessage = transferMessage
            self.targetAwsAccount = targetAwsAccount
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
            self.transferMessage = dictionary["transferMessage"] as? String
            guard let targetAwsAccount = dictionary["targetAwsAccount"] as? String else { throw InitializableError.missingRequiredParam("targetAwsAccount") }
            self.targetAwsAccount = targetAwsAccount
        }
    }

    public struct GetRegistrationCodeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListCertificatesByCARequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        public static var pathParams: [String: String] {
            return ["caCertificateId": "caCertificateId"]
        }
        /// The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate. 
        public var caCertificateId: String = ""
        /// The result page size.
        public var pageSize: Int32? = nil
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public var ascendingOrder: Bool? = nil

        public init() {}

        public init(caCertificateId: String, pageSize: Int32? = nil, marker: String? = nil, ascendingOrder: Bool? = nil) {
            self.caCertificateId = caCertificateId
            self.pageSize = pageSize
            self.marker = marker
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            guard let caCertificateId = dictionary["caCertificateId"] as? String else { throw InitializableError.missingRequiredParam("caCertificateId") }
            self.caCertificateId = caCertificateId
            self.pageSize = dictionary["pageSize"] as? Int32
            self.marker = dictionary["marker"] as? String
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
        }
    }

    public struct Policy: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy ARN.
        public var policyArn: String? = nil
        /// The policy name.
        public var policyName: String? = nil

        public init() {}

        public init(policyArn: String? = nil, policyName: String? = nil) {
            self.policyArn = policyArn
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            self.policyArn = dictionary["policyArn"] as? String
            self.policyName = dictionary["policyName"] as? String
        }
    }

    public struct SetLoggingOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "loggingOptionsPayload"
        /// The logging options payload.
        public var loggingOptionsPayload: LoggingOptionsPayload = LoggingOptionsPayload()

        public init() {}

        public init(loggingOptionsPayload: LoggingOptionsPayload) {
            self.loggingOptionsPayload = loggingOptionsPayload
        }

        public init(dictionary: [String: Any]) throws {
            guard let loggingOptionsPayload = dictionary["loggingOptionsPayload"] as? [String: Any] else { throw InitializableError.missingRequiredParam("loggingOptionsPayload") }
            self.loggingOptionsPayload = try Iot.LoggingOptionsPayload(dictionary: loggingOptionsPayload)
        }
    }

    public struct ListThingTypesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The thing types.
        public var thingTypes: [ThingTypeDefinition]? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public var nextToken: String? = nil

        public init() {}

        public init(thingTypes: [ThingTypeDefinition]? = nil, nextToken: String? = nil) {
            self.thingTypes = thingTypes
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let thingTypes = dictionary["thingTypes"] as? [[String: Any]] {
                self.thingTypes = try thingTypes.map({ try ThingTypeDefinition(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct Action: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Write data to an Amazon Kinesis stream.
        public var kinesis: KinesisAction? = nil
        /// Write data to an Amazon Elasticsearch Service domain.
        public var elasticsearch: ElasticsearchAction? = nil
        /// Publish to an Amazon SQS queue.
        public var sqs: SqsAction? = nil
        /// Capture a CloudWatch metric.
        public var cloudwatchMetric: CloudwatchMetricAction? = nil
        /// Publish to another MQTT topic.
        public var republish: RepublishAction? = nil
        /// Write to an Amazon S3 bucket.
        public var s3: S3Action? = nil
        /// Change the state of a CloudWatch alarm.
        public var cloudwatchAlarm: CloudwatchAlarmAction? = nil
        /// Write to an Amazon Kinesis Firehose stream.
        public var firehose: FirehoseAction? = nil
        /// Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        public var dynamoDBv2: DynamoDBv2Action? = nil
        /// Write to a DynamoDB table.
        public var dynamoDB: DynamoDBAction? = nil
        /// Invoke a Lambda function.
        public var lambda: LambdaAction? = nil
        /// Publish to an Amazon SNS topic.
        public var sns: SnsAction? = nil

        public init() {}

        public init(kinesis: KinesisAction? = nil, elasticsearch: ElasticsearchAction? = nil, sqs: SqsAction? = nil, cloudwatchMetric: CloudwatchMetricAction? = nil, republish: RepublishAction? = nil, s3: S3Action? = nil, cloudwatchAlarm: CloudwatchAlarmAction? = nil, firehose: FirehoseAction? = nil, dynamoDBv2: DynamoDBv2Action? = nil, dynamoDB: DynamoDBAction? = nil, lambda: LambdaAction? = nil, sns: SnsAction? = nil) {
            self.kinesis = kinesis
            self.elasticsearch = elasticsearch
            self.sqs = sqs
            self.cloudwatchMetric = cloudwatchMetric
            self.republish = republish
            self.s3 = s3
            self.cloudwatchAlarm = cloudwatchAlarm
            self.firehose = firehose
            self.dynamoDBv2 = dynamoDBv2
            self.dynamoDB = dynamoDB
            self.lambda = lambda
            self.sns = sns
        }

        public init(dictionary: [String: Any]) throws {
            if let kinesis = dictionary["kinesis"] as? [String: Any] { self.kinesis = try Iot.KinesisAction(dictionary: kinesis) }
            if let elasticsearch = dictionary["elasticsearch"] as? [String: Any] { self.elasticsearch = try Iot.ElasticsearchAction(dictionary: elasticsearch) }
            if let sqs = dictionary["sqs"] as? [String: Any] { self.sqs = try Iot.SqsAction(dictionary: sqs) }
            if let cloudwatchMetric = dictionary["cloudwatchMetric"] as? [String: Any] { self.cloudwatchMetric = try Iot.CloudwatchMetricAction(dictionary: cloudwatchMetric) }
            if let republish = dictionary["republish"] as? [String: Any] { self.republish = try Iot.RepublishAction(dictionary: republish) }
            if let s3 = dictionary["s3"] as? [String: Any] { self.s3 = try Iot.S3Action(dictionary: s3) }
            if let cloudwatchAlarm = dictionary["cloudwatchAlarm"] as? [String: Any] { self.cloudwatchAlarm = try Iot.CloudwatchAlarmAction(dictionary: cloudwatchAlarm) }
            if let firehose = dictionary["firehose"] as? [String: Any] { self.firehose = try Iot.FirehoseAction(dictionary: firehose) }
            if let dynamoDBv2 = dictionary["dynamoDBv2"] as? [String: Any] { self.dynamoDBv2 = try Iot.DynamoDBv2Action(dictionary: dynamoDBv2) }
            if let dynamoDB = dictionary["dynamoDB"] as? [String: Any] { self.dynamoDB = try Iot.DynamoDBAction(dictionary: dynamoDB) }
            if let lambda = dictionary["lambda"] as? [String: Any] { self.lambda = try Iot.LambdaAction(dictionary: lambda) }
            if let sns = dictionary["sns"] as? [String: Any] { self.sns = try Iot.SnsAction(dictionary: sns) }
        }
    }

    public struct DescribeCACertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificate description.
        public var certificateDescription: CACertificateDescription? = nil

        public init() {}

        public init(certificateDescription: CACertificateDescription? = nil) {
            self.certificateDescription = certificateDescription
        }

        public init(dictionary: [String: Any]) throws {
            if let certificateDescription = dictionary["certificateDescription"] as? [String: Any] { self.certificateDescription = try Iot.CACertificateDescription(dictionary: certificateDescription) }
        }
    }

    public struct RepublishAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access.
        public var roleArn: String = ""
        /// The name of the MQTT topic.
        public var topic: String = ""

        public init() {}

        public init(roleArn: String, topic: String) {
            self.roleArn = roleArn
            self.topic = topic
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let topic = dictionary["topic"] as? String else { throw InitializableError.missingRequiredParam("topic") }
            self.topic = topic
        }
    }

    public struct GetTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public var ruleName: String = ""

        public init() {}

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["ruleName"] as? String else { throw InitializableError.missingRequiredParam("ruleName") }
            self.ruleName = ruleName
        }
    }

    public struct ListPolicyPrincipalsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The descriptions of the principals.
        public var principals: [String]? = nil
        /// The marker for the next set of results, or null if there are no additional results.
        public var nextMarker: String? = nil

        public init() {}

        public init(principals: [String]? = nil, nextMarker: String? = nil) {
            self.principals = principals
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let principals = dictionary["principals"] as? [String] {
                self.principals = principals
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ListCertificatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The descriptions of the certificates.
        public var certificates: [Certificate]? = nil
        /// The marker for the next set of results, or null if there are no additional results.
        public var nextMarker: String? = nil

        public init() {}

        public init(certificates: [Certificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let certificates = dictionary["certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try Certificate(dictionary: $0) })
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct RegisterCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["allowAutoRegistration": "allowAutoRegistration", "setAsActive": "setAsActive"]
        }
        /// Allows this CA certificate to be used for auto registration of device certificates.
        public var allowAutoRegistration: Bool? = nil
        /// The private key verification certificate.
        public var verificationCertificate: String = ""
        /// The CA certificate.
        public var caCertificate: String = ""
        /// A boolean value that specifies if the CA certificate is set to active.
        public var setAsActive: Bool? = nil

        public init() {}

        public init(allowAutoRegistration: Bool? = nil, verificationCertificate: String, caCertificate: String, setAsActive: Bool? = nil) {
            self.allowAutoRegistration = allowAutoRegistration
            self.verificationCertificate = verificationCertificate
            self.caCertificate = caCertificate
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            self.allowAutoRegistration = dictionary["allowAutoRegistration"] as? Bool
            guard let verificationCertificate = dictionary["verificationCertificate"] as? String else { throw InitializableError.missingRequiredParam("verificationCertificate") }
            self.verificationCertificate = verificationCertificate
            guard let caCertificate = dictionary["caCertificate"] as? String else { throw InitializableError.missingRequiredParam("caCertificate") }
            self.caCertificate = caCertificate
            self.setAsActive = dictionary["setAsActive"] as? Bool
        }
    }

    public struct DetachThingPrincipalRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public var thingName: String = ""
        /// If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.
        public var principal: String = ""

        public init() {}

        public init(thingName: String, principal: String) {
            self.thingName = thingName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
            guard let principal = dictionary["principal"] as? String else { throw InitializableError.missingRequiredParam("principal") }
            self.principal = principal
        }
    }

    public struct CreateThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the new thing.
        public var thingName: String? = nil
        /// The ARN of the new thing.
        public var thingArn: String? = nil

        public init() {}

        public init(thingName: String? = nil, thingArn: String? = nil) {
            self.thingName = thingName
            self.thingArn = thingArn
        }

        public init(dictionary: [String: Any]) throws {
            self.thingName = dictionary["thingName"] as? String
            self.thingArn = dictionary["thingArn"] as? String
        }
    }

    public struct ListPrincipalThingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public var nextToken: String? = nil
        /// The things.
        public var things: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, things: [String]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let things = dictionary["things"] as? [String] {
                self.things = things
            }
        }
    }

    public struct LoggingOptionsPayload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access.
        public var roleArn: String = ""
        /// The logging level.
        public var logLevel: String? = nil

        public init() {}

        public init(roleArn: String, logLevel: String? = nil) {
            self.roleArn = roleArn
            self.logLevel = logLevel
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            self.logLevel = dictionary["logLevel"] as? String
        }
    }

    public struct ListThingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["attributeValue": "attributeValue", "thingTypeName": "thingTypeName", "nextToken": "nextToken", "maxResults": "maxResults", "attributeName": "attributeName"]
        }
        /// The attribute value used to search for things.
        public var attributeValue: String? = nil
        /// The name of the thing type used to search for things.
        public var thingTypeName: String? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in this operation.
        public var maxResults: Int32? = nil
        /// The attribute name used to search for things.
        public var attributeName: String? = nil

        public init() {}

        public init(attributeValue: String? = nil, thingTypeName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil, attributeName: String? = nil) {
            self.attributeValue = attributeValue
            self.thingTypeName = thingTypeName
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.attributeName = attributeName
        }

        public init(dictionary: [String: Any]) throws {
            self.attributeValue = dictionary["attributeValue"] as? String
            self.thingTypeName = dictionary["thingTypeName"] as? String
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
            self.attributeName = dictionary["attributeName"] as? String
        }
    }

    public struct ThingTypeDefinition: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public var thingTypeMetadata: ThingTypeMetadata? = nil
        /// The name of the thing type.
        public var thingTypeName: String? = nil
        /// The ThingTypeProperties for the thing type.
        public var thingTypeProperties: ThingTypeProperties? = nil

        public init() {}

        public init(thingTypeMetadata: ThingTypeMetadata? = nil, thingTypeName: String? = nil, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        public init(dictionary: [String: Any]) throws {
            if let thingTypeMetadata = dictionary["thingTypeMetadata"] as? [String: Any] { self.thingTypeMetadata = try Iot.ThingTypeMetadata(dictionary: thingTypeMetadata) }
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let thingTypeProperties = dictionary["thingTypeProperties"] as? [String: Any] { self.thingTypeProperties = try Iot.ThingTypeProperties(dictionary: thingTypeProperties) }
        }
    }

    public struct CreateKeysAndCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The generated key pair.
        public var keyPair: KeyPair? = nil
        /// The certificate data, in PEM format.
        public var certificatePem: String? = nil
        /// The ID of the certificate. AWS IoT issues a default subject name for the certificate (for example, AWS IoT Certificate).
        public var certificateId: String? = nil
        /// The ARN of the certificate.
        public var certificateArn: String? = nil

        public init() {}

        public init(keyPair: KeyPair? = nil, certificatePem: String? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.keyPair = keyPair
            self.certificatePem = certificatePem
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            if let keyPair = dictionary["keyPair"] as? [String: Any] { self.keyPair = try Iot.KeyPair(dictionary: keyPair) }
            self.certificatePem = dictionary["certificatePem"] as? String
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct GetTopicRuleResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The rule ARN.
        public var ruleArn: String? = nil
        /// The rule.
        public var rule: TopicRule? = nil

        public init() {}

        public init(ruleArn: String? = nil, rule: TopicRule? = nil) {
            self.ruleArn = ruleArn
            self.rule = rule
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleArn = dictionary["ruleArn"] as? String
            if let rule = dictionary["rule"] as? [String: Any] { self.rule = try Iot.TopicRule(dictionary: rule) }
        }
    }

    public struct CreateThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type.
        public var thingTypeName: String = ""
        /// The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.
        public var thingTypeProperties: ThingTypeProperties? = nil

        public init() {}

        public init(thingTypeName: String, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["thingTypeName"] as? String else { throw InitializableError.missingRequiredParam("thingTypeName") }
            self.thingTypeName = thingTypeName
            if let thingTypeProperties = dictionary["thingTypeProperties"] as? [String: Any] { self.thingTypeProperties = try Iot.ThingTypeProperties(dictionary: thingTypeProperties) }
        }
    }

    public struct DescribeCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["caCertificateId": "certificateId"]
        }
        /// The CA certificate identifier.
        public var certificateId: String = ""

        public init() {}

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
        }
    }

    public struct DescribeCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""

        public init() {}

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
        }
    }

    public struct CreateCertificateFromCsrRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        /// The certificate signing request (CSR).
        public var certificateSigningRequest: String = ""
        /// Specifies whether the certificate is active.
        public var setAsActive: Bool? = nil

        public init() {}

        public init(certificateSigningRequest: String, setAsActive: Bool? = nil) {
            self.certificateSigningRequest = certificateSigningRequest
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateSigningRequest = dictionary["certificateSigningRequest"] as? String else { throw InitializableError.missingRequiredParam("certificateSigningRequest") }
            self.certificateSigningRequest = certificateSigningRequest
            self.setAsActive = dictionary["setAsActive"] as? Bool
        }
    }

    public struct DescribeCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description of the certificate.
        public var certificateDescription: CertificateDescription? = nil

        public init() {}

        public init(certificateDescription: CertificateDescription? = nil) {
            self.certificateDescription = certificateDescription
        }

        public init(dictionary: [String: Any]) throws {
            if let certificateDescription = dictionary["certificateDescription"] as? [String: Any] { self.certificateDescription = try Iot.CertificateDescription(dictionary: certificateDescription) }
        }
    }

    public struct CreateKeysAndCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        /// Specifies whether the certificate is active.
        public var setAsActive: Bool? = nil

        public init() {}

        public init(setAsActive: Bool? = nil) {
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            self.setAsActive = dictionary["setAsActive"] as? Bool
        }
    }

    public struct ListPrincipalPoliciesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policies.
        public var policies: [Policy]? = nil
        /// The marker for the next set of results, or null if there are no additional results.
        public var nextMarker: String? = nil

        public init() {}

        public init(policies: [Policy]? = nil, nextMarker: String? = nil) {
            self.policies = policies
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let policies = dictionary["policies"] as? [[String: Any]] {
                self.policies = try policies.map({ try Policy(dictionary: $0) })
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct DetachPrincipalPolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The name of the policy to detach.
        public var policyName: String = ""
        /// The principal. If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.
        public var principal: String = ""

        public init() {}

        public init(policyName: String, principal: String) {
            self.policyName = policyName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
            guard let principal = dictionary["principal"] as? String else { throw InitializableError.missingRequiredParam("principal") }
            self.principal = principal
        }
    }

    public struct ThingTypeMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Whether the thing type is deprecated. If true, no new things could be associated with this type.
        public var deprecated: Bool? = nil
        /// The date and time when the thing type was deprecated.
        public var deprecationDate: Date? = nil
        /// The date and time when the thing type was created.
        public var creationDate: Date? = nil

        public init() {}

        public init(deprecated: Bool? = nil, deprecationDate: Date? = nil, creationDate: Date? = nil) {
            self.deprecated = deprecated
            self.deprecationDate = deprecationDate
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            self.deprecated = dictionary["deprecated"] as? Bool
            self.deprecationDate = dictionary["deprecationDate"] as? Date
            self.creationDate = dictionary["creationDate"] as? Date
        }
    }

    public struct EnableTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the topic rule to enable.
        public var ruleName: String = ""

        public init() {}

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["ruleName"] as? String else { throw InitializableError.missingRequiredParam("ruleName") }
            self.ruleName = ruleName
        }
    }

    public struct CreatePolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsDefault": "setAsDefault"]
        }
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The policy name.
        public var policyName: String = ""
        /// Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).
        public var setAsDefault: Bool? = nil
        /// The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespaces
        public var policyDocument: String = ""

        public init() {}

        public init(policyName: String, setAsDefault: Bool? = nil, policyDocument: String) {
            self.policyName = policyName
            self.setAsDefault = setAsDefault
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
            self.setAsDefault = dictionary["setAsDefault"] as? Bool
            guard let policyDocument = dictionary["policyDocument"] as? String else { throw InitializableError.missingRequiredParam("policyDocument") }
            self.policyDocument = policyDocument
        }
    }

    public struct KinesisAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        public var roleArn: String = ""
        /// The name of the Amazon Kinesis stream.
        public var streamName: String = ""
        /// The partition key.
        public var partitionKey: String? = nil

        public init() {}

        public init(roleArn: String, streamName: String, partitionKey: String? = nil) {
            self.roleArn = roleArn
            self.streamName = streamName
            self.partitionKey = partitionKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let streamName = dictionary["streamName"] as? String else { throw InitializableError.missingRequiredParam("streamName") }
            self.streamName = streamName
            self.partitionKey = dictionary["partitionKey"] as? String
        }
    }

    public struct SqsAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether to use Base64 encoding.
        public var useBase64: Bool? = nil
        /// The ARN of the IAM role that grants access.
        public var roleArn: String = ""
        /// The URL of the Amazon SQS queue.
        public var queueUrl: String = ""

        public init() {}

        public init(useBase64: Bool? = nil, roleArn: String, queueUrl: String) {
            self.useBase64 = useBase64
            self.roleArn = roleArn
            self.queueUrl = queueUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.useBase64 = dictionary["useBase64"] as? Bool
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let queueUrl = dictionary["queueUrl"] as? String else { throw InitializableError.missingRequiredParam("queueUrl") }
            self.queueUrl = queueUrl
        }
    }

    public struct UpdateThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListThingPrincipalsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public var thingName: String = ""

        public init() {}

        public init(thingName: String) {
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
        }
    }

    public struct SetDefaultPolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyVersionId": "policyVersionId", "policyName": "policyName"]
        }
        /// The policy version ID.
        public var policyVersionId: String = ""
        /// The policy name.
        public var policyName: String = ""

        public init() {}

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyVersionId = dictionary["policyVersionId"] as? String else { throw InitializableError.missingRequiredParam("policyVersionId") }
            self.policyVersionId = policyVersionId
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct UpdateCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["newStatus": "newStatus", "newAutoRegistrationStatus": "newAutoRegistrationStatus"]
        }
        public static var pathParams: [String: String] {
            return ["caCertificateId": "certificateId"]
        }
        /// The CA certificate identifier.
        public var certificateId: String = ""
        /// The updated status of the CA certificate. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var newStatus: String? = nil
        /// The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".
        public var newAutoRegistrationStatus: String? = nil

        public init() {}

        public init(certificateId: String, newStatus: String? = nil, newAutoRegistrationStatus: String? = nil) {
            self.certificateId = certificateId
            self.newStatus = newStatus
            self.newAutoRegistrationStatus = newAutoRegistrationStatus
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
            self.newStatus = dictionary["newStatus"] as? String
            self.newAutoRegistrationStatus = dictionary["newAutoRegistrationStatus"] as? String
        }
    }

    public struct ListPoliciesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The descriptions of the policies.
        public var policies: [Policy]? = nil
        /// The marker for the next set of results, or null if there are no additional results.
        public var nextMarker: String? = nil

        public init() {}

        public init(policies: [Policy]? = nil, nextMarker: String? = nil) {
            self.policies = policies
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let policies = dictionary["policies"] as? [[String: Any]] {
                self.policies = try policies.map({ try Policy(dictionary: $0) })
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ElasticsearchAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM role ARN that has access to Elasticsearch.
        public var roleArn: String = ""
        /// The endpoint of your Elasticsearch domain.
        public var endpoint: String = ""
        /// The unique identifier for the document you are storing.
        public var id: String = ""
        /// The type of document you are storing.
        public var type: String = ""
        /// The Elasticsearch index where you want to store your data.
        public var index: String = ""

        public init() {}

        public init(roleArn: String, endpoint: String, id: String, type: String, index: String) {
            self.roleArn = roleArn
            self.endpoint = endpoint
            self.id = id
            self.type = type
            self.index = index
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let endpoint = dictionary["endpoint"] as? String else { throw InitializableError.missingRequiredParam("endpoint") }
            self.endpoint = endpoint
            guard let id = dictionary["id"] as? String else { throw InitializableError.missingRequiredParam("id") }
            self.id = id
            guard let type = dictionary["type"] as? String else { throw InitializableError.missingRequiredParam("type") }
            self.type = type
            guard let index = dictionary["index"] as? String else { throw InitializableError.missingRequiredParam("index") }
            self.index = index
        }
    }

    public struct ListOutgoingCertificatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The marker for the next set of results.
        public var nextMarker: String? = nil
        /// The certificates that are being transfered but not yet accepted.
        public var outgoingCertificates: [OutgoingCertificate]? = nil

        public init() {}

        public init(nextMarker: String? = nil, outgoingCertificates: [OutgoingCertificate]? = nil) {
            self.nextMarker = nextMarker
            self.outgoingCertificates = outgoingCertificates
        }

        public init(dictionary: [String: Any]) throws {
            self.nextMarker = dictionary["nextMarker"] as? String
            if let outgoingCertificates = dictionary["outgoingCertificates"] as? [[String: Any]] {
                self.outgoingCertificates = try outgoingCertificates.map({ try OutgoingCertificate(dictionary: $0) })
            }
        }
    }

    public struct UpdateCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["newStatus": "newStatus"]
        }
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""
        /// The new status. Note: Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use. Note: The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var newStatus: String = ""

        public init() {}

        public init(certificateId: String, newStatus: String) {
            self.certificateId = certificateId
            self.newStatus = newStatus
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
            guard let newStatus = dictionary["newStatus"] as? String else { throw InitializableError.missingRequiredParam("newStatus") }
            self.newStatus = newStatus
        }
    }

    public struct TopicRuleListItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Bool? = nil
        /// The pattern for the topic names that apply.
        public var topicPattern: String? = nil
        /// The name of the rule.
        public var ruleName: String? = nil
        /// The rule ARN.
        public var ruleArn: String? = nil
        /// The date and time the rule was created.
        public var createdAt: Date? = nil

        public init() {}

        public init(ruleDisabled: Bool? = nil, topicPattern: String? = nil, ruleName: String? = nil, ruleArn: String? = nil, createdAt: Date? = nil) {
            self.ruleDisabled = ruleDisabled
            self.topicPattern = topicPattern
            self.ruleName = ruleName
            self.ruleArn = ruleArn
            self.createdAt = createdAt
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.topicPattern = dictionary["topicPattern"] as? String
            self.ruleName = dictionary["ruleName"] as? String
            self.ruleArn = dictionary["ruleArn"] as? String
            self.createdAt = dictionary["createdAt"] as? Date
        }
    }

    public struct DeleteThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type.
        public var thingTypeName: String = ""

        public init() {}

        public init(thingTypeName: String) {
            self.thingTypeName = thingTypeName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["thingTypeName"] as? String else { throw InitializableError.missingRequiredParam("thingTypeName") }
            self.thingTypeName = thingTypeName
        }
    }

    public struct RegisterCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The certificate identifier.
        public var certificateId: String? = nil
        /// The certificate ARN.
        public var certificateArn: String? = nil

        public init() {}

        public init(certificateId: String? = nil, certificateArn: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct PutItemInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The table where the message data will be written
        public var tableName: String = ""

        public init() {}

        public init(tableName: String) {
            self.tableName = tableName
        }

        public init(dictionary: [String: Any]) throws {
            guard let tableName = dictionary["tableName"] as? String else { throw InitializableError.missingRequiredParam("tableName") }
            self.tableName = tableName
        }
    }

    public struct AttributePayload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether the list of attributes provided in the AttributePayload is merged with the attributes stored in the registry, instead of overwriting them. To remove an attribute, call UpdateThing with an empty attribute value.  The merge attribute is only valid when calling UpdateThing. 
        public var merge: Bool? = nil
        /// A JSON string containing up to three key-value pair in JSON format. For example: {\"attributes\":{\"string1\":\"string2\"}})
        public var attributes: [String: String]? = nil

        public init() {}

        public init(merge: Bool? = nil, attributes: [String: String]? = nil) {
            self.merge = merge
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            self.merge = dictionary["merge"] as? Bool
            if let attributes = dictionary["attributes"] as? [String: String] {
                self.attributes = attributes
            }
        }
    }

    public struct CreatePolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The JSON document that describes the policy. policyDocument must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.
        public var policyDocument: String = ""
        /// The policy name.
        public var policyName: String = ""

        public init() {}

        public init(policyDocument: String, policyName: String) {
            self.policyDocument = policyDocument
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyDocument = dictionary["policyDocument"] as? String else { throw InitializableError.missingRequiredParam("policyDocument") }
            self.policyDocument = policyDocument
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct DeletePolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyVersionId": "policyVersionId", "policyName": "policyName"]
        }
        /// The policy version ID.
        public var policyVersionId: String = ""
        /// The name of the policy.
        public var policyName: String = ""

        public init() {}

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyVersionId = dictionary["policyVersionId"] as? String else { throw InitializableError.missingRequiredParam("policyVersionId") }
            self.policyVersionId = policyVersionId
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct DeleteThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteRegistrationCodeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetLoggingOptionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct LambdaAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the Lambda function.
        public var functionArn: String = ""

        public init() {}

        public init(functionArn: String) {
            self.functionArn = functionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let functionArn = dictionary["functionArn"] as? String else { throw InitializableError.missingRequiredParam("functionArn") }
            self.functionArn = functionArn
        }
    }

    public struct TopicRule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Bool? = nil
        /// The name of the rule.
        public var ruleName: String? = nil
        /// The date and time the rule was created.
        public var createdAt: Date? = nil
        /// The version of the SQL rules engine to use when evaluating the rule.
        public var awsIotSqlVersion: String? = nil
        /// The description of the rule.
        public var description: String? = nil
        /// The actions associated with the rule.
        public var actions: [Action]? = nil
        /// The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.
        public var sql: String? = nil

        public init() {}

        public init(ruleDisabled: Bool? = nil, ruleName: String? = nil, createdAt: Date? = nil, awsIotSqlVersion: String? = nil, description: String? = nil, actions: [Action]? = nil, sql: String? = nil) {
            self.ruleDisabled = ruleDisabled
            self.ruleName = ruleName
            self.createdAt = createdAt
            self.awsIotSqlVersion = awsIotSqlVersion
            self.description = description
            self.actions = actions
            self.sql = sql
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.ruleName = dictionary["ruleName"] as? String
            self.createdAt = dictionary["createdAt"] as? Date
            self.awsIotSqlVersion = dictionary["awsIotSqlVersion"] as? String
            self.description = dictionary["description"] as? String
            if let actions = dictionary["actions"] as? [[String: Any]] {
                self.actions = try actions.map({ try Action(dictionary: $0) })
            }
            self.sql = dictionary["sql"] as? String
        }
    }

    public struct CreateThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing type associated with the new thing.
        public var thingTypeName: String? = nil
        /// The attribute payload, which consists of up to three name/value pairs in a JSON document. For example: {\"attributes\":{\"string1\":\"string2\"}})
        public var attributePayload: AttributePayload? = nil
        /// The name of the thing to create.
        public var thingName: String = ""

        public init() {}

        public init(thingTypeName: String? = nil, attributePayload: AttributePayload? = nil, thingName: String) {
            self.thingTypeName = thingTypeName
            self.attributePayload = attributePayload
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let attributePayload = dictionary["attributePayload"] as? [String: Any] { self.attributePayload = try Iot.AttributePayload(dictionary: attributePayload) }
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
        }
    }

    public struct CertificateDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The certificate ID of the CA certificate used to sign this certificate.
        public var caCertificateId: String? = nil
        /// The status of the certificate.
        public var status: String? = nil
        /// The date and time the certificate was created.
        public var creationDate: Date? = nil
        /// The ID of the certificate.
        public var certificateId: String? = nil
        /// The certificate data, in PEM format.
        public var certificatePem: String? = nil
        /// The ID of the AWS account of the previous owner of the certificate.
        public var previousOwnedBy: String? = nil
        /// The transfer data.
        public var transferData: TransferData? = nil
        /// The ID of the AWS account that owns the certificate.
        public var ownedBy: String? = nil
        /// The ARN of the certificate.
        public var certificateArn: String? = nil
        /// The date and time the certificate was last modified.
        public var lastModifiedDate: Date? = nil

        public init() {}

        public init(caCertificateId: String? = nil, status: String? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificatePem: String? = nil, previousOwnedBy: String? = nil, transferData: TransferData? = nil, ownedBy: String? = nil, certificateArn: String? = nil, lastModifiedDate: Date? = nil) {
            self.caCertificateId = caCertificateId
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificatePem = certificatePem
            self.previousOwnedBy = previousOwnedBy
            self.transferData = transferData
            self.ownedBy = ownedBy
            self.certificateArn = certificateArn
            self.lastModifiedDate = lastModifiedDate
        }

        public init(dictionary: [String: Any]) throws {
            self.caCertificateId = dictionary["caCertificateId"] as? String
            self.status = dictionary["status"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificatePem = dictionary["certificatePem"] as? String
            self.previousOwnedBy = dictionary["previousOwnedBy"] as? String
            if let transferData = dictionary["transferData"] as? [String: Any] { self.transferData = try Iot.TransferData(dictionary: transferData) }
            self.ownedBy = dictionary["ownedBy"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
            self.lastModifiedDate = dictionary["lastModifiedDate"] as? Date
        }
    }

    public struct CloudwatchAlarmAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM role that allows access to the CloudWatch alarm.
        public var roleArn: String = ""
        /// The reason for the alarm change.
        public var stateReason: String = ""
        /// The CloudWatch alarm name.
        public var alarmName: String = ""
        /// The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        public var stateValue: String = ""

        public init() {}

        public init(roleArn: String, stateReason: String, alarmName: String, stateValue: String) {
            self.roleArn = roleArn
            self.stateReason = stateReason
            self.alarmName = alarmName
            self.stateValue = stateValue
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let stateReason = dictionary["stateReason"] as? String else { throw InitializableError.missingRequiredParam("stateReason") }
            self.stateReason = stateReason
            guard let alarmName = dictionary["alarmName"] as? String else { throw InitializableError.missingRequiredParam("alarmName") }
            self.alarmName = alarmName
            guard let stateValue = dictionary["stateValue"] as? String else { throw InitializableError.missingRequiredParam("stateValue") }
            self.stateValue = stateValue
        }
    }

    public struct DisableTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule to disable.
        public var ruleName: String = ""

        public init() {}

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["ruleName"] as? String else { throw InitializableError.missingRequiredParam("ruleName") }
            self.ruleName = ruleName
        }
    }

    public struct ListPrincipalThingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-principal": "principal"]
        }
        public static var queryParams: [String: String] {
            return ["maxResults": "maxResults", "nextToken": "nextToken"]
        }
        /// The maximum number of results to return in this operation.
        public var maxResults: Int32? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public var nextToken: String? = nil
        /// The principal.
        public var principal: String = ""

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil, principal: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
            guard let principal = dictionary["principal"] as? String else { throw InitializableError.missingRequiredParam("principal") }
            self.principal = principal
        }
    }

    public struct CreateTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "topicRulePayload"
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public var ruleName: String = ""
        /// The rule payload.
        public var topicRulePayload: TopicRulePayload = TopicRulePayload()

        public init() {}

        public init(ruleName: String, topicRulePayload: TopicRulePayload) {
            self.ruleName = ruleName
            self.topicRulePayload = topicRulePayload
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["ruleName"] as? String else { throw InitializableError.missingRequiredParam("ruleName") }
            self.ruleName = ruleName
            guard let topicRulePayload = dictionary["topicRulePayload"] as? [String: Any] else { throw InitializableError.missingRequiredParam("topicRulePayload") }
            self.topicRulePayload = try Iot.TopicRulePayload(dictionary: topicRulePayload)
        }
    }

    public struct DeleteCACertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["caCertificateId": "certificateId"]
        }
        /// The ID of the certificate to delete.
        public var certificateId: String = ""

        public init() {}

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
        }
    }

    public struct CACertificate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the CA certificate.  The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var status: String? = nil
        /// The date the CA certificate was created.
        public var creationDate: Date? = nil
        /// The ID of the CA certificate.
        public var certificateId: String? = nil
        /// The ARN of the CA certificate.
        public var certificateArn: String? = nil

        public init() {}

        public init(status: String? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["status"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct ListPolicyVersionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The policy name.
        public var policyName: String = ""

        public init() {}

        public init(policyName: String) {
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct ListPolicyPrincipalsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-policy": "policyName"]
        }
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// The result page size.
        public var pageSize: Int32? = nil
        /// The policy name.
        public var policyName: String = ""
        /// Specifies the order for results. If true, the results are returned in ascending creation order.
        public var ascendingOrder: Bool? = nil

        public init() {}

        public init(marker: String? = nil, pageSize: Int32? = nil, policyName: String, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.policyName = policyName
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["marker"] as? String
            self.pageSize = dictionary["pageSize"] as? Int32
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
        }
    }

    public struct PolicyVersion: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date and time the policy was created.
        public var createDate: Date? = nil
        /// The policy version ID.
        public var versionId: String? = nil
        /// Specifies whether the policy version is the default.
        public var isDefaultVersion: Bool? = nil

        public init() {}

        public init(createDate: Date? = nil, versionId: String? = nil, isDefaultVersion: Bool? = nil) {
            self.createDate = createDate
            self.versionId = versionId
            self.isDefaultVersion = isDefaultVersion
        }

        public init(dictionary: [String: Any]) throws {
            self.createDate = dictionary["createDate"] as? Date
            self.versionId = dictionary["versionId"] as? String
            self.isDefaultVersion = dictionary["isDefaultVersion"] as? Bool
        }
    }

    public struct AttachThingPrincipalRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public var thingName: String = ""
        /// The principal, such as a certificate or other credential.
        public var principal: String = ""

        public init() {}

        public init(thingName: String, principal: String) {
            self.thingName = thingName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
            guard let principal = dictionary["principal"] as? String else { throw InitializableError.missingRequiredParam("principal") }
            self.principal = principal
        }
    }

    public struct DeleteCACertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetRegistrationCodeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificate registration code.
        public var registrationCode: String? = nil

        public init() {}

        public init(registrationCode: String? = nil) {
            self.registrationCode = registrationCode
        }

        public init(dictionary: [String: Any]) throws {
            self.registrationCode = dictionary["registrationCode"] as? String
        }
    }

    public struct ListCertificatesByCAResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device certificates signed by the specified CA certificate.
        public var certificates: [Certificate]? = nil
        /// The marker for the next set of results, or null if there are no additional results.
        public var nextMarker: String? = nil

        public init() {}

        public init(certificates: [Certificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let certificates = dictionary["certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try Certificate(dictionary: $0) })
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ListPoliciesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// The result page size.
        public var pageSize: Int32? = nil
        /// Specifies the order for results. If true, the results are returned in ascending creation order.
        public var ascendingOrder: Bool? = nil

        public init() {}

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["marker"] as? String
            self.pageSize = dictionary["pageSize"] as? Int32
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
        }
    }

    public struct ListCACertificatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// The result page size.
        public var pageSize: Int32? = nil
        /// Determines the order of the results.
        public var ascendingOrder: Bool? = nil

        public init() {}

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["marker"] as? String
            self.pageSize = dictionary["pageSize"] as? Int32
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
        }
    }

    public struct DeprecateThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type to deprecate.
        public var thingTypeName: String = ""
        /// Whether to undeprecate a deprecated thing type. If true, the thing type will not be deprecated anymore and you can associate it with things.
        public var undoDeprecate: Bool? = nil

        public init() {}

        public init(thingTypeName: String, undoDeprecate: Bool? = nil) {
            self.thingTypeName = thingTypeName
            self.undoDeprecate = undoDeprecate
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["thingTypeName"] as? String else { throw InitializableError.missingRequiredParam("thingTypeName") }
            self.thingTypeName = thingTypeName
            self.undoDeprecate = dictionary["undoDeprecate"] as? Bool
        }
    }

    public struct TopicRulePayload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The version of the SQL rules engine to use when evaluating the rule.
        public var awsIotSqlVersion: String? = nil
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Bool? = nil
        /// The description of the rule.
        public var description: String? = nil
        /// The actions associated with the rule.
        public var actions: [Action] = []
        /// The SQL statement used to query the topic. For more information, see AWS IoT SQL Reference in the AWS IoT Developer Guide.
        public var sql: String = ""

        public init() {}

        public init(awsIotSqlVersion: String? = nil, ruleDisabled: Bool? = nil, description: String? = nil, actions: [Action], sql: String) {
            self.awsIotSqlVersion = awsIotSqlVersion
            self.ruleDisabled = ruleDisabled
            self.description = description
            self.actions = actions
            self.sql = sql
        }

        public init(dictionary: [String: Any]) throws {
            self.awsIotSqlVersion = dictionary["awsIotSqlVersion"] as? String
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.description = dictionary["description"] as? String
            guard let actions = dictionary["actions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("actions") }
            self.actions = try actions.map({ try Action(dictionary: $0) })
            guard let sql = dictionary["sql"] as? String else { throw InitializableError.missingRequiredParam("sql") }
            self.sql = sql
        }
    }

    public struct SnsAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The message format of the message to publish. Optional. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see  refer to their official documentation.
        public var messageFormat: String? = nil
        /// The ARN of the IAM role that grants access.
        public var roleArn: String = ""
        /// The ARN of the SNS topic.
        public var targetArn: String = ""

        public init() {}

        public init(messageFormat: String? = nil, roleArn: String, targetArn: String) {
            self.messageFormat = messageFormat
            self.roleArn = roleArn
            self.targetArn = targetArn
        }

        public init(dictionary: [String: Any]) throws {
            self.messageFormat = dictionary["messageFormat"] as? String
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let targetArn = dictionary["targetArn"] as? String else { throw InitializableError.missingRequiredParam("targetArn") }
            self.targetArn = targetArn
        }
    }

    public struct KeyPair: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The public key.
        public var publicKey: String? = nil
        /// The private key.
        public var privateKey: String? = nil

        public init() {}

        public init(publicKey: String? = nil, privateKey: String? = nil) {
            self.publicKey = publicKey
            self.privateKey = privateKey
        }

        public init(dictionary: [String: Any]) throws {
            self.publicKey = dictionary["PublicKey"] as? String
            self.privateKey = dictionary["PrivateKey"] as? String
        }
    }

    public struct DeleteRegistrationCodeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListPolicyVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy versions.
        public var policyVersions: [PolicyVersion]? = nil

        public init() {}

        public init(policyVersions: [PolicyVersion]? = nil) {
            self.policyVersions = policyVersions
        }

        public init(dictionary: [String: Any]) throws {
            if let policyVersions = dictionary["policyVersions"] as? [[String: Any]] {
                self.policyVersions = try policyVersions.map({ try PolicyVersion(dictionary: $0) })
            }
        }
    }

    public struct GetPolicyVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The JSON document that describes the policy.
        public var policyDocument: String? = nil
        /// The policy version ID.
        public var policyVersionId: String? = nil
        /// The policy name.
        public var policyName: String? = nil
        /// Specifies whether the policy version is the default.
        public var isDefaultVersion: Bool? = nil
        /// The policy ARN.
        public var policyArn: String? = nil

        public init() {}

        public init(policyDocument: String? = nil, policyVersionId: String? = nil, policyName: String? = nil, isDefaultVersion: Bool? = nil, policyArn: String? = nil) {
            self.policyDocument = policyDocument
            self.policyVersionId = policyVersionId
            self.policyName = policyName
            self.isDefaultVersion = isDefaultVersion
            self.policyArn = policyArn
        }

        public init(dictionary: [String: Any]) throws {
            self.policyDocument = dictionary["policyDocument"] as? String
            self.policyVersionId = dictionary["policyVersionId"] as? String
            self.policyName = dictionary["policyName"] as? String
            self.isDefaultVersion = dictionary["isDefaultVersion"] as? Bool
            self.policyArn = dictionary["policyArn"] as? String
        }
    }

    public struct ListThingTypesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["thingTypeName": "thingTypeName", "nextToken": "nextToken", "maxResults": "maxResults"]
        }
        /// The name of the thing type.
        public var thingTypeName: String? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public var nextToken: String? = nil
        /// The maximum number of results to return in this operation.
        public var maxResults: Int32? = nil

        public init() {}

        public init(thingTypeName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.thingTypeName = thingTypeName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeName = dictionary["thingTypeName"] as? String
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
        }
    }

    public struct CreateThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the thing type.
        public var thingTypeName: String? = nil
        /// The Amazon Resource Name (ARN) of the thing type.
        public var thingTypeArn: String? = nil

        public init() {}

        public init(thingTypeName: String? = nil, thingTypeArn: String? = nil) {
            self.thingTypeName = thingTypeName
            self.thingTypeArn = thingTypeArn
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeName = dictionary["thingTypeName"] as? String
            self.thingTypeArn = dictionary["thingTypeArn"] as? String
        }
    }

    public struct DeleteTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public var ruleName: String = ""

        public init() {}

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["ruleName"] as? String else { throw InitializableError.missingRequiredParam("ruleName") }
            self.ruleName = ruleName
        }
    }

    public struct GetPolicyVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyVersionId": "policyVersionId", "policyName": "policyName"]
        }
        /// The policy version ID.
        public var policyVersionId: String = ""
        /// The name of the policy.
        public var policyName: String = ""

        public init() {}

        public init(policyVersionId: String, policyName: String) {
            self.policyVersionId = policyVersionId
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyVersionId = dictionary["policyVersionId"] as? String else { throw InitializableError.missingRequiredParam("policyVersionId") }
            self.policyVersionId = policyVersionId
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct ListTopicRulesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The rules.
        public var rules: [TopicRuleListItem]? = nil
        /// A token used to retrieve the next value.
        public var nextToken: String? = nil

        public init() {}

        public init(rules: [TopicRuleListItem]? = nil, nextToken: String? = nil) {
            self.rules = rules
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let rules = dictionary["rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try TopicRuleListItem(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct S3Action: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon S3 bucket.
        public var bucketName: String = ""
        /// The ARN of the IAM role that grants access.
        public var roleArn: String = ""
        /// The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see S3 canned ACLs.
        public var cannedAcl: String? = nil
        /// The object key.
        public var key: String = ""

        public init() {}

        public init(bucketName: String, roleArn: String, cannedAcl: String? = nil, key: String) {
            self.bucketName = bucketName
            self.roleArn = roleArn
            self.cannedAcl = cannedAcl
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            guard let bucketName = dictionary["bucketName"] as? String else { throw InitializableError.missingRequiredParam("bucketName") }
            self.bucketName = bucketName
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            self.cannedAcl = dictionary["cannedAcl"] as? String
            guard let key = dictionary["key"] as? String else { throw InitializableError.missingRequiredParam("key") }
            self.key = key
        }
    }

    public struct OutgoingCertificate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The transfer message.
        public var transferMessage: String? = nil
        /// The certificate creation date.
        public var creationDate: Date? = nil
        /// The certificate ID.
        public var certificateId: String? = nil
        /// The certificate ARN.
        public var certificateArn: String? = nil
        /// The AWS account to which the transfer was made.
        public var transferredTo: String? = nil
        /// The date the transfer was initiated.
        public var transferDate: Date? = nil

        public init() {}

        public init(transferMessage: String? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificateArn: String? = nil, transferredTo: String? = nil, transferDate: Date? = nil) {
            self.transferMessage = transferMessage
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
            self.transferredTo = transferredTo
            self.transferDate = transferDate
        }

        public init(dictionary: [String: Any]) throws {
            self.transferMessage = dictionary["transferMessage"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
            self.transferredTo = dictionary["transferredTo"] as? String
            self.transferDate = dictionary["transferDate"] as? Date
        }
    }

    public struct CreateCertificateFromCsrResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the certificate. Certificate management operations only take a certificateId.
        public var certificateId: String? = nil
        /// The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.
        public var certificateArn: String? = nil
        /// The certificate data, in PEM format.
        public var certificatePem: String? = nil

        public init() {}

        public init(certificateId: String? = nil, certificateArn: String? = nil, certificatePem: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
            self.certificatePem = certificatePem
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
            self.certificatePem = dictionary["certificatePem"] as? String
        }
    }

    public struct TransferCertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the certificate.
        public var transferredCertificateArn: String? = nil

        public init() {}

        public init(transferredCertificateArn: String? = nil) {
            self.transferredCertificateArn = transferredCertificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.transferredCertificateArn = dictionary["transferredCertificateArn"] as? String
        }
    }

    public struct FirehoseAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The IAM role that grants access to the Amazon Kinesis Firehost stream.
        public var roleArn: String = ""
        /// The delivery stream name.
        public var deliveryStreamName: String = ""
        /// A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
        public var separator: String? = nil

        public init() {}

        public init(roleArn: String, deliveryStreamName: String, separator: String? = nil) {
            self.roleArn = roleArn
            self.deliveryStreamName = deliveryStreamName
            self.separator = separator
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            guard let deliveryStreamName = dictionary["deliveryStreamName"] as? String else { throw InitializableError.missingRequiredParam("deliveryStreamName") }
            self.deliveryStreamName = deliveryStreamName
            self.separator = dictionary["separator"] as? String
        }
    }

    public struct CreatePolicyVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy ARN.
        public var policyArn: String? = nil
        /// The policy version ID.
        public var policyVersionId: String? = nil
        /// Specifies whether the policy version is the default.
        public var isDefaultVersion: Bool? = nil
        /// The JSON document that describes the policy.
        public var policyDocument: String? = nil

        public init() {}

        public init(policyArn: String? = nil, policyVersionId: String? = nil, isDefaultVersion: Bool? = nil, policyDocument: String? = nil) {
            self.policyArn = policyArn
            self.policyVersionId = policyVersionId
            self.isDefaultVersion = isDefaultVersion
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            self.policyArn = dictionary["policyArn"] as? String
            self.policyVersionId = dictionary["policyVersionId"] as? String
            self.isDefaultVersion = dictionary["isDefaultVersion"] as? Bool
            self.policyDocument = dictionary["policyDocument"] as? String
        }
    }

    public struct AcceptCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""
        /// Specifies whether the certificate is active.
        public var setAsActive: Bool? = nil

        public init() {}

        public init(certificateId: String, setAsActive: Bool? = nil) {
            self.certificateId = certificateId
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
            self.setAsActive = dictionary["setAsActive"] as? Bool
        }
    }

    public struct CancelCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""

        public init() {}

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
        }
    }

    public struct DeleteCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""

        public init() {}

        public init(certificateId: String) {
            self.certificateId = certificateId
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
        }
    }

    public struct DetachThingPrincipalResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The endpoint. The format of the endpoint is as follows: identifier.iot.region.amazonaws.com.
        public var endpointAddress: String? = nil

        public init() {}

        public init(endpointAddress: String? = nil) {
            self.endpointAddress = endpointAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.endpointAddress = dictionary["endpointAddress"] as? String
        }
    }

    public struct RejectCertificateTransferRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["certificateId": "certificateId"]
        }
        /// The ID of the certificate.
        public var certificateId: String = ""
        /// The reason the certificate transfer was rejected.
        public var rejectReason: String? = nil

        public init() {}

        public init(certificateId: String, rejectReason: String? = nil) {
            self.certificateId = certificateId
            self.rejectReason = rejectReason
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateId = dictionary["certificateId"] as? String else { throw InitializableError.missingRequiredParam("certificateId") }
            self.certificateId = certificateId
            self.rejectReason = dictionary["rejectReason"] as? String
        }
    }

    public struct TransferData: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The date the transfer was rejected.
        public var rejectDate: Date? = nil
        /// The date the transfer was accepted.
        public var acceptDate: Date? = nil
        /// The transfer message.
        public var transferMessage: String? = nil
        /// The date the transfer took place.
        public var transferDate: Date? = nil
        /// The reason why the transfer was rejected.
        public var rejectReason: String? = nil

        public init() {}

        public init(rejectDate: Date? = nil, acceptDate: Date? = nil, transferMessage: String? = nil, transferDate: Date? = nil, rejectReason: String? = nil) {
            self.rejectDate = rejectDate
            self.acceptDate = acceptDate
            self.transferMessage = transferMessage
            self.transferDate = transferDate
            self.rejectReason = rejectReason
        }

        public init(dictionary: [String: Any]) throws {
            self.rejectDate = dictionary["rejectDate"] as? Date
            self.acceptDate = dictionary["acceptDate"] as? Date
            self.transferMessage = dictionary["transferMessage"] as? String
            self.transferDate = dictionary["transferDate"] as? Date
            self.rejectReason = dictionary["rejectReason"] as? String
        }
    }

    public struct GetPolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The name of the policy.
        public var policyName: String = ""

        public init() {}

        public init(policyName: String) {
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct Certificate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of the certificate. The status value REGISTER_INACTIVE is deprecated and should not be used.
        public var status: String? = nil
        /// The date and time the certificate was created.
        public var creationDate: Date? = nil
        /// The ID of the certificate.
        public var certificateId: String? = nil
        /// The ARN of the certificate.
        public var certificateArn: String? = nil

        public init() {}

        public init(status: String? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["status"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct RegisterCertificateRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["setAsActive": "setAsActive"]
        }
        /// The CA certificate used to sign the device certificate being registered.
        public var caCertificatePem: String? = nil
        public var status: String? = nil
        /// The certificate data, in PEM format.
        public var certificatePem: String = ""
        /// A boolean value that specifies if the CA certificate is set to active.
        public var setAsActive: Bool? = nil

        public init() {}

        public init(caCertificatePem: String? = nil, status: String? = nil, certificatePem: String, setAsActive: Bool? = nil) {
            self.caCertificatePem = caCertificatePem
            self.status = status
            self.certificatePem = certificatePem
            self.setAsActive = setAsActive
        }

        public init(dictionary: [String: Any]) throws {
            self.caCertificatePem = dictionary["caCertificatePem"] as? String
            self.status = dictionary["status"] as? String
            guard let certificatePem = dictionary["certificatePem"] as? String else { throw InitializableError.missingRequiredParam("certificatePem") }
            self.certificatePem = certificatePem
            self.setAsActive = dictionary["setAsActive"] as? Bool
        }
    }

    public struct ListThingPrincipalsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The principals associated with the thing.
        public var principals: [String]? = nil

        public init() {}

        public init(principals: [String]? = nil) {
            self.principals = principals
        }

        public init(dictionary: [String: Any]) throws {
            if let principals = dictionary["principals"] as? [String] {
                self.principals = principals
            }
        }
    }

    public struct GetLoggingOptionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access.
        public var roleArn: String? = nil
        /// The logging level.
        public var logLevel: String? = nil

        public init() {}

        public init(roleArn: String? = nil, logLevel: String? = nil) {
            self.roleArn = roleArn
            self.logLevel = logLevel
        }

        public init(dictionary: [String: Any]) throws {
            self.roleArn = dictionary["roleArn"] as? String
            self.logLevel = dictionary["logLevel"] as? String
        }
    }

    public struct ListOutgoingCertificatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// The result page size.
        public var pageSize: Int32? = nil
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public var ascendingOrder: Bool? = nil

        public init() {}

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["marker"] as? String
            self.pageSize = dictionary["pageSize"] as? Int32
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
        }
    }

    public struct ListCACertificatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificates registered in your AWS account.
        public var certificates: [CACertificate]? = nil
        /// The current position within the list of CA certificates.
        public var nextMarker: String? = nil

        public init() {}

        public init(certificates: [CACertificate]? = nil, nextMarker: String? = nil) {
            self.certificates = certificates
            self.nextMarker = nextMarker
        }

        public init(dictionary: [String: Any]) throws {
            if let certificates = dictionary["certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try CACertificate(dictionary: $0) })
            }
            self.nextMarker = dictionary["nextMarker"] as? String
        }
    }

    public struct ThingTypeProperties: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The description of the thing type.
        public var thingTypeDescription: String? = nil
        /// A list of searchable thing attribute names.
        public var searchableAttributes: [String]? = nil

        public init() {}

        public init(thingTypeDescription: String? = nil, searchableAttributes: [String]? = nil) {
            self.thingTypeDescription = thingTypeDescription
            self.searchableAttributes = searchableAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.thingTypeDescription = dictionary["thingTypeDescription"] as? String
            if let searchableAttributes = dictionary["searchableAttributes"] as? [String] {
                self.searchableAttributes = searchableAttributes
            }
        }
    }

    public struct GetPolicyResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The policy name.
        public var policyName: String? = nil
        /// The default policy version ID.
        public var defaultVersionId: String? = nil
        /// The policy ARN.
        public var policyArn: String? = nil
        /// The JSON document that describes the policy.
        public var policyDocument: String? = nil

        public init() {}

        public init(policyName: String? = nil, defaultVersionId: String? = nil, policyArn: String? = nil, policyDocument: String? = nil) {
            self.policyName = policyName
            self.defaultVersionId = defaultVersionId
            self.policyArn = policyArn
            self.policyDocument = policyDocument
        }

        public init(dictionary: [String: Any]) throws {
            self.policyName = dictionary["policyName"] as? String
            self.defaultVersionId = dictionary["defaultVersionId"] as? String
            self.policyArn = dictionary["policyArn"] as? String
            self.policyDocument = dictionary["policyDocument"] as? String
        }
    }

    public struct ListThingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The token for the next set of results, or null if there are no additional results.
        public var nextToken: String? = nil
        /// The things.
        public var things: [ThingAttribute]? = nil

        public init() {}

        public init(nextToken: String? = nil, things: [ThingAttribute]? = nil) {
            self.nextToken = nextToken
            self.things = things
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let things = dictionary["things"] as? [[String: Any]] {
                self.things = try things.map({ try ThingAttribute(dictionary: $0) })
            }
        }
    }

    public struct ListPrincipalPoliciesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-principal": "principal"]
        }
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// The result page size.
        public var pageSize: Int32? = nil
        /// Specifies the order for results. If true, results are returned in ascending creation order.
        public var ascendingOrder: Bool? = nil
        /// The principal.
        public var principal: String = ""

        public init() {}

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil, principal: String) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["marker"] as? String
            self.pageSize = dictionary["pageSize"] as? Int32
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
            guard let principal = dictionary["principal"] as? String else { throw InitializableError.missingRequiredParam("principal") }
            self.principal = principal
        }
    }

    public struct ThingAttribute: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the thing.
        public var thingName: String? = nil
        /// The name of the thing type, if the thing has been associated with a type.
        public var thingTypeName: String? = nil
        /// A list of thing attributes which are name-value pairs.
        public var attributes: [String: String]? = nil
        /// The version of the thing record in the registry.
        public var version: Int64? = nil

        public init() {}

        public init(thingName: String? = nil, thingTypeName: String? = nil, attributes: [String: String]? = nil, version: Int64? = nil) {
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.attributes = attributes
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.thingName = dictionary["thingName"] as? String
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let attributes = dictionary["attributes"] as? [String: String] {
                self.attributes = attributes
            }
            self.version = dictionary["version"] as? Int64
        }
    }

    public struct DeletePolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The name of the policy to delete.
        public var policyName: String = ""

        public init() {}

        public init(policyName: String) {
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
        }
    }

    public struct DescribeThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The name of the thing.
        public var thingName: String = ""

        public init() {}

        public init(thingName: String) {
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
        }
    }

    public struct CACertificateDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The status of a CA certificate.
        public var status: String? = nil
        /// Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"
        public var autoRegistrationStatus: String? = nil
        /// The date the CA certificate was created.
        public var creationDate: Date? = nil
        /// The CA certificate ID.
        public var certificateId: String? = nil
        /// The CA certificate data, in PEM format.
        public var certificatePem: String? = nil
        /// The owner of the CA certificate.
        public var ownedBy: String? = nil
        /// The CA certificate ARN.
        public var certificateArn: String? = nil

        public init() {}

        public init(status: String? = nil, autoRegistrationStatus: String? = nil, creationDate: Date? = nil, certificateId: String? = nil, certificatePem: String? = nil, ownedBy: String? = nil, certificateArn: String? = nil) {
            self.status = status
            self.autoRegistrationStatus = autoRegistrationStatus
            self.creationDate = creationDate
            self.certificateId = certificateId
            self.certificatePem = certificatePem
            self.ownedBy = ownedBy
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["status"] as? String
            self.autoRegistrationStatus = dictionary["autoRegistrationStatus"] as? String
            self.creationDate = dictionary["creationDate"] as? Date
            self.certificateId = dictionary["certificateId"] as? String
            self.certificatePem = dictionary["certificatePem"] as? String
            self.ownedBy = dictionary["ownedBy"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct ListTopicRulesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["ruleDisabled": "ruleDisabled", "maxResults": "maxResults", "nextToken": "nextToken", "topic": "topic"]
        }
        /// Specifies whether the rule is disabled.
        public var ruleDisabled: Bool? = nil
        /// The maximum number of results to return.
        public var maxResults: Int32? = nil
        /// A token used to retrieve the next value.
        public var nextToken: String? = nil
        /// The topic.
        public var topic: String? = nil

        public init() {}

        public init(ruleDisabled: Bool? = nil, maxResults: Int32? = nil, nextToken: String? = nil, topic: String? = nil) {
            self.ruleDisabled = ruleDisabled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.topic = topic
        }

        public init(dictionary: [String: Any]) throws {
            self.ruleDisabled = dictionary["ruleDisabled"] as? Bool
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
            self.topic = dictionary["topic"] as? String
        }
    }

    public struct DescribeThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The default client ID.
        public var defaultClientId: String? = nil
        /// The name of the thing.
        public var thingName: String? = nil
        /// The thing type name.
        public var thingTypeName: String? = nil
        /// The thing attributes.
        public var attributes: [String: String]? = nil
        /// The current version of the thing record in the registry.  To avoid unintentional changes to the information in the registry, you can pass the version information in the expectedVersion parameter of the UpdateThing and DeleteThing calls. 
        public var version: Int64? = nil

        public init() {}

        public init(defaultClientId: String? = nil, thingName: String? = nil, thingTypeName: String? = nil, attributes: [String: String]? = nil, version: Int64? = nil) {
            self.defaultClientId = defaultClientId
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.attributes = attributes
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultClientId = dictionary["defaultClientId"] as? String
            self.thingName = dictionary["thingName"] as? String
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let attributes = dictionary["attributes"] as? [String: String] {
                self.attributes = attributes
            }
            self.version = dictionary["version"] as? Int64
        }
    }

    public struct DescribeThingTypeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingTypeName": "thingTypeName"]
        }
        /// The name of the thing type.
        public var thingTypeName: String = ""

        public init() {}

        public init(thingTypeName: String) {
            self.thingTypeName = thingTypeName
        }

        public init(dictionary: [String: Any]) throws {
            guard let thingTypeName = dictionary["thingTypeName"] as? String else { throw InitializableError.missingRequiredParam("thingTypeName") }
            self.thingTypeName = thingTypeName
        }
    }

    public struct AttachPrincipalPolicyRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var headerParams: [String: String] {
            return ["x-amzn-iot-principal": "principal"]
        }
        public static var pathParams: [String: String] {
            return ["policyName": "policyName"]
        }
        /// The policy name.
        public var policyName: String = ""
        /// The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.
        public var principal: String = ""

        public init() {}

        public init(policyName: String, principal: String) {
            self.policyName = policyName
            self.principal = principal
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyName = dictionary["policyName"] as? String else { throw InitializableError.missingRequiredParam("policyName") }
            self.policyName = policyName
            guard let principal = dictionary["principal"] as? String else { throw InitializableError.missingRequiredParam("principal") }
            self.principal = principal
        }
    }

    public struct UpdateThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// Remove a thing type association. If true, the assocation is removed.
        public var removeThingType: Bool? = nil
        /// The name of the thing to update.
        public var thingName: String = ""
        /// The name of the thing type.
        public var thingTypeName: String? = nil
        /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the UpdateThing request is rejected with a VersionConflictException.
        public var expectedVersion: Int64? = nil
        /// A list of thing attributes, a JSON string containing name-value pairs. For example: {\"attributes\":{\"name1\":\"value2\"}}) This data is used to add new attributes or update existing attributes.
        public var attributePayload: AttributePayload? = nil

        public init() {}

        public init(removeThingType: Bool? = nil, thingName: String, thingTypeName: String? = nil, expectedVersion: Int64? = nil, attributePayload: AttributePayload? = nil) {
            self.removeThingType = removeThingType
            self.thingName = thingName
            self.thingTypeName = thingTypeName
            self.expectedVersion = expectedVersion
            self.attributePayload = attributePayload
        }

        public init(dictionary: [String: Any]) throws {
            self.removeThingType = dictionary["removeThingType"] as? Bool
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
            self.thingTypeName = dictionary["thingTypeName"] as? String
            self.expectedVersion = dictionary["expectedVersion"] as? Int64
            if let attributePayload = dictionary["attributePayload"] as? [String: Any] { self.attributePayload = try Iot.AttributePayload(dictionary: attributePayload) }
        }
    }

    public struct DeprecateThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListCertificatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["marker": "marker", "pageSize": "pageSize", "isAscendingOrder": "ascendingOrder"]
        }
        /// The marker for the next set of results.
        public var marker: String? = nil
        /// The result page size.
        public var pageSize: Int32? = nil
        /// Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.
        public var ascendingOrder: Bool? = nil

        public init() {}

        public init(marker: String? = nil, pageSize: Int32? = nil, ascendingOrder: Bool? = nil) {
            self.marker = marker
            self.pageSize = pageSize
            self.ascendingOrder = ascendingOrder
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["marker"] as? String
            self.pageSize = dictionary["pageSize"] as? Int32
            self.ascendingOrder = dictionary["ascendingOrder"] as? Bool
        }
    }

    public struct ReplaceTopicRuleRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "topicRulePayload"
        public static var pathParams: [String: String] {
            return ["ruleName": "ruleName"]
        }
        /// The name of the rule.
        public var ruleName: String = ""
        /// The rule payload.
        public var topicRulePayload: TopicRulePayload = TopicRulePayload()

        public init() {}

        public init(ruleName: String, topicRulePayload: TopicRulePayload) {
            self.ruleName = ruleName
            self.topicRulePayload = topicRulePayload
        }

        public init(dictionary: [String: Any]) throws {
            guard let ruleName = dictionary["ruleName"] as? String else { throw InitializableError.missingRequiredParam("ruleName") }
            self.ruleName = ruleName
            guard let topicRulePayload = dictionary["topicRulePayload"] as? [String: Any] else { throw InitializableError.missingRequiredParam("topicRulePayload") }
            self.topicRulePayload = try Iot.TopicRulePayload(dictionary: topicRulePayload)
        }
    }

    public struct CloudwatchMetricAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CloudWatch metric value.
        public var metricValue: String = ""
        /// The IAM role that allows access to the CloudWatch metric.
        public var roleArn: String = ""
        /// An optional Unix timestamp.
        public var metricTimestamp: String? = nil
        /// The CloudWatch metric namespace name.
        public var metricNamespace: String = ""
        /// The CloudWatch metric name.
        public var metricName: String = ""
        /// The metric unit supported by CloudWatch.
        public var metricUnit: String = ""

        public init() {}

        public init(metricValue: String, roleArn: String, metricTimestamp: String? = nil, metricNamespace: String, metricName: String, metricUnit: String) {
            self.metricValue = metricValue
            self.roleArn = roleArn
            self.metricTimestamp = metricTimestamp
            self.metricNamespace = metricNamespace
            self.metricName = metricName
            self.metricUnit = metricUnit
        }

        public init(dictionary: [String: Any]) throws {
            guard let metricValue = dictionary["metricValue"] as? String else { throw InitializableError.missingRequiredParam("metricValue") }
            self.metricValue = metricValue
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            self.metricTimestamp = dictionary["metricTimestamp"] as? String
            guard let metricNamespace = dictionary["metricNamespace"] as? String else { throw InitializableError.missingRequiredParam("metricNamespace") }
            self.metricNamespace = metricNamespace
            guard let metricName = dictionary["metricName"] as? String else { throw InitializableError.missingRequiredParam("metricName") }
            self.metricName = metricName
            guard let metricUnit = dictionary["metricUnit"] as? String else { throw InitializableError.missingRequiredParam("metricUnit") }
            self.metricUnit = metricUnit
        }
    }

    public struct RegisterCACertificateResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CA certificate identifier.
        public var certificateId: String? = nil
        /// The CA certificate ARN.
        public var certificateArn: String? = nil

        public init() {}

        public init(certificateId: String? = nil, certificateArn: String? = nil) {
            self.certificateId = certificateId
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateId = dictionary["certificateId"] as? String
            self.certificateArn = dictionary["certificateArn"] as? String
        }
    }

    public struct DescribeThingTypeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public var thingTypeMetadata: ThingTypeMetadata? = nil
        /// The name of the thing type.
        public var thingTypeName: String? = nil
        /// The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.
        public var thingTypeProperties: ThingTypeProperties? = nil

        public init() {}

        public init(thingTypeMetadata: ThingTypeMetadata? = nil, thingTypeName: String? = nil, thingTypeProperties: ThingTypeProperties? = nil) {
            self.thingTypeMetadata = thingTypeMetadata
            self.thingTypeName = thingTypeName
            self.thingTypeProperties = thingTypeProperties
        }

        public init(dictionary: [String: Any]) throws {
            if let thingTypeMetadata = dictionary["thingTypeMetadata"] as? [String: Any] { self.thingTypeMetadata = try Iot.ThingTypeMetadata(dictionary: thingTypeMetadata) }
            self.thingTypeName = dictionary["thingTypeName"] as? String
            if let thingTypeProperties = dictionary["thingTypeProperties"] as? [String: Any] { self.thingTypeProperties = try Iot.ThingTypeProperties(dictionary: thingTypeProperties) }
        }
    }

    public struct DynamoDBAction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the IAM role that grants access to the DynamoDB table.
        public var roleArn: String = ""
        /// The range key type. Valid values are "STRING" or "NUMBER"
        public var rangeKeyType: String? = nil
        /// The range key value.
        public var rangeKeyValue: String? = nil
        /// The hash key value.
        public var hashKeyValue: String = ""
        /// The type of operation to be performed. This follows the substitution template, so it can be ${operation}, but the substitution must result in one of the following: INSERT, UPDATE, or DELETE.
        public var operation: String? = nil
        /// The action payload. This name can be customized.
        public var payloadField: String? = nil
        /// The range key name.
        public var rangeKeyField: String? = nil
        /// The name of the DynamoDB table.
        public var tableName: String = ""
        /// The hash key name.
        public var hashKeyField: String = ""
        /// The hash key type. Valid values are "STRING" or "NUMBER"
        public var hashKeyType: String? = nil

        public init() {}

        public init(roleArn: String, rangeKeyType: String? = nil, rangeKeyValue: String? = nil, hashKeyValue: String, operation: String? = nil, payloadField: String? = nil, rangeKeyField: String? = nil, tableName: String, hashKeyField: String, hashKeyType: String? = nil) {
            self.roleArn = roleArn
            self.rangeKeyType = rangeKeyType
            self.rangeKeyValue = rangeKeyValue
            self.hashKeyValue = hashKeyValue
            self.operation = operation
            self.payloadField = payloadField
            self.rangeKeyField = rangeKeyField
            self.tableName = tableName
            self.hashKeyField = hashKeyField
            self.hashKeyType = hashKeyType
        }

        public init(dictionary: [String: Any]) throws {
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
            self.rangeKeyType = dictionary["rangeKeyType"] as? String
            self.rangeKeyValue = dictionary["rangeKeyValue"] as? String
            guard let hashKeyValue = dictionary["hashKeyValue"] as? String else { throw InitializableError.missingRequiredParam("hashKeyValue") }
            self.hashKeyValue = hashKeyValue
            self.operation = dictionary["operation"] as? String
            self.payloadField = dictionary["payloadField"] as? String
            self.rangeKeyField = dictionary["rangeKeyField"] as? String
            guard let tableName = dictionary["tableName"] as? String else { throw InitializableError.missingRequiredParam("tableName") }
            self.tableName = tableName
            guard let hashKeyField = dictionary["hashKeyField"] as? String else { throw InitializableError.missingRequiredParam("hashKeyField") }
            self.hashKeyField = hashKeyField
            self.hashKeyType = dictionary["hashKeyType"] as? String
        }
    }

    public struct AttachThingPrincipalResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteThingResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteThingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var queryParams: [String: String] {
            return ["expectedVersion": "expectedVersion"]
        }
        public static var pathParams: [String: String] {
            return ["thingName": "thingName"]
        }
        /// The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the DeleteThing request is rejected with a VersionConflictException.
        public var expectedVersion: Int64? = nil
        /// The name of the thing to delete.
        public var thingName: String = ""

        public init() {}

        public init(expectedVersion: Int64? = nil, thingName: String) {
            self.expectedVersion = expectedVersion
            self.thingName = thingName
        }

        public init(dictionary: [String: Any]) throws {
            self.expectedVersion = dictionary["expectedVersion"] as? Int64
            guard let thingName = dictionary["thingName"] as? String else { throw InitializableError.missingRequiredParam("thingName") }
            self.thingName = thingName
        }
    }

}