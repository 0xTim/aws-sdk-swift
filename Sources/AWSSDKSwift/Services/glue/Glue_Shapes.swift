// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Glue {

    public struct GetTableResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Table", required: false, type: .structure)
        ]
        /// The Table object that defines the specified table.
        public let table: Table?

        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct DeleteTableResponse: AWSShape {

    }

    public struct CreateTableResponse: AWSShape {

    }

    public struct Partition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Values", required: false, type: .list), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "TableName", required: false, type: .string), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp)
        ]
        /// Partition parameters, in the form of a list of key-value pairs.
        public let parameters: [String: String]?
        /// The name of the catalog database where the table in question is located.
        public let databaseName: String?
        /// The values of the partition.
        public let values: [String]?
        /// The time at which the partition was created.
        public let creationTime: TimeStamp?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The name of the table in question.
        public let tableName: String?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: TimeStamp?
        /// The last time at which the partition was accessed.
        public let lastAccessTime: TimeStamp?

        public init(parameters: [String: String]? = nil, databaseName: String? = nil, values: [String]? = nil, creationTime: TimeStamp? = nil, storageDescriptor: StorageDescriptor? = nil, tableName: String? = nil, lastAnalyzedTime: TimeStamp? = nil, lastAccessTime: TimeStamp? = nil) {
            self.parameters = parameters
            self.databaseName = databaseName
            self.values = values
            self.creationTime = creationTime
            self.storageDescriptor = storageDescriptor
            self.tableName = tableName
            self.lastAnalyzedTime = lastAnalyzedTime
            self.lastAccessTime = lastAccessTime
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
            case databaseName = "DatabaseName"
            case values = "Values"
            case creationTime = "CreationTime"
            case storageDescriptor = "StorageDescriptor"
            case tableName = "TableName"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case lastAccessTime = "LastAccessTime"
        }
    }

    public struct CreateUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "FunctionInput", required: true, type: .structure), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog in which to create the function. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A FunctionInput object that defines the function to create in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput
        /// The name of the catalog database in which to create the function.
        public let databaseName: String

        public init(catalogId: String? = nil, functionInput: UserDefinedFunctionInput, databaseName: String) {
            self.catalogId = catalogId
            self.functionInput = functionInput
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case functionInput = "FunctionInput"
            case databaseName = "DatabaseName"
        }
    }

    public struct GetJobRunsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The name of the job for which to retrieve all job runs.
        public let jobName: String
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum size of the response.
        public let maxResults: Int32?

        public init(jobName: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.jobName = jobName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct Crawler: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Targets", required: false, type: .structure), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Schedule", required: false, type: .structure), 
            AWSShapeMember(label: "Configuration", required: false, type: .string), 
            AWSShapeMember(label: "SchemaChangePolicy", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "TablePrefix", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "LastCrawl", required: false, type: .structure), 
            AWSShapeMember(label: "CrawlElapsedTime", required: false, type: .long)
        ]
        /// Indicates whether the crawler is running, or whether a run is pending.
        public let state: CrawlerState?
        /// A collection of targets to crawl.
        public let targets: CrawlerTargets?
        /// The time when the crawler was created.
        public let creationTime: TimeStamp?
        /// For scheduled crawlers, the schedule when the crawler runs.
        public let schedule: Schedule?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a Crawler's behavior. You can use this field to force partitions to inherit metadata such as classification, input format, output format, serde information, and schema from their parent table, rather than detect this information separately for each partition. Use the following JSON string to specify that behavior:
        public let configuration: String?
        /// Sets the behavior when the crawler finds a changed or deleted object.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// A description of the crawler.
        public let description: String?
        /// The prefix added to the names of tables that are created.
        public let tablePrefix: String?
        /// The crawler name.
        public let name: String?
        /// The version of the crawler.
        public let version: Int64?
        /// The IAM role (or ARN of an IAM role) used to access customer resources, such as data in Amazon S3.
        public let role: String?
        /// The database where metadata is written by this crawler.
        public let databaseName: String?
        /// The time the crawler was last updated.
        public let lastUpdated: TimeStamp?
        /// A list of custom classifiers associated with the crawler.
        public let classifiers: [String]?
        /// The status of the last crawl, and potentially error information if an error occurred.
        public let lastCrawl: LastCrawlInfo?
        /// If the crawler is running, contains the total time elapsed since the last crawl began.
        public let crawlElapsedTime: Int64?

        public init(state: CrawlerState? = nil, targets: CrawlerTargets? = nil, creationTime: TimeStamp? = nil, schedule: Schedule? = nil, configuration: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, description: String? = nil, tablePrefix: String? = nil, name: String? = nil, version: Int64? = nil, role: String? = nil, databaseName: String? = nil, lastUpdated: TimeStamp? = nil, classifiers: [String]? = nil, lastCrawl: LastCrawlInfo? = nil, crawlElapsedTime: Int64? = nil) {
            self.state = state
            self.targets = targets
            self.creationTime = creationTime
            self.schedule = schedule
            self.configuration = configuration
            self.schemaChangePolicy = schemaChangePolicy
            self.description = description
            self.tablePrefix = tablePrefix
            self.name = name
            self.version = version
            self.role = role
            self.databaseName = databaseName
            self.lastUpdated = lastUpdated
            self.classifiers = classifiers
            self.lastCrawl = lastCrawl
            self.crawlElapsedTime = crawlElapsedTime
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case targets = "Targets"
            case creationTime = "CreationTime"
            case schedule = "Schedule"
            case configuration = "Configuration"
            case schemaChangePolicy = "SchemaChangePolicy"
            case description = "Description"
            case tablePrefix = "TablePrefix"
            case name = "Name"
            case version = "Version"
            case role = "Role"
            case databaseName = "DatabaseName"
            case lastUpdated = "LastUpdated"
            case classifiers = "Classifiers"
            case lastCrawl = "LastCrawl"
            case crawlElapsedTime = "CrawlElapsedTime"
        }
    }

    public struct GetMappingResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Mapping", required: true, type: .list)
        ]
        /// A list of mappings to the specified targets.
        public let mapping: [MappingEntry]

        public init(mapping: [MappingEntry]) {
            self.mapping = mapping
        }

        private enum CodingKeys: String, CodingKey {
            case mapping = "Mapping"
        }
    }

    public struct UserDefinedFunctionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClassName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerName", required: false, type: .string), 
            AWSShapeMember(label: "FunctionName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerType", required: false, type: .enum), 
            AWSShapeMember(label: "ResourceUris", required: false, type: .list)
        ]
        /// The Java class that contains the function code.
        public let className: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The name of the function.
        public let functionName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        public init(className: String? = nil, ownerName: String? = nil, functionName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.className = className
            self.ownerName = ownerName
            self.functionName = functionName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case ownerName = "OwnerName"
            case functionName = "FunctionName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct Action: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]
        /// Arguments to be passed to the job.
        public let arguments: [String: String]?
        /// The name of a job to be executed.
        public let jobName: String?

        public init(arguments: [String: String]? = nil, jobName: String? = nil) {
            self.arguments = arguments
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case jobName = "JobName"
        }
    }

    public struct StartJobRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "JobRunId", required: false, type: .string), 
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "AllocatedCapacity", required: false, type: .integer)
        ]
        /// Specific arguments for this job run.
        public let arguments: [String: String]?
        /// The ID of the job run to start.
        public let jobRunId: String?
        /// The name of the job to start.
        public let jobName: String
        /// The infrastructure capacity to allocate to this job.
        public let allocatedCapacity: Int32?

        public init(arguments: [String: String]? = nil, jobRunId: String? = nil, jobName: String, allocatedCapacity: Int32? = nil) {
            self.arguments = arguments
            self.jobRunId = jobRunId
            self.jobName = jobName
            self.allocatedCapacity = allocatedCapacity
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case jobRunId = "JobRunId"
            case jobName = "JobName"
            case allocatedCapacity = "AllocatedCapacity"
        }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable {
        case user = "USER"
        case role = "ROLE"
        case group = "GROUP"
        public var description: String { return self.rawValue }
    }

    public struct GetConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the connection definition to retrieve.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct StopTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name of the trigger that was stopped.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetConnectionsFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MatchCriteria", required: false, type: .list), 
            AWSShapeMember(label: "ConnectionType", required: false, type: .enum)
        ]
        /// A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.
        public let matchCriteria: [String]?
        /// The type of connections to return. Currently, only JDBC is supported; SFTP is not supported.
        public let connectionType: ConnectionType?

        public init(matchCriteria: [String]? = nil, connectionType: ConnectionType? = nil) {
            self.matchCriteria = matchCriteria
            self.connectionType = connectionType
        }

        private enum CodingKeys: String, CodingKey {
            case matchCriteria = "MatchCriteria"
            case connectionType = "ConnectionType"
        }
    }

    public struct ConnectionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PhysicalConnectionRequirements", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionProperties", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionType", required: false, type: .enum), 
            AWSShapeMember(label: "MatchCriteria", required: false, type: .list)
        ]
        /// A map of physical connection requirements, such as VPC and SecurityGroup, needed for making this connection successfully.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?
        /// Description of the connection.
        public let description: String?
        /// A list of key-value pairs used as parameters for this connection.
        public let connectionProperties: [ConnectionPropertyKey: String]?
        /// The name of the connection.
        public let name: String?
        /// The type of the connection. Currently, only JDBC is supported; SFTP is not supported.
        public let connectionType: ConnectionType?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?

        public init(physicalConnectionRequirements: PhysicalConnectionRequirements? = nil, description: String? = nil, connectionProperties: [ConnectionPropertyKey: String]? = nil, name: String? = nil, connectionType: ConnectionType? = nil, matchCriteria: [String]? = nil) {
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.description = description
            self.connectionProperties = connectionProperties
            self.name = name
            self.connectionType = connectionType
            self.matchCriteria = matchCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
            case description = "Description"
            case connectionProperties = "ConnectionProperties"
            case name = "Name"
            case connectionType = "ConnectionType"
            case matchCriteria = "MatchCriteria"
        }
    }

    public struct DeleteDevEndpointResponse: AWSShape {

    }

    public struct Order: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Column", required: true, type: .string), 
            AWSShapeMember(label: "SortOrder", required: true, type: .integer)
        ]
        /// The name of the column.
        public let column: String
        /// Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        public let sortOrder: Int32

        public init(column: String, sortOrder: Int32) {
            self.column = column
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortOrder = "SortOrder"
        }
    }

    public struct CreatePartitionResponse: AWSShape {

    }

    public struct GetConnectionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filter", required: false, type: .structure), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// A filter that controls which connections will be returned.
        public let filter: GetConnectionsFilter?
        /// The ID of the Data Catalog in which the connections reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum number of connections to return in one response.
        public let maxResults: Int32?

        public init(filter: GetConnectionsFilter? = nil, catalogId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.filter = filter
            self.catalogId = catalogId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case catalogId = "CatalogId"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct GetClassifierResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classifier", required: false, type: .structure)
        ]
        /// The requested classifier.
        public let classifier: Classifier?

        public init(classifier: Classifier? = nil) {
            self.classifier = classifier
        }

        private enum CodingKeys: String, CodingKey {
            case classifier = "Classifier"
        }
    }

    public struct BatchDeletePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PartitionsToDelete", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// A list of PartitionInput structures that define the partitions to be deleted.
        public let partitionsToDelete: [PartitionValueList]
        /// The name of the table where the partitions to be deleted is located.
        public let tableName: String
        /// The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String

        public init(partitionsToDelete: [PartitionValueList], tableName: String, catalogId: String? = nil, databaseName: String) {
            self.partitionsToDelete = partitionsToDelete
            self.tableName = tableName
            self.catalogId = catalogId
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case partitionsToDelete = "PartitionsToDelete"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
        }
    }

    public struct JobCommand: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ScriptLocation", required: false, type: .string)
        ]
        /// The name of this job command.
        public let name: String?
        /// Specifies the location of a script that executes a job.
        public let scriptLocation: String?

        public init(name: String? = nil, scriptLocation: String? = nil) {
            self.name = name
            self.scriptLocation = scriptLocation
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case scriptLocation = "ScriptLocation"
        }
    }

    public struct DeleteTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the trigger to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the table to be deleted.
        public let name: String
        /// The name of the catalog database in which the table resides.
        public let databaseName: String

        public init(catalogId: String? = nil, name: String, databaseName: String) {
            self.catalogId = catalogId
            self.name = name
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
            case databaseName = "DatabaseName"
        }
    }

    public struct GetJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", required: false, type: .structure)
        ]
        /// The requested job definition.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "Job"
        }
    }

    public struct CreateDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseInput", required: true, type: .structure), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]
        /// A DatabaseInput object defining the metadata database to create in the catalog.
        public let databaseInput: DatabaseInput
        /// The ID of the Data Catalog in which to create the database. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?

        public init(databaseInput: DatabaseInput, catalogId: String? = nil) {
            self.databaseInput = databaseInput
            self.catalogId = catalogId
        }

        private enum CodingKeys: String, CodingKey {
            case databaseInput = "DatabaseInput"
            case catalogId = "CatalogId"
        }
    }

    public struct CreateTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name assigned to the new trigger.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct BatchGetPartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "PartitionsToGet", required: true, type: .list)
        ]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A list of partition values identifying the partitions to retrieve.
        public let partitionsToGet: [PartitionValueList]

        public init(databaseName: String, tableName: String, catalogId: String? = nil, partitionsToGet: [PartitionValueList]) {
            self.databaseName = databaseName
            self.tableName = tableName
            self.catalogId = catalogId
            self.partitionsToGet = partitionsToGet
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case partitionsToGet = "PartitionsToGet"
        }
    }

    public struct GetDatabasesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The ID of the Data Catalog from which to retrieve Databases. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum number of databases to return in one response.
        public let maxResults: Int32?

        public init(catalogId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.catalogId = catalogId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct SchemaChangePolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UpdateBehavior", required: false, type: .enum), 
            AWSShapeMember(label: "DeleteBehavior", required: false, type: .enum)
        ]
        /// The update behavior when the crawler finds a changed schema.
        public let updateBehavior: UpdateBehavior?
        /// The deletion behavior when the crawler finds a deleted object.
        public let deleteBehavior: DeleteBehavior?

        public init(updateBehavior: UpdateBehavior? = nil, deleteBehavior: DeleteBehavior? = nil) {
            self.updateBehavior = updateBehavior
            self.deleteBehavior = deleteBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case updateBehavior = "UpdateBehavior"
            case deleteBehavior = "DeleteBehavior"
        }
    }

    public struct BatchCreatePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "PartitionInputList", required: true, type: .list), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String
        /// The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.
        public let catalogId: String?
        /// A list of PartitionInput structures that define the partitions to be created.
        public let partitionInputList: [PartitionInput]
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String

        public init(tableName: String, catalogId: String? = nil, partitionInputList: [PartitionInput], databaseName: String) {
            self.tableName = tableName
            self.catalogId = catalogId
            self.partitionInputList = partitionInputList
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case partitionInputList = "PartitionInputList"
            case databaseName = "DatabaseName"
        }
    }

    public struct BatchDeleteConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .map), 
            AWSShapeMember(label: "Succeeded", required: false, type: .list)
        ]
        /// A map of the names of connections that were not successfully deleted to error details.
        public let errors: [String: ErrorDetail]?
        /// A list of names of the connection definitions that were successfully deleted.
        public let succeeded: [String]?

        public init(errors: [String: ErrorDetail]? = nil, succeeded: [String]? = nil) {
            self.errors = errors
            self.succeeded = succeeded
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case succeeded = "Succeeded"
        }
    }

    public enum LastCrawlStatus: String, CustomStringConvertible, Codable {
        case succeeded = "SUCCEEDED"
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct GetUserDefinedFunctionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Pattern", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// An optional function-name pattern string that filters the function definitions returned.
        public let pattern: String
        /// The name of the catalog database where the functions are located.
        public let databaseName: String
        /// The ID of the Data Catalog where the functions to be retrieved are located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum number of functions to return in one response.
        public let maxResults: Int32?

        public init(pattern: String, databaseName: String, catalogId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.pattern = pattern
            self.databaseName = databaseName
            self.catalogId = catalogId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case pattern = "Pattern"
            case databaseName = "DatabaseName"
            case catalogId = "CatalogId"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct ErrorDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string)
        ]
        /// A message describing the error.
        public let errorMessage: String?
        /// The code associated with this error.
        public let errorCode: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorCode = "ErrorCode"
        }
    }

    public struct UpdateTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Trigger", required: false, type: .structure)
        ]
        /// The resulting trigger definition.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct Trigger: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Actions", required: false, type: .list), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "Predicate", required: false, type: .structure), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The trigger ID.
        public let id: String?
        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// The current state of the trigger.
        public let state: TriggerState?
        /// Name of the trigger.
        public let name: String?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The predicate of this trigger.
        public let predicate: Predicate?
        /// The type of trigger that this is.
        public let `type`: TriggerType?
        /// A description of this trigger.
        public let description: String?

        public init(id: String? = nil, actions: [Action]? = nil, state: TriggerState? = nil, name: String? = nil, schedule: String? = nil, predicate: Predicate? = nil, type: TriggerType? = nil, description: String? = nil) {
            self.id = id
            self.actions = actions
            self.state = state
            self.name = name
            self.schedule = schedule
            self.predicate = predicate
            self.`type` = `type`
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case actions = "Actions"
            case state = "State"
            case name = "Name"
            case schedule = "Schedule"
            case predicate = "Predicate"
            case `type` = "Type"
            case description = "Description"
        }
    }

    public struct CreateTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "TableInput", required: true, type: .structure), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog in which to create the Table. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The TableInput object that defines the metadata table to create in the catalog.
        public let tableInput: TableInput
        /// The catalog database in which to create the new table.
        public let databaseName: String

        public init(catalogId: String? = nil, tableInput: TableInput, databaseName: String) {
            self.catalogId = catalogId
            self.tableInput = tableInput
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case tableInput = "TableInput"
            case databaseName = "DatabaseName"
        }
    }

    public struct JobUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connections", required: false, type: .structure), 
            AWSShapeMember(label: "ExecutionProperty", required: false, type: .structure), 
            AWSShapeMember(label: "LogUri", required: false, type: .string), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "MaxRetries", required: false, type: .integer), 
            AWSShapeMember(label: "Command", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultArguments", required: false, type: .map), 
            AWSShapeMember(label: "AllocatedCapacity", required: false, type: .integer), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// This field is reserved for future use.
        public let logUri: String?
        /// The role associated with this job.
        public let role: String?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int32?
        /// The JobCommand that executes this job.
        public let command: JobCommand?
        /// The default parameters for this job.
        public let defaultArguments: [String: String]?
        /// The number of capacity units allocated to this job.
        public let allocatedCapacity: Int32?
        /// Description of the job.
        public let description: String?

        public init(connections: ConnectionsList? = nil, executionProperty: ExecutionProperty? = nil, logUri: String? = nil, role: String? = nil, maxRetries: Int32? = nil, command: JobCommand? = nil, defaultArguments: [String: String]? = nil, allocatedCapacity: Int32? = nil, description: String? = nil) {
            self.connections = connections
            self.executionProperty = executionProperty
            self.logUri = logUri
            self.role = role
            self.maxRetries = maxRetries
            self.command = command
            self.defaultArguments = defaultArguments
            self.allocatedCapacity = allocatedCapacity
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case executionProperty = "ExecutionProperty"
            case logUri = "LogUri"
            case role = "Role"
            case maxRetries = "MaxRetries"
            case command = "Command"
            case defaultArguments = "DefaultArguments"
            case allocatedCapacity = "AllocatedCapacity"
            case description = "Description"
        }
    }

    public struct UpdateDevEndpointResponse: AWSShape {

    }

    public enum CrawlerState: String, CustomStringConvertible, Codable {
        case ready = "READY"
        case running = "RUNNING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public struct StopCrawlerResponse: AWSShape {

    }

    public struct UpdateGrokClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GrokPattern", required: false, type: .string), 
            AWSShapeMember(label: "Classification", required: false, type: .string), 
            AWSShapeMember(label: "CustomPatterns", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The grok pattern used by this classifier.
        public let grokPattern: String?
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String?
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The name of the GrokClassifier.
        public let name: String

        public init(grokPattern: String? = nil, classification: String? = nil, customPatterns: String? = nil, name: String) {
            self.grokPattern = grokPattern
            self.classification = classification
            self.customPatterns = customPatterns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case grokPattern = "GrokPattern"
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case name = "Name"
        }
    }

    public struct CatalogEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The name of the table in question.
        public let tableName: String
        /// The database in which the table metadata resides.
        public let databaseName: String

        public init(tableName: String, databaseName: String) {
            self.tableName = tableName
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case tableName = "TableName"
            case databaseName = "DatabaseName"
        }
    }

    public struct DeleteDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]
        /// The name of the DevEndpoint.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct DeleteConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the connection to delete.
        public let connectionName: String

        public init(catalogId: String? = nil, connectionName: String) {
            self.catalogId = catalogId
            self.connectionName = connectionName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
        }
    }

    public struct GetDatabaseResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Database", required: false, type: .structure)
        ]
        /// The definition of the specified database in the catalog.
        public let database: Database?

        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct BatchStopJobRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "JobRunIds", required: true, type: .list)
        ]
        /// The name of the job whose job runs are to be stopped.
        public let jobName: String
        /// A list of job run Ids of the given job to be stopped.
        public let jobRunIds: [String]

        public init(jobName: String, jobRunIds: [String]) {
            self.jobName = jobName
            self.jobRunIds = jobRunIds
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunIds = "JobRunIds"
        }
    }

    public struct DeleteDatabaseResponse: AWSShape {

    }

    public struct CreateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connections", required: false, type: .structure), 
            AWSShapeMember(label: "ExecutionProperty", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "LogUri", required: false, type: .string), 
            AWSShapeMember(label: "Role", required: true, type: .string), 
            AWSShapeMember(label: "MaxRetries", required: false, type: .integer), 
            AWSShapeMember(label: "Command", required: true, type: .structure), 
            AWSShapeMember(label: "DefaultArguments", required: false, type: .map), 
            AWSShapeMember(label: "AllocatedCapacity", required: false, type: .integer), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// The name you assign to this job.
        public let name: String
        /// This field is reserved for future use.
        public let logUri: String?
        /// The role associated with this job.
        public let role: String
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int32?
        /// The JobCommand that executes this job.
        public let command: JobCommand
        /// The default parameters for this job.
        public let defaultArguments: [String: String]?
        /// The number of capacity units allocated to this job.
        public let allocatedCapacity: Int32?
        /// Description of the job.
        public let description: String?

        public init(connections: ConnectionsList? = nil, executionProperty: ExecutionProperty? = nil, name: String, logUri: String? = nil, role: String, maxRetries: Int32? = nil, command: JobCommand, defaultArguments: [String: String]? = nil, allocatedCapacity: Int32? = nil, description: String? = nil) {
            self.connections = connections
            self.executionProperty = executionProperty
            self.name = name
            self.logUri = logUri
            self.role = role
            self.maxRetries = maxRetries
            self.command = command
            self.defaultArguments = defaultArguments
            self.allocatedCapacity = allocatedCapacity
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case executionProperty = "ExecutionProperty"
            case name = "Name"
            case logUri = "LogUri"
            case role = "Role"
            case maxRetries = "MaxRetries"
            case command = "Command"
            case defaultArguments = "DefaultArguments"
            case allocatedCapacity = "AllocatedCapacity"
            case description = "Description"
        }
    }

    public struct DevEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "PublicKey", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdateStatus", required: false, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "EndpointName", required: false, type: .string), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "ZeppelinRemoteSparkInterpreterPort", required: false, type: .integer), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "PublicAddress", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string), 
            AWSShapeMember(label: "YarnEndpointAddress", required: false, type: .string), 
            AWSShapeMember(label: "NumberOfNodes", required: false, type: .integer), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimestamp", required: false, type: .timestamp)
        ]
        /// The subnet ID for this DevEndpoint.
        public let subnetId: String?
        /// The public key to be used by this DevEndpoint for authentication.
        public let publicKey: String?
        /// The status of the last update.
        public let lastUpdateStatus: String?
        /// Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// A list of security group identifiers used in this DevEndpoint.
        public let securityGroupIds: [String]?
        /// The name of the DevEndpoint.
        public let endpointName: String?
        /// The AWS availability zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: TimeStamp?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int32?
        /// The current status of this DevEndpoint.
        public let status: String?
        /// The public address used by this DevEndpoint.
        public let publicAddress: String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public let vpcId: String?
        /// The YARN endpoint address used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The number of AWS Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int32?
        /// Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint. Please note that only pure Java/Scala libraries can currently be used on a DevEndpoint.
        public let extraJarsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// The AWS ARN of the IAM role used in this DevEndpoint.
        public let roleArn: String?
        /// The point in time at which this DevEndpoint was last modified.
        public let lastModifiedTimestamp: TimeStamp?

        public init(subnetId: String? = nil, publicKey: String? = nil, lastUpdateStatus: String? = nil, extraPythonLibsS3Path: String? = nil, securityGroupIds: [String]? = nil, endpointName: String? = nil, availabilityZone: String? = nil, createdTimestamp: TimeStamp? = nil, zeppelinRemoteSparkInterpreterPort: Int32? = nil, status: String? = nil, publicAddress: String? = nil, vpcId: String? = nil, yarnEndpointAddress: String? = nil, numberOfNodes: Int32? = nil, extraJarsS3Path: String? = nil, failureReason: String? = nil, roleArn: String? = nil, lastModifiedTimestamp: TimeStamp? = nil) {
            self.subnetId = subnetId
            self.publicKey = publicKey
            self.lastUpdateStatus = lastUpdateStatus
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.securityGroupIds = securityGroupIds
            self.endpointName = endpointName
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
            self.status = status
            self.publicAddress = publicAddress
            self.vpcId = vpcId
            self.yarnEndpointAddress = yarnEndpointAddress
            self.numberOfNodes = numberOfNodes
            self.extraJarsS3Path = extraJarsS3Path
            self.failureReason = failureReason
            self.roleArn = roleArn
            self.lastModifiedTimestamp = lastModifiedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case publicKey = "PublicKey"
            case lastUpdateStatus = "LastUpdateStatus"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case securityGroupIds = "SecurityGroupIds"
            case endpointName = "EndpointName"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
            case status = "Status"
            case publicAddress = "PublicAddress"
            case vpcId = "VpcId"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case numberOfNodes = "NumberOfNodes"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case failureReason = "FailureReason"
            case roleArn = "RoleArn"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
        }
    }

    public struct GetCrawlerMetricsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerMetricsList", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of metrics for the specified crawler.
        public let crawlerMetricsList: [CrawlerMetrics]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(crawlerMetricsList: [CrawlerMetrics]? = nil, nextToken: String? = nil) {
            self.crawlerMetricsList = crawlerMetricsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerMetricsList = "CrawlerMetricsList"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobRunsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRuns", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of job-run metatdata objects.
        public let jobRuns: [JobRun]?
        /// A continuation token, if not all reequested job runs have been returned.
        public let nextToken: String?

        public init(jobRuns: [JobRun]? = nil, nextToken: String? = nil) {
            self.jobRuns = jobRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
            case nextToken = "NextToken"
        }
    }

    public struct BatchDeleteConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionNameList", required: true, type: .list)
        ]
        /// The ID of the Data Catalog in which the connections reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A list of names of the connections to delete.
        public let connectionNameList: [String]

        public init(catalogId: String? = nil, connectionNameList: [String]) {
            self.catalogId = catalogId
            self.connectionNameList = connectionNameList
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionNameList = "ConnectionNameList"
        }
    }

    public struct StartTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name of the trigger that was started.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Column: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Comment", required: false, type: .string)
        ]
        /// The datatype of data in the Column.
        public let `type`: String?
        /// The name of the Column.
        public let name: String
        /// Free-form text comment.
        public let comment: String?

        public init(type: String? = nil, name: String, comment: String? = nil) {
            self.`type` = `type`
            self.name = name
            self.comment = comment
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case name = "Name"
            case comment = "Comment"
        }
    }

    public enum DeleteBehavior: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case deleteFromDatabase = "DELETE_FROM_DATABASE"
        case deprecateInDatabase = "DEPRECATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public struct ResetJobBookmarkResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobBookmarkEntry", required: false, type: .structure)
        ]
        /// The reset bookmark entry.
        public let jobBookmarkEntry: JobBookmarkEntry?

        public init(jobBookmarkEntry: JobBookmarkEntry? = nil) {
            self.jobBookmarkEntry = jobBookmarkEntry
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarkEntry = "JobBookmarkEntry"
        }
    }

    public struct UpdateConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "ConnectionInput", required: true, type: .structure)
        ]
        /// The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the connection definition to update.
        public let name: String
        /// A ConnectionInput object that redefines the connection in question.
        public let connectionInput: ConnectionInput

        public init(catalogId: String? = nil, name: String, connectionInput: ConnectionInput) {
            self.catalogId = catalogId
            self.name = name
            self.connectionInput = connectionInput
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
            case connectionInput = "ConnectionInput"
        }
    }

    public struct GetClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the classifier to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct SkewedInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SkewedColumnValueLocationMaps", required: false, type: .map), 
            AWSShapeMember(label: "SkewedColumnNames", required: false, type: .list), 
            AWSShapeMember(label: "SkewedColumnValues", required: false, type: .list)
        ]
        /// A mapping of skewed values to the columns that contain them.
        public let skewedColumnValueLocationMaps: [String: String]?
        /// A list of names of columns that contain skewed values.
        public let skewedColumnNames: [String]?
        /// A list of values that appear so frequently as to be considered skewed.
        public let skewedColumnValues: [String]?

        public init(skewedColumnValueLocationMaps: [String: String]? = nil, skewedColumnNames: [String]? = nil, skewedColumnValues: [String]? = nil) {
            self.skewedColumnValueLocationMaps = skewedColumnValueLocationMaps
            self.skewedColumnNames = skewedColumnNames
            self.skewedColumnValues = skewedColumnValues
        }

        private enum CodingKeys: String, CodingKey {
            case skewedColumnValueLocationMaps = "SkewedColumnValueLocationMaps"
            case skewedColumnNames = "SkewedColumnNames"
            case skewedColumnValues = "SkewedColumnValues"
        }
    }

    public struct GetConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connection", required: false, type: .structure)
        ]
        /// The requested connection definition.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case conditional = "CONDITIONAL"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public struct JdbcTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exclusions", required: false, type: .list), 
            AWSShapeMember(label: "ConnectionName", required: false, type: .string), 
            AWSShapeMember(label: "Path", required: false, type: .string)
        ]
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The name of the connection to use to connect to the JDBC target.
        public let connectionName: String?
        /// The path of the JDBC target.
        public let path: String?

        public init(exclusions: [String]? = nil, connectionName: String? = nil, path: String? = nil) {
            self.exclusions = exclusions
            self.connectionName = connectionName
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case exclusions = "Exclusions"
            case connectionName = "ConnectionName"
            case path = "Path"
        }
    }

    public struct ResourceUri: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceType", required: false, type: .enum), 
            AWSShapeMember(label: "Uri", required: false, type: .string)
        ]
        /// The type of the resource.
        public let resourceType: ResourceType?
        /// The URI for accessing the resource.
        public let uri: String?

        public init(resourceType: ResourceType? = nil, uri: String? = nil) {
            self.resourceType = resourceType
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case uri = "Uri"
        }
    }

    public struct Connection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastUpdatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionType", required: false, type: .enum), 
            AWSShapeMember(label: "MatchCriteria", required: false, type: .list), 
            AWSShapeMember(label: "PhysicalConnectionRequirements", required: false, type: .structure), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ConnectionProperties", required: false, type: .map), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The last time this connection definition was updated.
        public let lastUpdatedTime: TimeStamp?
        /// The user, group or role that last updated this connection definition.
        public let lastUpdatedBy: String?
        /// The name of the connection definition.
        public let name: String?
        /// The type of the connection. Currently, only JDBC is supported; SFTP is not supported.
        public let connectionType: ConnectionType?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// A map of physical connection requirements, such as VPC and SecurityGroup, needed for making this connection successfully.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?
        /// The time this connection definition was created.
        public let creationTime: TimeStamp?
        /// A list of key-value pairs used as parameters for this connection.
        public let connectionProperties: [ConnectionPropertyKey: String]?
        /// Description of the connection.
        public let description: String?

        public init(lastUpdatedTime: TimeStamp? = nil, lastUpdatedBy: String? = nil, name: String? = nil, connectionType: ConnectionType? = nil, matchCriteria: [String]? = nil, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil, creationTime: TimeStamp? = nil, connectionProperties: [ConnectionPropertyKey: String]? = nil, description: String? = nil) {
            self.lastUpdatedTime = lastUpdatedTime
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.connectionType = connectionType
            self.matchCriteria = matchCriteria
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.creationTime = creationTime
            self.connectionProperties = connectionProperties
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdatedTime = "LastUpdatedTime"
            case lastUpdatedBy = "LastUpdatedBy"
            case name = "Name"
            case connectionType = "ConnectionType"
            case matchCriteria = "MatchCriteria"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
            case creationTime = "CreationTime"
            case connectionProperties = "ConnectionProperties"
            case description = "Description"
        }
    }

    public struct UpdateConnectionResponse: AWSShape {

    }

    public struct CreatePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PartitionInput", required: true, type: .structure), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// A PartitionInput structure defining the partition to be created.
        public let partitionInput: PartitionInput
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String
        /// The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String

        public init(partitionInput: PartitionInput, tableName: String, catalogId: String? = nil, databaseName: String) {
            self.partitionInput = partitionInput
            self.tableName = tableName
            self.catalogId = catalogId
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case partitionInput = "PartitionInput"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
        }
    }

    public struct BatchDeletePartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]
        /// Errors encountered when trying to delete the requested partitions.
        public let errors: [PartitionError]?

        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct DeletePartitionResponse: AWSShape {

    }

    public enum UpdateBehavior: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case updateInDatabase = "UPDATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public struct CreateScriptResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PythonScript", required: false, type: .string)
        ]
        /// The Python script generated from the DAG.
        public let pythonScript: String?

        public init(pythonScript: String? = nil) {
            self.pythonScript = pythonScript
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
        }
    }

    public struct DeleteTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name of the trigger that was deleted.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetCrawlerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Crawler", required: false, type: .structure)
        ]
        /// The metadata for the specified crawler.
        public let crawler: Crawler?

        public init(crawler: Crawler? = nil) {
            self.crawler = crawler
        }

        private enum CodingKeys: String, CodingKey {
            case crawler = "Crawler"
        }
    }

    public struct GetDataflowGraphResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DagEdges", required: false, type: .list), 
            AWSShapeMember(label: "DagNodes", required: false, type: .list)
        ]
        /// A list of the edges in the resulting DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the resulting DAG.
        public let dagNodes: [CodeGenNode]?

        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
        }
    }

    public struct JobBookmarkEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Run", required: false, type: .integer), 
            AWSShapeMember(label: "Attempt", required: false, type: .integer), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "JobBookmark", required: false, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .integer)
        ]
        /// The run ID number.
        public let run: Int32?
        /// The attempt ID number.
        public let attempt: Int32?
        /// Name of the job in question.
        public let jobName: String?
        /// The bookmark itself.
        public let jobBookmark: String?
        /// Version of the job.
        public let version: Int32?

        public init(run: Int32? = nil, attempt: Int32? = nil, jobName: String? = nil, jobBookmark: String? = nil, version: Int32? = nil) {
            self.run = run
            self.attempt = attempt
            self.jobName = jobName
            self.jobBookmark = jobBookmark
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case run = "Run"
            case attempt = "Attempt"
            case jobName = "JobName"
            case jobBookmark = "JobBookmark"
            case version = "Version"
        }
    }

    public struct GetTableVersionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableVersions", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of strings identifying available versions of the specified table.
        public let tableVersions: [TableVersion]?
        /// A continuation token, if the list of available versions does not include the last one.
        public let nextToken: String?

        public init(tableVersions: [TableVersion]? = nil, nextToken: String? = nil) {
            self.tableVersions = tableVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case tableVersions = "TableVersions"
            case nextToken = "NextToken"
        }
    }

    public struct DeleteCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the crawler to remove.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateUserDefinedFunctionResponse: AWSShape {

    }

    public struct GetTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the trigger to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Condition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "LogicalOperator", required: false, type: .enum)
        ]
        /// The name of the job in question.
        public let jobName: String?
        /// The condition state.
        public let state: JobRunState?
        /// A logical operator.
        public let logicalOperator: LogicalOperator?

        public init(jobName: String? = nil, state: JobRunState? = nil, logicalOperator: LogicalOperator? = nil) {
            self.jobName = jobName
            self.state = state
            self.logicalOperator = logicalOperator
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case state = "State"
            case logicalOperator = "LogicalOperator"
        }
    }

    public struct UpdateUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FunctionInput", required: true, type: .structure), 
            AWSShapeMember(label: "FunctionName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// A FunctionInput object that re-defines the function in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput
        /// The name of the function.
        public let functionName: String
        /// The ID of the Data Catalog where the function to be updated is located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function to be updated is located.
        public let databaseName: String

        public init(functionInput: UserDefinedFunctionInput, functionName: String, catalogId: String? = nil, databaseName: String) {
            self.functionInput = functionInput
            self.functionName = functionName
            self.catalogId = catalogId
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case functionInput = "FunctionInput"
            case functionName = "FunctionName"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
        }
    }

    public struct UpdateClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GrokClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "XMLClassifier", required: false, type: .structure)
        ]
        /// A GrokClassifier object with updated fields.
        public let grokClassifier: UpdateGrokClassifierRequest?
        /// An XMLClassifier object with updated fields.
        public let xMLClassifier: UpdateXMLClassifierRequest?

        public init(grokClassifier: UpdateGrokClassifierRequest? = nil, xMLClassifier: UpdateXMLClassifierRequest? = nil) {
            self.grokClassifier = grokClassifier
            self.xMLClassifier = xMLClassifier
        }

        private enum CodingKeys: String, CodingKey {
            case grokClassifier = "GrokClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct TableError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "TableName", required: false, type: .string)
        ]
        /// Detail about the error.
        public let errorDetail: ErrorDetail?
        /// Name of the table.
        public let tableName: String?

        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
        }
    }

    public struct StartCrawlerScheduleResponse: AWSShape {

    }

    public struct GetJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]
        /// The name of the job to retrieve.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct CreateUserDefinedFunctionResponse: AWSShape {

    }

    public struct ResetJobBookmarkRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]
        /// The name of the job in question.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct GetPartitionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Partitions", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of requested partitions.
        public let partitions: [Partition]?
        /// A continuation token, if the returned list of partitions does not does not include the last one.
        public let nextToken: String?

        public init(partitions: [Partition]? = nil, nextToken: String? = nil) {
            self.partitions = partitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case partitions = "Partitions"
            case nextToken = "NextToken"
        }
    }

    public struct UpdateCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TablePrefix", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Targets", required: false, type: .structure), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "Configuration", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "SchemaChangePolicy", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// Name of the new crawler.
        public let name: String
        /// The AWS Glue database where results are stored, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A list of targets to crawl.
        public let targets: CrawlerTargets?
        /// The IAM role (or ARN of an IAM role) used by the new crawler to access customer resources.
        public let role: String?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a Crawler's behavior. You can use this field to force partitions to inherit metadata such as classification, input format, output format, serde information, and schema from their parent table, rather than detect this information separately for each partition. Use the following JSON string to specify that behavior:
        public let configuration: String?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// A list of custom classifiers that the user has registered. By default, all classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// Policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// A description of the new crawler.
        public let description: String?

        public init(tablePrefix: String? = nil, name: String, databaseName: String? = nil, targets: CrawlerTargets? = nil, role: String? = nil, configuration: String? = nil, schedule: String? = nil, classifiers: [String]? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, description: String? = nil) {
            self.tablePrefix = tablePrefix
            self.name = name
            self.databaseName = databaseName
            self.targets = targets
            self.role = role
            self.configuration = configuration
            self.schedule = schedule
            self.classifiers = classifiers
            self.schemaChangePolicy = schemaChangePolicy
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case tablePrefix = "TablePrefix"
            case name = "Name"
            case databaseName = "DatabaseName"
            case targets = "Targets"
            case role = "Role"
            case configuration = "Configuration"
            case schedule = "Schedule"
            case classifiers = "Classifiers"
            case schemaChangePolicy = "SchemaChangePolicy"
            case description = "Description"
        }
    }

    public struct PhysicalConnectionRequirements: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIdList", required: false, type: .list), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string)
        ]
        /// The connection's availability zone.
        public let availabilityZone: String?
        /// The security group ID list used by the connection.
        public let securityGroupIdList: [String]?
        /// The subnet ID used by the connection.
        public let subnetId: String?

        public init(availabilityZone: String? = nil, securityGroupIdList: [String]? = nil, subnetId: String? = nil) {
            self.availabilityZone = availabilityZone
            self.securityGroupIdList = securityGroupIdList
            self.subnetId = subnetId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case securityGroupIdList = "SecurityGroupIdList"
            case subnetId = "SubnetId"
        }
    }

    public struct GetJobRunRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string), 
            AWSShapeMember(label: "RunId", required: true, type: .string), 
            AWSShapeMember(label: "PredecessorsIncluded", required: false, type: .boolean)
        ]
        /// Name of the job being run.
        public let jobName: String
        /// The ID of the job run.
        public let runId: String
        /// A list of the predecessor runs to return as well.
        public let predecessorsIncluded: Bool?

        public init(jobName: String, runId: String, predecessorsIncluded: Bool? = nil) {
            self.jobName = jobName
            self.runId = runId
            self.predecessorsIncluded = predecessorsIncluded
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
            case predecessorsIncluded = "PredecessorsIncluded"
        }
    }

    public struct DeleteJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]
        /// The name of the job that was deleted.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct StorageDescriptor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputFormat", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "Location", required: false, type: .string), 
            AWSShapeMember(label: "BucketColumns", required: false, type: .list), 
            AWSShapeMember(label: "Columns", required: false, type: .list), 
            AWSShapeMember(label: "SkewedInfo", required: false, type: .structure), 
            AWSShapeMember(label: "OutputFormat", required: false, type: .string), 
            AWSShapeMember(label: "StoredAsSubDirectories", required: false, type: .boolean), 
            AWSShapeMember(label: "SortColumns", required: false, type: .list), 
            AWSShapeMember(label: "SerdeInfo", required: false, type: .structure), 
            AWSShapeMember(label: "NumberOfBuckets", required: false, type: .integer), 
            AWSShapeMember(label: "Compressed", required: false, type: .boolean)
        ]
        /// The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        public let inputFormat: String?
        /// User-supplied properties in key-value form.
        public let parameters: [String: String]?
        /// The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        public let location: String?
        /// A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        public let bucketColumns: [String]?
        /// A list of the Columns in the table.
        public let columns: [Column]?
        /// Information about values that appear very frequently in a column (skewed values).
        public let skewedInfo: SkewedInfo?
        /// The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        public let outputFormat: String?
        /// True if the table data is stored in subdirectories, or False if not.
        public let storedAsSubDirectories: Bool?
        /// A list specifying the sort order of each bucket in the table.
        public let sortColumns: [Order]?
        /// Serialization/deserialization (SerDe) information.
        public let serdeInfo: SerDeInfo?
        /// Must be specified if the table contains any dimension columns.
        public let numberOfBuckets: Int32?
        /// True if the data in the table is compressed, or False if not.
        public let compressed: Bool?

        public init(inputFormat: String? = nil, parameters: [String: String]? = nil, location: String? = nil, bucketColumns: [String]? = nil, columns: [Column]? = nil, skewedInfo: SkewedInfo? = nil, outputFormat: String? = nil, storedAsSubDirectories: Bool? = nil, sortColumns: [Order]? = nil, serdeInfo: SerDeInfo? = nil, numberOfBuckets: Int32? = nil, compressed: Bool? = nil) {
            self.inputFormat = inputFormat
            self.parameters = parameters
            self.location = location
            self.bucketColumns = bucketColumns
            self.columns = columns
            self.skewedInfo = skewedInfo
            self.outputFormat = outputFormat
            self.storedAsSubDirectories = storedAsSubDirectories
            self.sortColumns = sortColumns
            self.serdeInfo = serdeInfo
            self.numberOfBuckets = numberOfBuckets
            self.compressed = compressed
        }

        private enum CodingKeys: String, CodingKey {
            case inputFormat = "InputFormat"
            case parameters = "Parameters"
            case location = "Location"
            case bucketColumns = "BucketColumns"
            case columns = "Columns"
            case skewedInfo = "SkewedInfo"
            case outputFormat = "OutputFormat"
            case storedAsSubDirectories = "StoredAsSubDirectories"
            case sortColumns = "SortColumns"
            case serdeInfo = "SerdeInfo"
            case numberOfBuckets = "NumberOfBuckets"
            case compressed = "Compressed"
        }
    }

    public struct BatchGetPartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedKeys", required: false, type: .list), 
            AWSShapeMember(label: "Partitions", required: false, type: .list)
        ]
        /// A list of the partition values in the request for which partions were not returned.
        public let unprocessedKeys: [PartitionValueList]?
        /// A list of the requested partitions.
        public let partitions: [Partition]?

        public init(unprocessedKeys: [PartitionValueList]? = nil, partitions: [Partition]? = nil) {
            self.unprocessedKeys = unprocessedKeys
            self.partitions = partitions
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedKeys = "UnprocessedKeys"
            case partitions = "Partitions"
        }
    }

    public struct GetUserDefinedFunctionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserDefinedFunction", required: false, type: .structure)
        ]
        /// The requested function definition.
        public let userDefinedFunction: UserDefinedFunction?

        public init(userDefinedFunction: UserDefinedFunction? = nil) {
            self.userDefinedFunction = userDefinedFunction
        }

        private enum CodingKeys: String, CodingKey {
            case userDefinedFunction = "UserDefinedFunction"
        }
    }

    public struct CodeGenEdge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetParameter", required: false, type: .string), 
            AWSShapeMember(label: "Target", required: true, type: .string), 
            AWSShapeMember(label: "Source", required: true, type: .string)
        ]
        /// The target of the edge.
        public let targetParameter: String?
        /// The ID of the node at which the edge ends.
        public let target: String
        /// The ID of the node at which the edge starts.
        public let source: String

        public init(targetParameter: String? = nil, target: String, source: String) {
            self.targetParameter = targetParameter
            self.target = target
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case targetParameter = "TargetParameter"
            case target = "Target"
            case source = "Source"
        }
    }

    public struct JobRun: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PredecessorRuns", required: false, type: .list), 
            AWSShapeMember(label: "CompletedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "JobRunState", required: false, type: .enum), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "AllocatedCapacity", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "StartedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "Attempt", required: false, type: .integer), 
            AWSShapeMember(label: "TriggerName", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "PreviousRunId", required: false, type: .string), 
            AWSShapeMember(label: "Arguments", required: false, type: .map), 
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]
        /// A list of predecessors to this job run.
        public let predecessorRuns: [Predecessor]?
        /// The date and time this job run completed.
        public let completedOn: TimeStamp?
        /// The current state of the job run.
        public let jobRunState: JobRunState?
        /// An error message associated with this job run.
        public let errorMessage: String?
        /// The amount of infrastructure capacity allocated to this job run.
        public let allocatedCapacity: Int32?
        /// The ID of this job run.
        public let id: String?
        /// The date and time at which this job run was started.
        public let startedOn: TimeStamp?
        /// The number or the attempt to run this job.
        public let attempt: Int32?
        /// The name of the trigger for this job run.
        public let triggerName: String?
        /// The last time this job run was modified.
        public let lastModifiedOn: TimeStamp?
        /// The ID of the previous run of this job.
        public let previousRunId: String?
        /// The job arguments associated with this run.
        public let arguments: [String: String]?
        /// The name of the job being run.
        public let jobName: String?

        public init(predecessorRuns: [Predecessor]? = nil, completedOn: TimeStamp? = nil, jobRunState: JobRunState? = nil, errorMessage: String? = nil, allocatedCapacity: Int32? = nil, id: String? = nil, startedOn: TimeStamp? = nil, attempt: Int32? = nil, triggerName: String? = nil, lastModifiedOn: TimeStamp? = nil, previousRunId: String? = nil, arguments: [String: String]? = nil, jobName: String? = nil) {
            self.predecessorRuns = predecessorRuns
            self.completedOn = completedOn
            self.jobRunState = jobRunState
            self.errorMessage = errorMessage
            self.allocatedCapacity = allocatedCapacity
            self.id = id
            self.startedOn = startedOn
            self.attempt = attempt
            self.triggerName = triggerName
            self.lastModifiedOn = lastModifiedOn
            self.previousRunId = previousRunId
            self.arguments = arguments
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case predecessorRuns = "PredecessorRuns"
            case completedOn = "CompletedOn"
            case jobRunState = "JobRunState"
            case errorMessage = "ErrorMessage"
            case allocatedCapacity = "AllocatedCapacity"
            case id = "Id"
            case startedOn = "StartedOn"
            case attempt = "Attempt"
            case triggerName = "TriggerName"
            case lastModifiedOn = "LastModifiedOn"
            case previousRunId = "PreviousRunId"
            case arguments = "Arguments"
            case jobName = "JobName"
        }
    }

    public struct CreateConnectionResponse: AWSShape {

    }

    public struct CodeGenNodeArg: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Param", required: false, type: .boolean)
        ]
        /// The value of the argument or property.
        public let value: String
        /// The name of the argument or property.
        public let name: String
        /// True if the value is used as a parameter.
        public let param: Bool?

        public init(value: String, name: String, param: Bool? = nil) {
            self.value = value
            self.name = name
            self.param = param
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case name = "Name"
            case param = "Param"
        }
    }

    public struct BatchStopJobRunError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "JobRunId", required: false, type: .string)
        ]
        /// The details of the error that occurred.
        public let errorDetail: ErrorDetail?
        /// The name of the job.
        public let jobName: String?
        /// The job run Id.
        public let jobRunId: String?

        public init(errorDetail: ErrorDetail? = nil, jobName: String? = nil, jobRunId: String? = nil) {
            self.errorDetail = errorDetail
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct CreateConnectionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionInput", required: true, type: .structure)
        ]
        /// The ID of the Data Catalog in which to create the connection. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object defining the connection to create.
        public let connectionInput: ConnectionInput

        public init(catalogId: String? = nil, connectionInput: ConnectionInput) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
        }
    }

    public struct GetConnectionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionList", required: false, type: .list)
        ]
        /// A continuation token, if the list of connections returned does not include the last of the filtered connections.
        public let nextToken: String?
        /// A list of requested connection definitions.
        public let connectionList: [Connection]?

        public init(nextToken: String? = nil, connectionList: [Connection]? = nil) {
            self.nextToken = nextToken
            self.connectionList = connectionList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case connectionList = "ConnectionList"
        }
    }

    public struct UpdateCrawlerResponse: AWSShape {

    }

    public struct GetCrawlersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Crawlers", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of crawler metadata.
        public let crawlers: [Crawler]?
        /// A continuation token, if the returned list has not reached the end of those defined in this customer account.
        public let nextToken: String?

        public init(crawlers: [Crawler]? = nil, nextToken: String? = nil) {
            self.crawlers = crawlers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case nextToken = "NextToken"
        }
    }

    public struct Predicate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Logical", required: false, type: .enum), 
            AWSShapeMember(label: "Conditions", required: false, type: .list)
        ]
        /// Currently "OR" is not supported.
        public let logical: Logical?
        /// A list of the conditions that determine when the trigger will fire.
        public let conditions: [Condition]?

        public init(logical: Logical? = nil, conditions: [Condition]? = nil) {
            self.logical = logical
            self.conditions = conditions
        }

        private enum CodingKeys: String, CodingKey {
            case logical = "Logical"
            case conditions = "Conditions"
        }
    }

    public struct CreateCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TablePrefix", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Targets", required: true, type: .structure), 
            AWSShapeMember(label: "Role", required: true, type: .string), 
            AWSShapeMember(label: "Configuration", required: false, type: .string), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "Classifiers", required: false, type: .list), 
            AWSShapeMember(label: "SchemaChangePolicy", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// Name of the new crawler.
        public let name: String
        /// The AWS Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String
        /// A list of collection of targets to crawl.
        public let targets: CrawlerTargets
        /// The IAM role (or ARN of an IAM role) used by the new crawler to access customer resources.
        public let role: String
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a Crawler's behavior. You can use this field to force partitions to inherit metadata such as classification, input format, output format, serde information, and schema from their parent table, rather than detect this information separately for each partition.
        public let configuration: String?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// A list of custom classifiers that the user has registered. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// Policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// A description of the new crawler.
        public let description: String?

        public init(tablePrefix: String? = nil, name: String, databaseName: String, targets: CrawlerTargets, role: String, configuration: String? = nil, schedule: String? = nil, classifiers: [String]? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, description: String? = nil) {
            self.tablePrefix = tablePrefix
            self.name = name
            self.databaseName = databaseName
            self.targets = targets
            self.role = role
            self.configuration = configuration
            self.schedule = schedule
            self.classifiers = classifiers
            self.schemaChangePolicy = schemaChangePolicy
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case tablePrefix = "TablePrefix"
            case name = "Name"
            case databaseName = "DatabaseName"
            case targets = "Targets"
            case role = "Role"
            case configuration = "Configuration"
            case schedule = "Schedule"
            case classifiers = "Classifiers"
            case schemaChangePolicy = "SchemaChangePolicy"
            case description = "Description"
        }
    }

    public struct GetDataflowGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PythonScript", required: false, type: .string)
        ]
        /// The Python script to transform.
        public let pythonScript: String?

        public init(pythonScript: String? = nil) {
            self.pythonScript = pythonScript
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
        }
    }

    public struct ExecutionProperty: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxConcurrentRuns", required: false, type: .integer)
        ]
        /// The maximum number of concurrent runs allowed for a job.
        public let maxConcurrentRuns: Int32?

        public init(maxConcurrentRuns: Int32? = nil) {
            self.maxConcurrentRuns = maxConcurrentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrentRuns = "MaxConcurrentRuns"
        }
    }

    public struct GetCatalogImportStatusResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportStatus", required: false, type: .structure)
        ]
        /// The status of the specified catalog migration.
        public let importStatus: CatalogImportStatus?

        public init(importStatus: CatalogImportStatus? = nil) {
            self.importStatus = importStatus
        }

        private enum CodingKeys: String, CodingKey {
            case importStatus = "ImportStatus"
        }
    }

    public struct BatchCreatePartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]
        /// Errors encountered when trying to create the requested partitions.
        public let errors: [PartitionError]?

        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct GetPartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PartitionValues", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the partition's table.
        public let tableName: String
        /// The ID of the Data Catalog where the partition in question resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partition resides.
        public let databaseName: String

        public init(partitionValues: [String], tableName: String, catalogId: String? = nil, databaseName: String) {
            self.partitionValues = partitionValues
            self.tableName = tableName
            self.catalogId = catalogId
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
        }
    }

    public struct ImportCatalogToGlueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]
        /// The ID of the catalog to import. Currently, this should be the AWS account ID.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct UpdatePartitionResponse: AWSShape {

    }

    public struct CreateScriptRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DagEdges", required: false, type: .list), 
            AWSShapeMember(label: "DagNodes", required: false, type: .list)
        ]
        /// A list of the edges in the DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the DAG.
        public let dagNodes: [CodeGenNode]?

        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
        }
    }

    public struct UpdateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobUpdate", required: true, type: .structure), 
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]
        /// Specifies the values with which to update the job.
        public let jobUpdate: JobUpdate
        /// Name of the job definition to update.
        public let jobName: String

        public init(jobUpdate: JobUpdate, jobName: String) {
            self.jobUpdate = jobUpdate
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobUpdate = "JobUpdate"
            case jobName = "JobName"
        }
    }

    public struct UpdateTableResponse: AWSShape {

    }

    public struct CreateClassifierResponse: AWSShape {

    }

    public struct UpdateTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "TableInput", required: true, type: .structure), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// An updated TableInput object to define the metadata table in the catalog.
        public let tableInput: TableInput
        /// The name of the catalog database in which the table resides.
        public let databaseName: String

        public init(catalogId: String? = nil, tableInput: TableInput, databaseName: String) {
            self.catalogId = catalogId
            self.tableInput = tableInput
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case tableInput = "TableInput"
            case databaseName = "DatabaseName"
        }
    }

    public struct GetPlanResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PythonScript", required: false, type: .string)
        ]
        /// A Python script to perform the mapping.
        public let pythonScript: String?

        public init(pythonScript: String? = nil) {
            self.pythonScript = pythonScript
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
        }
    }

    public struct Predecessor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RunId", required: false, type: .string), 
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]
        /// The job-run ID of the precessor job run.
        public let runId: String?
        /// The name of the predecessor job.
        public let jobName: String?

        public init(runId: String? = nil, jobName: String? = nil) {
            self.runId = runId
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
            case jobName = "JobName"
        }
    }

    public struct GetTriggerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Trigger", required: false, type: .structure)
        ]
        /// The requested trigger definition.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public enum TriggerState: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case created = "CREATED"
        case activating = "ACTIVATING"
        case activated = "ACTIVATED"
        case deactivating = "DEACTIVATING"
        case deactivated = "DEACTIVATED"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public struct Segment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalSegments", required: true, type: .integer), 
            AWSShapeMember(label: "SegmentNumber", required: true, type: .integer)
        ]
        /// The total numer of segments.
        public let totalSegments: Int32
        /// The zero-based index number of the this segment. For example, if the total number of segments is 4, SegmentNumber values will range from zero through three.
        public let segmentNumber: Int32

        public init(totalSegments: Int32, segmentNumber: Int32) {
            self.totalSegments = totalSegments
            self.segmentNumber = segmentNumber
        }

        private enum CodingKeys: String, CodingKey {
            case totalSegments = "TotalSegments"
            case segmentNumber = "SegmentNumber"
        }
    }

    public struct ConnectionsList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connections", required: false, type: .list)
        ]
        /// A list of connections used by the job.
        public let connections: [String]?

        public init(connections: [String]? = nil) {
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
        }
    }

    public struct GetCatalogImportStatusRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]
        /// The ID of the catalog to migrate. Currently, this should be the AWS account ID.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct CreateClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GrokClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "XMLClassifier", required: false, type: .structure)
        ]
        /// A GrokClassifier object specifying the classifier to create.
        public let grokClassifier: CreateGrokClassifierRequest?
        /// An XMLClassifier object specifying the classifier to create.
        public let xMLClassifier: CreateXMLClassifierRequest?

        public init(grokClassifier: CreateGrokClassifierRequest? = nil, xMLClassifier: CreateXMLClassifierRequest? = nil) {
            self.grokClassifier = grokClassifier
            self.xMLClassifier = xMLClassifier
        }

        private enum CodingKeys: String, CodingKey {
            case grokClassifier = "GrokClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct DeletePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PartitionValues", required: true, type: .list), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the table where the partition to be deleted is located.
        public let tableName: String
        /// The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String

        public init(partitionValues: [String], tableName: String, catalogId: String? = nil, databaseName: String) {
            self.partitionValues = partitionValues
            self.tableName = tableName
            self.catalogId = catalogId
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
        }
    }

    public struct UpdatePartitionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PartitionInput", required: true, type: .structure), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "PartitionValueList", required: true, type: .list), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The new partition object to which to update the partition.
        public let partitionInput: PartitionInput
        /// The name of the table where the partition to be updated is located.
        public let tableName: String
        /// The ID of the Data Catalog where the partition to be updated resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A list of the values defining the partition.
        public let partitionValueList: [String]
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String

        public init(partitionInput: PartitionInput, tableName: String, catalogId: String? = nil, partitionValueList: [String], databaseName: String) {
            self.partitionInput = partitionInput
            self.tableName = tableName
            self.catalogId = catalogId
            self.partitionValueList = partitionValueList
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case partitionInput = "PartitionInput"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case partitionValueList = "PartitionValueList"
            case databaseName = "DatabaseName"
        }
    }

    public struct CreateXMLClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RowTag", required: false, type: .string)
        ]
        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot be an empty element. It must contain child elements representing fields in the record.
        public let rowTag: String?

        public init(classification: String, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct UpdateCrawlerScheduleResponse: AWSShape {

    }

    public enum ConnectionPropertyKey: String, CustomStringConvertible, Codable {
        case host = "HOST"
        case port = "PORT"
        case username = "USERNAME"
        case password = "PASSWORD"
        case jdbcDriverJarUri = "JDBC_DRIVER_JAR_URI"
        case jdbcDriverClassName = "JDBC_DRIVER_CLASS_NAME"
        case jdbcEngine = "JDBC_ENGINE"
        case jdbcEngineVersion = "JDBC_ENGINE_VERSION"
        case configFiles = "CONFIG_FILES"
        case instanceId = "INSTANCE_ID"
        case jdbcConnectionUrl = "JDBC_CONNECTION_URL"
        public var description: String { return self.rawValue }
    }

    public struct GetJobRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRun", required: false, type: .structure)
        ]
        /// The requested job-run metadata.
        public let jobRun: JobRun?

        public init(jobRun: JobRun? = nil) {
            self.jobRun = jobRun
        }

        private enum CodingKeys: String, CodingKey {
            case jobRun = "JobRun"
        }
    }

    public struct CrawlerMetrics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TablesDeleted", required: false, type: .integer), 
            AWSShapeMember(label: "TimeLeftSeconds", required: false, type: .double), 
            AWSShapeMember(label: "CrawlerName", required: false, type: .string), 
            AWSShapeMember(label: "LastRuntimeSeconds", required: false, type: .double), 
            AWSShapeMember(label: "TablesCreated", required: false, type: .integer), 
            AWSShapeMember(label: "MedianRuntimeSeconds", required: false, type: .double), 
            AWSShapeMember(label: "StillEstimating", required: false, type: .boolean), 
            AWSShapeMember(label: "TablesUpdated", required: false, type: .integer)
        ]
        /// The number of tables deleted by this crawler.
        public let tablesDeleted: Int32?
        /// The estimated time left to complete a running crawl.
        public let timeLeftSeconds: Double?
        /// The name of the crawler.
        public let crawlerName: String?
        /// The duration of the crawler's most recent run, in seconds.
        public let lastRuntimeSeconds: Double?
        /// The number of tables created by this crawler.
        public let tablesCreated: Int32?
        /// The median duration of this crawler's runs, in seconds.
        public let medianRuntimeSeconds: Double?
        /// True if the crawler is still estimating how long it will take to complete this run.
        public let stillEstimating: Bool?
        /// The number of tables updated by this crawler.
        public let tablesUpdated: Int32?

        public init(tablesDeleted: Int32? = nil, timeLeftSeconds: Double? = nil, crawlerName: String? = nil, lastRuntimeSeconds: Double? = nil, tablesCreated: Int32? = nil, medianRuntimeSeconds: Double? = nil, stillEstimating: Bool? = nil, tablesUpdated: Int32? = nil) {
            self.tablesDeleted = tablesDeleted
            self.timeLeftSeconds = timeLeftSeconds
            self.crawlerName = crawlerName
            self.lastRuntimeSeconds = lastRuntimeSeconds
            self.tablesCreated = tablesCreated
            self.medianRuntimeSeconds = medianRuntimeSeconds
            self.stillEstimating = stillEstimating
            self.tablesUpdated = tablesUpdated
        }

        private enum CodingKeys: String, CodingKey {
            case tablesDeleted = "TablesDeleted"
            case timeLeftSeconds = "TimeLeftSeconds"
            case crawlerName = "CrawlerName"
            case lastRuntimeSeconds = "LastRuntimeSeconds"
            case tablesCreated = "TablesCreated"
            case medianRuntimeSeconds = "MedianRuntimeSeconds"
            case stillEstimating = "StillEstimating"
            case tablesUpdated = "TablesUpdated"
        }
    }

    public struct GetPartitionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Partition", required: false, type: .structure)
        ]
        /// The requested information, in the form of a Partition object.
        public let partition: Partition?

        public init(partition: Partition? = nil) {
            self.partition = partition
        }

        private enum CodingKeys: String, CodingKey {
            case partition = "Partition"
        }
    }

    public struct XMLClassifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "RowTag", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long)
        ]
        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The time this classifier was last updated.
        public let lastUpdated: TimeStamp?
        /// The time this classifier was registered.
        public let creationTime: TimeStamp?
        /// The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot be an empty element. It must contain child elements representing fields in the record.
        public let rowTag: String?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        public init(classification: String, lastUpdated: TimeStamp? = nil, creationTime: TimeStamp? = nil, rowTag: String? = nil, name: String, version: Int64? = nil) {
            self.classification = classification
            self.lastUpdated = lastUpdated
            self.creationTime = creationTime
            self.rowTag = rowTag
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case lastUpdated = "LastUpdated"
            case creationTime = "CreationTime"
            case rowTag = "RowTag"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct StartCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the crawler to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartJobRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobRunId", required: false, type: .string)
        ]
        /// The ID assigned to this job run.
        public let jobRunId: String?

        public init(jobRunId: String? = nil) {
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobRunId = "JobRunId"
        }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable {
        case jdbc = "JDBC"
        case sftp = "SFTP"
        public var description: String { return self.rawValue }
    }

    public struct DeleteClassifierResponse: AWSShape {

    }

    public struct BatchDeleteTableResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]
        /// A list of errors encountered in attempting to delete the specified tables.
        public let errors: [TableError]?

        public init(errors: [TableError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct GetTablesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TableList", required: false, type: .list)
        ]
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of the requested Table objects.
        public let tableList: [Table]?

        public init(nextToken: String? = nil, tableList: [Table]? = nil) {
            self.nextToken = nextToken
            self.tableList = tableList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableList = "TableList"
        }
    }

    public struct Classifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GrokClassifier", required: false, type: .structure), 
            AWSShapeMember(label: "XMLClassifier", required: false, type: .structure)
        ]
        /// A GrokClassifier object.
        public let grokClassifier: GrokClassifier?
        /// An XMLClassifier object.
        public let xMLClassifier: XMLClassifier?

        public init(grokClassifier: GrokClassifier? = nil, xMLClassifier: XMLClassifier? = nil) {
            self.grokClassifier = grokClassifier
            self.xMLClassifier = xMLClassifier
        }

        private enum CodingKeys: String, CodingKey {
            case grokClassifier = "GrokClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct SerDeInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SerializationLibrary", required: false, type: .string)
        ]
        /// A list of initialization parameters for the SerDe, in key-value form.
        public let parameters: [String: String]?
        /// Name of the SerDe.
        public let name: String?
        /// Usually the class that implements the SerDe. An example is: org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        public let serializationLibrary: String?

        public init(parameters: [String: String]? = nil, name: String? = nil, serializationLibrary: String? = nil) {
            self.parameters = parameters
            self.name = name
            self.serializationLibrary = serializationLibrary
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
            case name = "Name"
            case serializationLibrary = "SerializationLibrary"
        }
    }

    public struct LastCrawlInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "LogGroup", required: false, type: .string), 
            AWSShapeMember(label: "MessagePrefix", required: false, type: .string), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "LogStream", required: false, type: .string)
        ]
        /// The time at which the crawl started.
        public let startTime: TimeStamp?
        /// Status of the last crawl.
        public let status: LastCrawlStatus?
        /// The log group for the last crawl.
        public let logGroup: String?
        /// The prefix for a message about this crawl.
        public let messagePrefix: String?
        /// If an error occurred, the error information about the last crawl.
        public let errorMessage: String?
        /// The log stream for the last crawl.
        public let logStream: String?

        public init(startTime: TimeStamp? = nil, status: LastCrawlStatus? = nil, logGroup: String? = nil, messagePrefix: String? = nil, errorMessage: String? = nil, logStream: String? = nil) {
            self.startTime = startTime
            self.status = status
            self.logGroup = logGroup
            self.messagePrefix = messagePrefix
            self.errorMessage = errorMessage
            self.logStream = logStream
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case status = "Status"
            case logGroup = "LogGroup"
            case messagePrefix = "MessagePrefix"
            case errorMessage = "ErrorMessage"
            case logStream = "LogStream"
        }
    }

    public enum ScheduleState: String, CustomStringConvertible, Codable {
        case scheduled = "SCHEDULED"
        case notScheduled = "NOT_SCHEDULED"
        case transitioning = "TRANSITIONING"
        public var description: String { return self.rawValue }
    }

    public struct TableInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableType", required: false, type: .string), 
            AWSShapeMember(label: "ViewOriginalText", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "PartitionKeys", required: false, type: .list), 
            AWSShapeMember(label: "Retention", required: false, type: .integer), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "ViewExpandedText", required: false, type: .string), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Owner", required: false, type: .string), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).
        public let tableType: String?
        /// If the table is a view, the original text of the view; otherwise null.
        public let viewOriginalText: String?
        /// Properties associated with this table, as a list of key-value pairs.
        public let parameters: [String: String]?
        /// Name of the table.
        public let name: String
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.
        public let partitionKeys: [Column]?
        /// Retention time for this table.
        public let retention: Int32?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// If the table is a view, the expanded text of the view; otherwise null.
        public let viewExpandedText: String?
        /// Last time the table was accessed.
        public let lastAccessTime: TimeStamp?
        /// Owner of the table.
        public let owner: String?
        /// Last time column statistics were computed for this table.
        public let lastAnalyzedTime: TimeStamp?
        /// Description of the table.
        public let description: String?

        public init(tableType: String? = nil, viewOriginalText: String? = nil, parameters: [String: String]? = nil, name: String, partitionKeys: [Column]? = nil, retention: Int32? = nil, storageDescriptor: StorageDescriptor? = nil, viewExpandedText: String? = nil, lastAccessTime: TimeStamp? = nil, owner: String? = nil, lastAnalyzedTime: TimeStamp? = nil, description: String? = nil) {
            self.tableType = tableType
            self.viewOriginalText = viewOriginalText
            self.parameters = parameters
            self.name = name
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.viewExpandedText = viewExpandedText
            self.lastAccessTime = lastAccessTime
            self.owner = owner
            self.lastAnalyzedTime = lastAnalyzedTime
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case tableType = "TableType"
            case viewOriginalText = "ViewOriginalText"
            case parameters = "Parameters"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case storageDescriptor = "StorageDescriptor"
            case viewExpandedText = "ViewExpandedText"
            case lastAccessTime = "LastAccessTime"
            case owner = "Owner"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case description = "Description"
        }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case jar = "JAR"
        case file = "FILE"
        case archive = "ARCHIVE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteCrawlerResponse: AWSShape {

    }

    public struct CreateDevEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "EndpointName", required: false, type: .string), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "ZeppelinRemoteSparkInterpreterPort", required: false, type: .integer), 
            AWSShapeMember(label: "VpcId", required: false, type: .string), 
            AWSShapeMember(label: "YarnEndpointAddress", required: false, type: .string), 
            AWSShapeMember(label: "NumberOfNodes", required: false, type: .integer), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "FailureReason", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: false, type: .string)
        ]
        /// The subnet ID assigned to the new DevEndpoint.
        public let subnetId: String?
        /// Path(s) to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraPythonLibsS3Path: String?
        /// The security groups assigned to the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The name assigned to the new DevEndpoint.
        public let endpointName: String?
        /// The AWS availability zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: TimeStamp?
        /// The current status of the new DevEndpoint.
        public let status: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int32?
        /// The ID of the VPC used by this DevEndpoint.
        public let vpcId: String?
        /// The address of the YARN endpoint used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The number of AWS Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int32?
        /// Path to one or more Java Jars in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// The AWS ARN of the role assigned to the new DevEndpoint.
        public let roleArn: String?

        public init(subnetId: String? = nil, extraPythonLibsS3Path: String? = nil, securityGroupIds: [String]? = nil, endpointName: String? = nil, availabilityZone: String? = nil, createdTimestamp: TimeStamp? = nil, status: String? = nil, zeppelinRemoteSparkInterpreterPort: Int32? = nil, vpcId: String? = nil, yarnEndpointAddress: String? = nil, numberOfNodes: Int32? = nil, extraJarsS3Path: String? = nil, failureReason: String? = nil, roleArn: String? = nil) {
            self.subnetId = subnetId
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.securityGroupIds = securityGroupIds
            self.endpointName = endpointName
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.status = status
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
            self.vpcId = vpcId
            self.yarnEndpointAddress = yarnEndpointAddress
            self.numberOfNodes = numberOfNodes
            self.extraJarsS3Path = extraJarsS3Path
            self.failureReason = failureReason
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case securityGroupIds = "SecurityGroupIds"
            case endpointName = "EndpointName"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case status = "Status"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
            case vpcId = "VpcId"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case numberOfNodes = "NumberOfNodes"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case failureReason = "FailureReason"
            case roleArn = "RoleArn"
        }
    }

    public struct GetTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the table for which to retrieve the definition.
        public let name: String
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String

        public init(catalogId: String? = nil, name: String, databaseName: String) {
            self.catalogId = catalogId
            self.name = name
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
            case databaseName = "DatabaseName"
        }
    }

    public struct CreateDatabaseResponse: AWSShape {

    }

    public struct DeleteUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "FunctionName", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the function definition to be deleted.
        public let functionName: String
        /// The name of the catalog database where the function is located.
        public let databaseName: String

        public init(catalogId: String? = nil, functionName: String, databaseName: String) {
            self.catalogId = catalogId
            self.functionName = functionName
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case functionName = "FunctionName"
            case databaseName = "DatabaseName"
        }
    }

    public struct GetClassifiersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Classifiers", required: false, type: .list)
        ]
        /// A continuation token.
        public let nextToken: String?
        /// The requested list of classifier objects.
        public let classifiers: [Classifier]?

        public init(nextToken: String? = nil, classifiers: [Classifier]? = nil) {
            self.nextToken = nextToken
            self.classifiers = classifiers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case classifiers = "Classifiers"
        }
    }

    public struct GetTriggersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Triggers", required: false, type: .list)
        ]
        /// A continuation token, if not all the requested triggers have yet been returned.
        public let nextToken: String?
        /// A list of triggers for the specified job.
        public let triggers: [Trigger]?

        public init(nextToken: String? = nil, triggers: [Trigger]? = nil) {
            self.nextToken = nextToken
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggers = "Triggers"
        }
    }

    public struct Table: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableType", required: false, type: .string), 
            AWSShapeMember(label: "ViewOriginalText", required: false, type: .string), 
            AWSShapeMember(label: "UpdateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Retention", required: false, type: .integer), 
            AWSShapeMember(label: "ViewExpandedText", required: false, type: .string), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Owner", required: false, type: .string), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "PartitionKeys", required: false, type: .list), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CreatedBy", required: false, type: .string)
        ]
        /// The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).
        public let tableType: String?
        /// If the table is a view, the original text of the view; otherwise null.
        public let viewOriginalText: String?
        /// Last time the table was updated.
        public let updateTime: TimeStamp?
        /// Retention time for this table.
        public let retention: Int32?
        /// If the table is a view, the expanded text of the view; otherwise null.
        public let viewExpandedText: String?
        /// Last time the table was accessed. This is usually taken from HDFS, and may not be reliable.
        public let lastAccessTime: TimeStamp?
        /// Owner of the table.
        public let owner: String?
        /// Last time column statistics were computed for this table.
        public let lastAnalyzedTime: TimeStamp?
        /// Description of the table.
        public let description: String?
        /// Properties associated with this table, as a list of key-value pairs.
        public let parameters: [String: String]?
        /// Name of the table.
        public let name: String
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.
        public let partitionKeys: [Column]?
        /// Name of the metadata database where the table metadata resides.
        public let databaseName: String?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// Time when the table definition was created in the Data Catalog.
        public let createTime: TimeStamp?
        /// Person or entity who created the table.
        public let createdBy: String?

        public init(tableType: String? = nil, viewOriginalText: String? = nil, updateTime: TimeStamp? = nil, retention: Int32? = nil, viewExpandedText: String? = nil, lastAccessTime: TimeStamp? = nil, owner: String? = nil, lastAnalyzedTime: TimeStamp? = nil, description: String? = nil, parameters: [String: String]? = nil, name: String, partitionKeys: [Column]? = nil, databaseName: String? = nil, storageDescriptor: StorageDescriptor? = nil, createTime: TimeStamp? = nil, createdBy: String? = nil) {
            self.tableType = tableType
            self.viewOriginalText = viewOriginalText
            self.updateTime = updateTime
            self.retention = retention
            self.viewExpandedText = viewExpandedText
            self.lastAccessTime = lastAccessTime
            self.owner = owner
            self.lastAnalyzedTime = lastAnalyzedTime
            self.description = description
            self.parameters = parameters
            self.name = name
            self.partitionKeys = partitionKeys
            self.databaseName = databaseName
            self.storageDescriptor = storageDescriptor
            self.createTime = createTime
            self.createdBy = createdBy
        }

        private enum CodingKeys: String, CodingKey {
            case tableType = "TableType"
            case viewOriginalText = "ViewOriginalText"
            case updateTime = "UpdateTime"
            case retention = "Retention"
            case viewExpandedText = "ViewExpandedText"
            case lastAccessTime = "LastAccessTime"
            case owner = "Owner"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case description = "Description"
            case parameters = "Parameters"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case databaseName = "DatabaseName"
            case storageDescriptor = "StorageDescriptor"
            case createTime = "CreateTime"
            case createdBy = "CreatedBy"
        }
    }

    public struct PartitionError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorDetail", required: false, type: .structure), 
            AWSShapeMember(label: "PartitionValues", required: false, type: .list)
        ]
        /// Details about the partition error.
        public let errorDetail: ErrorDetail?
        /// The values that define the partition.
        public let partitionValues: [String]?

        public init(errorDetail: ErrorDetail? = nil, partitionValues: [String]? = nil) {
            self.errorDetail = errorDetail
            self.partitionValues = partitionValues
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case partitionValues = "PartitionValues"
        }
    }

    public struct UpdateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string)
        ]
        /// Returns the name of the updated job.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct Database: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "LocationUri", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The time at which the metadata database was created in the catalog.
        public let createTime: TimeStamp?
        /// A list of key-value pairs that define parameters and properties of the database.
        public let parameters: [String: String]?
        /// Name of the database.
        public let name: String
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// Description of the database.
        public let description: String?

        public init(createTime: TimeStamp? = nil, parameters: [String: String]? = nil, name: String, locationUri: String? = nil, description: String? = nil) {
            self.createTime = createTime
            self.parameters = parameters
            self.name = name
            self.locationUri = locationUri
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case parameters = "Parameters"
            case name = "Name"
            case locationUri = "LocationUri"
            case description = "Description"
        }
    }

    public struct CodeGenNode: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NodeType", required: true, type: .string), 
            AWSShapeMember(label: "Args", required: true, type: .list), 
            AWSShapeMember(label: "LineNumber", required: false, type: .integer), 
            AWSShapeMember(label: "Id", required: true, type: .string)
        ]
        /// The type of node this is.
        public let nodeType: String
        /// Properties of the node, in the form of name-value pairs.
        public let args: [CodeGenNodeArg]
        /// The line number of the node.
        public let lineNumber: Int32?
        /// A node identifier that is unique within the node's graph.
        public let id: String

        public init(nodeType: String, args: [CodeGenNodeArg], lineNumber: Int32? = nil, id: String) {
            self.nodeType = nodeType
            self.args = args
            self.lineNumber = lineNumber
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case nodeType = "NodeType"
            case args = "Args"
            case lineNumber = "LineNumber"
            case id = "Id"
        }
    }

    public struct Schedule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "ScheduleExpression", required: false, type: .string)
        ]
        /// The state of the schedule.
        public let state: ScheduleState?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let scheduleExpression: String?

        public init(state: ScheduleState? = nil, scheduleExpression: String? = nil) {
            self.state = state
            self.scheduleExpression = scheduleExpression
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case scheduleExpression = "ScheduleExpression"
        }
    }

    public struct BatchStopJobRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SuccessfulSubmissions", required: false, type: .list), 
            AWSShapeMember(label: "Errors", required: false, type: .list)
        ]
        /// A list of job runs which are successfully submitted for stopping.
        public let successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]?
        /// A list containing the job run Ids and details of the error that occurred for each job run while submitting to stop.
        public let errors: [BatchStopJobRunError]?

        public init(successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]? = nil, errors: [BatchStopJobRunError]? = nil) {
            self.successfulSubmissions = successfulSubmissions
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case successfulSubmissions = "SuccessfulSubmissions"
            case errors = "Errors"
        }
    }

    public struct DeleteClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the classifier to remove.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct TriggerUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Actions", required: false, type: .list), 
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "Predicate", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// An updated cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// The name of the trigger.
        public let name: String?
        /// A description of this trigger.
        public let description: String?

        public init(actions: [Action]? = nil, schedule: String? = nil, predicate: Predicate? = nil, name: String? = nil, description: String? = nil) {
            self.actions = actions
            self.schedule = schedule
            self.predicate = predicate
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case schedule = "Schedule"
            case predicate = "Predicate"
            case name = "Name"
            case description = "Description"
        }
    }

    public struct DeleteConnectionResponse: AWSShape {

    }

    public struct MappingEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceTable", required: false, type: .string), 
            AWSShapeMember(label: "TargetTable", required: false, type: .string), 
            AWSShapeMember(label: "TargetType", required: false, type: .string), 
            AWSShapeMember(label: "TargetPath", required: false, type: .string), 
            AWSShapeMember(label: "SourcePath", required: false, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .string)
        ]
        /// The name of the source table.
        public let sourceTable: String?
        /// The target table.
        public let targetTable: String?
        /// The target type.
        public let targetType: String?
        /// The target path.
        public let targetPath: String?
        /// The source path.
        public let sourcePath: String?
        /// The source type.
        public let sourceType: String?

        public init(sourceTable: String? = nil, targetTable: String? = nil, targetType: String? = nil, targetPath: String? = nil, sourcePath: String? = nil, sourceType: String? = nil) {
            self.sourceTable = sourceTable
            self.targetTable = targetTable
            self.targetType = targetType
            self.targetPath = targetPath
            self.sourcePath = sourcePath
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTable = "SourceTable"
            case targetTable = "TargetTable"
            case targetType = "TargetType"
            case targetPath = "TargetPath"
            case sourcePath = "SourcePath"
            case sourceType = "SourceType"
        }
    }

    public struct CreateDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "PublicKey", required: true, type: .string), 
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "NumberOfNodes", required: false, type: .integer), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string)
        ]
        /// The subnet ID for the new DevEndpoint to use.
        public let subnetId: String?
        /// The public key to use for authentication.
        public let publicKey: String
        /// Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// Security group IDs for the security groups to be used by the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The name to be assigned to the new DevEndpoint.
        public let endpointName: String
        /// The number of AWS Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
        public let numberOfNodes: Int32?
        /// Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// The IAM role for the DevEndpoint.
        public let roleArn: String

        public init(subnetId: String? = nil, publicKey: String, extraPythonLibsS3Path: String? = nil, securityGroupIds: [String]? = nil, endpointName: String, numberOfNodes: Int32? = nil, extraJarsS3Path: String? = nil, roleArn: String) {
            self.subnetId = subnetId
            self.publicKey = publicKey
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.securityGroupIds = securityGroupIds
            self.endpointName = endpointName
            self.numberOfNodes = numberOfNodes
            self.extraJarsS3Path = extraJarsS3Path
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case publicKey = "PublicKey"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case securityGroupIds = "SecurityGroupIds"
            case endpointName = "EndpointName"
            case numberOfNodes = "NumberOfNodes"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case roleArn = "RoleArn"
        }
    }

    public struct GetDevEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum size of information to return.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct CreateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The unique name of the new job that has been created.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct BatchDeleteTableRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "TablesToDelete", required: true, type: .list), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A list of the table to delete.
        public let tablesToDelete: [String]
        /// The name of the catalog database where the tables to delete reside.
        public let databaseName: String

        public init(catalogId: String? = nil, tablesToDelete: [String], databaseName: String) {
            self.catalogId = catalogId
            self.tablesToDelete = tablesToDelete
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case tablesToDelete = "TablesToDelete"
            case databaseName = "DatabaseName"
        }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public struct GetCrawlerMetricsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "CrawlerNameList", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// A list of the names of crawlers about which to retrieve metrics.
        public let crawlerNameList: [String]?
        /// The maximum size of a list to return.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, crawlerNameList: [String]? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.crawlerNameList = crawlerNameList
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case crawlerNameList = "CrawlerNameList"
            case maxResults = "MaxResults"
        }
    }

    public struct GetDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the database to retrieve.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct BatchStopJobRunSuccessfulSubmission: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: false, type: .string), 
            AWSShapeMember(label: "JobRunId", required: false, type: .string)
        ]
        /// The name of the job.
        public let jobName: String?
        /// The job run Id.
        public let jobRunId: String?

        public init(jobName: String? = nil, jobRunId: String? = nil) {
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct UpdateXMLClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Classification", required: false, type: .string), 
            AWSShapeMember(label: "RowTag", required: false, type: .string)
        ]
        /// The name of the classifier.
        public let name: String
        /// An identifier of the data format that the classifier matches.
        public let classification: String?
        /// The XML tag designating the element that contains each record in an XML document being parsed. Note that this cannot be an empty element. It must contain child elements representing fields in the record.
        public let rowTag: String?

        public init(name: String, classification: String? = nil, rowTag: String? = nil) {
            self.name = name
            self.classification = classification
            self.rowTag = rowTag
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case classification = "Classification"
            case rowTag = "RowTag"
        }
    }

    public struct UpdateDatabaseResponse: AWSShape {

    }

    public struct UpdateDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseInput", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string)
        ]
        /// A DatabaseInput object specifying the new definition of the metadata database in the catalog.
        public let databaseInput: DatabaseInput
        /// The name of the metadata database to update in the catalog.
        public let name: String
        /// The ID of the Data Catalog in which the metadata database resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?

        public init(databaseInput: DatabaseInput, name: String, catalogId: String? = nil) {
            self.databaseInput = databaseInput
            self.name = name
            self.catalogId = catalogId
        }

        private enum CodingKeys: String, CodingKey {
            case databaseInput = "DatabaseInput"
            case name = "Name"
            case catalogId = "CatalogId"
        }
    }

    public struct DevEndpointCustomLibraries: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExtraPythonLibsS3Path", required: false, type: .string), 
            AWSShapeMember(label: "ExtraJarsS3Path", required: false, type: .string)
        ]
        /// Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma. Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint. Please note that only pure Java/Scala libraries can currently be used on a DevEndpoint.
        public let extraJarsS3Path: String?

        public init(extraPythonLibsS3Path: String? = nil, extraJarsS3Path: String? = nil) {
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.extraJarsS3Path = extraJarsS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case extraJarsS3Path = "ExtraJarsS3Path"
        }
    }

    public struct GetDatabasesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseList", required: true, type: .list)
        ]
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// A list of Database objects from the specified catalog.
        public let databaseList: [Database]

        public init(nextToken: String? = nil, databaseList: [Database]) {
            self.nextToken = nextToken
            self.databaseList = databaseList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case databaseList = "DatabaseList"
        }
    }

    public struct CreateTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "Predicate", required: false, type: .structure), 
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Actions", required: true, type: .list), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// A predicate to specify when the new trigger should fire.
        public let predicate: Predicate?
        /// The type of the new trigger.
        public let `type`: TriggerType
        /// The name to assign to the new trigger.
        public let name: String
        /// The actions initiated by this trigger when it fires.
        public let actions: [Action]
        /// A description of the new trigger.
        public let description: String?

        public init(schedule: String? = nil, predicate: Predicate? = nil, type: TriggerType, name: String, actions: [Action], description: String? = nil) {
            self.schedule = schedule
            self.predicate = predicate
            self.`type` = `type`
            self.name = name
            self.actions = actions
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "Schedule"
            case predicate = "Predicate"
            case `type` = "Type"
            case name = "Name"
            case actions = "Actions"
            case description = "Description"
        }
    }

    public struct UpdateCrawlerScheduleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Schedule", required: false, type: .string), 
            AWSShapeMember(label: "CrawlerName", required: true, type: .string)
        ]
        /// The updated cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// Name of the crawler whose schedule to update.
        public let crawlerName: String

        public init(schedule: String? = nil, crawlerName: String) {
            self.schedule = schedule
            self.crawlerName = crawlerName
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "Schedule"
            case crawlerName = "CrawlerName"
        }
    }

    public struct UpdateTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "TriggerUpdate", required: true, type: .structure)
        ]
        /// The name of the trigger to update.
        public let name: String
        /// The new values with which to update the trigger.
        public let triggerUpdate: TriggerUpdate

        public init(name: String, triggerUpdate: TriggerUpdate) {
            self.name = name
            self.triggerUpdate = triggerUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case triggerUpdate = "TriggerUpdate"
        }
    }

    public struct DeleteJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobName", required: true, type: .string)
        ]
        /// The name of the job to delete.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct StopTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the trigger to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Jobs", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of jobs.
        public let jobs: [Job]?
        /// A continuation token, if not all jobs have yet been returned.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct GetClassifiersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// An optional continuation token.
        public let nextToken: String?
        /// Size of the list to return (optional).
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct GrokClassifier: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GrokPattern", required: true, type: .string), 
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: false, type: .long), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastUpdated", required: false, type: .timestamp), 
            AWSShapeMember(label: "CustomPatterns", required: false, type: .string)
        ]
        /// The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in Writing Custom Classifers.
        public let grokPattern: String
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.
        public let classification: String
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?
        /// The time this classifier was registered.
        public let creationTime: TimeStamp?
        /// The time this classifier was last updated.
        public let lastUpdated: TimeStamp?
        /// Optional custom grok patterns defined by this classifier. For more information, see custom patterns in Writing Custom Classifers.
        public let customPatterns: String?

        public init(grokPattern: String, classification: String, name: String, version: Int64? = nil, creationTime: TimeStamp? = nil, lastUpdated: TimeStamp? = nil, customPatterns: String? = nil) {
            self.grokPattern = grokPattern
            self.classification = classification
            self.name = name
            self.version = version
            self.creationTime = creationTime
            self.lastUpdated = lastUpdated
            self.customPatterns = customPatterns
        }

        private enum CodingKeys: String, CodingKey {
            case grokPattern = "GrokPattern"
            case classification = "Classification"
            case name = "Name"
            case version = "Version"
            case creationTime = "CreationTime"
            case lastUpdated = "LastUpdated"
            case customPatterns = "CustomPatterns"
        }
    }

    public struct GetJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum size of the response.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct CreateCrawlerResponse: AWSShape {

    }

    public struct GetUserDefinedFunctionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserDefinedFunctions", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of requested function definitions.
        public let userDefinedFunctions: [UserDefinedFunction]?
        /// A continuation token, if the list of functions returned does not include the last requested function.
        public let nextToken: String?

        public init(userDefinedFunctions: [UserDefinedFunction]? = nil, nextToken: String? = nil) {
            self.userDefinedFunctions = userDefinedFunctions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case userDefinedFunctions = "UserDefinedFunctions"
            case nextToken = "NextToken"
        }
    }

    public struct StartTriggerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the trigger to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteUserDefinedFunctionResponse: AWSShape {

    }

    public struct StopCrawlerScheduleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: true, type: .string)
        ]
        /// Name of the crawler whose schedule state to set.
        public let crawlerName: String

        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct CatalogImportStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ImportCompleted", required: false, type: .boolean), 
            AWSShapeMember(label: "ImportedBy", required: false, type: .string), 
            AWSShapeMember(label: "ImportTime", required: false, type: .timestamp)
        ]
        /// True if the migration has completed, or False otherwise.
        public let importCompleted: Bool?
        /// The name of the person who initiated the migration.
        public let importedBy: String?
        /// The time that the migration was started.
        public let importTime: TimeStamp?

        public init(importCompleted: Bool? = nil, importedBy: String? = nil, importTime: TimeStamp? = nil) {
            self.importCompleted = importCompleted
            self.importedBy = importedBy
            self.importTime = importTime
        }

        private enum CodingKeys: String, CodingKey {
            case importCompleted = "ImportCompleted"
            case importedBy = "ImportedBy"
            case importTime = "ImportTime"
        }
    }

    public struct UpdateDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string), 
            AWSShapeMember(label: "PublicKey", required: false, type: .string), 
            AWSShapeMember(label: "CustomLibraries", required: false, type: .structure), 
            AWSShapeMember(label: "UpdateEtlLibraries", required: false, type: .boolean)
        ]
        /// The name of the DevEndpoint to be updated.
        public let endpointName: String
        /// The public key for the DevEndpoint to use.
        public let publicKey: String?
        /// Custom Python or Java libraries to be loaded in the DevEndpoint.
        public let customLibraries: DevEndpointCustomLibraries?
        /// True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False otherwise.
        public let updateEtlLibraries: Bool?

        public init(endpointName: String, publicKey: String? = nil, customLibraries: DevEndpointCustomLibraries? = nil, updateEtlLibraries: Bool? = nil) {
            self.endpointName = endpointName
            self.publicKey = publicKey
            self.customLibraries = customLibraries
            self.updateEtlLibraries = updateEtlLibraries
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
            case publicKey = "PublicKey"
            case customLibraries = "CustomLibraries"
            case updateEtlLibraries = "UpdateEtlLibraries"
        }
    }

    public struct DatabaseInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "LocationUri", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// A list of key-value pairs that define parameters and properties of the database.
        public let parameters: [String: String]?
        /// Name of the database.
        public let name: String
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// Description of the database
        public let description: String?

        public init(parameters: [String: String]? = nil, name: String, locationUri: String? = nil, description: String? = nil) {
            self.parameters = parameters
            self.name = name
            self.locationUri = locationUri
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
            case name = "Name"
            case locationUri = "LocationUri"
            case description = "Description"
        }
    }

    public struct DeleteDatabaseRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the Database to delete.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct ImportCatalogToGlueResponse: AWSShape {

    }

    public struct GetDevEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointName", required: true, type: .string)
        ]
        /// Name of the DevEndpoint for which to retrieve information.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct GetCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the crawler to retrieve metadata for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetPartitionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Segment", required: false, type: .structure), 
            AWSShapeMember(label: "Expression", required: false, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The segment of the table's partitions to scan in this request.
        public let segment: Segment?
        /// An expression filtering the partitions to be returned.
        public let expression: String?
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String
        /// A continuation token, if this is not the first call to retrieve these partitions.
        public let nextToken: String?
        /// The maximum number of partitions to return in a single response.
        public let maxResults: Int32?

        public init(segment: Segment? = nil, expression: String? = nil, catalogId: String? = nil, databaseName: String, tableName: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.segment = segment
            self.expression = expression
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case segment = "Segment"
            case expression = "Expression"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct StopCrawlerScheduleResponse: AWSShape {

    }

    public struct GetDevEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DevEndpoint", required: false, type: .structure)
        ]
        /// A DevEndpoint definition.
        public let devEndpoint: DevEndpoint?

        public init(devEndpoint: DevEndpoint? = nil) {
            self.devEndpoint = devEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoint = "DevEndpoint"
        }
    }

    public struct StartCrawlerResponse: AWSShape {

    }

    public struct GetUserDefinedFunctionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "FunctionName", required: true, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: true, type: .string)
        ]
        /// The ID of the Data Catalog where the function to be retrieved is located. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// The name of the function.
        public let functionName: String
        /// The name of the catalog database where the function is located.
        public let databaseName: String

        public init(catalogId: String? = nil, functionName: String, databaseName: String) {
            self.catalogId = catalogId
            self.functionName = functionName
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case functionName = "FunctionName"
            case databaseName = "DatabaseName"
        }
    }

    public struct Location: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Jdbc", required: false, type: .list), 
            AWSShapeMember(label: "S3", required: false, type: .list)
        ]
        /// A JDBC location.
        public let jdbc: [CodeGenNodeArg]?
        /// An Amazon S3 location.
        public let s3: [CodeGenNodeArg]?

        public init(jdbc: [CodeGenNodeArg]? = nil, s3: [CodeGenNodeArg]? = nil) {
            self.jdbc = jdbc
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case jdbc = "Jdbc"
            case s3 = "S3"
        }
    }

    public struct GetTriggersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DependentJobName", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The name of the job for which to retrieve triggers.
        public let dependentJobName: String?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The maximum size of the response.
        public let maxResults: Int32?

        public init(dependentJobName: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.dependentJobName = dependentJobName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct PartitionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StorageDescriptor", required: false, type: .structure), 
            AWSShapeMember(label: "Parameters", required: false, type: .map), 
            AWSShapeMember(label: "LastAnalyzedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastAccessTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// Partition parameters, in the form of a list of key-value pairs.
        public let parameters: [String: String]?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: TimeStamp?
        /// The last time at which the partition was accessed.
        public let lastAccessTime: TimeStamp?
        /// The values of the partition.
        public let values: [String]?

        public init(storageDescriptor: StorageDescriptor? = nil, parameters: [String: String]? = nil, lastAnalyzedTime: TimeStamp? = nil, lastAccessTime: TimeStamp? = nil, values: [String]? = nil) {
            self.storageDescriptor = storageDescriptor
            self.parameters = parameters
            self.lastAnalyzedTime = lastAnalyzedTime
            self.lastAccessTime = lastAccessTime
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case storageDescriptor = "StorageDescriptor"
            case parameters = "Parameters"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case lastAccessTime = "LastAccessTime"
            case values = "Values"
        }
    }

    public struct StartCrawlerScheduleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CrawlerName", required: true, type: .string)
        ]
        /// Name of the crawler to schedule.
        public let crawlerName: String

        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct UserDefinedFunction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClassName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerName", required: false, type: .string), 
            AWSShapeMember(label: "CreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "FunctionName", required: false, type: .string), 
            AWSShapeMember(label: "OwnerType", required: false, type: .enum), 
            AWSShapeMember(label: "ResourceUris", required: false, type: .list)
        ]
        /// The Java class that contains the function code.
        public let className: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The time at which the function was created.
        public let createTime: TimeStamp?
        /// The name of the function.
        public let functionName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        public init(className: String? = nil, ownerName: String? = nil, createTime: TimeStamp? = nil, functionName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.className = className
            self.ownerName = ownerName
            self.createTime = createTime
            self.functionName = functionName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case ownerName = "OwnerName"
            case createTime = "CreateTime"
            case functionName = "FunctionName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct GetTableVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The database in the catalog in which the table resides.
        public let databaseName: String
        /// The name of the table.
        public let tableName: String
        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A continuation token, if this is not the first call.
        public let nextToken: String?
        /// The maximum number of table versions to return in one response.
        public let maxResults: Int32?

        public init(databaseName: String, tableName: String, catalogId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.databaseName = databaseName
            self.tableName = tableName
            self.catalogId = catalogId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case catalogId = "CatalogId"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct GetDevEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "DevEndpoints", required: false, type: .list)
        ]
        /// A continuation token, if not all DevEndpoint definitions have yet been returned.
        public let nextToken: String?
        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?

        public init(nextToken: String? = nil, devEndpoints: [DevEndpoint]? = nil) {
            self.nextToken = nextToken
            self.devEndpoints = devEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case devEndpoints = "DevEndpoints"
        }
    }

    public struct TableVersion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VersionId", required: false, type: .string), 
            AWSShapeMember(label: "Table", required: false, type: .structure)
        ]
        /// The ID value that identifies this table version.
        public let versionId: String?
        /// The table in question
        public let table: Table?

        public init(versionId: String? = nil, table: Table? = nil) {
            self.versionId = versionId
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case versionId = "VersionId"
            case table = "Table"
        }
    }

    public struct GetCrawlersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// The number of crawlers to return on each call.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public enum JobRunState: String, CustomStringConvertible, Codable {
        case starting = "STARTING"
        case running = "RUNNING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct Job: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connections", required: false, type: .structure), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ExecutionProperty", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedOn", required: false, type: .timestamp), 
            AWSShapeMember(label: "Role", required: false, type: .string), 
            AWSShapeMember(label: "LogUri", required: false, type: .string), 
            AWSShapeMember(label: "MaxRetries", required: false, type: .integer), 
            AWSShapeMember(label: "Command", required: false, type: .structure), 
            AWSShapeMember(label: "DefaultArguments", required: false, type: .map), 
            AWSShapeMember(label: "AllocatedCapacity", required: false, type: .integer), 
            AWSShapeMember(label: "CreatedOn", required: false, type: .timestamp)
        ]
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// Description of this job.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// The name you assign to this job.
        public let name: String?
        /// The last point in time when this job specification was modified.
        public let lastModifiedOn: TimeStamp?
        /// The role associated with this job.
        public let role: String?
        /// This field is reserved for future use.
        public let logUri: String?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int32?
        /// The JobCommand that executes this job.
        public let command: JobCommand?
        /// The default parameters for this job.
        public let defaultArguments: [String: String]?
        /// The number of capacity units allocated to this job.
        public let allocatedCapacity: Int32?
        /// The time and date that this job specification was created.
        public let createdOn: TimeStamp?

        public init(connections: ConnectionsList? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, name: String? = nil, lastModifiedOn: TimeStamp? = nil, role: String? = nil, logUri: String? = nil, maxRetries: Int32? = nil, command: JobCommand? = nil, defaultArguments: [String: String]? = nil, allocatedCapacity: Int32? = nil, createdOn: TimeStamp? = nil) {
            self.connections = connections
            self.description = description
            self.executionProperty = executionProperty
            self.name = name
            self.lastModifiedOn = lastModifiedOn
            self.role = role
            self.logUri = logUri
            self.maxRetries = maxRetries
            self.command = command
            self.defaultArguments = defaultArguments
            self.allocatedCapacity = allocatedCapacity
            self.createdOn = createdOn
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case name = "Name"
            case lastModifiedOn = "LastModifiedOn"
            case role = "Role"
            case logUri = "LogUri"
            case maxRetries = "MaxRetries"
            case command = "Command"
            case defaultArguments = "DefaultArguments"
            case allocatedCapacity = "AllocatedCapacity"
            case createdOn = "CreatedOn"
        }
    }

    public struct GetPlanRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Sinks", required: false, type: .list), 
            AWSShapeMember(label: "Source", required: true, type: .structure), 
            AWSShapeMember(label: "Mapping", required: true, type: .list), 
            AWSShapeMember(label: "Location", required: false, type: .structure)
        ]
        /// The target tables.
        public let sinks: [CatalogEntry]?
        /// The source table.
        public let source: CatalogEntry
        /// The list of mappings from a source table to target tables.
        public let mapping: [MappingEntry]
        /// Parameters for the mapping.
        public let location: Location?

        public init(sinks: [CatalogEntry]? = nil, source: CatalogEntry, mapping: [MappingEntry], location: Location? = nil) {
            self.sinks = sinks
            self.source = source
            self.mapping = mapping
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case sinks = "Sinks"
            case source = "Source"
            case mapping = "Mapping"
            case location = "Location"
        }
    }

    public struct S3Target: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exclusions", required: false, type: .list), 
            AWSShapeMember(label: "Path", required: false, type: .string)
        ]
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path to the Amazon S3 target.
        public let path: String?

        public init(exclusions: [String]? = nil, path: String? = nil) {
            self.exclusions = exclusions
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case exclusions = "Exclusions"
            case path = "Path"
        }
    }

    public struct CreateGrokClassifierRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GrokPattern", required: true, type: .string), 
            AWSShapeMember(label: "Classification", required: true, type: .string), 
            AWSShapeMember(label: "CustomPatterns", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The grok pattern used by this classifier.
        public let grokPattern: String
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The name of the new classifier.
        public let name: String

        public init(grokPattern: String, classification: String, customPatterns: String? = nil, name: String) {
            self.grokPattern = grokPattern
            self.classification = classification
            self.customPatterns = customPatterns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case grokPattern = "GrokPattern"
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case name = "Name"
        }
    }

    public struct PartitionValueList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]
        /// The list of values.
        public let values: [String]

        public init(values: [String]) {
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct CrawlerTargets: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3Targets", required: false, type: .list), 
            AWSShapeMember(label: "JdbcTargets", required: false, type: .list)
        ]
        /// Specifies Amazon S3 targets.
        public let s3Targets: [S3Target]?
        /// Specifies JDBC targets.
        public let jdbcTargets: [JdbcTarget]?

        public init(s3Targets: [S3Target]? = nil, jdbcTargets: [JdbcTarget]? = nil) {
            self.s3Targets = s3Targets
            self.jdbcTargets = jdbcTargets
        }

        private enum CodingKeys: String, CodingKey {
            case s3Targets = "S3Targets"
            case jdbcTargets = "JdbcTargets"
        }
    }

    public struct GetTablesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: true, type: .string), 
            AWSShapeMember(label: "Expression", required: false, type: .string), 
            AWSShapeMember(label: "CatalogId", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The database in the catalog whose tables to list.
        public let databaseName: String
        /// A regular expression pattern. If present, only those tables whose names match the pattern are returned.
        public let expression: String?
        /// The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
        public let catalogId: String?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// The maximum number of tables to return in a single response.
        public let maxResults: Int32?

        public init(databaseName: String, expression: String? = nil, catalogId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.databaseName = databaseName
            self.expression = expression
            self.catalogId = catalogId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case expression = "Expression"
            case catalogId = "CatalogId"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct UpdateClassifierResponse: AWSShape {

    }

    public struct StopCrawlerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// Name of the crawler to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetMappingRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Sinks", required: false, type: .list), 
            AWSShapeMember(label: "Location", required: false, type: .structure), 
            AWSShapeMember(label: "Source", required: true, type: .structure)
        ]
        /// A list of target tables.
        public let sinks: [CatalogEntry]?
        /// Parameters for the mapping.
        public let location: Location?
        /// Specifies the source table.
        public let source: CatalogEntry

        public init(sinks: [CatalogEntry]? = nil, location: Location? = nil, source: CatalogEntry) {
            self.sinks = sinks
            self.location = location
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case sinks = "Sinks"
            case location = "Location"
            case source = "Source"
        }
    }

    public enum Logical: String, CustomStringConvertible, Codable {
        case and = "AND"
        public var description: String { return self.rawValue }
    }

}