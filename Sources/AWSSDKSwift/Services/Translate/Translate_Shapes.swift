// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Translate {

    public struct TranslateTextResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AppliedTerminologies", required: false, type: .list), 
            AWSShapeMember(label: "SourceLanguageCode", required: true, type: .string), 
            AWSShapeMember(label: "TranslatedText", required: true, type: .string), 
            AWSShapeMember(label: "TargetLanguageCode", required: true, type: .string)
        ]
        /// The names of the custom terminologies applied to the input text by Amazon Translate for the translated text response.
        public let appliedTerminologies: [AppliedTerminology]?
        /// The language code for the language of the source text. 
        public let sourceLanguageCode: String
        /// The the translated text. The maximum length of this text is 5kb.
        public let translatedText: String
        /// The language code for the language of the target text. 
        public let targetLanguageCode: String

        public init(appliedTerminologies: [AppliedTerminology]? = nil, sourceLanguageCode: String, translatedText: String, targetLanguageCode: String) {
            self.appliedTerminologies = appliedTerminologies
            self.sourceLanguageCode = sourceLanguageCode
            self.translatedText = translatedText
            self.targetLanguageCode = targetLanguageCode
        }

        private enum CodingKeys: String, CodingKey {
            case appliedTerminologies = "AppliedTerminologies"
            case sourceLanguageCode = "SourceLanguageCode"
            case translatedText = "TranslatedText"
            case targetLanguageCode = "TargetLanguageCode"
        }
    }

    public struct TerminologyData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Format", required: true, type: .enum), 
            AWSShapeMember(label: "File", required: true, type: .blob)
        ]
        /// The data format of the custom terminology. Either CSV or TMX.
        public let format: TerminologyDataFormat
        /// The file containing the custom terminology data.
        public let file: Data

        public init(format: TerminologyDataFormat, file: Data) {
            self.format = format
            self.file = file
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case file = "File"
        }
    }

    public struct GetTerminologyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminologyDataLocation", required: false, type: .structure), 
            AWSShapeMember(label: "TerminologyProperties", required: false, type: .structure)
        ]
        /// The data location of the custom terminology being retrieved. The custom terminology file is returned in a presigned url that has a 30 minute expiration.
        public let terminologyDataLocation: TerminologyDataLocation?
        /// The properties of the custom terminology being retrieved.
        public let terminologyProperties: TerminologyProperties?

        public init(terminologyDataLocation: TerminologyDataLocation? = nil, terminologyProperties: TerminologyProperties? = nil) {
            self.terminologyDataLocation = terminologyDataLocation
            self.terminologyProperties = terminologyProperties
        }

        private enum CodingKeys: String, CodingKey {
            case terminologyDataLocation = "TerminologyDataLocation"
            case terminologyProperties = "TerminologyProperties"
        }
    }

    public enum TerminologyDataFormat: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case tmx = "TMX"
        public var description: String { return self.rawValue }
    }

    public struct GetTerminologyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminologyDataFormat", required: true, type: .enum), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The data format of the custom terminology being retrieved, either CSV or TMX.
        public let terminologyDataFormat: TerminologyDataFormat
        /// The name of the custom terminology being retrieved.
        public let name: String

        public init(terminologyDataFormat: TerminologyDataFormat, name: String) {
            self.terminologyDataFormat = terminologyDataFormat
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case terminologyDataFormat = "TerminologyDataFormat"
            case name = "Name"
        }
    }

    public enum EncryptionKeyType: String, CustomStringConvertible, Codable {
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public struct TranslateTextRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminologyNames", required: false, type: .list), 
            AWSShapeMember(label: "SourceLanguageCode", required: true, type: .string), 
            AWSShapeMember(label: "Text", required: true, type: .string), 
            AWSShapeMember(label: "TargetLanguageCode", required: true, type: .string)
        ]
        /// The TerminologyNames list that is taken as input to the TranslateText request. This has a minimum length of 0 and a maximum length of 1.
        public let terminologyNames: [String]?
        /// The language code for the language of the source text. The language must be a language supported by Amazon Translate.  To have Amazon Translate determine the source language of your text, you can specify auto in the SourceLanguageCode field. If you specify auto, Amazon Translate will call Amazon Comprehend to determine the source language.
        public let sourceLanguageCode: String
        /// The text to translate. The text string can be a maximum of 5,000 bytes long. Depending on your character set, this may be fewer than 5,000 characters.
        public let text: String
        /// The language code requested for the language of the target text. The language must be a language supported by Amazon Translate.
        public let targetLanguageCode: String

        public init(terminologyNames: [String]? = nil, sourceLanguageCode: String, text: String, targetLanguageCode: String) {
            self.terminologyNames = terminologyNames
            self.sourceLanguageCode = sourceLanguageCode
            self.text = text
            self.targetLanguageCode = targetLanguageCode
        }

        private enum CodingKeys: String, CodingKey {
            case terminologyNames = "TerminologyNames"
            case sourceLanguageCode = "SourceLanguageCode"
            case text = "Text"
            case targetLanguageCode = "TargetLanguageCode"
        }
    }

    public struct Term: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TargetText", required: false, type: .string), 
            AWSShapeMember(label: "SourceText", required: false, type: .string)
        ]
        /// The target text of the term being translated by the custom terminology.
        public let targetText: String?
        /// The source text of the term being translated by the custom terminology.
        public let sourceText: String?

        public init(targetText: String? = nil, sourceText: String? = nil) {
            self.targetText = targetText
            self.sourceText = sourceText
        }

        private enum CodingKeys: String, CodingKey {
            case targetText = "TargetText"
            case sourceText = "SourceText"
        }
    }

    public struct EncryptionKey: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: true, type: .string), 
            AWSShapeMember(label: "Type", required: true, type: .enum)
        ]
        /// The Amazon Resource Name (ARN) of the encryption key being used to encrypt the custom terminology.
        public let id: String
        /// The type of encryption key used by Amazon Translate to encrypt custom terminologies.
        public let `type`: EncryptionKeyType

        public init(id: String, type: EncryptionKeyType) {
            self.id = id
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case `type` = "Type"
        }
    }

    public struct ListTerminologiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The maximum number of custom terminologies returned per list request.
        public let maxResults: Int32?
        /// If the result of the request to ListTerminologies was truncated, include the NextToken to fetch the next group of custom terminologies. 
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ImportTerminologyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionKey", required: false, type: .structure), 
            AWSShapeMember(label: "TerminologyData", required: true, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "MergeStrategy", required: true, type: .enum)
        ]
        /// The encryption key for the custom terminology being imported.
        public let encryptionKey: EncryptionKey?
        /// The terminology data for the custom terminology being imported.
        public let terminologyData: TerminologyData
        /// The name of the custom terminology being imported.
        public let name: String
        /// The description of the custom terminology being imported.
        public let description: String?
        /// The merge strategy of the custom terminology being imported. Currently, only the OVERWRITE merge strategy is supported. In this case, the imported terminology will overwrite an existing terminology of the same name.
        public let mergeStrategy: MergeStrategy

        public init(encryptionKey: EncryptionKey? = nil, terminologyData: TerminologyData, name: String, description: String? = nil, mergeStrategy: MergeStrategy) {
            self.encryptionKey = encryptionKey
            self.terminologyData = terminologyData
            self.name = name
            self.description = description
            self.mergeStrategy = mergeStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKey = "EncryptionKey"
            case terminologyData = "TerminologyData"
            case name = "Name"
            case description = "Description"
            case mergeStrategy = "MergeStrategy"
        }
    }

    public struct ImportTerminologyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminologyProperties", required: false, type: .structure)
        ]
        /// The properties of the custom terminology being imported.
        public let terminologyProperties: TerminologyProperties?

        public init(terminologyProperties: TerminologyProperties? = nil) {
            self.terminologyProperties = terminologyProperties
        }

        private enum CodingKeys: String, CodingKey {
            case terminologyProperties = "TerminologyProperties"
        }
    }

    public enum MergeStrategy: String, CustomStringConvertible, Codable {
        case overwrite = "OVERWRITE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteTerminologyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the custom terminology being deleted. 
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct TerminologyProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TermCount", required: false, type: .integer), 
            AWSShapeMember(label: "EncryptionKey", required: false, type: .structure), 
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastUpdatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "SourceLanguageCode", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SizeBytes", required: false, type: .integer), 
            AWSShapeMember(label: "TargetLanguageCodes", required: false, type: .list)
        ]
        /// The number of terms included in the custom terminology.
        public let termCount: Int32?
        /// The encryption key for the custom terminology.
        public let encryptionKey: EncryptionKey?
        /// The time at which the custom terminology was created, based on the timestamp.
        public let createdAt: TimeStamp?
        /// The time at which the custom terminology was last update, based on the timestamp.
        public let lastUpdatedAt: TimeStamp?
        ///  The Amazon Resource Name (ARN) of the custom terminology. 
        public let arn: String?
        /// The language code for the source text of the translation request for which the custom terminology is being used.
        public let sourceLanguageCode: String?
        /// The description of the custom terminology properties.
        public let description: String?
        /// The name of the custom terminology.
        public let name: String?
        /// The size of the file used when importing a custom terminology.
        public let sizeBytes: Int32?
        /// The language codes for the target languages available with the custom terminology file. All possible target languages are returned in array.
        public let targetLanguageCodes: [String]?

        public init(termCount: Int32? = nil, encryptionKey: EncryptionKey? = nil, createdAt: TimeStamp? = nil, lastUpdatedAt: TimeStamp? = nil, arn: String? = nil, sourceLanguageCode: String? = nil, description: String? = nil, name: String? = nil, sizeBytes: Int32? = nil, targetLanguageCodes: [String]? = nil) {
            self.termCount = termCount
            self.encryptionKey = encryptionKey
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.arn = arn
            self.sourceLanguageCode = sourceLanguageCode
            self.description = description
            self.name = name
            self.sizeBytes = sizeBytes
            self.targetLanguageCodes = targetLanguageCodes
        }

        private enum CodingKeys: String, CodingKey {
            case termCount = "TermCount"
            case encryptionKey = "EncryptionKey"
            case createdAt = "CreatedAt"
            case lastUpdatedAt = "LastUpdatedAt"
            case arn = "Arn"
            case sourceLanguageCode = "SourceLanguageCode"
            case description = "Description"
            case name = "Name"
            case sizeBytes = "SizeBytes"
            case targetLanguageCodes = "TargetLanguageCodes"
        }
    }

    public struct TerminologyDataLocation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Location", required: true, type: .string), 
            AWSShapeMember(label: "RepositoryType", required: true, type: .string)
        ]
        /// The location of the custom terminology data.
        public let location: String
        /// The repository type for the custom terminology data.
        public let repositoryType: String

        public init(location: String, repositoryType: String) {
            self.location = location
            self.repositoryType = repositoryType
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case repositoryType = "RepositoryType"
        }
    }

    public struct AppliedTerminology: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Terms", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The specific terms of the custom terminology applied to the input text by Amazon Translate for the translated text response. A maximum of 250 terms will be returned, and the specific terms applied will be the first 250 terms in the source text. 
        public let terms: [Term]?
        /// The name of the custom terminology applied to the input text by Amazon Translate for the translated text response.
        public let name: String?

        public init(terms: [Term]? = nil, name: String? = nil) {
            self.terms = terms
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case terms = "Terms"
            case name = "Name"
        }
    }

    public struct ListTerminologiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TerminologyPropertiesList", required: false, type: .list)
        ]
        ///  If the response to the ListTerminologies was truncated, the NextToken fetches the next group of custom terminologies. 
        public let nextToken: String?
        /// The properties list of the custom terminologies returned on the list request.
        public let terminologyPropertiesList: [TerminologyProperties]?

        public init(nextToken: String? = nil, terminologyPropertiesList: [TerminologyProperties]? = nil) {
            self.nextToken = nextToken
            self.terminologyPropertiesList = terminologyPropertiesList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case terminologyPropertiesList = "TerminologyPropertiesList"
        }
    }

}