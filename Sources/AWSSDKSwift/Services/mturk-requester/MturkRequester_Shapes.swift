// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension MturkRequester {

    public struct HIT: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The amount of time, in seconds, after the Worker submits an assignment for the HIT that the results are automatically approved by Amazon Mechanical Turk. This is the amount of time the Requester has to reject an assignment submitted by a Worker before the assignment is auto-approved and the Worker is paid. 
        public var autoApprovalDelayInSeconds: Int64? = nil
        ///  The ID of the HIT Layout of this HIT.
        public var hITLayoutId: String? = nil
        ///  The number of assignments for this HIT that have been approved or rejected.
        public var numberOfAssignmentsCompleted: Int32? = nil
        ///  The number of assignments for this HIT that are available for Workers to accept.
        public var numberOfAssignmentsAvailable: Int32? = nil
        ///  The title of the HIT.
        public var title: String? = nil
        ///  The length of time, in seconds, that a Worker has to complete the HIT after accepting it.
        public var assignmentDurationInSeconds: Int64? = nil
        ///  The date and time the HIT was created.
        public var creationTime: Date? = nil
        ///  The ID of the HIT Group of this HIT.
        public var hITGroupId: String? = nil
        public var reward: String? = nil
        ///  Indicates the review status of the HIT. Valid Values are NotReviewed | MarkedForReview | ReviewedAppropriate | ReviewedInappropriate.
        public var hITReviewStatus: String? = nil
        /// The ID of the HIT type of this HIT
        public var hITTypeId: String? = nil
        ///  A general description of the HIT.
        public var description: String? = nil
        /// The number of times the HIT can be accepted and completed before the HIT becomes unavailable. 
        public var maxAssignments: Int32? = nil
        ///  A unique identifier for the HIT.
        public var hITId: String? = nil
        /// The status of the HIT and its assignments. Valid Values are Assignable | Unassignable | Reviewable | Reviewing | Disposed. 
        public var hITStatus: String? = nil
        /// The date and time the HIT expires.
        public var expiration: Date? = nil
        ///  A condition that a Worker's Qualifications must meet in order to accept the HIT. A HIT can have between zero and ten Qualification requirements. All requirements must be met by a Worker's Qualifications for the Worker to accept the HIT.
        public var qualificationRequirements: [QualificationRequirement]? = nil
        ///  One or more words or phrases that describe the HIT, separated by commas. Search terms similar to the keywords of a HIT are more likely to have the HIT in the search results.
        public var keywords: String? = nil
        ///  The data the Worker completing the HIT uses produce the results. This is either either a QuestionForm, HTMLQuestion or an ExternalQuestion data structure.
        public var question: String? = nil
        ///  An arbitrary data field the Requester who created the HIT can use. This field is visible only to the creator of the HIT.
        public var requesterAnnotation: String? = nil
        ///  The number of assignments for this HIT that are being previewed or have been accepted by Workers, but have not yet been submitted, returned, or abandoned.
        public var numberOfAssignmentsPending: Int32? = nil

        public init() {}

        public init(autoApprovalDelayInSeconds: Int64? = nil, hITLayoutId: String? = nil, numberOfAssignmentsCompleted: Int32? = nil, numberOfAssignmentsAvailable: Int32? = nil, title: String? = nil, assignmentDurationInSeconds: Int64? = nil, creationTime: Date? = nil, hITGroupId: String? = nil, reward: String? = nil, hITReviewStatus: String? = nil, hITTypeId: String? = nil, description: String? = nil, maxAssignments: Int32? = nil, hITId: String? = nil, hITStatus: String? = nil, expiration: Date? = nil, qualificationRequirements: [QualificationRequirement]? = nil, keywords: String? = nil, question: String? = nil, requesterAnnotation: String? = nil, numberOfAssignmentsPending: Int32? = nil) {
            self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
            self.hITLayoutId = hITLayoutId
            self.numberOfAssignmentsCompleted = numberOfAssignmentsCompleted
            self.numberOfAssignmentsAvailable = numberOfAssignmentsAvailable
            self.title = title
            self.assignmentDurationInSeconds = assignmentDurationInSeconds
            self.creationTime = creationTime
            self.hITGroupId = hITGroupId
            self.reward = reward
            self.hITReviewStatus = hITReviewStatus
            self.hITTypeId = hITTypeId
            self.description = description
            self.maxAssignments = maxAssignments
            self.hITId = hITId
            self.hITStatus = hITStatus
            self.expiration = expiration
            self.qualificationRequirements = qualificationRequirements
            self.keywords = keywords
            self.question = question
            self.requesterAnnotation = requesterAnnotation
            self.numberOfAssignmentsPending = numberOfAssignmentsPending
        }

        public init(dictionary: [String: Any]) throws {
            self.autoApprovalDelayInSeconds = dictionary["AutoApprovalDelayInSeconds"] as? Int64
            self.hITLayoutId = dictionary["HITLayoutId"] as? String
            self.numberOfAssignmentsCompleted = dictionary["NumberOfAssignmentsCompleted"] as? Int32
            self.numberOfAssignmentsAvailable = dictionary["NumberOfAssignmentsAvailable"] as? Int32
            self.title = dictionary["Title"] as? String
            self.assignmentDurationInSeconds = dictionary["AssignmentDurationInSeconds"] as? Int64
            self.creationTime = dictionary["CreationTime"] as? Date
            self.hITGroupId = dictionary["HITGroupId"] as? String
            self.reward = dictionary["Reward"] as? String
            self.hITReviewStatus = dictionary["HITReviewStatus"] as? String
            self.hITTypeId = dictionary["HITTypeId"] as? String
            self.description = dictionary["Description"] as? String
            self.maxAssignments = dictionary["MaxAssignments"] as? Int32
            self.hITId = dictionary["HITId"] as? String
            self.hITStatus = dictionary["HITStatus"] as? String
            self.expiration = dictionary["Expiration"] as? Date
            if let qualificationRequirements = dictionary["QualificationRequirements"] as? [[String: Any]] {
                self.qualificationRequirements = try qualificationRequirements.map({ try QualificationRequirement(dictionary: $0) })
            }
            self.keywords = dictionary["Keywords"] as? String
            self.question = dictionary["Question"] as? String
            self.requesterAnnotation = dictionary["RequesterAnnotation"] as? String
            self.numberOfAssignmentsPending = dictionary["NumberOfAssignmentsPending"] as? Int32
        }
    }

    public struct DeleteQualificationTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the QualificationType to dispose.
        public var qualificationTypeId: String = ""

        public init() {}

        public init(qualificationTypeId: String) {
            self.qualificationTypeId = qualificationTypeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
        }
    }

    public struct ListAssignmentsForHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the HIT.
        public var hITId: String = ""
        /// Pagination token
        public var nextToken: String? = nil
        /// The status of the assignments to return: Submitted | Approved | Rejected
        public var assignmentStatuses: [String]? = nil
        public var maxResults: Int32? = nil

        public init() {}

        public init(hITId: String, nextToken: String? = nil, assignmentStatuses: [String]? = nil, maxResults: Int32? = nil) {
            self.hITId = hITId
            self.nextToken = nextToken
            self.assignmentStatuses = assignmentStatuses
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
            self.nextToken = dictionary["NextToken"] as? String
            if let assignmentStatuses = dictionary["AssignmentStatuses"] as? [String] {
                self.assignmentStatuses = assignmentStatuses
            }
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DeleteHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct UpdateHITReviewStatusResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct NotifyWorkersRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The subject line of the email message to send. Can include up to 200 characters.
        public var subject: String = ""
        /// The text of the email message to send. Can include up to 4,096 characters
        public var messageText: String = ""
        /// A list of Worker IDs you wish to notify. You can notify upto 100 Workers at a time.
        public var workerIds: [String] = []

        public init() {}

        public init(subject: String, messageText: String, workerIds: [String]) {
            self.subject = subject
            self.messageText = messageText
            self.workerIds = workerIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let subject = dictionary["Subject"] as? String else { throw InitializableError.missingRequiredParam("Subject") }
            self.subject = subject
            guard let messageText = dictionary["MessageText"] as? String else { throw InitializableError.missingRequiredParam("MessageText") }
            self.messageText = messageText
            guard let workerIds = dictionary["WorkerIds"] as? [String] else { throw InitializableError.missingRequiredParam("WorkerIds") }
            self.workerIds = workerIds
        }
    }

    public struct CreateHITTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The ID of the newly registered HIT type.
        public var hITTypeId: String? = nil

        public init() {}

        public init(hITTypeId: String? = nil) {
            self.hITTypeId = hITTypeId
        }

        public init(dictionary: [String: Any]) throws {
            self.hITTypeId = dictionary["HITTypeId"] as? String
        }
    }

    public struct ListAssignmentsForHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The collection of Assignment data structures returned by this call.
        public var assignments: [Assignment]? = nil
        public var nextToken: String? = nil
        ///  The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.
        public var numResults: Int32? = nil

        public init() {}

        public init(assignments: [Assignment]? = nil, nextToken: String? = nil, numResults: Int32? = nil) {
            self.assignments = assignments
            self.nextToken = nextToken
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            if let assignments = dictionary["Assignments"] as? [[String: Any]] {
                self.assignments = try assignments.map({ try Assignment(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct ListQualificationTypesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Specifies that only Qualification types that the Requester created are returned. If false, the operation returns all Qualification types. 
        public var mustBeOwnedByCaller: Bool? = nil
        /// Specifies that only Qualification types that a user can request through the Amazon Mechanical Turk web site, such as by taking a Qualification test, are returned as results of the search. Some Qualification types, such as those assigned automatically by the system, cannot be requested directly by users. If false, all Qualification types, including those managed by the system, are considered. Valid values are True | False. 
        public var mustBeRequestable: Bool = false
        ///  A text query against all of the searchable attributes of Qualification types. 
        public var query: String? = nil
        public var nextToken: String? = nil
        ///  The maximum number of results to return in a single call. 
        public var maxResults: Int32? = nil

        public init() {}

        public init(mustBeOwnedByCaller: Bool? = nil, mustBeRequestable: Bool, query: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.mustBeOwnedByCaller = mustBeOwnedByCaller
            self.mustBeRequestable = mustBeRequestable
            self.query = query
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.mustBeOwnedByCaller = dictionary["MustBeOwnedByCaller"] as? Bool
            guard let mustBeRequestable = dictionary["MustBeRequestable"] as? Bool else { throw InitializableError.missingRequiredParam("MustBeRequestable") }
            self.mustBeRequestable = mustBeRequestable
            self.query = dictionary["Query"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ListQualificationRequestsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var nextToken: String? = nil
        /// The ID of the QualificationType.
        public var qualificationTypeId: String? = nil
        ///  The maximum number of results to return in a single call. 
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, qualificationTypeId: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.qualificationTypeId = qualificationTypeId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.qualificationTypeId = dictionary["QualificationTypeId"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ListReviewableHITsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The list of HIT elements returned by the query.
        public var hITs: [HIT]? = nil
        public var nextToken: String? = nil
        ///  The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. 
        public var numResults: Int32? = nil

        public init() {}

        public init(hITs: [HIT]? = nil, nextToken: String? = nil, numResults: Int32? = nil) {
            self.hITs = hITs
            self.nextToken = nextToken
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            if let hITs = dictionary["HITs"] as? [[String: Any]] {
                self.hITs = try hITs.map({ try HIT(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct GetFileUploadURLResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  A temporary URL for the file that the Worker uploaded for the answer. 
        public var fileUploadURL: String? = nil

        public init() {}

        public init(fileUploadURL: String? = nil) {
            self.fileUploadURL = fileUploadURL
        }

        public init(dictionary: [String: Any]) throws {
            self.fileUploadURL = dictionary["FileUploadURL"] as? String
        }
    }

    public struct HITLayoutParameter: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The value substituted for the parameter referenced in the HITLayout. 
        public var value: String? = nil
        ///  The name of the parameter in the HITLayout. 
        public var name: String? = nil

        public init() {}

        public init(value: String? = nil, name: String? = nil) {
            self.value = value
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct QualificationType: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The amount of time, in seconds, given to a Worker to complete the Qualification test, beginning from the time the Worker requests the Qualification. 
        public var testDurationInSeconds: Int64? = nil
        ///  The amount of time, in seconds, Workers must wait after taking the Qualification test before they can take it again. Workers can take a Qualification test multiple times if they were not granted the Qualification from a previous attempt, or if the test offers a gradient score and they want a better score. If not specified, retries are disabled and Workers can request a Qualification only once. 
        public var retryDelayInSeconds: Int64? = nil
        ///  The status of the Qualification type. A Qualification type's status determines if users can apply to receive a Qualification of this type, and if HITs can be created with requirements based on this type. Valid values are Active | Inactive. 
        public var qualificationTypeStatus: String? = nil
        ///  The date and time the Qualification type was created. 
        public var creationTime: Date? = nil
        /// The answers to the Qualification test specified in the Test parameter.
        public var answerKey: String? = nil
        ///  A long description for the Qualification type. 
        public var description: String? = nil
        /// Specifies that requests for the Qualification type are granted immediately, without prompting the Worker with a Qualification test. Valid values are True | False.
        public var autoGranted: Bool? = nil
        ///  The questions for a Qualification test associated with this Qualification type that a user can take to obtain a Qualification of this type. This parameter must be specified if AnswerKey is present. A Qualification type cannot have both a specified Test parameter and an AutoGranted value of true. 
        public var test: String? = nil
        ///  The name of the Qualification type. The type name is used to identify the type, and to find the type using a Qualification type search. 
        public var name: String? = nil
        ///  One or more words or phrases that describe theQualification type, separated by commas. The Keywords make the type easier to find using a search. 
        public var keywords: String? = nil
        ///  Specifies whether the Qualification type is one that a user can request through the Amazon Mechanical Turk web site, such as by taking a Qualification test. This value is False for Qualifications assigned automatically by the system. Valid values are True | False. 
        public var isRequestable: Bool? = nil
        ///  The Qualification integer value to use for automatically granted Qualifications, if AutoGranted is true. This is 1 by default. 
        public var autoGrantedValue: Int32? = nil
        ///  A unique identifier for the Qualification type. A Qualification type is given a Qualification type ID when you call the CreateQualificationType operation. 
        public var qualificationTypeId: String? = nil

        public init() {}

        public init(testDurationInSeconds: Int64? = nil, retryDelayInSeconds: Int64? = nil, qualificationTypeStatus: String? = nil, creationTime: Date? = nil, answerKey: String? = nil, description: String? = nil, autoGranted: Bool? = nil, test: String? = nil, name: String? = nil, keywords: String? = nil, isRequestable: Bool? = nil, autoGrantedValue: Int32? = nil, qualificationTypeId: String? = nil) {
            self.testDurationInSeconds = testDurationInSeconds
            self.retryDelayInSeconds = retryDelayInSeconds
            self.qualificationTypeStatus = qualificationTypeStatus
            self.creationTime = creationTime
            self.answerKey = answerKey
            self.description = description
            self.autoGranted = autoGranted
            self.test = test
            self.name = name
            self.keywords = keywords
            self.isRequestable = isRequestable
            self.autoGrantedValue = autoGrantedValue
            self.qualificationTypeId = qualificationTypeId
        }

        public init(dictionary: [String: Any]) throws {
            self.testDurationInSeconds = dictionary["TestDurationInSeconds"] as? Int64
            self.retryDelayInSeconds = dictionary["RetryDelayInSeconds"] as? Int64
            self.qualificationTypeStatus = dictionary["QualificationTypeStatus"] as? String
            self.creationTime = dictionary["CreationTime"] as? Date
            self.answerKey = dictionary["AnswerKey"] as? String
            self.description = dictionary["Description"] as? String
            self.autoGranted = dictionary["AutoGranted"] as? Bool
            self.test = dictionary["Test"] as? String
            self.name = dictionary["Name"] as? String
            self.keywords = dictionary["Keywords"] as? String
            self.isRequestable = dictionary["IsRequestable"] as? Bool
            self.autoGrantedValue = dictionary["AutoGrantedValue"] as? Int32
            self.qualificationTypeId = dictionary["QualificationTypeId"] as? String
        }
    }

    public struct UpdateExpirationForHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The date and time at which you want the HIT to expire 
        public var expireAt: Date? = nil
        ///  The HIT to update. 
        public var hITId: String = ""

        public init() {}

        public init(expireAt: Date? = nil, hITId: String) {
            self.expireAt = expireAt
            self.hITId = hITId
        }

        public init(dictionary: [String: Any]) throws {
            self.expireAt = dictionary["ExpireAt"] as? Date
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
        }
    }

    public struct UpdateHITTypeOfHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DisassociateQualificationFromWorkerResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListQualificationTypesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var nextToken: String? = nil
        ///  The list of QualificationType elements returned by the query. 
        public var qualificationTypes: [QualificationType]? = nil
        ///  The number of Qualification types on this page in the filtered results list, equivalent to the number of types this operation returns. 
        public var numResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, qualificationTypes: [QualificationType]? = nil, numResults: Int32? = nil) {
            self.nextToken = nextToken
            self.qualificationTypes = qualificationTypes
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let qualificationTypes = dictionary["QualificationTypes"] as? [[String: Any]] {
                self.qualificationTypes = try qualificationTypes.map({ try QualificationType(dictionary: $0) })
            }
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct SendBonusResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ReviewPolicy: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Name of the parameter from the Review policy.
        public var parameters: [PolicyParameter]? = nil
        ///  Name of a Review Policy: SimplePlurality/2011-09-01 or ScoreMyKnownAnswers/2011-09-01 
        public var policyName: String? = nil

        public init() {}

        public init(parameters: [PolicyParameter]? = nil, policyName: String? = nil) {
            self.parameters = parameters
            self.policyName = policyName
        }

        public init(dictionary: [String: Any]) throws {
            if let parameters = dictionary["Parameters"] as? [[String: Any]] {
                self.parameters = try parameters.map({ try PolicyParameter(dictionary: $0) })
            }
            self.policyName = dictionary["PolicyName"] as? String
        }
    }

    public struct GetHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Contains the requested HIT data.
        public var hIT: HIT? = nil

        public init() {}

        public init(hIT: HIT? = nil) {
            self.hIT = hIT
        }

        public init(dictionary: [String: Any]) throws {
            if let hIT = dictionary["HIT"] as? [String: Any] { self.hIT = try MturkRequester.HIT(dictionary: hIT) }
        }
    }

    public struct NotifyWorkersFailureStatus: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  A message detailing the reason the Worker could not be notified. 
        public var notifyWorkersFailureMessage: String? = nil
        ///  The ID of the Worker.
        public var workerId: String? = nil
        ///  Encoded value for the failure type. 
        public var notifyWorkersFailureCode: String? = nil

        public init() {}

        public init(notifyWorkersFailureMessage: String? = nil, workerId: String? = nil, notifyWorkersFailureCode: String? = nil) {
            self.notifyWorkersFailureMessage = notifyWorkersFailureMessage
            self.workerId = workerId
            self.notifyWorkersFailureCode = notifyWorkersFailureCode
        }

        public init(dictionary: [String: Any]) throws {
            self.notifyWorkersFailureMessage = dictionary["NotifyWorkersFailureMessage"] as? String
            self.workerId = dictionary["WorkerId"] as? String
            self.notifyWorkersFailureCode = dictionary["NotifyWorkersFailureCode"] as? String
        }
    }

    public struct DeleteQualificationTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListHITsForQualificationTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The list of HIT elements returned by the query.
        public var hITs: [HIT]? = nil
        public var nextToken: String? = nil
        ///  The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call. 
        public var numResults: Int32? = nil

        public init() {}

        public init(hITs: [HIT]? = nil, nextToken: String? = nil, numResults: Int32? = nil) {
            self.hITs = hITs
            self.nextToken = nextToken
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            if let hITs = dictionary["HITs"] as? [[String: Any]] {
                self.hITs = try hITs.map({ try HIT(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct DeleteWorkerBlockResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The number of seconds after an assignment for the HIT has been submitted, after which the assignment is considered Approved automatically unless the Requester explicitly rejects it. 
        public var autoApprovalDelayInSeconds: Int64? = nil
        ///  If the HITLayoutId is provided, any placeholder values must be filled in with values using the HITLayoutParameter structure. For more information, see HITLayout. 
        public var hITLayoutParameters: [HITLayoutParameter]? = nil
        ///  The HITLayoutId allows you to use a pre-existing HIT design with placeholder values and create an additional HIT by providing those values as HITLayoutParameters.   Constraints: Either a Question parameter or a HITLayoutId parameter must be provided. 
        public var hITLayoutId: String? = nil
        ///  The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains. On the Amazon Mechanical Turk web site, the HIT title appears in search results, and everywhere the HIT is mentioned. 
        public var title: String = ""
        ///  The HIT-level Review Policy applies to the HIT. You can specify for Mechanical Turk to take various actions based on the policy. 
        public var hITReviewPolicy: ReviewPolicy? = nil
        ///  The amount of time, in seconds, that a Worker has to complete the HIT after accepting it. If a Worker does not complete the assignment within the specified duration, the assignment is considered abandoned. If the HIT is still active (that is, its lifetime has not elapsed), the assignment becomes available for other users to find and accept. 
        public var assignmentDurationInSeconds: Int64 = 0
        ///  The amount of money the Requester will pay a Worker for successfully completing the HIT. 
        public var reward: String = ""
        ///  A unique identifier for this request which allows you to retry the call on error without creating duplicate HITs. This is useful in cases such as network timeouts where it is unclear whether or not the call succeeded on the server. If the HIT already exists in the system from a previous call using the same UniqueRequestToken, subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error with a message containing the HITId.    Note: It is your responsibility to ensure uniqueness of the token. The unique token expires after 24 hours. Subsequent calls using the same UniqueRequestToken made after the 24 hour limit could create duplicate HITs.  
        public var uniqueRequestToken: String? = nil
        ///  A general description of the HIT. A description includes detailed information about the kind of task the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded view of search results, and in the HIT and assignment screens. A good description gives the user enough information to evaluate the HIT before accepting it. 
        public var description: String = ""
        ///  The number of times the HIT can be accepted and completed before the HIT becomes unavailable. 
        public var maxAssignments: Int32? = nil
        ///  A condition that a Worker's Qualifications must meet before the Worker is allowed to accept and complete the HIT. 
        public var qualificationRequirements: [QualificationRequirement]? = nil
        ///  One or more words or phrases that describe the HIT, separated by commas. These words are used in searches to find HITs. 
        public var keywords: String? = nil
        ///  The data the person completing the HIT uses to produce the results.   Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure, or an HTMLQuestion data structure. The XML question data must not be larger than 64 kilobytes (65,535 bytes) in size, including whitespace.  Either a Question parameter or a HITLayoutId parameter must be provided.
        public var question: String? = nil
        ///  An amount of time, in seconds, after which the HIT is no longer available for users to accept. After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches, even if not all of the assignments for the HIT have been accepted. 
        public var lifetimeInSeconds: Int64 = 0
        ///  The Assignment-level Review Policy applies to the assignments under the HIT. You can specify for Mechanical Turk to take various actions based on the policy. 
        public var assignmentReviewPolicy: ReviewPolicy? = nil
        ///  An arbitrary data field. The RequesterAnnotation parameter lets your application attach arbitrary data to the HIT for tracking purposes. For example, this parameter could be an identifier internal to the Requester's application that corresponds with the HIT.   The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT. It is not shown to the Worker, or any other Requester.   The RequesterAnnotation parameter may be different for each HIT you submit. It does not affect how your HITs are grouped. 
        public var requesterAnnotation: String? = nil

        public init() {}

        public init(autoApprovalDelayInSeconds: Int64? = nil, hITLayoutParameters: [HITLayoutParameter]? = nil, hITLayoutId: String? = nil, title: String, hITReviewPolicy: ReviewPolicy? = nil, assignmentDurationInSeconds: Int64, reward: String, uniqueRequestToken: String? = nil, description: String, maxAssignments: Int32? = nil, qualificationRequirements: [QualificationRequirement]? = nil, keywords: String? = nil, question: String? = nil, lifetimeInSeconds: Int64, assignmentReviewPolicy: ReviewPolicy? = nil, requesterAnnotation: String? = nil) {
            self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
            self.hITLayoutParameters = hITLayoutParameters
            self.hITLayoutId = hITLayoutId
            self.title = title
            self.hITReviewPolicy = hITReviewPolicy
            self.assignmentDurationInSeconds = assignmentDurationInSeconds
            self.reward = reward
            self.uniqueRequestToken = uniqueRequestToken
            self.description = description
            self.maxAssignments = maxAssignments
            self.qualificationRequirements = qualificationRequirements
            self.keywords = keywords
            self.question = question
            self.lifetimeInSeconds = lifetimeInSeconds
            self.assignmentReviewPolicy = assignmentReviewPolicy
            self.requesterAnnotation = requesterAnnotation
        }

        public init(dictionary: [String: Any]) throws {
            self.autoApprovalDelayInSeconds = dictionary["AutoApprovalDelayInSeconds"] as? Int64
            if let hITLayoutParameters = dictionary["HITLayoutParameters"] as? [[String: Any]] {
                self.hITLayoutParameters = try hITLayoutParameters.map({ try HITLayoutParameter(dictionary: $0) })
            }
            self.hITLayoutId = dictionary["HITLayoutId"] as? String
            guard let title = dictionary["Title"] as? String else { throw InitializableError.missingRequiredParam("Title") }
            self.title = title
            if let hITReviewPolicy = dictionary["HITReviewPolicy"] as? [String: Any] { self.hITReviewPolicy = try MturkRequester.ReviewPolicy(dictionary: hITReviewPolicy) }
            guard let assignmentDurationInSeconds = dictionary["AssignmentDurationInSeconds"] as? Int64 else { throw InitializableError.missingRequiredParam("AssignmentDurationInSeconds") }
            self.assignmentDurationInSeconds = assignmentDurationInSeconds
            guard let reward = dictionary["Reward"] as? String else { throw InitializableError.missingRequiredParam("Reward") }
            self.reward = reward
            self.uniqueRequestToken = dictionary["UniqueRequestToken"] as? String
            guard let description = dictionary["Description"] as? String else { throw InitializableError.missingRequiredParam("Description") }
            self.description = description
            self.maxAssignments = dictionary["MaxAssignments"] as? Int32
            if let qualificationRequirements = dictionary["QualificationRequirements"] as? [[String: Any]] {
                self.qualificationRequirements = try qualificationRequirements.map({ try QualificationRequirement(dictionary: $0) })
            }
            self.keywords = dictionary["Keywords"] as? String
            self.question = dictionary["Question"] as? String
            guard let lifetimeInSeconds = dictionary["LifetimeInSeconds"] as? Int64 else { throw InitializableError.missingRequiredParam("LifetimeInSeconds") }
            self.lifetimeInSeconds = lifetimeInSeconds
            if let assignmentReviewPolicy = dictionary["AssignmentReviewPolicy"] as? [String: Any] { self.assignmentReviewPolicy = try MturkRequester.ReviewPolicy(dictionary: assignmentReviewPolicy) }
            self.requesterAnnotation = dictionary["RequesterAnnotation"] as? String
        }
    }

    public struct ListWorkerBlocksRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Pagination token
        public var nextToken: String? = nil
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct AcceptQualificationRequestResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct RejectQualificationRequestResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct SendTestEventNotificationResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetQualificationScoreResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The Qualification data structure of the Qualification assigned to a user, including the Qualification type and the value (score). 
        public var qualification: Qualification? = nil

        public init() {}

        public init(qualification: Qualification? = nil) {
            self.qualification = qualification
        }

        public init(dictionary: [String: Any]) throws {
            if let qualification = dictionary["Qualification"] as? [String: Any] { self.qualification = try MturkRequester.Qualification(dictionary: qualification) }
        }
    }

    public struct UpdateNotificationSettingsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct UpdateHITReviewStatusRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The ID of the HIT to update. 
        public var hITId: String = ""
        ///  Specifies how to update the HIT status. Default is False.     Setting this to false will only transition a HIT from Reviewable to Reviewing     Setting this to true will only transition a HIT from Reviewing to Reviewable   
        public var revert: Bool? = nil

        public init() {}

        public init(hITId: String, revert: Bool? = nil) {
            self.hITId = hITId
            self.revert = revert
        }

        public init(dictionary: [String: Any]) throws {
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
            self.revert = dictionary["Revert"] as? Bool
        }
    }

    public struct AssociateQualificationWithWorkerRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The value of the Qualification to assign.
        public var integerValue: Int32? = nil
        ///  Specifies whether to send a notification email message to the Worker saying that the qualification was assigned to the Worker. Note: this is true by default. 
        public var sendNotification: Bool? = nil
        ///  The ID of the Worker to whom the Qualification is being assigned. Worker IDs are included with submitted HIT assignments and Qualification requests. 
        public var workerId: String = ""
        /// The ID of the Qualification type to use for the assigned Qualification.
        public var qualificationTypeId: String = ""

        public init() {}

        public init(integerValue: Int32? = nil, sendNotification: Bool? = nil, workerId: String, qualificationTypeId: String) {
            self.integerValue = integerValue
            self.sendNotification = sendNotification
            self.workerId = workerId
            self.qualificationTypeId = qualificationTypeId
        }

        public init(dictionary: [String: Any]) throws {
            self.integerValue = dictionary["IntegerValue"] as? Int32
            self.sendNotification = dictionary["SendNotification"] as? Bool
            guard let workerId = dictionary["WorkerId"] as? String else { throw InitializableError.missingRequiredParam("WorkerId") }
            self.workerId = workerId
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
        }
    }

    public struct DeleteHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the HIT to be deleted.
        public var hITId: String = ""

        public init() {}

        public init(hITId: String) {
            self.hITId = hITId
        }

        public init(dictionary: [String: Any]) throws {
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
        }
    }

    public struct UpdateQualificationTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of seconds the Worker has to complete the Qualification test, starting from the time the Worker requests the Qualification.
        public var testDurationInSeconds: Int64? = nil
        /// Specifies whether requests for the Qualification type are granted immediately, without prompting the Worker with a Qualification test. Constraints: If the Test parameter is specified, this parameter cannot be true.
        public var autoGranted: Bool? = nil
        /// The questions for the Qualification test a Worker must answer correctly to obtain a Qualification of this type. If this parameter is specified, TestDurationInSeconds must also be specified. Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm data structure. This parameter cannot be specified if AutoGranted is true. Constraints: None. If not specified, the Worker may request the Qualification without answering any questions.
        public var test: String? = nil
        /// The amount of time, in seconds, that Workers must wait after requesting a Qualification of the specified Qualification type before they can retry the Qualification request. It is not possible to disable retries for a Qualification type after it has been created with retries enabled. If you want to disable retries, you must dispose of the existing retry-enabled Qualification type using DisposeQualificationType and then create a new Qualification type with retries disabled using CreateQualificationType.
        public var retryDelayInSeconds: Int64? = nil
        /// The new status of the Qualification type - Active | Inactive
        public var qualificationTypeStatus: String? = nil
        /// The answers to the Qualification test specified in the Test parameter, in the form of an AnswerKey data structure.
        public var answerKey: String? = nil
        /// The Qualification value to use for automatically granted Qualifications. This parameter is used only if the AutoGranted parameter is true.
        public var autoGrantedValue: Int32? = nil
        /// The ID of the Qualification type to update.
        public var qualificationTypeId: String = ""
        /// The new description of the Qualification type.
        public var description: String? = nil

        public init() {}

        public init(testDurationInSeconds: Int64? = nil, autoGranted: Bool? = nil, test: String? = nil, retryDelayInSeconds: Int64? = nil, qualificationTypeStatus: String? = nil, answerKey: String? = nil, autoGrantedValue: Int32? = nil, qualificationTypeId: String, description: String? = nil) {
            self.testDurationInSeconds = testDurationInSeconds
            self.autoGranted = autoGranted
            self.test = test
            self.retryDelayInSeconds = retryDelayInSeconds
            self.qualificationTypeStatus = qualificationTypeStatus
            self.answerKey = answerKey
            self.autoGrantedValue = autoGrantedValue
            self.qualificationTypeId = qualificationTypeId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.testDurationInSeconds = dictionary["TestDurationInSeconds"] as? Int64
            self.autoGranted = dictionary["AutoGranted"] as? Bool
            self.test = dictionary["Test"] as? String
            self.retryDelayInSeconds = dictionary["RetryDelayInSeconds"] as? Int64
            self.qualificationTypeStatus = dictionary["QualificationTypeStatus"] as? String
            self.answerKey = dictionary["AnswerKey"] as? String
            self.autoGrantedValue = dictionary["AutoGrantedValue"] as? Int32
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
            self.description = dictionary["Description"] as? String
        }
    }

    public struct Qualification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The value (score) of the Qualification, if the Qualification has an integer value.
        public var integerValue: Int32? = nil
        ///  The status of the Qualification. Valid values are Granted | Revoked.
        public var status: String? = nil
        public var localeValue: Locale? = nil
        ///  The date and time the Qualification was granted to the Worker. If the Worker's Qualification was revoked, and then re-granted based on a new Qualification request, GrantTime is the date and time of the last call to the AcceptQualificationRequest operation.
        public var grantTime: Date? = nil
        ///  The ID of the Worker who possesses the Qualification. 
        public var workerId: String? = nil
        ///  The ID of the Qualification type for the Qualification.
        public var qualificationTypeId: String? = nil

        public init() {}

        public init(integerValue: Int32? = nil, status: String? = nil, localeValue: Locale? = nil, grantTime: Date? = nil, workerId: String? = nil, qualificationTypeId: String? = nil) {
            self.integerValue = integerValue
            self.status = status
            self.localeValue = localeValue
            self.grantTime = grantTime
            self.workerId = workerId
            self.qualificationTypeId = qualificationTypeId
        }

        public init(dictionary: [String: Any]) throws {
            self.integerValue = dictionary["IntegerValue"] as? Int32
            self.status = dictionary["Status"] as? String
            if let localeValue = dictionary["LocaleValue"] as? [String: Any] { self.localeValue = try MturkRequester.Locale(dictionary: localeValue) }
            self.grantTime = dictionary["GrantTime"] as? Date
            self.workerId = dictionary["WorkerId"] as? String
            self.qualificationTypeId = dictionary["QualificationTypeId"] as? String
        }
    }

    public struct AssociateQualificationWithWorkerResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct UpdateExpirationForHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateWorkerBlockRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A message explaining the reason for blocking the Worker. This parameter enables you to keep track of your Workers. The Worker does not see this message.
        public var reason: String = ""
        /// The ID of the Worker to block.
        public var workerId: String = ""

        public init() {}

        public init(reason: String, workerId: String) {
            self.reason = reason
            self.workerId = workerId
        }

        public init(dictionary: [String: Any]) throws {
            guard let reason = dictionary["Reason"] as? String else { throw InitializableError.missingRequiredParam("Reason") }
            self.reason = reason
            guard let workerId = dictionary["WorkerId"] as? String else { throw InitializableError.missingRequiredParam("WorkerId") }
            self.workerId = workerId
        }
    }

    public struct ListHITsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The list of HIT elements returned by the query.
        public var hITs: [HIT]? = nil
        public var nextToken: String? = nil
        /// The number of HITs on this page in the filtered results list, equivalent to the number of HITs being returned by this call.
        public var numResults: Int32? = nil

        public init() {}

        public init(hITs: [HIT]? = nil, nextToken: String? = nil, numResults: Int32? = nil) {
            self.hITs = hITs
            self.nextToken = nextToken
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            if let hITs = dictionary["HITs"] as? [[String: Any]] {
                self.hITs = try hITs.map({ try HIT(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct CreateAdditionalAssignmentsForHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the HIT to extend.
        public var hITId: String = ""
        /// The number of additional assignments to request for this HIT.
        public var numberOfAdditionalAssignments: Int32? = nil
        ///  A unique identifier for this request, which allows you to retry the call on error without extending the HIT multiple times. This is useful in cases such as network timeouts where it is unclear whether or not the call succeeded on the server. If the extend HIT already exists in the system from a previous call using the same UniqueRequestToken, subsequent calls will return an error with a message containing the request ID. 
        public var uniqueRequestToken: String? = nil

        public init() {}

        public init(hITId: String, numberOfAdditionalAssignments: Int32? = nil, uniqueRequestToken: String? = nil) {
            self.hITId = hITId
            self.numberOfAdditionalAssignments = numberOfAdditionalAssignments
            self.uniqueRequestToken = uniqueRequestToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
            self.numberOfAdditionalAssignments = dictionary["NumberOfAdditionalAssignments"] as? Int32
            self.uniqueRequestToken = dictionary["UniqueRequestToken"] as? String
        }
    }

    public struct GetFileUploadURLRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the assignment that contains the question with a FileUploadAnswer.
        public var assignmentId: String = ""
        /// The identifier of the question with a FileUploadAnswer, as specified in the QuestionForm of the HIT.
        public var questionIdentifier: String = ""

        public init() {}

        public init(assignmentId: String, questionIdentifier: String) {
            self.assignmentId = assignmentId
            self.questionIdentifier = questionIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            guard let assignmentId = dictionary["AssignmentId"] as? String else { throw InitializableError.missingRequiredParam("AssignmentId") }
            self.assignmentId = assignmentId
            guard let questionIdentifier = dictionary["QuestionIdentifier"] as? String else { throw InitializableError.missingRequiredParam("QuestionIdentifier") }
            self.questionIdentifier = questionIdentifier
        }
    }

    public struct ListQualificationRequestsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var nextToken: String? = nil
        /// The Qualification request. The response includes one QualificationRequest element for each Qualification request returned by the query.
        public var qualificationRequests: [QualificationRequest]? = nil
        /// The number of Qualification requests on this page in the filtered results list, equivalent to the number of Qualification requests being returned by this call.
        public var numResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, qualificationRequests: [QualificationRequest]? = nil, numResults: Int32? = nil) {
            self.nextToken = nextToken
            self.qualificationRequests = qualificationRequests
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let qualificationRequests = dictionary["QualificationRequests"] as? [[String: Any]] {
                self.qualificationRequests = try qualificationRequests.map({ try QualificationRequest(dictionary: $0) })
            }
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct ReviewReport: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  A list of ReviewResults objects for each action specified in the Review Policy. 
        public var reviewResults: [ReviewResultDetail]? = nil
        ///  A list of ReviewAction objects for each action specified in the Review Policy. 
        public var reviewActions: [ReviewActionDetail]? = nil

        public init() {}

        public init(reviewResults: [ReviewResultDetail]? = nil, reviewActions: [ReviewActionDetail]? = nil) {
            self.reviewResults = reviewResults
            self.reviewActions = reviewActions
        }

        public init(dictionary: [String: Any]) throws {
            if let reviewResults = dictionary["ReviewResults"] as? [[String: Any]] {
                self.reviewResults = try reviewResults.map({ try ReviewResultDetail(dictionary: $0) })
            }
            if let reviewActions = dictionary["ReviewActions"] as? [[String: Any]] {
                self.reviewActions = try reviewActions.map({ try ReviewActionDetail(dictionary: $0) })
            }
        }
    }

    public struct RejectAssignmentResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetAssignmentResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The HIT associated with this assignment. The response includes one HIT element.
        public var hIT: HIT? = nil
        ///  The assignment. The response includes one Assignment element. 
        public var assignment: Assignment? = nil

        public init() {}

        public init(hIT: HIT? = nil, assignment: Assignment? = nil) {
            self.hIT = hIT
            self.assignment = assignment
        }

        public init(dictionary: [String: Any]) throws {
            if let hIT = dictionary["HIT"] as? [String: Any] { self.hIT = try MturkRequester.HIT(dictionary: hIT) }
            if let assignment = dictionary["Assignment"] as? [String: Any] { self.assignment = try MturkRequester.Assignment(dictionary: assignment) }
        }
    }

    public struct QualificationRequirement: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The ID of the Qualification type for the requirement.
        public var qualificationTypeId: String = ""
        ///  The integer value to compare against the Qualification's value. IntegerValue must not be present if Comparator is Exists or DoesNotExist. IntegerValue can only be used if the Qualification type has an integer value; it cannot be used with the Worker_Locale QualificationType ID. When performing a set comparison by using the In or the NotIn comparator, you can use up to 15 IntegerValue elements in a QualificationRequirement data structure. 
        public var integerValues: [Int32]? = nil
        ///  If true, the question data for the HIT will not be shown when a Worker whose Qualifications do not meet this requirement tries to preview the HIT. That is, a Worker's Qualifications must meet all of the requirements for which RequiredToPreview is true in order to preview the HIT. If a Worker meets all of the requirements where RequiredToPreview is true (or if there are no such requirements), but does not meet all of the requirements for the HIT, the Worker will be allowed to preview the HIT's question data, but will not be allowed to accept and complete the HIT. The default is false. 
        public var requiredToPreview: Bool? = nil
        /// The kind of comparison to make against a Qualification's value. You can compare a Qualification's value to an IntegerValue to see if it is LessThan, LessThanOrEqualTo, GreaterThan, GreaterThanOrEqualTo, EqualTo, or NotEqualTo the IntegerValue. You can compare it to a LocaleValue to see if it is EqualTo, or NotEqualTo the LocaleValue. You can check to see if the value is In or NotIn a set of IntegerValue or LocaleValue values. Lastly, a Qualification requirement can also test if a Qualification Exists or DoesNotExist in the user's profile, regardless of its value. 
        public var comparator: String = ""
        ///  The locale value to compare against the Qualification's value. The local value must be a valid ISO 3166 country code or supports ISO 3166-2 subdivisions. LocaleValue can only be used with a Worker_Locale QualificationType ID. LocaleValue can only be used with the EqualTo, NotEqualTo, In, and NotIn comparators. You must only use a single LocaleValue element when using the EqualTo or NotEqualTo comparators. When performing a set comparison by using the In or the NotIn comparator, you can use up to 30 LocaleValue elements in a QualificationRequirement data structure. 
        public var localeValues: [Locale]? = nil

        public init() {}

        public init(qualificationTypeId: String, integerValues: [Int32]? = nil, requiredToPreview: Bool? = nil, comparator: String, localeValues: [Locale]? = nil) {
            self.qualificationTypeId = qualificationTypeId
            self.integerValues = integerValues
            self.requiredToPreview = requiredToPreview
            self.comparator = comparator
            self.localeValues = localeValues
        }

        public init(dictionary: [String: Any]) throws {
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
            if let integerValues = dictionary["IntegerValues"] as? [Int32] {
                self.integerValues = integerValues
            }
            self.requiredToPreview = dictionary["RequiredToPreview"] as? Bool
            guard let comparator = dictionary["Comparator"] as? String else { throw InitializableError.missingRequiredParam("Comparator") }
            self.comparator = comparator
            if let localeValues = dictionary["LocaleValues"] as? [[String: Any]] {
                self.localeValues = try localeValues.map({ try Locale(dictionary: $0) })
            }
        }
    }

    public struct GetAccountBalanceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct Locale: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The country of the locale. Must be a valid ISO 3166 country code. For example, the code US refers to the United States of America. 
        public var country: String = ""
        /// The state or subdivision of the locale. A valid ISO 3166-2 subdivision code. For example, the code WA refers to the state of Washington.
        public var subdivision: String? = nil

        public init() {}

        public init(country: String, subdivision: String? = nil) {
            self.country = country
            self.subdivision = subdivision
        }

        public init(dictionary: [String: Any]) throws {
            guard let country = dictionary["Country"] as? String else { throw InitializableError.missingRequiredParam("Country") }
            self.country = country
            self.subdivision = dictionary["Subdivision"] as? String
        }
    }

    public struct WorkerBlock: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  A message explaining the reason the Worker was blocked. 
        public var reason: String? = nil
        ///  The ID of the Worker who accepted the HIT.
        public var workerId: String? = nil

        public init() {}

        public init(reason: String? = nil, workerId: String? = nil) {
            self.reason = reason
            self.workerId = workerId
        }

        public init(dictionary: [String: Any]) throws {
            self.reason = dictionary["Reason"] as? String
            self.workerId = dictionary["WorkerId"] as? String
        }
    }

    public struct ListWorkersWithQualificationTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The list of Qualification elements returned by this call. 
        public var qualifications: [Qualification]? = nil
        public var nextToken: String? = nil
        ///  The number of Qualifications on this page in the filtered results list, equivalent to the number of Qualifications being returned by this call.
        public var numResults: Int32? = nil

        public init() {}

        public init(qualifications: [Qualification]? = nil, nextToken: String? = nil, numResults: Int32? = nil) {
            self.qualifications = qualifications
            self.nextToken = nextToken
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            if let qualifications = dictionary["Qualifications"] as? [[String: Any]] {
                self.qualifications = try qualifications.map({ try Qualification(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct ParameterMapEntry: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The QuestionID from the HIT that is used to identify which question requires Mechanical Turk to score as part of the ScoreMyKnownAnswers/2011-09-01 Review Policy. 
        public var key: String? = nil
        ///  The list of answers to the question specified in the MapEntry Key element. The Worker must match all values in order for the answer to be scored correctly. 
        public var values: [String]? = nil

        public init() {}

        public init(key: String? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            if let values = dictionary["Values"] as? [String] {
                self.values = values
            }
        }
    }

    public struct CreateHITWithHITTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. 
        public var hIT: HIT? = nil

        public init() {}

        public init(hIT: HIT? = nil) {
            self.hIT = hIT
        }

        public init(dictionary: [String: Any]) throws {
            if let hIT = dictionary["HIT"] as? [String: Any] { self.hIT = try MturkRequester.HIT(dictionary: hIT) }
        }
    }

    public struct GetHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the HIT to be retrieved.
        public var hITId: String = ""

        public init() {}

        public init(hITId: String) {
            self.hITId = hITId
        }

        public init(dictionary: [String: Any]) throws {
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
        }
    }

    public struct ListWorkersWithQualificationTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The status of the Qualifications to return. Can be Granted | Revoked. 
        public var status: String? = nil
        /// Pagination Token
        public var nextToken: String? = nil
        /// The ID of the Qualification type of the Qualifications to return.
        public var qualificationTypeId: String = ""
        ///  Limit the number of results returned. 
        public var maxResults: Int32? = nil

        public init() {}

        public init(status: String? = nil, nextToken: String? = nil, qualificationTypeId: String, maxResults: Int32? = nil) {
            self.status = status
            self.nextToken = nextToken
            self.qualificationTypeId = qualificationTypeId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CreateQualificationTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of seconds the Worker has to complete the Qualification test, starting from the time the Worker requests the Qualification.
        public var testDurationInSeconds: Int64? = nil
        /// Specifies whether requests for the Qualification type are granted immediately, without prompting the Worker with a Qualification test. Constraints: If the Test parameter is specified, this parameter cannot be true.
        public var autoGranted: Bool? = nil
        ///  The questions for the Qualification test a Worker must answer correctly to obtain a Qualification of this type. If this parameter is specified, TestDurationInSeconds must also be specified.  Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm data structure. This parameter cannot be specified if AutoGranted is true. Constraints: None. If not specified, the Worker may request the Qualification without answering any questions.
        public var test: String? = nil
        /// The number of seconds that a Worker must wait after requesting a Qualification of the Qualification type before the worker can retry the Qualification request. Constraints: None. If not specified, retries are disabled and Workers can request a Qualification of this type only once, even if the Worker has not been granted the Qualification. It is not possible to disable retries for a Qualification type after it has been created with retries enabled. If you want to disable retries, you must delete existing retry-enabled Qualification type and then create a new Qualification type with retries disabled.
        public var retryDelayInSeconds: Int64? = nil
        ///  The name you give to the Qualification type. The type name is used to represent the Qualification to Workers, and to find the type using a Qualification type search. It must be unique across all of your Qualification types.
        public var name: String = ""
        /// One or more words or phrases that describe the Qualification type, separated by commas. The keywords of a type make the type easier to find during a search.
        public var keywords: String? = nil
        /// The initial status of the Qualification type. Constraints: Valid values are: Active | Inactive
        public var qualificationTypeStatus: String = ""
        /// The answers to the Qualification test specified in the Test parameter, in the form of an AnswerKey data structure. Constraints: Must not be longer than 65535 bytes. Constraints: None. If not specified, you must process Qualification requests manually.
        public var answerKey: String? = nil
        /// The Qualification value to use for automatically granted Qualifications. This parameter is used only if the AutoGranted parameter is true.
        public var autoGrantedValue: Int32? = nil
        /// A long description for the Qualification type. On the Amazon Mechanical Turk website, the long description is displayed when a Worker examines a Qualification type.
        public var description: String = ""

        public init() {}

        public init(testDurationInSeconds: Int64? = nil, autoGranted: Bool? = nil, test: String? = nil, retryDelayInSeconds: Int64? = nil, name: String, keywords: String? = nil, qualificationTypeStatus: String, answerKey: String? = nil, autoGrantedValue: Int32? = nil, description: String) {
            self.testDurationInSeconds = testDurationInSeconds
            self.autoGranted = autoGranted
            self.test = test
            self.retryDelayInSeconds = retryDelayInSeconds
            self.name = name
            self.keywords = keywords
            self.qualificationTypeStatus = qualificationTypeStatus
            self.answerKey = answerKey
            self.autoGrantedValue = autoGrantedValue
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.testDurationInSeconds = dictionary["TestDurationInSeconds"] as? Int64
            self.autoGranted = dictionary["AutoGranted"] as? Bool
            self.test = dictionary["Test"] as? String
            self.retryDelayInSeconds = dictionary["RetryDelayInSeconds"] as? Int64
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.keywords = dictionary["Keywords"] as? String
            guard let qualificationTypeStatus = dictionary["QualificationTypeStatus"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeStatus") }
            self.qualificationTypeStatus = qualificationTypeStatus
            self.answerKey = dictionary["AnswerKey"] as? String
            self.autoGrantedValue = dictionary["AutoGrantedValue"] as? Int32
            guard let description = dictionary["Description"] as? String else { throw InitializableError.missingRequiredParam("Description") }
            self.description = description
        }
    }

    public struct CreateAdditionalAssignmentsForHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListHITsForQualificationTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Pagination Token
        public var nextToken: String? = nil
        ///  The ID of the Qualification type to use when querying HITs. 
        public var qualificationTypeId: String = ""
        ///  Limit the number of results returned. 
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, qualificationTypeId: String, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.qualificationTypeId = qualificationTypeId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct RejectQualificationRequestRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A text message explaining why the request was rejected, to be shown to the Worker who made the request.
        public var reason: String? = nil
        ///  The ID of the Qualification request, as returned by the ListQualificationRequests operation. 
        public var qualificationRequestId: String = ""

        public init() {}

        public init(reason: String? = nil, qualificationRequestId: String) {
            self.reason = reason
            self.qualificationRequestId = qualificationRequestId
        }

        public init(dictionary: [String: Any]) throws {
            self.reason = dictionary["Reason"] as? String
            guard let qualificationRequestId = dictionary["QualificationRequestId"] as? String else { throw InitializableError.missingRequiredParam("QualificationRequestId") }
            self.qualificationRequestId = qualificationRequestId
        }
    }

    public struct CreateHITTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The number of seconds after an assignment for the HIT has been submitted, after which the assignment is considered Approved automatically unless the Requester explicitly rejects it. 
        public var autoApprovalDelayInSeconds: Int64? = nil
        ///  A condition that a Worker's Qualifications must meet before the Worker is allowed to accept and complete the HIT. 
        public var qualificationRequirements: [QualificationRequirement]? = nil
        ///  The amount of time, in seconds, that a Worker has to complete the HIT after accepting it. If a Worker does not complete the assignment within the specified duration, the assignment is considered abandoned. If the HIT is still active (that is, its lifetime has not elapsed), the assignment becomes available for other users to find and accept. 
        public var assignmentDurationInSeconds: Int64 = 0
        ///  The title of the HIT. A title should be short and descriptive about the kind of task the HIT contains. On the Amazon Mechanical Turk web site, the HIT title appears in search results, and everywhere the HIT is mentioned. 
        public var title: String = ""
        ///  The amount of money the Requester will pay a Worker for successfully completing the HIT. 
        public var reward: String = ""
        ///  One or more words or phrases that describe the HIT, separated by commas. These words are used in searches to find HITs. 
        public var keywords: String? = nil
        ///  A general description of the HIT. A description includes detailed information about the kind of task the HIT contains. On the Amazon Mechanical Turk web site, the HIT description appears in the expanded view of search results, and in the HIT and assignment screens. A good description gives the user enough information to evaluate the HIT before accepting it. 
        public var description: String = ""

        public init() {}

        public init(autoApprovalDelayInSeconds: Int64? = nil, qualificationRequirements: [QualificationRequirement]? = nil, assignmentDurationInSeconds: Int64, title: String, reward: String, keywords: String? = nil, description: String) {
            self.autoApprovalDelayInSeconds = autoApprovalDelayInSeconds
            self.qualificationRequirements = qualificationRequirements
            self.assignmentDurationInSeconds = assignmentDurationInSeconds
            self.title = title
            self.reward = reward
            self.keywords = keywords
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.autoApprovalDelayInSeconds = dictionary["AutoApprovalDelayInSeconds"] as? Int64
            if let qualificationRequirements = dictionary["QualificationRequirements"] as? [[String: Any]] {
                self.qualificationRequirements = try qualificationRequirements.map({ try QualificationRequirement(dictionary: $0) })
            }
            guard let assignmentDurationInSeconds = dictionary["AssignmentDurationInSeconds"] as? Int64 else { throw InitializableError.missingRequiredParam("AssignmentDurationInSeconds") }
            self.assignmentDurationInSeconds = assignmentDurationInSeconds
            guard let title = dictionary["Title"] as? String else { throw InitializableError.missingRequiredParam("Title") }
            self.title = title
            guard let reward = dictionary["Reward"] as? String else { throw InitializableError.missingRequiredParam("Reward") }
            self.reward = reward
            self.keywords = dictionary["Keywords"] as? String
            guard let description = dictionary["Description"] as? String else { throw InitializableError.missingRequiredParam("Description") }
            self.description = description
        }
    }

    public struct Assignment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  If results have been submitted, AutoApprovalTime is the date and time the results of the assignment results are considered Approved automatically if they have not already been explicitly approved or rejected by the Requester. This value is derived from the auto-approval delay specified by the Requester in the HIT. This value is omitted from the assignment if the Worker has not yet submitted results.
        public var autoApprovalTime: Date? = nil
        ///  If the Worker has submitted results, SubmitTime is the date and time the assignment was submitted. This value is omitted from the assignment if the Worker has not yet submitted results.
        public var submitTime: Date? = nil
        ///  The ID of the HIT.
        public var hITId: String? = nil
        ///  The date and time of the deadline for the assignment. This value is derived from the deadline specification for the HIT and the date and time the Worker accepted the HIT.
        public var deadline: Date? = nil
        ///  The status of the assignment.
        public var assignmentStatus: String? = nil
        ///  If the Worker has submitted results and the Requester has approved the results, ApprovalTime is the date and time the Requester approved the results. This value is omitted from the assignment if the Requester has not yet approved the results.
        public var approvalTime: Date? = nil
        ///  The feedback string included with the call to the ApproveAssignment operation or the RejectAssignment operation, if the Requester approved or rejected the assignment and specified feedback.
        public var requesterFeedback: String? = nil
        ///  The date and time the Worker accepted the assignment.
        public var acceptTime: Date? = nil
        ///  If the Worker has submitted results and the Requester has rejected the results, RejectionTime is the date and time the Requester rejected the results.
        public var rejectionTime: Date? = nil
        ///  A unique identifier for the assignment.
        public var assignmentId: String? = nil
        ///  The ID of the Worker who accepted the HIT.
        public var workerId: String? = nil
        ///  The Worker's answers submitted for the HIT contained in a QuestionFormAnswers document, if the Worker provides an answer. If the Worker does not provide any answers, Answer may contain a QuestionFormAnswers document, or Answer may be empty.
        public var answer: String? = nil

        public init() {}

        public init(autoApprovalTime: Date? = nil, submitTime: Date? = nil, hITId: String? = nil, deadline: Date? = nil, assignmentStatus: String? = nil, approvalTime: Date? = nil, requesterFeedback: String? = nil, acceptTime: Date? = nil, rejectionTime: Date? = nil, assignmentId: String? = nil, workerId: String? = nil, answer: String? = nil) {
            self.autoApprovalTime = autoApprovalTime
            self.submitTime = submitTime
            self.hITId = hITId
            self.deadline = deadline
            self.assignmentStatus = assignmentStatus
            self.approvalTime = approvalTime
            self.requesterFeedback = requesterFeedback
            self.acceptTime = acceptTime
            self.rejectionTime = rejectionTime
            self.assignmentId = assignmentId
            self.workerId = workerId
            self.answer = answer
        }

        public init(dictionary: [String: Any]) throws {
            self.autoApprovalTime = dictionary["AutoApprovalTime"] as? Date
            self.submitTime = dictionary["SubmitTime"] as? Date
            self.hITId = dictionary["HITId"] as? String
            self.deadline = dictionary["Deadline"] as? Date
            self.assignmentStatus = dictionary["AssignmentStatus"] as? String
            self.approvalTime = dictionary["ApprovalTime"] as? Date
            self.requesterFeedback = dictionary["RequesterFeedback"] as? String
            self.acceptTime = dictionary["AcceptTime"] as? Date
            self.rejectionTime = dictionary["RejectionTime"] as? Date
            self.assignmentId = dictionary["AssignmentId"] as? String
            self.workerId = dictionary["WorkerId"] as? String
            self.answer = dictionary["Answer"] as? String
        }
    }

    public struct SendBonusRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the assignment for which this bonus is paid.
        public var assignmentId: String = ""
        /// A unique identifier for this request, which allows you to retry the call on error without granting multiple bonuses. This is useful in cases such as network timeouts where it is unclear whether or not the call succeeded on the server. If the bonus already exists in the system from a previous call using the same UniqueRequestToken, subsequent calls will return an error with a message containing the request ID.
        public var uniqueRequestToken: String? = nil
        /// A message that explains the reason for the bonus payment. The Worker receiving the bonus can see this message.
        public var reason: String? = nil
        /// The ID of the Worker being paid the bonus.
        public var workerId: String = ""
        ///  The Bonus amount is a US Dollar amount specified using a string (for example, "5" represents $5.00 USD and "101.42" represents $101.42 USD). Do not include currency symbols or currency codes. 
        public var bonusAmount: String = ""

        public init() {}

        public init(assignmentId: String, uniqueRequestToken: String? = nil, reason: String? = nil, workerId: String, bonusAmount: String) {
            self.assignmentId = assignmentId
            self.uniqueRequestToken = uniqueRequestToken
            self.reason = reason
            self.workerId = workerId
            self.bonusAmount = bonusAmount
        }

        public init(dictionary: [String: Any]) throws {
            guard let assignmentId = dictionary["AssignmentId"] as? String else { throw InitializableError.missingRequiredParam("AssignmentId") }
            self.assignmentId = assignmentId
            self.uniqueRequestToken = dictionary["UniqueRequestToken"] as? String
            self.reason = dictionary["Reason"] as? String
            guard let workerId = dictionary["WorkerId"] as? String else { throw InitializableError.missingRequiredParam("WorkerId") }
            self.workerId = workerId
            guard let bonusAmount = dictionary["BonusAmount"] as? String else { throw InitializableError.missingRequiredParam("BonusAmount") }
            self.bonusAmount = bonusAmount
        }
    }

    public struct CreateWorkerBlockResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateQualificationTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The created Qualification type, returned as a QualificationType data structure.
        public var qualificationType: QualificationType? = nil

        public init() {}

        public init(qualificationType: QualificationType? = nil) {
            self.qualificationType = qualificationType
        }

        public init(dictionary: [String: Any]) throws {
            if let qualificationType = dictionary["QualificationType"] as? [String: Any] { self.qualificationType = try MturkRequester.QualificationType(dictionary: qualificationType) }
        }
    }

    public struct ListReviewPolicyResultsForHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the HIT-level Review Policy. This contains only the PolicyName element.
        public var hITReviewPolicy: ReviewPolicy? = nil
        /// Contains both ReviewResult and ReviewAction elements for a particular HIT. 
        public var hITReviewReport: ReviewReport? = nil
        /// The HITId of the HIT for which results have been returned.
        public var hITId: String? = nil
        ///  The name of the Assignment-level Review Policy. This contains only the PolicyName element. 
        public var assignmentReviewPolicy: ReviewPolicy? = nil
        public var nextToken: String? = nil
        ///  Contains both ReviewResult and ReviewAction elements for an Assignment. 
        public var assignmentReviewReport: ReviewReport? = nil

        public init() {}

        public init(hITReviewPolicy: ReviewPolicy? = nil, hITReviewReport: ReviewReport? = nil, hITId: String? = nil, assignmentReviewPolicy: ReviewPolicy? = nil, nextToken: String? = nil, assignmentReviewReport: ReviewReport? = nil) {
            self.hITReviewPolicy = hITReviewPolicy
            self.hITReviewReport = hITReviewReport
            self.hITId = hITId
            self.assignmentReviewPolicy = assignmentReviewPolicy
            self.nextToken = nextToken
            self.assignmentReviewReport = assignmentReviewReport
        }

        public init(dictionary: [String: Any]) throws {
            if let hITReviewPolicy = dictionary["HITReviewPolicy"] as? [String: Any] { self.hITReviewPolicy = try MturkRequester.ReviewPolicy(dictionary: hITReviewPolicy) }
            if let hITReviewReport = dictionary["HITReviewReport"] as? [String: Any] { self.hITReviewReport = try MturkRequester.ReviewReport(dictionary: hITReviewReport) }
            self.hITId = dictionary["HITId"] as? String
            if let assignmentReviewPolicy = dictionary["AssignmentReviewPolicy"] as? [String: Any] { self.assignmentReviewPolicy = try MturkRequester.ReviewPolicy(dictionary: assignmentReviewPolicy) }
            self.nextToken = dictionary["NextToken"] as? String
            if let assignmentReviewReport = dictionary["AssignmentReviewReport"] as? [String: Any] { self.assignmentReviewReport = try MturkRequester.ReviewReport(dictionary: assignmentReviewReport) }
        }
    }

    public struct ListBonusPaymentsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var nextToken: String? = nil
        /// A successful request to the ListBonusPayments operation returns a list of BonusPayment objects. 
        public var bonusPayments: [BonusPayment]? = nil
        /// The number of bonus payments on this page in the filtered results list, equivalent to the number of bonus payments being returned by this call. 
        public var numResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, bonusPayments: [BonusPayment]? = nil, numResults: Int32? = nil) {
            self.nextToken = nextToken
            self.bonusPayments = bonusPayments
            self.numResults = numResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let bonusPayments = dictionary["BonusPayments"] as? [[String: Any]] {
                self.bonusPayments = try bonusPayments.map({ try BonusPayment(dictionary: $0) })
            }
            self.numResults = dictionary["NumResults"] as? Int32
        }
    }

    public struct ListBonusPaymentsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the assignment associated with the bonus payments to retrieve. If specified, only bonus payments for the given assignment are returned. Either the HITId parameter or the AssignmentId parameter must be specified
        public var assignmentId: String? = nil
        /// The ID of the HIT associated with the bonus payments to retrieve. If not specified, all bonus payments for all assignments for the given HIT are returned. Either the HITId parameter or the AssignmentId parameter must be specified
        public var hITId: String? = nil
        /// Pagination token
        public var nextToken: String? = nil
        public var maxResults: Int32? = nil

        public init() {}

        public init(assignmentId: String? = nil, hITId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.assignmentId = assignmentId
            self.hITId = hITId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.assignmentId = dictionary["AssignmentId"] as? String
            self.hITId = dictionary["HITId"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BonusPayment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the assignment associated with this bonus payment.
        public var assignmentId: String? = nil
        /// The Reason text given when the bonus was granted, if any.
        public var reason: String? = nil
        /// The date and time of when the bonus was granted.
        public var grantTime: Date? = nil
        /// The ID of the Worker to whom the bonus was paid.
        public var workerId: String? = nil
        public var bonusAmount: String? = nil

        public init() {}

        public init(assignmentId: String? = nil, reason: String? = nil, grantTime: Date? = nil, workerId: String? = nil, bonusAmount: String? = nil) {
            self.assignmentId = assignmentId
            self.reason = reason
            self.grantTime = grantTime
            self.workerId = workerId
            self.bonusAmount = bonusAmount
        }

        public init(dictionary: [String: Any]) throws {
            self.assignmentId = dictionary["AssignmentId"] as? String
            self.reason = dictionary["Reason"] as? String
            self.grantTime = dictionary["GrantTime"] as? Date
            self.workerId = dictionary["WorkerId"] as? String
            self.bonusAmount = dictionary["BonusAmount"] as? String
        }
    }

    public struct CreateHITResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Contains the newly created HIT data. For a description of the HIT data structure as it appears in responses, see the HIT Data Structure documentation. 
        public var hIT: HIT? = nil

        public init() {}

        public init(hIT: HIT? = nil) {
            self.hIT = hIT
        }

        public init(dictionary: [String: Any]) throws {
            if let hIT = dictionary["HIT"] as? [String: Any] { self.hIT = try MturkRequester.HIT(dictionary: hIT) }
        }
    }

    public struct CreateHITWithHITTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The number of times the HIT can be accepted and completed before the HIT becomes unavailable. 
        public var maxAssignments: Int32? = nil
        ///  The HITLayoutId allows you to use a pre-existing HIT design with placeholder values and create an additional HIT by providing those values as HITLayoutParameters.   Constraints: Either a Question parameter or a HITLayoutId parameter must be provided. 
        public var hITLayoutId: String? = nil
        ///  If the HITLayoutId is provided, any placeholder values must be filled in with values using the HITLayoutParameter structure. For more information, see HITLayout. 
        public var hITLayoutParameters: [HITLayoutParameter]? = nil
        ///  The HIT-level Review Policy applies to the HIT. You can specify for Mechanical Turk to take various actions based on the policy. 
        public var hITReviewPolicy: ReviewPolicy? = nil
        ///  The data the person completing the HIT uses to produce the results.   Constraints: Must be a QuestionForm data structure, an ExternalQuestion data structure, or an HTMLQuestion data structure. The XML question data must not be larger than 64 kilobytes (65,535 bytes) in size, including whitespace.  Either a Question parameter or a HITLayoutId parameter must be provided.
        public var question: String? = nil
        ///  An arbitrary data field. The RequesterAnnotation parameter lets your application attach arbitrary data to the HIT for tracking purposes. For example, this parameter could be an identifier internal to the Requester's application that corresponds with the HIT.   The RequesterAnnotation parameter for a HIT is only visible to the Requester who created the HIT. It is not shown to the Worker, or any other Requester.   The RequesterAnnotation parameter may be different for each HIT you submit. It does not affect how your HITs are grouped. 
        public var requesterAnnotation: String? = nil
        ///  The Assignment-level Review Policy applies to the assignments under the HIT. You can specify for Mechanical Turk to take various actions based on the policy. 
        public var assignmentReviewPolicy: ReviewPolicy? = nil
        ///  An amount of time, in seconds, after which the HIT is no longer available for users to accept. After the lifetime of the HIT elapses, the HIT no longer appears in HIT searches, even if not all of the assignments for the HIT have been accepted. 
        public var lifetimeInSeconds: Int64 = 0
        ///  A unique identifier for this request which allows you to retry the call on error without creating duplicate HITs. This is useful in cases such as network timeouts where it is unclear whether or not the call succeeded on the server. If the HIT already exists in the system from a previous call using the same UniqueRequestToken, subsequent calls will return a AWS.MechanicalTurk.HitAlreadyExists error with a message containing the HITId.    Note: It is your responsibility to ensure uniqueness of the token. The unique token expires after 24 hours. Subsequent calls using the same UniqueRequestToken made after the 24 hour limit could create duplicate HITs.  
        public var uniqueRequestToken: String? = nil
        /// The HIT type ID you want to create this HIT with.
        public var hITTypeId: String = ""

        public init() {}

        public init(maxAssignments: Int32? = nil, hITLayoutId: String? = nil, hITLayoutParameters: [HITLayoutParameter]? = nil, hITReviewPolicy: ReviewPolicy? = nil, question: String? = nil, requesterAnnotation: String? = nil, assignmentReviewPolicy: ReviewPolicy? = nil, lifetimeInSeconds: Int64, uniqueRequestToken: String? = nil, hITTypeId: String) {
            self.maxAssignments = maxAssignments
            self.hITLayoutId = hITLayoutId
            self.hITLayoutParameters = hITLayoutParameters
            self.hITReviewPolicy = hITReviewPolicy
            self.question = question
            self.requesterAnnotation = requesterAnnotation
            self.assignmentReviewPolicy = assignmentReviewPolicy
            self.lifetimeInSeconds = lifetimeInSeconds
            self.uniqueRequestToken = uniqueRequestToken
            self.hITTypeId = hITTypeId
        }

        public init(dictionary: [String: Any]) throws {
            self.maxAssignments = dictionary["MaxAssignments"] as? Int32
            self.hITLayoutId = dictionary["HITLayoutId"] as? String
            if let hITLayoutParameters = dictionary["HITLayoutParameters"] as? [[String: Any]] {
                self.hITLayoutParameters = try hITLayoutParameters.map({ try HITLayoutParameter(dictionary: $0) })
            }
            if let hITReviewPolicy = dictionary["HITReviewPolicy"] as? [String: Any] { self.hITReviewPolicy = try MturkRequester.ReviewPolicy(dictionary: hITReviewPolicy) }
            self.question = dictionary["Question"] as? String
            self.requesterAnnotation = dictionary["RequesterAnnotation"] as? String
            if let assignmentReviewPolicy = dictionary["AssignmentReviewPolicy"] as? [String: Any] { self.assignmentReviewPolicy = try MturkRequester.ReviewPolicy(dictionary: assignmentReviewPolicy) }
            guard let lifetimeInSeconds = dictionary["LifetimeInSeconds"] as? Int64 else { throw InitializableError.missingRequiredParam("LifetimeInSeconds") }
            self.lifetimeInSeconds = lifetimeInSeconds
            self.uniqueRequestToken = dictionary["UniqueRequestToken"] as? String
            guard let hITTypeId = dictionary["HITTypeId"] as? String else { throw InitializableError.missingRequiredParam("HITTypeId") }
            self.hITTypeId = hITTypeId
        }
    }

    public struct ReviewActionDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The current disposition of the action: INTENDED, SUCCEEDED, FAILED, or CANCELLED. 
        public var status: String? = nil
        ///  The nature of the action itself. The Review Policy is responsible for examining the HIT and Assignments, emitting results, and deciding which other actions will be necessary. 
        public var actionName: String? = nil
        /// The unique identifier for the action.
        public var actionId: String? = nil
        ///  The specific HITId or AssignmentID targeted by the action.
        public var targetId: String? = nil
        ///  The type of object in TargetId.
        public var targetType: String? = nil
        ///  A description of the outcome of the review.
        public var result: String? = nil
        ///  Present only when the Results have a FAILED Status.
        public var errorCode: String? = nil
        ///  The date when the action was completed.
        public var completeTime: Date? = nil

        public init() {}

        public init(status: String? = nil, actionName: String? = nil, actionId: String? = nil, targetId: String? = nil, targetType: String? = nil, result: String? = nil, errorCode: String? = nil, completeTime: Date? = nil) {
            self.status = status
            self.actionName = actionName
            self.actionId = actionId
            self.targetId = targetId
            self.targetType = targetType
            self.result = result
            self.errorCode = errorCode
            self.completeTime = completeTime
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.actionName = dictionary["ActionName"] as? String
            self.actionId = dictionary["ActionId"] as? String
            self.targetId = dictionary["TargetId"] as? String
            self.targetType = dictionary["TargetType"] as? String
            self.result = dictionary["Result"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.completeTime = dictionary["CompleteTime"] as? Date
        }
    }

    public struct UpdateHITTypeOfHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the new HIT type.
        public var hITTypeId: String = ""
        /// The HIT to update.
        public var hITId: String = ""

        public init() {}

        public init(hITTypeId: String, hITId: String) {
            self.hITTypeId = hITTypeId
            self.hITId = hITId
        }

        public init(dictionary: [String: Any]) throws {
            guard let hITTypeId = dictionary["HITTypeId"] as? String else { throw InitializableError.missingRequiredParam("HITTypeId") }
            self.hITTypeId = hITTypeId
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
        }
    }

    public struct ApproveAssignmentResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct QualificationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date and time the Qualification request had a status of Submitted. This is either the time the Worker submitted answers for a Qualification test, or the time the Worker requested the Qualification if the Qualification type does not have a test. 
        public var submitTime: Date? = nil
        ///  The ID of the Worker requesting the Qualification.
        public var workerId: String? = nil
        ///  The Worker's answers for the Qualification type's test contained in a QuestionFormAnswers document, if the type has a test and the Worker has submitted answers. If the Worker does not provide any answers, Answer may be empty. 
        public var answer: String? = nil
        ///  The contents of the Qualification test that was presented to the Worker, if the type has a test and the Worker has submitted answers. This value is identical to the QuestionForm associated with the Qualification type at the time the Worker requests the Qualification.
        public var test: String? = nil
        ///  The ID of the Qualification type the Worker is requesting, as returned by the CreateQualificationType operation. 
        public var qualificationTypeId: String? = nil
        /// The ID of the Qualification request, a unique identifier generated when the request was submitted. 
        public var qualificationRequestId: String? = nil

        public init() {}

        public init(submitTime: Date? = nil, workerId: String? = nil, answer: String? = nil, test: String? = nil, qualificationTypeId: String? = nil, qualificationRequestId: String? = nil) {
            self.submitTime = submitTime
            self.workerId = workerId
            self.answer = answer
            self.test = test
            self.qualificationTypeId = qualificationTypeId
            self.qualificationRequestId = qualificationRequestId
        }

        public init(dictionary: [String: Any]) throws {
            self.submitTime = dictionary["SubmitTime"] as? Date
            self.workerId = dictionary["WorkerId"] as? String
            self.answer = dictionary["Answer"] as? String
            self.test = dictionary["Test"] as? String
            self.qualificationTypeId = dictionary["QualificationTypeId"] as? String
            self.qualificationRequestId = dictionary["QualificationRequestId"] as? String
        }
    }

    public struct DisassociateQualificationFromWorkerRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A text message that explains why the Qualification was revoked. The user who had the Qualification sees this message.
        public var reason: String? = nil
        /// The ID of the Worker who possesses the Qualification to be revoked.
        public var workerId: String = ""
        /// The ID of the Qualification type of the Qualification to be revoked.
        public var qualificationTypeId: String = ""

        public init() {}

        public init(reason: String? = nil, workerId: String, qualificationTypeId: String) {
            self.reason = reason
            self.workerId = workerId
            self.qualificationTypeId = qualificationTypeId
        }

        public init(dictionary: [String: Any]) throws {
            self.reason = dictionary["Reason"] as? String
            guard let workerId = dictionary["WorkerId"] as? String else { throw InitializableError.missingRequiredParam("WorkerId") }
            self.workerId = workerId
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
        }
    }

    public struct UpdateQualificationTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Contains a QualificationType data structure.
        public var qualificationType: QualificationType? = nil

        public init() {}

        public init(qualificationType: QualificationType? = nil) {
            self.qualificationType = qualificationType
        }

        public init(dictionary: [String: Any]) throws {
            if let qualificationType = dictionary["QualificationType"] as? [String: Any] { self.qualificationType = try MturkRequester.QualificationType(dictionary: qualificationType) }
        }
    }

    public struct ReviewResultDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Key identifies the particular piece of reviewed information. 
        public var key: String? = nil
        ///  The type of the object from the SubjectId field.
        public var subjectType: String? = nil
        /// The HITID or AssignmentId about which this result was taken. Note that HIT-level Review Policies will often emit results about both the HIT itself and its Assignments, while Assignment-level review policies generally only emit results about the Assignment itself. 
        public var subjectId: String? = nil
        ///  A unique identifier of the Review action result. 
        public var actionId: String? = nil
        ///  The values of Key provided by the review policies you have selected. 
        public var value: String? = nil
        ///  Specifies the QuestionId the result is describing. Depending on whether the TargetType is a HIT or Assignment this results could specify multiple values. If TargetType is HIT and QuestionId is absent, then the result describes results of the HIT, including the HIT agreement score. If ObjectType is Assignment and QuestionId is absent, then the result describes the Worker's performance on the HIT. 
        public var questionId: String? = nil

        public init() {}

        public init(key: String? = nil, subjectType: String? = nil, subjectId: String? = nil, actionId: String? = nil, value: String? = nil, questionId: String? = nil) {
            self.key = key
            self.subjectType = subjectType
            self.subjectId = subjectId
            self.actionId = actionId
            self.value = value
            self.questionId = questionId
        }

        public init(dictionary: [String: Any]) throws {
            self.key = dictionary["Key"] as? String
            self.subjectType = dictionary["SubjectType"] as? String
            self.subjectId = dictionary["SubjectId"] as? String
            self.actionId = dictionary["ActionId"] as? String
            self.value = dictionary["Value"] as? String
            self.questionId = dictionary["QuestionId"] as? String
        }
    }

    public struct GetAssignmentRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the Assignment to be retrieved.
        public var assignmentId: String = ""

        public init() {}

        public init(assignmentId: String) {
            self.assignmentId = assignmentId
        }

        public init(dictionary: [String: Any]) throws {
            guard let assignmentId = dictionary["AssignmentId"] as? String else { throw InitializableError.missingRequiredParam("AssignmentId") }
            self.assignmentId = assignmentId
        }
    }

    public struct ListHITsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Pagination token
        public var nextToken: String? = nil
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct NotifyWorkersResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  When MTurk sends notifications to the list of Workers, it returns back any failures it encounters in this list of NotifyWorkersFailureStatus objects. 
        public var notifyWorkersFailureStatuses: [NotifyWorkersFailureStatus]? = nil

        public init() {}

        public init(notifyWorkersFailureStatuses: [NotifyWorkersFailureStatus]? = nil) {
            self.notifyWorkersFailureStatuses = notifyWorkersFailureStatuses
        }

        public init(dictionary: [String: Any]) throws {
            if let notifyWorkersFailureStatuses = dictionary["NotifyWorkersFailureStatuses"] as? [[String: Any]] {
                self.notifyWorkersFailureStatuses = try notifyWorkersFailureStatuses.map({ try NotifyWorkersFailureStatus(dictionary: $0) })
            }
        }
    }

    public struct GetQualificationTypeResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The returned Qualification Type
        public var qualificationType: QualificationType? = nil

        public init() {}

        public init(qualificationType: QualificationType? = nil) {
            self.qualificationType = qualificationType
        }

        public init(dictionary: [String: Any]) throws {
            if let qualificationType = dictionary["QualificationType"] as? [String: Any] { self.qualificationType = try MturkRequester.QualificationType(dictionary: qualificationType) }
        }
    }

    public struct PolicyParameter: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  List of ParameterMapEntry objects. 
        public var mapEntries: [ParameterMapEntry]? = nil
        ///  Name of the parameter from the list of Review Polices. 
        public var key: String? = nil
        ///  The list of values of the Parameter
        public var values: [String]? = nil

        public init() {}

        public init(mapEntries: [ParameterMapEntry]? = nil, key: String? = nil, values: [String]? = nil) {
            self.mapEntries = mapEntries
            self.key = key
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            if let mapEntries = dictionary["MapEntries"] as? [[String: Any]] {
                self.mapEntries = try mapEntries.map({ try ParameterMapEntry(dictionary: $0) })
            }
            self.key = dictionary["Key"] as? String
            if let values = dictionary["Values"] as? [String] {
                self.values = values
            }
        }
    }

    public struct DeleteWorkerBlockRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A message that explains the reason for unblocking the Worker. The Worker does not see this message.
        public var reason: String? = nil
        /// The ID of the Worker to unblock.
        public var workerId: String = ""

        public init() {}

        public init(reason: String? = nil, workerId: String) {
            self.reason = reason
            self.workerId = workerId
        }

        public init(dictionary: [String: Any]) throws {
            self.reason = dictionary["Reason"] as? String
            guard let workerId = dictionary["WorkerId"] as? String else { throw InitializableError.missingRequiredParam("WorkerId") }
            self.workerId = workerId
        }
    }

    public struct RejectAssignmentRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  A message for the Worker, which the Worker can see in the Status section of the web site. 
        public var requesterFeedback: String? = nil
        ///  The ID of the assignment. The assignment must correspond to a HIT created by the Requester. 
        public var assignmentId: String = ""

        public init() {}

        public init(requesterFeedback: String? = nil, assignmentId: String) {
            self.requesterFeedback = requesterFeedback
            self.assignmentId = assignmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.requesterFeedback = dictionary["RequesterFeedback"] as? String
            guard let assignmentId = dictionary["AssignmentId"] as? String else { throw InitializableError.missingRequiredParam("AssignmentId") }
            self.assignmentId = assignmentId
        }
    }

    public struct AcceptQualificationRequestRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The value of the Qualification. You can omit this value if you are using the presence or absence of the Qualification as the basis for a HIT requirement. 
        public var integerValue: Int32? = nil
        /// The ID of the Qualification request, as returned by the GetQualificationRequests operation.
        public var qualificationRequestId: String = ""

        public init() {}

        public init(integerValue: Int32? = nil, qualificationRequestId: String) {
            self.integerValue = integerValue
            self.qualificationRequestId = qualificationRequestId
        }

        public init(dictionary: [String: Any]) throws {
            self.integerValue = dictionary["IntegerValue"] as? Int32
            guard let qualificationRequestId = dictionary["QualificationRequestId"] as? String else { throw InitializableError.missingRequiredParam("QualificationRequestId") }
            self.qualificationRequestId = qualificationRequestId
        }
    }

    public struct ListReviewableHITsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Can be either Reviewable or Reviewing. Reviewable is the default value. 
        public var status: String? = nil
        ///  The ID of the HIT type of the HITs to consider for the query. If not specified, all HITs for the Reviewer are considered 
        public var hITTypeId: String? = nil
        /// Pagination Token
        public var nextToken: String? = nil
        ///  Limit the number of results returned. 
        public var maxResults: Int32? = nil

        public init() {}

        public init(status: String? = nil, hITTypeId: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.status = status
            self.hITTypeId = hITTypeId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.hITTypeId = dictionary["HITTypeId"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct SendTestEventNotificationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The notification specification to test. This value is identical to the value you would provide to the UpdateNotificationSettings operation when you establish the notification specification for a HIT type. 
        public var notification: NotificationSpecification = NotificationSpecification()
        ///  The event to simulate to test the notification specification. This event is included in the test message even if the notification specification does not include the event type. The notification specification does not filter out the test event. 
        public var testEventType: String = ""

        public init() {}

        public init(notification: NotificationSpecification, testEventType: String) {
            self.notification = notification
            self.testEventType = testEventType
        }

        public init(dictionary: [String: Any]) throws {
            guard let notification = dictionary["Notification"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Notification") }
            self.notification = try MturkRequester.NotificationSpecification(dictionary: notification)
            guard let testEventType = dictionary["TestEventType"] as? String else { throw InitializableError.missingRequiredParam("TestEventType") }
            self.testEventType = testEventType
        }
    }

    public struct ApproveAssignmentRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  A message for the Worker, which the Worker can see in the Status section of the web site. 
        public var requesterFeedback: String? = nil
        ///  The ID of the assignment. The assignment must correspond to a HIT created by the Requester. 
        public var assignmentId: String = ""
        ///  A flag indicating that an assignment should be approved even if it was previously rejected. Defaults to False. 
        public var overrideRejection: Bool? = nil

        public init() {}

        public init(requesterFeedback: String? = nil, assignmentId: String, overrideRejection: Bool? = nil) {
            self.requesterFeedback = requesterFeedback
            self.assignmentId = assignmentId
            self.overrideRejection = overrideRejection
        }

        public init(dictionary: [String: Any]) throws {
            self.requesterFeedback = dictionary["RequesterFeedback"] as? String
            guard let assignmentId = dictionary["AssignmentId"] as? String else { throw InitializableError.missingRequiredParam("AssignmentId") }
            self.assignmentId = assignmentId
            self.overrideRejection = dictionary["OverrideRejection"] as? Bool
        }
    }

    public struct GetAccountBalanceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var onHoldBalance: String? = nil
        public var availableBalance: String? = nil

        public init() {}

        public init(onHoldBalance: String? = nil, availableBalance: String? = nil) {
            self.onHoldBalance = onHoldBalance
            self.availableBalance = availableBalance
        }

        public init(dictionary: [String: Any]) throws {
            self.onHoldBalance = dictionary["OnHoldBalance"] as? String
            self.availableBalance = dictionary["AvailableBalance"] as? String
        }
    }

    public struct GetQualificationScoreRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the QualificationType.
        public var qualificationTypeId: String = ""
        /// The ID of the Worker whose Qualification is being updated.
        public var workerId: String = ""

        public init() {}

        public init(qualificationTypeId: String, workerId: String) {
            self.qualificationTypeId = qualificationTypeId
            self.workerId = workerId
        }

        public init(dictionary: [String: Any]) throws {
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
            guard let workerId = dictionary["WorkerId"] as? String else { throw InitializableError.missingRequiredParam("WorkerId") }
            self.workerId = workerId
        }
    }

    public struct ListWorkerBlocksResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var nextToken: String? = nil
        ///  The number of assignments on the page in the filtered results list, equivalent to the number of assignments returned by this call.
        public var numResults: Int32? = nil
        ///  The list of WorkerBlocks, containing the collection of Worker IDs and reasons for blocking.
        public var workerBlocks: [WorkerBlock]? = nil

        public init() {}

        public init(nextToken: String? = nil, numResults: Int32? = nil, workerBlocks: [WorkerBlock]? = nil) {
            self.nextToken = nextToken
            self.numResults = numResults
            self.workerBlocks = workerBlocks
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.numResults = dictionary["NumResults"] as? Int32
            if let workerBlocks = dictionary["WorkerBlocks"] as? [[String: Any]] {
                self.workerBlocks = try workerBlocks.map({ try WorkerBlock(dictionary: $0) })
            }
        }
    }

    public struct UpdateNotificationSettingsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The notification specification for the HIT type. 
        public var notification: NotificationSpecification? = nil
        ///  The ID of the HIT type whose notification specification is being updated. 
        public var hITTypeId: String = ""
        ///  Specifies whether notifications are sent for HITs of this HIT type, according to the notification specification. You must specify either the Notification parameter or the Active parameter for the call to UpdateNotificationSettings to succeed. 
        public var active: Bool? = nil

        public init() {}

        public init(notification: NotificationSpecification? = nil, hITTypeId: String, active: Bool? = nil) {
            self.notification = notification
            self.hITTypeId = hITTypeId
            self.active = active
        }

        public init(dictionary: [String: Any]) throws {
            if let notification = dictionary["Notification"] as? [String: Any] { self.notification = try MturkRequester.NotificationSpecification(dictionary: notification) }
            guard let hITTypeId = dictionary["HITTypeId"] as? String else { throw InitializableError.missingRequiredParam("HITTypeId") }
            self.hITTypeId = hITTypeId
            self.active = dictionary["Active"] as? Bool
        }
    }

    public struct GetQualificationTypeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the QualificationType.
        public var qualificationTypeId: String = ""

        public init() {}

        public init(qualificationTypeId: String) {
            self.qualificationTypeId = qualificationTypeId
        }

        public init(dictionary: [String: Any]) throws {
            guard let qualificationTypeId = dictionary["QualificationTypeId"] as? String else { throw InitializableError.missingRequiredParam("QualificationTypeId") }
            self.qualificationTypeId = qualificationTypeId
        }
    }

    public struct NotificationSpecification: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The list of events that should cause notifications to be sent. Valid Values: AssignmentAccepted | AssignmentAbandoned | AssignmentReturned | AssignmentSubmitted | AssignmentRejected | AssignmentApproved | HITCreated | HITExtended | HITDisposed | HITReviewable | HITExpired | Ping. The Ping event is only valid for the SendTestEventNotification operation. 
        public var eventTypes: [String]? = nil
        ///  The destination for notification messages. or email notifications (if Transport is Email), this is an email address. For Amazon Simple Queue Service (Amazon SQS) notifications (if Transport is SQS), this is the URL for your Amazon SQS queue. 
        public var destination: String = ""
        ///  The method Amazon Mechanical Turk uses to send the notification. Valid Values: Email | SQS. 
        public var transport: String = ""
        /// The version of the Notification API to use. Valid value is 2006-05-05.
        public var version: String? = nil

        public init() {}

        public init(eventTypes: [String]? = nil, destination: String, transport: String, version: String? = nil) {
            self.eventTypes = eventTypes
            self.destination = destination
            self.transport = transport
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            if let eventTypes = dictionary["EventTypes"] as? [String] {
                self.eventTypes = eventTypes
            }
            guard let destination = dictionary["Destination"] as? String else { throw InitializableError.missingRequiredParam("Destination") }
            self.destination = destination
            guard let transport = dictionary["Transport"] as? String else { throw InitializableError.missingRequiredParam("Transport") }
            self.transport = transport
            self.version = dictionary["Version"] as? String
        }
    }

    public struct ListReviewPolicyResultsForHITRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Pagination token
        public var nextToken: String? = nil
        ///  The Policy Level(s) to retrieve review results for - HIT or Assignment. If omitted, the default behavior is to retrieve all data for both policy levels. For a list of all the described policies, see Review Policies. 
        public var policyLevels: [String]? = nil
        /// The unique identifier of the HIT to retrieve review results for.
        public var hITId: String = ""
        ///  Specify if the operation should retrieve a list of the results computed by the Review Policies. 
        public var retrieveResults: Bool? = nil
        ///  Specify if the operation should retrieve a list of the actions taken executing the Review Policies and their outcomes. 
        public var retrieveActions: Bool? = nil
        /// Limit the number of results returned.
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, policyLevels: [String]? = nil, hITId: String, retrieveResults: Bool? = nil, retrieveActions: Bool? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.policyLevels = policyLevels
            self.hITId = hITId
            self.retrieveResults = retrieveResults
            self.retrieveActions = retrieveActions
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let policyLevels = dictionary["PolicyLevels"] as? [String] {
                self.policyLevels = policyLevels
            }
            guard let hITId = dictionary["HITId"] as? String else { throw InitializableError.missingRequiredParam("HITId") }
            self.hITId = hITId
            self.retrieveResults = dictionary["RetrieveResults"] as? Bool
            self.retrieveActions = dictionary["RetrieveActions"] as? Bool
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

}