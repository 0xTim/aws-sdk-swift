// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Workspaces {

    public struct CreateTagsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The resource ID of the request.
        public var resourceId: String = ""
        /// The tags of the request.
        public var tags: [Tag] = []

        public init() {}

        public init(resourceId: String, tags: [Tag]) {
            self.resourceId = resourceId
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct TerminateWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures that specify the WorkSpaces to terminate.
        public var terminateWorkspaceRequests: [TerminateRequest] = []

        public init() {}

        public init(terminateWorkspaceRequests: [TerminateRequest]) {
            self.terminateWorkspaceRequests = terminateWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let terminateWorkspaceRequests = dictionary["TerminateWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("TerminateWorkspaceRequests") }
            self.terminateWorkspaceRequests = try terminateWorkspaceRequests.map({ try TerminateRequest(dictionary: $0) })
        }
    }

    public struct FailedCreateWorkspaceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The textual error message.
        public var errorMessage: String? = nil
        /// A FailedCreateWorkspaceRequest$WorkspaceRequest object that contains the information about the WorkSpace that could not be created.
        public var workspaceRequest: WorkspaceRequest? = nil
        /// The error code.
        public var errorCode: String? = nil

        public init() {}

        public init(errorMessage: String? = nil, workspaceRequest: WorkspaceRequest? = nil, errorCode: String? = nil) {
            self.errorMessage = errorMessage
            self.workspaceRequest = workspaceRequest
            self.errorCode = errorCode
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            if let workspaceRequest = dictionary["WorkspaceRequest"] as? [String: Any] { self.workspaceRequest = try Workspaces.WorkspaceRequest(dictionary: workspaceRequest) }
            self.errorCode = dictionary["ErrorCode"] as? String
        }
    }

    public struct DescribeWorkspaceBundlesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The owner of the bundles to retrieve. This parameter cannot be combined with any other filter parameter. This contains one of the following values:   null- Retrieves the bundles that belong to the account making the call.    AMAZON- Retrieves the bundles that are provided by AWS.  
        public var owner: String? = nil
        /// The NextToken value from a previous call to this operation. Pass null if this is the first call.
        public var nextToken: String? = nil
        /// An array of strings that contains the identifiers of the bundles to retrieve. This parameter cannot be combined with any other filter parameter.
        public var bundleIds: [String]? = nil

        public init() {}

        public init(owner: String? = nil, nextToken: String? = nil, bundleIds: [String]? = nil) {
            self.owner = owner
            self.nextToken = nextToken
            self.bundleIds = bundleIds
        }

        public init(dictionary: [String: Any]) throws {
            self.owner = dictionary["Owner"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            if let bundleIds = dictionary["BundleIds"] as? [String] {
                self.bundleIds = bundleIds
            }
        }
    }

    public struct UserStorage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The amount of user storage for the bundle.
        public var capacity: String? = nil

        public init() {}

        public init(capacity: String? = nil) {
            self.capacity = capacity
        }

        public init(dictionary: [String: Any]) throws {
            self.capacity = dictionary["Capacity"] as? String
        }
    }

    public struct WorkspaceBundle: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The bundle description.
        public var description: String? = nil
        /// A ComputeType object that specifies the compute type for the bundle.
        public var computeType: ComputeType? = nil
        /// A UserStorage object that specifies the amount of user storage that the bundle contains.
        public var userStorage: UserStorage? = nil
        /// The owner of the bundle. This contains the owner's account identifier, or AMAZON if the bundle is provided by AWS.
        public var owner: String? = nil
        /// The name of the bundle.
        public var name: String? = nil
        /// The bundle identifier.
        public var bundleId: String? = nil

        public init() {}

        public init(description: String? = nil, computeType: ComputeType? = nil, userStorage: UserStorage? = nil, owner: String? = nil, name: String? = nil, bundleId: String? = nil) {
            self.description = description
            self.computeType = computeType
            self.userStorage = userStorage
            self.owner = owner
            self.name = name
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            if let computeType = dictionary["ComputeType"] as? [String: Any] { self.computeType = try Workspaces.ComputeType(dictionary: computeType) }
            if let userStorage = dictionary["UserStorage"] as? [String: Any] { self.userStorage = try Workspaces.UserStorage(dictionary: userStorage) }
            self.owner = dictionary["Owner"] as? String
            self.name = dictionary["Name"] as? String
            self.bundleId = dictionary["BundleId"] as? String
        }
    }

    public struct RebootWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures representing any WorkSpaces that could not be rebooted.
        public var failedRequests: [FailedWorkspaceChangeRequest]? = nil

        public init() {}

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            }
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The resource ID of the request.
        public var resourceId: String = ""

        public init() {}

        public init(resourceId: String) {
            self.resourceId = resourceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
        }
    }

    public struct CreateWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures that represent the WorkSpaces that could not be created.
        public var failedRequests: [FailedCreateWorkspaceRequest]? = nil
        /// An array of structures that represent the WorkSpaces that were created. Because this operation is asynchronous, the identifier in WorkspaceId is not immediately available. If you immediately call DescribeWorkspaces with this identifier, no information will be returned.
        public var pendingRequests: [Workspace]? = nil

        public init() {}

        public init(failedRequests: [FailedCreateWorkspaceRequest]? = nil, pendingRequests: [Workspace]? = nil) {
            self.failedRequests = failedRequests
            self.pendingRequests = pendingRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedCreateWorkspaceRequest(dictionary: $0) })
            }
            if let pendingRequests = dictionary["PendingRequests"] as? [[String: Any]] {
                self.pendingRequests = try pendingRequests.map({ try Workspace(dictionary: $0) })
            }
        }
    }

    public struct CreateTagsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct RebootWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures that specify the WorkSpaces to reboot.
        public var rebootWorkspaceRequests: [RebootRequest] = []

        public init() {}

        public init(rebootWorkspaceRequests: [RebootRequest]) {
            self.rebootWorkspaceRequests = rebootWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let rebootWorkspaceRequests = dictionary["RebootWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("RebootWorkspaceRequests") }
            self.rebootWorkspaceRequests = try rebootWorkspaceRequests.map({ try RebootRequest(dictionary: $0) })
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The value of the tag.
        public var value: String? = nil
        /// The key of the tag.
        public var key: String = ""

        public init() {}

        public init(value: String? = nil, key: String) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            guard let key = dictionary["Key"] as? String else { throw InitializableError.missingRequiredParam("Key") }
            self.key = key
        }
    }

    public struct ModifyWorkspacePropertiesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeWorkspacesConnectionStatusResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The connection status of the WorkSpace.
        public var workspacesConnectionStatus: [WorkspaceConnectionStatus]? = nil
        /// The next token of the result.
        public var nextToken: String? = nil

        public init() {}

        public init(workspacesConnectionStatus: [WorkspaceConnectionStatus]? = nil, nextToken: String? = nil) {
            self.workspacesConnectionStatus = workspacesConnectionStatus
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let workspacesConnectionStatus = dictionary["WorkspacesConnectionStatus"] as? [[String: Any]] {
                self.workspacesConnectionStatus = try workspacesConnectionStatus.map({ try WorkspaceConnectionStatus(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct StartWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The requests.
        public var startWorkspaceRequests: [StartRequest] = []

        public init() {}

        public init(startWorkspaceRequests: [StartRequest]) {
            self.startWorkspaceRequests = startWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let startWorkspaceRequests = dictionary["StartWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("StartWorkspaceRequests") }
            self.startWorkspaceRequests = try startWorkspaceRequests.map({ try StartRequest(dictionary: $0) })
        }
    }

    public struct ComputeType: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the compute type for the bundle.
        public var name: String? = nil

        public init() {}

        public init(name: String? = nil) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
        }
    }

    public struct FailedWorkspaceChangeRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The textual error message.
        public var errorMessage: String? = nil
        /// The error code.
        public var errorCode: String? = nil
        /// The identifier of the WorkSpace.
        public var workspaceId: String? = nil

        public init() {}

        public init(errorMessage: String? = nil, errorCode: String? = nil, workspaceId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.workspaceId = dictionary["WorkspaceId"] as? String
        }
    }

    public struct StopRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the WorkSpace.
        public var workspaceId: String? = nil

        public init() {}

        public init(workspaceId: String? = nil) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceId = dictionary["WorkspaceId"] as? String
        }
    }

    public struct StartRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the WorkSpace.
        public var workspaceId: String? = nil

        public init() {}

        public init(workspaceId: String? = nil) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceId = dictionary["WorkspaceId"] as? String
        }
    }

    public struct DefaultWorkspaceCreationProperties: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The organizational unit (OU) in the directory that the WorkSpace machine accounts are placed in.
        public var defaultOu: String? = nil
        /// The identifier of any custom security groups that are applied to the WorkSpaces when they are created.
        public var customSecurityGroupId: String? = nil
        /// A public IP address will be attached to all WorkSpaces that are created or rebuilt.
        public var enableInternetAccess: Bool? = nil
        /// The WorkSpace user is an administrator on the WorkSpace.
        public var userEnabledAsLocalAdministrator: Bool? = nil
        /// Specifies if the directory is enabled for Amazon WorkDocs.
        public var enableWorkDocs: Bool? = nil

        public init() {}

        public init(defaultOu: String? = nil, customSecurityGroupId: String? = nil, enableInternetAccess: Bool? = nil, userEnabledAsLocalAdministrator: Bool? = nil, enableWorkDocs: Bool? = nil) {
            self.defaultOu = defaultOu
            self.customSecurityGroupId = customSecurityGroupId
            self.enableInternetAccess = enableInternetAccess
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
            self.enableWorkDocs = enableWorkDocs
        }

        public init(dictionary: [String: Any]) throws {
            self.defaultOu = dictionary["DefaultOu"] as? String
            self.customSecurityGroupId = dictionary["CustomSecurityGroupId"] as? String
            self.enableInternetAccess = dictionary["EnableInternetAccess"] as? Bool
            self.userEnabledAsLocalAdministrator = dictionary["UserEnabledAsLocalAdministrator"] as? Bool
            self.enableWorkDocs = dictionary["EnableWorkDocs"] as? Bool
        }
    }

    public struct StopWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The requests.
        public var stopWorkspaceRequests: [StopRequest] = []

        public init() {}

        public init(stopWorkspaceRequests: [StopRequest]) {
            self.stopWorkspaceRequests = stopWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let stopWorkspaceRequests = dictionary["StopWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("StopWorkspaceRequests") }
            self.stopWorkspaceRequests = try stopWorkspaceRequests.map({ try StopRequest(dictionary: $0) })
        }
    }

    public struct DescribeWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Specifies the directory identifier to which to limit the WorkSpaces. Optionally, you can specify a specific directory user with the UserName parameter. This parameter cannot be combined with any other filter parameter.
        public var directoryId: String? = nil
        /// Used with the DirectoryId parameter to specify the directory user for whom to obtain the WorkSpace.
        public var userName: String? = nil
        /// The maximum number of items to return.
        public var limit: Int32? = nil
        /// The NextToken value from a previous call to this operation. Pass null if this is the first call.
        public var nextToken: String? = nil
        /// An array of strings that contain the identifiers of the WorkSpaces for which to retrieve information. This parameter cannot be combined with any other filter parameter. Because the CreateWorkspaces operation is asynchronous, the identifier it returns is not immediately available. If you immediately call DescribeWorkspaces with this identifier, no information is returned.
        public var workspaceIds: [String]? = nil
        /// The identifier of a bundle to obtain the WorkSpaces for. All WorkSpaces that are created from this bundle will be retrieved. This parameter cannot be combined with any other filter parameter.
        public var bundleId: String? = nil

        public init() {}

        public init(directoryId: String? = nil, userName: String? = nil, limit: Int32? = nil, nextToken: String? = nil, workspaceIds: [String]? = nil, bundleId: String? = nil) {
            self.directoryId = directoryId
            self.userName = userName
            self.limit = limit
            self.nextToken = nextToken
            self.workspaceIds = workspaceIds
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            self.directoryId = dictionary["DirectoryId"] as? String
            self.userName = dictionary["UserName"] as? String
            self.limit = dictionary["Limit"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
            if let workspaceIds = dictionary["WorkspaceIds"] as? [String] {
                self.workspaceIds = workspaceIds
            }
            self.bundleId = dictionary["BundleId"] as? String
        }
    }

    public struct RebuildWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures representing any WorkSpaces that could not be rebuilt.
        public var failedRequests: [FailedWorkspaceChangeRequest]? = nil

        public init() {}

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            }
        }
    }

    public struct RebootRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The identifier of the WorkSpace to reboot.
        public var workspaceId: String = ""

        public init() {}

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
        }
    }

    public struct DescribeWorkspacesConnectionStatusRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of strings that contain the identifiers of the WorkSpaces.
        public var workspaceIds: [String]? = nil
        /// The next token of the request.
        public var nextToken: String? = nil

        public init() {}

        public init(workspaceIds: [String]? = nil, nextToken: String? = nil) {
            self.workspaceIds = workspaceIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let workspaceIds = dictionary["WorkspaceIds"] as? [String] {
                self.workspaceIds = workspaceIds
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct WorkspaceConnectionStatus: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the WorkSpace.
        public var workspaceId: String? = nil
        /// The connection state of the WorkSpace. Returns UNKOWN if the WorkSpace is in a Stopped state.
        public var connectionState: String? = nil
        /// The timestamp of the last known user connection.
        public var lastKnownUserConnectionTimestamp: Date? = nil
        /// The timestamp of the connection state check.
        public var connectionStateCheckTimestamp: Date? = nil

        public init() {}

        public init(workspaceId: String? = nil, connectionState: String? = nil, lastKnownUserConnectionTimestamp: Date? = nil, connectionStateCheckTimestamp: Date? = nil) {
            self.workspaceId = workspaceId
            self.connectionState = connectionState
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
        }

        public init(dictionary: [String: Any]) throws {
            self.workspaceId = dictionary["WorkspaceId"] as? String
            self.connectionState = dictionary["ConnectionState"] as? String
            self.lastKnownUserConnectionTimestamp = dictionary["LastKnownUserConnectionTimestamp"] as? Date
            self.connectionStateCheckTimestamp = dictionary["ConnectionStateCheckTimestamp"] as? Date
        }
    }

    public struct DescribeTagsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The list of tags.
        public var tagList: [Tag]? = nil

        public init() {}

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        public init(dictionary: [String: Any]) throws {
            if let tagList = dictionary["TagList"] as? [[String: Any]] {
                self.tagList = try tagList.map({ try Tag(dictionary: $0) })
            }
        }
    }

    public struct DescribeWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that time frame.
        public var nextToken: String? = nil
        /// An array of structures that contain the information about the WorkSpaces. Because the CreateWorkspaces operation is asynchronous, some of this information may be incomplete for a newly-created WorkSpace.
        public var workspaces: [Workspace]? = nil

        public init() {}

        public init(nextToken: String? = nil, workspaces: [Workspace]? = nil) {
            self.nextToken = nextToken
            self.workspaces = workspaces
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let workspaces = dictionary["Workspaces"] as? [[String: Any]] {
                self.workspaces = try workspaces.map({ try Workspace(dictionary: $0) })
            }
        }
    }

    public struct WorkspaceProperties: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The running mode of the WorkSpace. AlwaysOn WorkSpaces are billed monthly. AutoStop WorkSpaces are billed by the hour and stopped when no longer being used in order to save on costs.
        public var runningMode: String? = nil
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60 minute intervals.
        public var runningModeAutoStopTimeoutInMinutes: Int32? = nil

        public init() {}

        public init(runningMode: String? = nil, runningModeAutoStopTimeoutInMinutes: Int32? = nil) {
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
        }

        public init(dictionary: [String: Any]) throws {
            self.runningMode = dictionary["RunningMode"] as? String
            self.runningModeAutoStopTimeoutInMinutes = dictionary["RunningModeAutoStopTimeoutInMinutes"] as? Int32
        }
    }

    public struct ModifyWorkspacePropertiesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ID of the WorkSpace.
        public var workspaceId: String = ""
        /// The WorkSpace properties of the request.
        public var workspaceProperties: WorkspaceProperties = WorkspaceProperties()

        public init() {}

        public init(workspaceId: String, workspaceProperties: WorkspaceProperties) {
            self.workspaceId = workspaceId
            self.workspaceProperties = workspaceProperties
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
            guard let workspaceProperties = dictionary["WorkspaceProperties"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WorkspaceProperties") }
            self.workspaceProperties = try Workspaces.WorkspaceProperties(dictionary: workspaceProperties)
        }
    }

    public struct DescribeWorkspaceBundlesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that time frame.
        public var nextToken: String? = nil
        /// An array of structures that contain information about the bundles.
        public var bundles: [WorkspaceBundle]? = nil

        public init() {}

        public init(nextToken: String? = nil, bundles: [WorkspaceBundle]? = nil) {
            self.nextToken = nextToken
            self.bundles = bundles
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let bundles = dictionary["Bundles"] as? [[String: Any]] {
                self.bundles = try bundles.map({ try WorkspaceBundle(dictionary: $0) })
            }
        }
    }

    public struct DeleteTagsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The resource ID of the request.
        public var resourceId: String = ""
        /// The tag keys of the request.
        public var tagKeys: [String] = []

        public init() {}

        public init(resourceId: String, tagKeys: [String]) {
            self.resourceId = resourceId
            self.tagKeys = tagKeys
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceId = dictionary["ResourceId"] as? String else { throw InitializableError.missingRequiredParam("ResourceId") }
            self.resourceId = resourceId
            guard let tagKeys = dictionary["TagKeys"] as? [String] else { throw InitializableError.missingRequiredParam("TagKeys") }
            self.tagKeys = tagKeys
        }
    }

    public struct Workspace: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The identifier of the subnet that the WorkSpace is in.
        public var subnetId: String? = nil
        /// The user that the WorkSpace is assigned to.
        public var userName: String? = nil
        /// The operational state of the WorkSpace.
        public var state: String? = nil
        /// Specifies whether the data stored on the root volume, or C: drive, is encrypted.
        public var rootVolumeEncryptionEnabled: Bool? = nil
        /// The identifier of the AWS Directory Service directory that the WorkSpace belongs to.
        public var directoryId: String? = nil
        public var workspaceProperties: WorkspaceProperties? = nil
        /// The name of the WorkSpace as seen by the operating system.
        public var computerName: String? = nil
        /// If the WorkSpace could not be created, this contains a textual error message that describes the failure.
        public var errorMessage: String? = nil
        /// If the WorkSpace could not be created, this contains the error code.
        public var errorCode: String? = nil
        /// The identifier of the bundle that the WorkSpace was created from.
        public var bundleId: String? = nil
        /// Specifies whether the data stored on the user volume, or D: drive, is encrypted.
        public var userVolumeEncryptionEnabled: Bool? = nil
        /// The identifier of the WorkSpace.
        public var workspaceId: String? = nil
        /// The KMS key used to encrypt data stored on your WorkSpace.
        public var volumeEncryptionKey: String? = nil
        /// The IP address of the WorkSpace.
        public var ipAddress: String? = nil

        public init() {}

        public init(subnetId: String? = nil, userName: String? = nil, state: String? = nil, rootVolumeEncryptionEnabled: Bool? = nil, directoryId: String? = nil, workspaceProperties: WorkspaceProperties? = nil, computerName: String? = nil, errorMessage: String? = nil, errorCode: String? = nil, bundleId: String? = nil, userVolumeEncryptionEnabled: Bool? = nil, workspaceId: String? = nil, volumeEncryptionKey: String? = nil, ipAddress: String? = nil) {
            self.subnetId = subnetId
            self.userName = userName
            self.state = state
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.directoryId = directoryId
            self.workspaceProperties = workspaceProperties
            self.computerName = computerName
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.bundleId = bundleId
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.workspaceId = workspaceId
            self.volumeEncryptionKey = volumeEncryptionKey
            self.ipAddress = ipAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetId = dictionary["SubnetId"] as? String
            self.userName = dictionary["UserName"] as? String
            self.state = dictionary["State"] as? String
            self.rootVolumeEncryptionEnabled = dictionary["RootVolumeEncryptionEnabled"] as? Bool
            self.directoryId = dictionary["DirectoryId"] as? String
            if let workspaceProperties = dictionary["WorkspaceProperties"] as? [String: Any] { self.workspaceProperties = try Workspaces.WorkspaceProperties(dictionary: workspaceProperties) }
            self.computerName = dictionary["ComputerName"] as? String
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.bundleId = dictionary["BundleId"] as? String
            self.userVolumeEncryptionEnabled = dictionary["UserVolumeEncryptionEnabled"] as? Bool
            self.workspaceId = dictionary["WorkspaceId"] as? String
            self.volumeEncryptionKey = dictionary["VolumeEncryptionKey"] as? String
            self.ipAddress = dictionary["IpAddress"] as? String
        }
    }

    public struct RebuildWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures that specify the WorkSpaces to rebuild.
        public var rebuildWorkspaceRequests: [RebuildRequest] = []

        public init() {}

        public init(rebuildWorkspaceRequests: [RebuildRequest]) {
            self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
        }

        public init(dictionary: [String: Any]) throws {
            guard let rebuildWorkspaceRequests = dictionary["RebuildWorkspaceRequests"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("RebuildWorkspaceRequests") }
            self.rebuildWorkspaceRequests = try rebuildWorkspaceRequests.map({ try RebuildRequest(dictionary: $0) })
        }
    }

    public struct DescribeWorkspaceDirectoriesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures that contain information about the directories.
        public var directories: [WorkspaceDirectory]? = nil
        /// If not null, more results are available. Pass this value for the NextToken parameter in a subsequent call to this operation to retrieve the next set of items. This token is valid for one day and must be used within that time frame.
        public var nextToken: String? = nil

        public init() {}

        public init(directories: [WorkspaceDirectory]? = nil, nextToken: String? = nil) {
            self.directories = directories
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let directories = dictionary["Directories"] as? [[String: Any]] {
                self.directories = try directories.map({ try WorkspaceDirectory(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct TerminateWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures representing any WorkSpaces that could not be terminated.
        public var failedRequests: [FailedWorkspaceChangeRequest]? = nil

        public init() {}

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            }
        }
    }

    public struct StopWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The failed requests.
        public var failedRequests: [FailedWorkspaceChangeRequest]? = nil

        public init() {}

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            }
        }
    }

    public struct RebuildRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The identifier of the WorkSpace to rebuild.
        public var workspaceId: String = ""

        public init() {}

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
        }
    }

    public struct CreateWorkspacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of structures that specify the WorkSpaces to create.
        public var workspaces: [WorkspaceRequest] = []

        public init() {}

        public init(workspaces: [WorkspaceRequest]) {
            self.workspaces = workspaces
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaces = dictionary["Workspaces"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Workspaces") }
            self.workspaces = try workspaces.map({ try WorkspaceRequest(dictionary: $0) })
        }
    }

    public struct WorkspaceDirectory: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of strings that contains the identifiers of the subnets used with the directory.
        public var subnetIds: [String]? = nil
        /// A structure that specifies the default creation properties for all WorkSpaces in the directory.
        public var workspaceCreationProperties: DefaultWorkspaceCreationProperties? = nil
        /// An array of strings that contains the IP addresses of the DNS servers for the directory.
        public var dnsIpAddresses: [String]? = nil
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public var registrationCode: String? = nil
        /// The state of the directory's registration with Amazon WorkSpaces
        public var state: String? = nil
        /// The user name for the service account.
        public var customerUserName: String? = nil
        /// The directory alias.
        public var alias: String? = nil
        /// The directory identifier.
        public var directoryId: String? = nil
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public var workspaceSecurityGroupId: String? = nil
        /// The directory type.
        public var directoryType: String? = nil
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public var iamRoleId: String? = nil
        /// The name of the directory.
        public var directoryName: String? = nil

        public init() {}

        public init(subnetIds: [String]? = nil, workspaceCreationProperties: DefaultWorkspaceCreationProperties? = nil, dnsIpAddresses: [String]? = nil, registrationCode: String? = nil, state: String? = nil, customerUserName: String? = nil, alias: String? = nil, directoryId: String? = nil, workspaceSecurityGroupId: String? = nil, directoryType: String? = nil, iamRoleId: String? = nil, directoryName: String? = nil) {
            self.subnetIds = subnetIds
            self.workspaceCreationProperties = workspaceCreationProperties
            self.dnsIpAddresses = dnsIpAddresses
            self.registrationCode = registrationCode
            self.state = state
            self.customerUserName = customerUserName
            self.alias = alias
            self.directoryId = directoryId
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
            self.directoryType = directoryType
            self.iamRoleId = iamRoleId
            self.directoryName = directoryName
        }

        public init(dictionary: [String: Any]) throws {
            if let subnetIds = dictionary["SubnetIds"] as? [String] {
                self.subnetIds = subnetIds
            }
            if let workspaceCreationProperties = dictionary["WorkspaceCreationProperties"] as? [String: Any] { self.workspaceCreationProperties = try Workspaces.DefaultWorkspaceCreationProperties(dictionary: workspaceCreationProperties) }
            if let dnsIpAddresses = dictionary["DnsIpAddresses"] as? [String] {
                self.dnsIpAddresses = dnsIpAddresses
            }
            self.registrationCode = dictionary["RegistrationCode"] as? String
            self.state = dictionary["State"] as? String
            self.customerUserName = dictionary["CustomerUserName"] as? String
            self.alias = dictionary["Alias"] as? String
            self.directoryId = dictionary["DirectoryId"] as? String
            self.workspaceSecurityGroupId = dictionary["WorkspaceSecurityGroupId"] as? String
            self.directoryType = dictionary["DirectoryType"] as? String
            self.iamRoleId = dictionary["IamRoleId"] as? String
            self.directoryName = dictionary["DirectoryName"] as? String
        }
    }

    public struct WorkspaceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The username that the WorkSpace is assigned to. This username must exist in the AWS Directory Service directory specified by the DirectoryId member.
        public var userName: String = ""
        /// The KMS key used to encrypt data stored on your WorkSpace.
        public var volumeEncryptionKey: String? = nil
        /// The tags of the WorkSpace request.
        public var tags: [Tag]? = nil
        public var workspaceProperties: WorkspaceProperties? = nil
        /// The identifier of the AWS Directory Service directory to create the WorkSpace in. You can use the DescribeWorkspaceDirectories operation to obtain a list of the directories that are available.
        public var directoryId: String = ""
        /// Specifies whether the data stored on the root volume, or C: drive, is encrypted.
        public var rootVolumeEncryptionEnabled: Bool? = nil
        /// Specifies whether the data stored on the user volume, or D: drive, is encrypted.
        public var userVolumeEncryptionEnabled: Bool? = nil
        /// The identifier of the bundle to create the WorkSpace from. You can use the DescribeWorkspaceBundles operation to obtain a list of the bundles that are available.
        public var bundleId: String = ""

        public init() {}

        public init(userName: String, volumeEncryptionKey: String? = nil, tags: [Tag]? = nil, workspaceProperties: WorkspaceProperties? = nil, directoryId: String, rootVolumeEncryptionEnabled: Bool? = nil, userVolumeEncryptionEnabled: Bool? = nil, bundleId: String) {
            self.userName = userName
            self.volumeEncryptionKey = volumeEncryptionKey
            self.tags = tags
            self.workspaceProperties = workspaceProperties
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.bundleId = bundleId
        }

        public init(dictionary: [String: Any]) throws {
            guard let userName = dictionary["UserName"] as? String else { throw InitializableError.missingRequiredParam("UserName") }
            self.userName = userName
            self.volumeEncryptionKey = dictionary["VolumeEncryptionKey"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            if let workspaceProperties = dictionary["WorkspaceProperties"] as? [String: Any] { self.workspaceProperties = try Workspaces.WorkspaceProperties(dictionary: workspaceProperties) }
            guard let directoryId = dictionary["DirectoryId"] as? String else { throw InitializableError.missingRequiredParam("DirectoryId") }
            self.directoryId = directoryId
            self.rootVolumeEncryptionEnabled = dictionary["RootVolumeEncryptionEnabled"] as? Bool
            self.userVolumeEncryptionEnabled = dictionary["UserVolumeEncryptionEnabled"] as? Bool
            guard let bundleId = dictionary["BundleId"] as? String else { throw InitializableError.missingRequiredParam("BundleId") }
            self.bundleId = bundleId
        }
    }

    public struct StartWorkspacesResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The failed requests.
        public var failedRequests: [FailedWorkspaceChangeRequest]? = nil

        public init() {}

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        public init(dictionary: [String: Any]) throws {
            if let failedRequests = dictionary["FailedRequests"] as? [[String: Any]] {
                self.failedRequests = try failedRequests.map({ try FailedWorkspaceChangeRequest(dictionary: $0) })
            }
        }
    }

    public struct DeleteTagsResult: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeWorkspaceDirectoriesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The NextToken value from a previous call to this operation. Pass null if this is the first call.
        public var nextToken: String? = nil
        /// An array of strings that contains the directory identifiers to retrieve information for. If this member is null, all directories are retrieved.
        public var directoryIds: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, directoryIds: [String]? = nil) {
            self.nextToken = nextToken
            self.directoryIds = directoryIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let directoryIds = dictionary["DirectoryIds"] as? [String] {
                self.directoryIds = directoryIds
            }
        }
    }

    public struct TerminateRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The identifier of the WorkSpace to terminate.
        public var workspaceId: String = ""

        public init() {}

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public init(dictionary: [String: Any]) throws {
            guard let workspaceId = dictionary["WorkspaceId"] as? String else { throw InitializableError.missingRequiredParam("WorkspaceId") }
            self.workspaceId = workspaceId
        }
    }

}