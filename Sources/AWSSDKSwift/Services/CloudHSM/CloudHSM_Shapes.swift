// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension CloudHSM {

    public struct CreateHsmRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SshKey", location: .body(locationName: "SshKey"), required: true, type: .string), 
            AWSShapeMember(label: "SyslogIp", location: .body(locationName: "SyslogIp"), required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionType", location: .body(locationName: "SubscriptionType"), required: true, type: .enum), 
            AWSShapeMember(label: "EniIp", location: .body(locationName: "EniIp"), required: false, type: .string), 
            AWSShapeMember(label: "ClientToken", location: .body(locationName: "ClientToken"), required: false, type: .string), 
            AWSShapeMember(label: "IamRoleArn", location: .body(locationName: "IamRoleArn"), required: true, type: .string), 
            AWSShapeMember(label: "SubnetId", location: .body(locationName: "SubnetId"), required: true, type: .string), 
            AWSShapeMember(label: "ExternalId", location: .body(locationName: "ExternalId"), required: false, type: .string)
        ]
        /// The SSH public key to install on the HSM.
        public let sshKey: String
        /// The IP address for the syslog monitoring server. The AWS CloudHSM service only supports one syslog monitoring server.
        public let syslogIp: String?
        public let subscriptionType: SubscriptionType
        /// The IP address to assign to the HSM's ENI. If an IP address is not specified, an IP address will be randomly chosen from the CIDR range of the subnet.
        public let eniIp: String?
        /// A user-defined token to ensure idempotence. Subsequent calls to this operation with the same token will be ignored.
        public let clientToken: String?
        /// The ARN of an IAM role to enable the AWS CloudHSM service to allocate an ENI on your behalf.
        public let iamRoleArn: String
        /// The identifier of the subnet in your VPC in which to place the HSM.
        public let subnetId: String
        /// The external ID from IamRoleArn, if present.
        public let externalId: String?

        public init(sshKey: String, syslogIp: String? = nil, subscriptionType: SubscriptionType, eniIp: String? = nil, clientToken: String? = nil, iamRoleArn: String, subnetId: String, externalId: String? = nil) {
            self.sshKey = sshKey
            self.syslogIp = syslogIp
            self.subscriptionType = subscriptionType
            self.eniIp = eniIp
            self.clientToken = clientToken
            self.iamRoleArn = iamRoleArn
            self.subnetId = subnetId
            self.externalId = externalId
        }

        private enum CodingKeys: String, CodingKey {
            case sshKey = "SshKey"
            case syslogIp = "SyslogIp"
            case subscriptionType = "SubscriptionType"
            case eniIp = "EniIp"
            case clientToken = "ClientToken"
            case iamRoleArn = "IamRoleArn"
            case subnetId = "SubnetId"
            case externalId = "ExternalId"
        }
    }

    public struct DescribeLunaClientRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientArn", required: false, type: .string), 
            AWSShapeMember(label: "CertificateFingerprint", required: false, type: .string)
        ]
        /// The ARN of the client.
        public let clientArn: String?
        /// The certificate fingerprint.
        public let certificateFingerprint: String?

        public init(clientArn: String? = nil, certificateFingerprint: String? = nil) {
            self.clientArn = clientArn
            self.certificateFingerprint = certificateFingerprint
        }

        private enum CodingKeys: String, CodingKey {
            case clientArn = "ClientArn"
            case certificateFingerprint = "CertificateFingerprint"
        }
    }

    public struct ListLunaClientsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ClientList", required: true, type: .list)
        ]
        /// If not null, more results are available. Pass this to ListLunaClients to retrieve the next set of items.
        public let nextToken: String?
        /// The list of clients.
        public let clientList: [String]

        public init(nextToken: String? = nil, clientList: [String]) {
            self.nextToken = nextToken
            self.clientList = clientList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case clientList = "ClientList"
        }
    }

    public struct ListHapgsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "HapgList", required: true, type: .list)
        ]
        /// If not null, more results are available. Pass this value to ListHapgs to retrieve the next set of items.
        public let nextToken: String?
        /// The list of high-availability partition groups.
        public let hapgList: [String]

        public init(nextToken: String? = nil, hapgList: [String]) {
            self.nextToken = nextToken
            self.hapgList = hapgList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case hapgList = "HapgList"
        }
    }

    public struct GetConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HapgList", required: true, type: .list), 
            AWSShapeMember(label: "ClientArn", required: true, type: .string), 
            AWSShapeMember(label: "ClientVersion", required: true, type: .enum)
        ]
        /// A list of ARNs that identify the high-availability partition groups that are associated with the client.
        public let hapgList: [String]
        /// The ARN of the client.
        public let clientArn: String
        /// The client version.
        public let clientVersion: ClientVersion

        public init(hapgList: [String], clientArn: String, clientVersion: ClientVersion) {
            self.hapgList = hapgList
            self.clientArn = clientArn
            self.clientVersion = clientVersion
        }

        private enum CodingKeys: String, CodingKey {
            case hapgList = "HapgList"
            case clientArn = "ClientArn"
            case clientVersion = "ClientVersion"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagList", required: true, type: .list)
        ]
        /// One or more tags.
        public let tagList: [Tag]

        public init(tagList: [Tag]) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct DeleteHapgResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: true, type: .string)
        ]
        /// The status of the action.
        public let status: String

        public init(status: String) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct CreateHapgResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HapgArn", required: false, type: .string)
        ]
        /// The ARN of the high-availability partition group.
        public let hapgArn: String?

        public init(hapgArn: String? = nil) {
            self.hapgArn = hapgArn
        }

        private enum CodingKeys: String, CodingKey {
            case hapgArn = "HapgArn"
        }
    }

    public struct ListHapgsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The NextToken value from a previous call to ListHapgs. Pass null if this is the first call.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct CreateLunaClientRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Label", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: true, type: .string)
        ]
        /// The label for the client.
        public let label: String?
        /// The contents of a Base64-Encoded X.509 v3 certificate to be installed on the HSMs used by this client.
        public let certificate: String

        public init(label: String? = nil, certificate: String) {
            self.label = label
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case certificate = "Certificate"
        }
    }

    public struct DescribeHapgResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HapgSerial", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimestamp", required: false, type: .string), 
            AWSShapeMember(label: "HsmsLastActionFailed", required: false, type: .list), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "PartitionSerialList", required: false, type: .list), 
            AWSShapeMember(label: "HapgArn", required: false, type: .string), 
            AWSShapeMember(label: "HsmsPendingDeletion", required: false, type: .list), 
            AWSShapeMember(label: "HsmsPendingRegistration", required: false, type: .list), 
            AWSShapeMember(label: "Label", required: false, type: .string)
        ]
        /// The serial number of the high-availability partition group.
        public let hapgSerial: String?
        /// The date and time the high-availability partition group was last modified.
        public let lastModifiedTimestamp: String?
        public let hsmsLastActionFailed: [String]?
        /// The state of the high-availability partition group.
        public let state: CloudHsmObjectState?
        /// The list of partition serial numbers that belong to the high-availability partition group.
        public let partitionSerialList: [String]?
        /// The ARN of the high-availability partition group.
        public let hapgArn: String?
        public let hsmsPendingDeletion: [String]?
        public let hsmsPendingRegistration: [String]?
        /// The label for the high-availability partition group.
        public let label: String?

        public init(hapgSerial: String? = nil, lastModifiedTimestamp: String? = nil, hsmsLastActionFailed: [String]? = nil, state: CloudHsmObjectState? = nil, partitionSerialList: [String]? = nil, hapgArn: String? = nil, hsmsPendingDeletion: [String]? = nil, hsmsPendingRegistration: [String]? = nil, label: String? = nil) {
            self.hapgSerial = hapgSerial
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.hsmsLastActionFailed = hsmsLastActionFailed
            self.state = state
            self.partitionSerialList = partitionSerialList
            self.hapgArn = hapgArn
            self.hsmsPendingDeletion = hsmsPendingDeletion
            self.hsmsPendingRegistration = hsmsPendingRegistration
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case hapgSerial = "HapgSerial"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case hsmsLastActionFailed = "HsmsLastActionFailed"
            case state = "State"
            case partitionSerialList = "PartitionSerialList"
            case hapgArn = "HapgArn"
            case hsmsPendingDeletion = "HsmsPendingDeletion"
            case hsmsPendingRegistration = "HsmsPendingRegistration"
            case label = "Label"
        }
    }

    public struct ModifyHsmResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HsmArn", required: false, type: .string)
        ]
        /// The ARN of the HSM.
        public let hsmArn: String?

        public init(hsmArn: String? = nil) {
            self.hsmArn = hsmArn
        }

        private enum CodingKeys: String, CodingKey {
            case hsmArn = "HsmArn"
        }
    }

    public struct DescribeLunaClientResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Label", required: false, type: .string), 
            AWSShapeMember(label: "Certificate", required: false, type: .string), 
            AWSShapeMember(label: "CertificateFingerprint", required: false, type: .string), 
            AWSShapeMember(label: "LastModifiedTimestamp", required: false, type: .string), 
            AWSShapeMember(label: "ClientArn", required: false, type: .string)
        ]
        /// The label of the client.
        public let label: String?
        /// The certificate installed on the HSMs used by this client.
        public let certificate: String?
        /// The certificate fingerprint.
        public let certificateFingerprint: String?
        /// The date and time the client was last modified.
        public let lastModifiedTimestamp: String?
        /// The ARN of the client.
        public let clientArn: String?

        public init(label: String? = nil, certificate: String? = nil, certificateFingerprint: String? = nil, lastModifiedTimestamp: String? = nil, clientArn: String? = nil) {
            self.label = label
            self.certificate = certificate
            self.certificateFingerprint = certificateFingerprint
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.clientArn = clientArn
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case certificate = "Certificate"
            case certificateFingerprint = "CertificateFingerprint"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case clientArn = "ClientArn"
        }
    }

    public struct ModifyLunaClientResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientArn", required: false, type: .string)
        ]
        /// The ARN of the client.
        public let clientArn: String?

        public init(clientArn: String? = nil) {
            self.clientArn = clientArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientArn = "ClientArn"
        }
    }

    public struct DeleteLunaClientRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientArn", required: true, type: .string)
        ]
        /// The ARN of the client to delete.
        public let clientArn: String

        public init(clientArn: String) {
            self.clientArn = clientArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientArn = "ClientArn"
        }
    }

    public struct ListHsmsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HsmList", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The list of ARNs that identify the HSMs.
        public let hsmList: [String]?
        /// If not null, more results are available. Pass this value to ListHsms to retrieve the next set of items.
        public let nextToken: String?

        public init(hsmList: [String]? = nil, nextToken: String? = nil) {
            self.hsmList = hsmList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hsmList = "HsmList"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeHapgRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HapgArn", required: true, type: .string)
        ]
        /// The ARN of the high-availability partition group to describe.
        public let hapgArn: String

        public init(hapgArn: String) {
            self.hapgArn = hapgArn
        }

        private enum CodingKeys: String, CodingKey {
            case hapgArn = "HapgArn"
        }
    }

    public struct GetConfigResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConfigFile", required: false, type: .string), 
            AWSShapeMember(label: "ConfigType", required: false, type: .string), 
            AWSShapeMember(label: "ConfigCred", required: false, type: .string)
        ]
        /// The chrystoki.conf configuration file.
        public let configFile: String?
        /// The type of credentials.
        public let configType: String?
        /// The certificate file containing the server.pem files of the HSMs.
        public let configCred: String?

        public init(configFile: String? = nil, configType: String? = nil, configCred: String? = nil) {
            self.configFile = configFile
            self.configType = configType
            self.configCred = configCred
        }

        private enum CodingKeys: String, CodingKey {
            case configFile = "ConfigFile"
            case configType = "ConfigType"
            case configCred = "ConfigCred"
        }
    }

    public enum ClientVersion: String, CustomStringConvertible, Codable {
        case clientVersion51 = "5.1"
        case clientVersion53 = "5.3"
        public var description: String { return self.rawValue }
    }

    public struct ListAvailableZonesRequest: AWSShape {

    }

    public struct DeleteHapgRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HapgArn", required: true, type: .string)
        ]
        /// The ARN of the high-availability partition group to delete.
        public let hapgArn: String

        public init(hapgArn: String) {
            self.hapgArn = hapgArn
        }

        private enum CodingKeys: String, CodingKey {
            case hapgArn = "HapgArn"
        }
    }

    public enum HsmStatus: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case running = "RUNNING"
        case updating = "UPDATING"
        case suspended = "SUSPENDED"
        case terminating = "TERMINATING"
        case terminated = "TERMINATED"
        case degraded = "DEGRADED"
        public var description: String { return self.rawValue }
    }

    public struct RemoveTagsFromResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagKeyList", required: true, type: .list), 
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// The tag key or keys to remove. Specify only the tag key to remove (not the value). To overwrite the value for an existing tag, use AddTagsToResource.
        public let tagKeyList: [String]
        /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
        public let resourceArn: String

        public init(tagKeyList: [String], resourceArn: String) {
            self.tagKeyList = tagKeyList
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeyList = "TagKeyList"
            case resourceArn = "ResourceArn"
        }
    }

    public struct DescribeHsmRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HsmSerialNumber", required: false, type: .string), 
            AWSShapeMember(label: "HsmArn", required: false, type: .string)
        ]
        /// The serial number of the HSM. Either the HsmArn or the HsmSerialNumber parameter must be specified.
        public let hsmSerialNumber: String?
        /// The ARN of the HSM. Either the HsmArn or the SerialNumber parameter must be specified.
        public let hsmArn: String?

        public init(hsmSerialNumber: String? = nil, hsmArn: String? = nil) {
            self.hsmSerialNumber = hsmSerialNumber
            self.hsmArn = hsmArn
        }

        private enum CodingKeys: String, CodingKey {
            case hsmSerialNumber = "HsmSerialNumber"
            case hsmArn = "HsmArn"
        }
    }

    public struct CreateLunaClientResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientArn", required: false, type: .string)
        ]
        /// The ARN of the client.
        public let clientArn: String?

        public init(clientArn: String? = nil) {
            self.clientArn = clientArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientArn = "ClientArn"
        }
    }

    public struct CreateHsmResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HsmArn", required: false, type: .string)
        ]
        /// The ARN of the HSM.
        public let hsmArn: String?

        public init(hsmArn: String? = nil) {
            self.hsmArn = hsmArn
        }

        private enum CodingKeys: String, CodingKey {
            case hsmArn = "HsmArn"
        }
    }

    public enum CloudHsmObjectState: String, CustomStringConvertible, Codable {
        case ready = "READY"
        case updating = "UPDATING"
        case degraded = "DEGRADED"
        public var description: String { return self.rawValue }
    }

    public struct DeleteHsmResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: true, type: .string)
        ]
        /// The status of the operation.
        public let status: String

        public init(status: String) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct DeleteHsmRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HsmArn", location: .body(locationName: "HsmArn"), required: true, type: .string)
        ]
        /// The ARN of the HSM to delete.
        public let hsmArn: String

        public init(hsmArn: String) {
            self.hsmArn = hsmArn
        }

        private enum CodingKeys: String, CodingKey {
            case hsmArn = "HsmArn"
        }
    }

    public struct ListLunaClientsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The NextToken value from a previous call to ListLunaClients. Pass null if this is the first call.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct ModifyLunaClientRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientArn", required: true, type: .string), 
            AWSShapeMember(label: "Certificate", required: true, type: .string)
        ]
        /// The ARN of the client.
        public let clientArn: String
        /// The new certificate for the client.
        public let certificate: String

        public init(clientArn: String, certificate: String) {
            self.clientArn = clientArn
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case clientArn = "ClientArn"
            case certificate = "Certificate"
        }
    }

    public struct ModifyHapgRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PartitionSerialList", required: false, type: .list), 
            AWSShapeMember(label: "Label", required: false, type: .string), 
            AWSShapeMember(label: "HapgArn", required: true, type: .string)
        ]
        /// The list of partition serial numbers to make members of the high-availability partition group.
        public let partitionSerialList: [String]?
        /// The new label for the high-availability partition group.
        public let label: String?
        /// The ARN of the high-availability partition group to modify.
        public let hapgArn: String

        public init(partitionSerialList: [String]? = nil, label: String? = nil, hapgArn: String) {
            self.partitionSerialList = partitionSerialList
            self.label = label
            self.hapgArn = hapgArn
        }

        private enum CodingKeys: String, CodingKey {
            case partitionSerialList = "PartitionSerialList"
            case label = "Label"
            case hapgArn = "HapgArn"
        }
    }

    public struct DescribeHsmResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubscriptionEndDate", required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionStartDate", required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionType", required: false, type: .enum), 
            AWSShapeMember(label: "VendorName", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string), 
            AWSShapeMember(label: "EniIp", required: false, type: .string), 
            AWSShapeMember(label: "SshPublicKey", required: false, type: .string), 
            AWSShapeMember(label: "HsmType", required: false, type: .string), 
            AWSShapeMember(label: "IamRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SshKeyLastUpdated", required: false, type: .string), 
            AWSShapeMember(label: "ServerCertLastUpdated", required: false, type: .string), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "ServerCertUri", required: false, type: .string), 
            AWSShapeMember(label: "EniId", required: false, type: .string), 
            AWSShapeMember(label: "Partitions", required: false, type: .list), 
            AWSShapeMember(label: "SerialNumber", required: false, type: .string), 
            AWSShapeMember(label: "StatusDetails", required: false, type: .string), 
            AWSShapeMember(label: "SoftwareVersion", required: false, type: .string), 
            AWSShapeMember(label: "HsmArn", required: false, type: .string)
        ]
        /// The subscription end date.
        public let subscriptionEndDate: String?
        /// The subscription start date.
        public let subscriptionStartDate: String?
        public let subscriptionType: SubscriptionType?
        /// The name of the HSM vendor.
        public let vendorName: String?
        /// The identifier of the VPC that the HSM is in.
        public let vpcId: String?
        /// The IP address assigned to the HSM's ENI.
        public let eniIp: String?
        /// The public SSH key.
        public let sshPublicKey: String?
        /// The HSM model type.
        public let hsmType: String?
        /// The ARN of the IAM role assigned to the HSM.
        public let iamRoleArn: String?
        /// The date and time that the SSH key was last updated.
        public let sshKeyLastUpdated: String?
        /// The date and time that the server certificate was last updated.
        public let serverCertLastUpdated: String?
        /// The Availability Zone that the HSM is in.
        public let availabilityZone: String?
        /// The identifier of the subnet that the HSM is in.
        public let subnetId: String?
        /// The status of the HSM.
        public let status: HsmStatus?
        /// The URI of the certificate server.
        public let serverCertUri: String?
        /// The identifier of the elastic network interface (ENI) attached to the HSM.
        public let eniId: String?
        /// The list of partitions on the HSM.
        public let partitions: [String]?
        /// The serial number of the HSM.
        public let serialNumber: String?
        /// Contains additional information about the status of the HSM.
        public let statusDetails: String?
        /// The HSM software version.
        public let softwareVersion: String?
        /// The ARN of the HSM.
        public let hsmArn: String?

        public init(subscriptionEndDate: String? = nil, subscriptionStartDate: String? = nil, subscriptionType: SubscriptionType? = nil, vendorName: String? = nil, vpcId: String? = nil, eniIp: String? = nil, sshPublicKey: String? = nil, hsmType: String? = nil, iamRoleArn: String? = nil, sshKeyLastUpdated: String? = nil, serverCertLastUpdated: String? = nil, availabilityZone: String? = nil, subnetId: String? = nil, status: HsmStatus? = nil, serverCertUri: String? = nil, eniId: String? = nil, partitions: [String]? = nil, serialNumber: String? = nil, statusDetails: String? = nil, softwareVersion: String? = nil, hsmArn: String? = nil) {
            self.subscriptionEndDate = subscriptionEndDate
            self.subscriptionStartDate = subscriptionStartDate
            self.subscriptionType = subscriptionType
            self.vendorName = vendorName
            self.vpcId = vpcId
            self.eniIp = eniIp
            self.sshPublicKey = sshPublicKey
            self.hsmType = hsmType
            self.iamRoleArn = iamRoleArn
            self.sshKeyLastUpdated = sshKeyLastUpdated
            self.serverCertLastUpdated = serverCertLastUpdated
            self.availabilityZone = availabilityZone
            self.subnetId = subnetId
            self.status = status
            self.serverCertUri = serverCertUri
            self.eniId = eniId
            self.partitions = partitions
            self.serialNumber = serialNumber
            self.statusDetails = statusDetails
            self.softwareVersion = softwareVersion
            self.hsmArn = hsmArn
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionEndDate = "SubscriptionEndDate"
            case subscriptionStartDate = "SubscriptionStartDate"
            case subscriptionType = "SubscriptionType"
            case vendorName = "VendorName"
            case vpcId = "VpcId"
            case eniIp = "EniIp"
            case sshPublicKey = "SshPublicKey"
            case hsmType = "HsmType"
            case iamRoleArn = "IamRoleArn"
            case sshKeyLastUpdated = "SshKeyLastUpdated"
            case serverCertLastUpdated = "ServerCertLastUpdated"
            case availabilityZone = "AvailabilityZone"
            case subnetId = "SubnetId"
            case status = "Status"
            case serverCertUri = "ServerCertUri"
            case eniId = "EniId"
            case partitions = "Partitions"
            case serialNumber = "SerialNumber"
            case statusDetails = "StatusDetails"
            case softwareVersion = "SoftwareVersion"
            case hsmArn = "HsmArn"
        }
    }

    public struct CreateHapgRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Label", required: true, type: .string)
        ]
        /// The label of the new high-availability partition group.
        public let label: String

        public init(label: String) {
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
        }
    }

    public struct RemoveTagsFromResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: true, type: .string)
        ]
        /// The status of the operation.
        public let status: String

        public init(status: String) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct ModifyHapgResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HapgArn", required: false, type: .string)
        ]
        /// The ARN of the high-availability partition group.
        public let hapgArn: String?

        public init(hapgArn: String? = nil) {
            self.hapgArn = hapgArn
        }

        private enum CodingKeys: String, CodingKey {
            case hapgArn = "HapgArn"
        }
    }

    public struct ListHsmsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The NextToken value from a previous call to ListHsms. Pass null if this is the first call.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct AddTagsToResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: true, type: .string)
        ]
        /// The status of the operation.
        public let status: String

        public init(status: String) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public enum SubscriptionType: String, CustomStringConvertible, Codable {
        case production = "PRODUCTION"
        public var description: String { return self.rawValue }
    }

    public struct ModifyHsmRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExternalId", location: .body(locationName: "ExternalId"), required: false, type: .string), 
            AWSShapeMember(label: "IamRoleArn", location: .body(locationName: "IamRoleArn"), required: false, type: .string), 
            AWSShapeMember(label: "EniIp", location: .body(locationName: "EniIp"), required: false, type: .string), 
            AWSShapeMember(label: "HsmArn", location: .body(locationName: "HsmArn"), required: true, type: .string), 
            AWSShapeMember(label: "SyslogIp", location: .body(locationName: "SyslogIp"), required: false, type: .string), 
            AWSShapeMember(label: "SubnetId", location: .body(locationName: "SubnetId"), required: false, type: .string)
        ]
        /// The new external ID.
        public let externalId: String?
        /// The new IAM role ARN.
        public let iamRoleArn: String?
        /// The new IP address for the elastic network interface (ENI) attached to the HSM. If the HSM is moved to a different subnet, and an IP address is not specified, an IP address will be randomly chosen from the CIDR range of the new subnet.
        public let eniIp: String?
        /// The ARN of the HSM to modify.
        public let hsmArn: String
        /// The new IP address for the syslog monitoring server. The AWS CloudHSM service only supports one syslog monitoring server.
        public let syslogIp: String?
        /// The new identifier of the subnet that the HSM is in. The new subnet must be in the same Availability Zone as the current subnet.
        public let subnetId: String?

        public init(externalId: String? = nil, iamRoleArn: String? = nil, eniIp: String? = nil, hsmArn: String, syslogIp: String? = nil, subnetId: String? = nil) {
            self.externalId = externalId
            self.iamRoleArn = iamRoleArn
            self.eniIp = eniIp
            self.hsmArn = hsmArn
            self.syslogIp = syslogIp
            self.subnetId = subnetId
        }

        private enum CodingKeys: String, CodingKey {
            case externalId = "ExternalId"
            case iamRoleArn = "IamRoleArn"
            case eniIp = "EniIp"
            case hsmArn = "HsmArn"
            case syslogIp = "SyslogIp"
            case subnetId = "SubnetId"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListAvailableZonesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AZList", required: false, type: .list)
        ]
        /// The list of Availability Zones that have available AWS CloudHSM capacity.
        public let aZList: [String]?

        public init(aZList: [String]? = nil) {
            self.aZList = aZList
        }

        private enum CodingKeys: String, CodingKey {
            case aZList = "AZList"
        }
    }

    public struct DeleteLunaClientResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: true, type: .string)
        ]
        /// The status of the action.
        public let status: String

        public init(status: String) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AddTagsToResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagList", required: true, type: .list), 
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// One or more tags.
        public let tagList: [Tag]
        /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource to tag.
        public let resourceArn: String

        public init(tagList: [Tag], resourceArn: String) {
            self.tagList = tagList
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
            case resourceArn = "ResourceArn"
        }
    }

}