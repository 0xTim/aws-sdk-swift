// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Appstream {

    public struct ListAssociatedFleetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The name of the stack whose associated fleets are listed.
        public let stackName: String
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?

        public init(stackName: String, nextToken: String? = nil) {
            self.stackName = stackName
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case stackName = "StackName"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeStacksResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Stacks", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The list of stack details.
        public let stacks: [Stack]?
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?

        public init(stacks: [Stack]? = nil, nextToken: String? = nil) {
            self.stacks = stacks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case stacks = "Stacks"
            case nextToken = "NextToken"
        }
    }

    public struct DeleteStackResult: AWSShape {
        /// The key for the payload

    }

    public struct ComputeCapacity: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DesiredInstances", required: true, type: .integer)
        ]
        /// The desired number of streaming instances.
        public let desiredInstances: Int32

        public init(desiredInstances: Int32) {
            self.desiredInstances = desiredInstances
        }

        private enum CodingKeys: String, CodingKey {
            case desiredInstances = "DesiredInstances"
        }
    }

    public struct DescribeImagesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// A specific list of images to describe.
        public let names: [String]?

        public init(names: [String]? = nil) {
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
        }
    }

    public struct DescribeImagesResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Images", required: false, type: .list)
        ]
        /// The list of images.
        public let images: [Image]?

        public init(images: [Image]? = nil) {
            self.images = images
        }

        private enum CodingKeys: String, CodingKey {
            case images = "Images"
        }
    }

    public enum FleetState: String, CustomStringConvertible, Codable {
        case starting = "STARTING"
        case running = "RUNNING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSessionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthenticationType", required: false, type: .enum), 
            AWSShapeMember(label: "UserId", required: false, type: .string), 
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The authentication method of the user. It can be API for a user authenticated using a streaming URL, or SAML for a SAML federated user. If an authentication type is not provided, the operation defaults to users authenticated using a streaming URL.
        public let authenticationType: AuthenticationType?
        /// The user for whom to list sessions. Use null to describe all the sessions for the stack and fleet.
        public let userId: String?
        /// The size of each page of results. The default value is 20 and the maximum supported value is 50.
        public let limit: Int32?
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The name of the stack for which to list sessions.
        public let stackName: String
        /// The name of the fleet for which to list sessions.
        public let fleetName: String

        public init(authenticationType: AuthenticationType? = nil, userId: String? = nil, limit: Int32? = nil, nextToken: String? = nil, stackName: String, fleetName: String) {
            self.authenticationType = authenticationType
            self.userId = userId
            self.limit = limit
            self.nextToken = nextToken
            self.stackName = stackName
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case userId = "UserId"
            case limit = "Limit"
            case nextToken = "NextToken"
            case stackName = "StackName"
            case fleetName = "FleetName"
        }
    }

    public struct Session: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserId", required: true, type: .string), 
            AWSShapeMember(label: "AuthenticationType", required: false, type: .enum), 
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "State", required: true, type: .enum), 
            AWSShapeMember(label: "FleetName", required: true, type: .string), 
            AWSShapeMember(label: "Id", required: true, type: .string)
        ]
        /// The identifier of the user for whom the session was created.
        public let userId: String
        /// The authentication method of the user for whom the session was created. It can be API for a user authenticated using a streaming URL or SAML for a SAML federated user.
        public let authenticationType: AuthenticationType?
        /// The name of the stack for which the streaming session was created.
        public let stackName: String
        /// The current state of the streaming session.
        public let state: SessionState
        /// The name of the fleet for which the streaming session was created.
        public let fleetName: String
        /// The unique ID for a streaming session.
        public let id: String

        public init(userId: String, authenticationType: AuthenticationType? = nil, stackName: String, state: SessionState, fleetName: String, id: String) {
            self.userId = userId
            self.authenticationType = authenticationType
            self.stackName = stackName
            self.state = state
            self.fleetName = fleetName
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "UserId"
            case authenticationType = "AuthenticationType"
            case stackName = "StackName"
            case state = "State"
            case fleetName = "FleetName"
            case id = "Id"
        }
    }

    public struct ListAssociatedFleetsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The names of associated fleets.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case names = "Names"
        }
    }

    public struct StackError: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .enum)
        ]
        /// The error message of a stack error.
        public let errorMessage: String?
        /// The error code of a stack error.
        public let errorCode: StackErrorCode?

        public init(errorMessage: String? = nil, errorCode: StackErrorCode? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorCode = "ErrorCode"
        }
    }

    public struct DescribeFleetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The fleet names to describe. Use null to describe all the fleets for the AWS account.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case names = "Names"
        }
    }

    public enum StackErrorCode: String, CustomStringConvertible, Codable {
        case storageConnectorError = "STORAGE_CONNECTOR_ERROR"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum PlatformType: String, CustomStringConvertible, Codable {
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public struct FleetError: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .enum)
        ]
        /// The error message generated when the fleet has errors.
        public let errorMessage: String?
        /// The error code for the fleet error.
        public let errorCode: FleetErrorCode?

        public init(errorMessage: String? = nil, errorCode: FleetErrorCode? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorCode = "ErrorCode"
        }
    }

    public struct ListAssociatedStacksResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The names of associated stacks.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case names = "Names"
        }
    }

    public enum StorageConnectorType: String, CustomStringConvertible, Codable {
        case homefolders = "HOMEFOLDERS"
        public var description: String { return self.rawValue }
    }

    public struct UpdateFleetResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fleet", required: false, type: .structure)
        ]
        /// A list of fleet details.
        public let fleet: Fleet?

        public init(fleet: Fleet? = nil) {
            self.fleet = fleet
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "Fleet"
        }
    }

    public enum FleetAttribute: String, CustomStringConvertible, Codable {
        case vpcConfiguration = "VPC_CONFIGURATION"
        case vpcConfigurationSecurityGroupIds = "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
        public var description: String { return self.rawValue }
    }

    public struct ExpireSessionResult: AWSShape {
        /// The key for the payload

    }

    public struct DisassociateFleetResult: AWSShape {
        /// The key for the payload

    }

    public struct Stack: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "StackErrors", required: false, type: .list), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "StorageConnectors", required: false, type: .list), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The ARN of the stack.
        public let arn: String?
        /// The list of errors associated with the stack.
        public let stackErrors: [StackError]?
        /// A display name for the stack.
        public let displayName: String?
        /// The unique identifier of the stack.
        public let name: String
        /// The storage connectors to be enabled for the stack.
        public let storageConnectors: [StorageConnector]?
        /// The timestamp when the stack was created.
        public let createdTime: TimeStamp?
        /// A meaningful description for the stack.
        public let description: String?

        public init(arn: String? = nil, stackErrors: [StackError]? = nil, displayName: String? = nil, name: String, storageConnectors: [StorageConnector]? = nil, createdTime: TimeStamp? = nil, description: String? = nil) {
            self.arn = arn
            self.stackErrors = stackErrors
            self.displayName = displayName
            self.name = name
            self.storageConnectors = storageConnectors
            self.createdTime = createdTime
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case stackErrors = "StackErrors"
            case displayName = "DisplayName"
            case name = "Name"
            case storageConnectors = "StorageConnectors"
            case createdTime = "CreatedTime"
            case description = "Description"
        }
    }

    public struct UpdateStackResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Stack", required: false, type: .structure)
        ]
        /// A list of stack details.
        public let stack: Stack?

        public init(stack: Stack? = nil) {
            self.stack = stack
        }

        private enum CodingKeys: String, CodingKey {
            case stack = "Stack"
        }
    }

    public struct CreateFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ComputeCapacity", required: true, type: .structure), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "ImageName", required: true, type: .string), 
            AWSShapeMember(label: "DisconnectTimeoutInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "MaxUserDurationInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "InstanceType", required: true, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The parameters for the capacity allocated to the fleet.
        public let computeCapacity: ComputeCapacity
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// A unique identifier for the fleet.
        public let name: String
        /// The display name of the fleet.
        public let displayName: String?
        /// Unique name of the image used by the fleet.
        public let imageName: String
        /// The time after disconnection when a session is considered to have ended. If a user who got disconnected reconnects within this timeout interval, the user is connected back to their previous session. The input can be any numeric value in seconds between 60 and 57600. 
        public let disconnectTimeoutInSeconds: Int32?
        /// Enables or disables default Internet access for the fleet.
        public let enableDefaultInternetAccess: Bool?
        /// The maximum time for which a streaming session can run. The input can be any numeric value in seconds between 600 and 57600.
        public let maxUserDurationInSeconds: Int32?
        /// The instance type of compute resources for the fleet. Fleet instances are launched from this instance type.
        public let instanceType: String
        /// The description of the fleet.
        public let description: String?

        public init(computeCapacity: ComputeCapacity, vpcConfig: VpcConfig? = nil, name: String, displayName: String? = nil, imageName: String, disconnectTimeoutInSeconds: Int32? = nil, enableDefaultInternetAccess: Bool? = nil, maxUserDurationInSeconds: Int32? = nil, instanceType: String, description: String? = nil) {
            self.computeCapacity = computeCapacity
            self.vpcConfig = vpcConfig
            self.name = name
            self.displayName = displayName
            self.imageName = imageName
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.instanceType = instanceType
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case computeCapacity = "ComputeCapacity"
            case vpcConfig = "VpcConfig"
            case name = "Name"
            case displayName = "DisplayName"
            case imageName = "ImageName"
            case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
            case instanceType = "InstanceType"
            case description = "Description"
        }
    }

    public struct DeleteFleetResult: AWSShape {
        /// The key for the payload

    }

    public struct UpdateFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeleteVpcConfig", required: false, type: .boolean), 
            AWSShapeMember(label: "ComputeCapacity", required: false, type: .structure), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "ImageName", required: false, type: .string), 
            AWSShapeMember(label: "DisconnectTimeoutInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "AttributesToDelete", required: false, type: .list), 
            AWSShapeMember(label: "InstanceType", required: false, type: .string), 
            AWSShapeMember(label: "MaxUserDurationInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// Delete the VPC association for the specified fleet.
        public let deleteVpcConfig: Bool?
        /// The parameters for the capacity allocated to the fleet. 
        public let computeCapacity: ComputeCapacity?
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The name of the fleet.
        public let name: String
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The image name from which a fleet is created.
        public let imageName: String?
        /// The time after disconnection when a session is considered to have ended. If a user who got disconnected reconnects within this timeout interval, the user is connected back to their previous session. The input can be any numeric value in seconds between 60 and 57600.
        public let disconnectTimeoutInSeconds: Int32?
        /// Fleet attributes to be deleted.
        public let attributesToDelete: [FleetAttribute]?
        /// The instance type of compute resources for the fleet. Fleet instances are launched from this instance type.
        public let instanceType: String?
        /// The maximum time for which a streaming session can run. The input can be any numeric value in seconds between 600 and 57600.
        public let maxUserDurationInSeconds: Int32?
        /// Enables or disables default Internet access for the fleet.
        public let enableDefaultInternetAccess: Bool?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?

        public init(deleteVpcConfig: Bool? = nil, computeCapacity: ComputeCapacity? = nil, vpcConfig: VpcConfig? = nil, name: String, displayName: String? = nil, imageName: String? = nil, disconnectTimeoutInSeconds: Int32? = nil, attributesToDelete: [FleetAttribute]? = nil, instanceType: String? = nil, maxUserDurationInSeconds: Int32? = nil, enableDefaultInternetAccess: Bool? = nil, description: String? = nil) {
            self.deleteVpcConfig = deleteVpcConfig
            self.computeCapacity = computeCapacity
            self.vpcConfig = vpcConfig
            self.name = name
            self.displayName = displayName
            self.imageName = imageName
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.attributesToDelete = attributesToDelete
            self.instanceType = instanceType
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case deleteVpcConfig = "DeleteVpcConfig"
            case computeCapacity = "ComputeCapacity"
            case vpcConfig = "VpcConfig"
            case name = "Name"
            case displayName = "DisplayName"
            case imageName = "ImageName"
            case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
            case attributesToDelete = "AttributesToDelete"
            case instanceType = "InstanceType"
            case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case description = "Description"
        }
    }

    public struct DisassociateFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The name of the stack with which the fleet is associated.
        public let stackName: String
        /// The name of the fleet to disassociate.
        public let fleetName: String

        public init(stackName: String, fleetName: String) {
            self.stackName = stackName
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case stackName = "StackName"
            case fleetName = "FleetName"
        }
    }

    public struct Application: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Metadata", required: false, type: .map), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "LaunchPath", required: false, type: .string), 
            AWSShapeMember(label: "LaunchParameters", required: false, type: .string), 
            AWSShapeMember(label: "IconURL", required: false, type: .string)
        ]
        /// Additional attributes that describe the application.
        public let metadata: [String: String]?
        /// The unique identifier for the application.
        public let name: String?
        /// The name of the application shown to the end users.
        public let displayName: String?
        /// An application can be disabled after image creation if there is a problem.
        public let enabled: Bool?
        /// The path to the application executable in the instance.
        public let launchPath: String?
        /// A list of arguments that are passed to the application at launch.
        public let launchParameters: String?
        /// The URL for the application icon. This URL may be time-limited.
        public let iconURL: String?

        public init(metadata: [String: String]? = nil, name: String? = nil, displayName: String? = nil, enabled: Bool? = nil, launchPath: String? = nil, launchParameters: String? = nil, iconURL: String? = nil) {
            self.metadata = metadata
            self.name = name
            self.displayName = displayName
            self.enabled = enabled
            self.launchPath = launchPath
            self.launchParameters = launchParameters
            self.iconURL = iconURL
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case name = "Name"
            case displayName = "DisplayName"
            case enabled = "Enabled"
            case launchPath = "LaunchPath"
            case launchParameters = "LaunchParameters"
            case iconURL = "IconURL"
        }
    }

    public struct Fleet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", required: true, type: .string), 
            AWSShapeMember(label: "VpcConfig", required: false, type: .structure), 
            AWSShapeMember(label: "State", required: true, type: .enum), 
            AWSShapeMember(label: "ComputeCapacityStatus", required: true, type: .structure), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "FleetErrors", required: false, type: .list), 
            AWSShapeMember(label: "ImageName", required: true, type: .string), 
            AWSShapeMember(label: "EnableDefaultInternetAccess", required: false, type: .boolean), 
            AWSShapeMember(label: "InstanceType", required: true, type: .string), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DisconnectTimeoutInSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "MaxUserDurationInSeconds", required: false, type: .integer)
        ]
        /// The ARN for the fleet.
        public let arn: String
        /// The VPC configuration for the fleet.
        public let vpcConfig: VpcConfig?
        /// The current state for the fleet.
        public let state: FleetState
        /// The capacity information for the fleet.
        public let computeCapacityStatus: ComputeCapacityStatus
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The list of fleet errors is appended to this list.
        public let fleetErrors: [FleetError]?
        /// The image used by the fleet.
        public let imageName: String
        /// Whether default Internet access is enabled for the fleet. 
        public let enableDefaultInternetAccess: Bool?
        /// The instance type of compute resources for the fleet. The fleet instances are launched from this instance type. 
        public let instanceType: String
        /// The time at which the fleet was created.
        public let createdTime: TimeStamp?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?
        /// The name of the fleet.
        public let name: String
        /// The time after disconnection when a session is considered to have ended. If a user who got disconnected reconnects within this timeout interval, the user is connected back to their previous session. The input can be any numeric value in seconds between 60 and 57600.
        public let disconnectTimeoutInSeconds: Int32?
        /// The maximum time for which a streaming session can run. The value can be any numeric value in seconds between 600 and 57600.
        public let maxUserDurationInSeconds: Int32?

        public init(arn: String, vpcConfig: VpcConfig? = nil, state: FleetState, computeCapacityStatus: ComputeCapacityStatus, displayName: String? = nil, fleetErrors: [FleetError]? = nil, imageName: String, enableDefaultInternetAccess: Bool? = nil, instanceType: String, createdTime: TimeStamp? = nil, description: String? = nil, name: String, disconnectTimeoutInSeconds: Int32? = nil, maxUserDurationInSeconds: Int32? = nil) {
            self.arn = arn
            self.vpcConfig = vpcConfig
            self.state = state
            self.computeCapacityStatus = computeCapacityStatus
            self.displayName = displayName
            self.fleetErrors = fleetErrors
            self.imageName = imageName
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.instanceType = instanceType
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case vpcConfig = "VpcConfig"
            case state = "State"
            case computeCapacityStatus = "ComputeCapacityStatus"
            case displayName = "DisplayName"
            case fleetErrors = "FleetErrors"
            case imageName = "ImageName"
            case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
            case instanceType = "InstanceType"
            case createdTime = "CreatedTime"
            case description = "Description"
            case name = "Name"
            case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
            case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        }
    }

    public struct StartFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the fleet to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartFleetResult: AWSShape {
        /// The key for the payload

    }

    public struct StorageConnector: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ConnectorType", required: true, type: .enum)
        ]
        /// The ARN associated with the storage connector.
        public let resourceIdentifier: String?
        /// The type of storage connector. The possible values include: HOMEFOLDERS.
        public let connectorType: StorageConnectorType

        public init(resourceIdentifier: String? = nil, connectorType: StorageConnectorType) {
            self.resourceIdentifier = resourceIdentifier
            self.connectorType = connectorType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdentifier = "ResourceIdentifier"
            case connectorType = "ConnectorType"
        }
    }

    public struct VpcConfig: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetIds", required: false, type: .list), 
            AWSShapeMember(label: "SecurityGroupIds", required: false, type: .list)
        ]
        /// The list of subnets to which a network interface is established from the fleet instance.
        public let subnetIds: [String]?
        /// Security groups associated with the fleet.
        public let securityGroupIds: [String]?

        public init(subnetIds: [String]? = nil, securityGroupIds: [String]? = nil) {
            self.subnetIds = subnetIds
            self.securityGroupIds = securityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIds = "SubnetIds"
            case securityGroupIds = "SecurityGroupIds"
        }
    }

    public struct ImageStateChangeReason: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Code", required: false, type: .enum), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]
        /// The state change reason code of the image.
        public let code: ImageStateChangeReasonCode?
        /// The state change reason message to the end user.
        public let message: String?

        public init(code: ImageStateChangeReasonCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct DescribeStacksRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The stack names to describe. Use null to describe all the stacks for the AWS account.
        public let names: [String]?

        public init(nextToken: String? = nil, names: [String]? = nil) {
            self.nextToken = nextToken
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case names = "Names"
        }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable {
        case api = "API"
        case saml = "SAML"
        case userpool = "USERPOOL"
        public var description: String { return self.rawValue }
    }

    public enum VisibilityType: String, CustomStringConvertible, Codable {
        case `public` = "PUBLIC"
        case `private` = "PRIVATE"
        public var description: String { return self.rawValue }
    }

    public struct ListAssociatedStacksRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
        public let nextToken: String?
        /// The name of the fleet whose associated stacks are listed.
        public let fleetName: String

        public init(nextToken: String? = nil, fleetName: String) {
            self.nextToken = nextToken
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case fleetName = "FleetName"
        }
    }

    public struct CreateStackRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StorageConnectors", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The storage connectors to be enabled for the stack.
        public let storageConnectors: [StorageConnector]?
        /// The unique identifier for this stack.
        public let name: String
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?

        public init(storageConnectors: [StorageConnector]? = nil, name: String, displayName: String? = nil, description: String? = nil) {
            self.storageConnectors = storageConnectors
            self.name = name
            self.displayName = displayName
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case storageConnectors = "StorageConnectors"
            case name = "Name"
            case displayName = "DisplayName"
            case description = "Description"
        }
    }

    public struct UpdateStackRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeleteStorageConnectors", required: false, type: .boolean), 
            AWSShapeMember(label: "StorageConnectors", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// Remove all the storage connectors currently enabled for the stack.
        public let deleteStorageConnectors: Bool?
        /// The storage connectors to be enabled for the stack.
        public let storageConnectors: [StorageConnector]?
        /// The name of the stack to update.
        public let name: String
        /// The name displayed to end users on the AppStream 2.0 portal.
        public let displayName: String?
        /// The description displayed to end users on the AppStream 2.0 portal.
        public let description: String?

        public init(deleteStorageConnectors: Bool? = nil, storageConnectors: [StorageConnector]? = nil, name: String, displayName: String? = nil, description: String? = nil) {
            self.deleteStorageConnectors = deleteStorageConnectors
            self.storageConnectors = storageConnectors
            self.name = name
            self.displayName = displayName
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case deleteStorageConnectors = "DeleteStorageConnectors"
            case storageConnectors = "StorageConnectors"
            case name = "Name"
            case displayName = "DisplayName"
            case description = "Description"
        }
    }

    public struct StopFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the fleet to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public enum ImageStateChangeReasonCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case imageBuilderNotAvailable = "IMAGE_BUILDER_NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public struct CreateStreamingURLRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Validity", required: false, type: .long), 
            AWSShapeMember(label: "UserId", required: true, type: .string), 
            AWSShapeMember(label: "ApplicationId", required: false, type: .string), 
            AWSShapeMember(label: "SessionContext", required: false, type: .string), 
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The duration up to which the URL returned by this action is valid. The input can be any numeric value in seconds between 1 and 604800 seconds.
        public let validity: Int64?
        /// A unique user ID for whom the URL is generated.
        public let userId: String
        /// The ID of the application that must be launched after the session starts.
        public let applicationId: String?
        /// The sessionContext of the streaming URL.
        public let sessionContext: String?
        /// The stack for which the URL is generated.
        public let stackName: String
        /// The fleet for which the URL is generated.
        public let fleetName: String

        public init(validity: Int64? = nil, userId: String, applicationId: String? = nil, sessionContext: String? = nil, stackName: String, fleetName: String) {
            self.validity = validity
            self.userId = userId
            self.applicationId = applicationId
            self.sessionContext = sessionContext
            self.stackName = stackName
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case validity = "Validity"
            case userId = "UserId"
            case applicationId = "ApplicationId"
            case sessionContext = "SessionContext"
            case stackName = "StackName"
            case fleetName = "FleetName"
        }
    }

    public struct CreateFleetResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fleet", required: false, type: .structure)
        ]
        /// The details for the created fleet.
        public let fleet: Fleet?

        public init(fleet: Fleet? = nil) {
            self.fleet = fleet
        }

        private enum CodingKeys: String, CodingKey {
            case fleet = "Fleet"
        }
    }

    public struct CreateStreamingURLResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamingURL", required: false, type: .string), 
            AWSShapeMember(label: "Expires", required: false, type: .timestamp)
        ]
        /// The URL to start the AppStream 2.0 streaming session.
        public let streamingURL: String?
        /// Elapsed seconds after the Unix epoch, at which time this URL expires.
        public let expires: TimeStamp?

        public init(streamingURL: String? = nil, expires: TimeStamp? = nil) {
            self.streamingURL = streamingURL
            self.expires = expires
        }

        private enum CodingKeys: String, CodingKey {
            case streamingURL = "StreamingURL"
            case expires = "Expires"
        }
    }

    public struct ComputeCapacityStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Available", required: false, type: .integer), 
            AWSShapeMember(label: "InUse", required: false, type: .integer), 
            AWSShapeMember(label: "Desired", required: true, type: .integer), 
            AWSShapeMember(label: "Running", required: false, type: .integer)
        ]
        /// The number of currently available instances that can be used to stream sessions.
        public let available: Int32?
        /// The number of instances that are being used for streaming.
        public let inUse: Int32?
        /// The desired number of streaming instances.
        public let desired: Int32
        /// The total number of simultaneous streaming instances that are running.
        public let running: Int32?

        public init(available: Int32? = nil, inUse: Int32? = nil, desired: Int32, running: Int32? = nil) {
            self.available = available
            self.inUse = inUse
            self.desired = desired
            self.running = running
        }

        private enum CodingKeys: String, CodingKey {
            case available = "Available"
            case inUse = "InUse"
            case desired = "Desired"
            case running = "Running"
        }
    }

    public struct AssociateFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StackName", required: true, type: .string), 
            AWSShapeMember(label: "FleetName", required: true, type: .string)
        ]
        /// The name of the stack to which the fleet is associated.
        public let stackName: String
        /// The name of the fleet to associate.
        public let fleetName: String

        public init(stackName: String, fleetName: String) {
            self.stackName = stackName
            self.fleetName = fleetName
        }

        private enum CodingKeys: String, CodingKey {
            case stackName = "StackName"
            case fleetName = "FleetName"
        }
    }

    public struct StopFleetResult: AWSShape {
        /// The key for the payload

    }

    public enum SessionState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case pending = "PENDING"
        case expired = "EXPIRED"
        public var description: String { return self.rawValue }
    }

    public struct DescribeFleetsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Fleets", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The list of fleet details.
        public let fleets: [Fleet]?

        public init(nextToken: String? = nil, fleets: [Fleet]? = nil) {
            self.nextToken = nextToken
            self.fleets = fleets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case fleets = "Fleets"
        }
    }

    public enum FleetErrorCode: String, CustomStringConvertible, Codable {
        case iamServiceRoleMissingEniDescribeAction = "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
        case iamServiceRoleMissingEniCreateAction = "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
        case iamServiceRoleMissingEniDeleteAction = "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
        case networkInterfaceLimitExceeded = "NETWORK_INTERFACE_LIMIT_EXCEEDED"
        case internalServiceError = "INTERNAL_SERVICE_ERROR"
        case iamServiceRoleIsMissing = "IAM_SERVICE_ROLE_IS_MISSING"
        case subnetHasInsufficientIpAddresses = "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
        case iamServiceRoleMissingDescribeSubnetAction = "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
        case subnetNotFound = "SUBNET_NOT_FOUND"
        case imageNotFound = "IMAGE_NOT_FOUND"
        case invalidSubnetConfiguration = "INVALID_SUBNET_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public struct DeleteStackRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the stack to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ExpireSessionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SessionId", required: true, type: .string)
        ]
        /// The unique identifier of the streaming session to be stopped.
        public let sessionId: String

        public init(sessionId: String) {
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "SessionId"
        }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Platform", required: false, type: .enum), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "DisplayName", required: false, type: .string), 
            AWSShapeMember(label: "BaseImageArn", required: false, type: .string), 
            AWSShapeMember(label: "Applications", required: false, type: .list), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "StateChangeReason", required: false, type: .structure), 
            AWSShapeMember(label: "ImageBuilderSupported", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "PublicBaseImageReleasedDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Visibility", required: false, type: .enum)
        ]
        /// The operating system platform of the image.
        public let platform: PlatformType?
        /// The ARN for the image.
        public let arn: String?
        /// The image starts in the PENDING state, and then moves to AVAILABLE if image creation succeeds and FAILED if image creation has failed.
        public let state: ImageState?
        /// The display name for the image.
        public let displayName: String?
        /// The source image ARN from which this image was created.
        public let baseImageArn: String?
        /// The applications associated with an image.
        public let applications: [Application]?
        /// The timestamp when the image was created.
        public let createdTime: TimeStamp?
        /// A meaningful description for the image.
        public let description: String?
        /// The reason why the last state change occurred.
        public let stateChangeReason: ImageStateChangeReason?
        /// Whether an image builder can be launched from this image.
        public let imageBuilderSupported: Bool?
        /// The unique identifier for the image.
        public let name: String
        /// The AWS release date of the public base image. For private images, this date is the release date of the base image from which the image was created.
        public let publicBaseImageReleasedDate: TimeStamp?
        /// The visibility of an image to the user; images can be public or private.
        public let visibility: VisibilityType?

        public init(platform: PlatformType? = nil, arn: String? = nil, state: ImageState? = nil, displayName: String? = nil, baseImageArn: String? = nil, applications: [Application]? = nil, createdTime: TimeStamp? = nil, description: String? = nil, stateChangeReason: ImageStateChangeReason? = nil, imageBuilderSupported: Bool? = nil, name: String, publicBaseImageReleasedDate: TimeStamp? = nil, visibility: VisibilityType? = nil) {
            self.platform = platform
            self.arn = arn
            self.state = state
            self.displayName = displayName
            self.baseImageArn = baseImageArn
            self.applications = applications
            self.createdTime = createdTime
            self.description = description
            self.stateChangeReason = stateChangeReason
            self.imageBuilderSupported = imageBuilderSupported
            self.name = name
            self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case platform = "Platform"
            case arn = "Arn"
            case state = "State"
            case displayName = "DisplayName"
            case baseImageArn = "BaseImageArn"
            case applications = "Applications"
            case createdTime = "CreatedTime"
            case description = "Description"
            case stateChangeReason = "StateChangeReason"
            case imageBuilderSupported = "ImageBuilderSupported"
            case name = "Name"
            case publicBaseImageReleasedDate = "PublicBaseImageReleasedDate"
            case visibility = "Visibility"
        }
    }

    public struct CreateStackResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Stack", required: false, type: .structure)
        ]
        /// The details for the created stack.
        public let stack: Stack?

        public init(stack: Stack? = nil) {
            self.stack = stack
        }

        private enum CodingKeys: String, CodingKey {
            case stack = "Stack"
        }
    }

    public enum ImageState: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case available = "AVAILABLE"
        case failed = "FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public struct DeleteFleetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The name of the fleet to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AssociateFleetResult: AWSShape {
        /// The key for the payload

    }

    public struct DescribeSessionsResult: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Sessions", required: false, type: .list)
        ]
        /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
        public let nextToken: String?
        /// The list of streaming sessions.
        public let sessions: [Session]?

        public init(nextToken: String? = nil, sessions: [Session]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sessions = "Sessions"
        }
    }

}