// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Rekognition {

    public struct Landmark: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// x-coordinate from the top left of the landmark expressed as the ration of the width of the image. For example, if the images is 700x200 and the x-coordinate of the landmark is at 350 pixels, this value is 0.5. 
        public var x: Float? = nil
        /// Type of the landmark.
        public var type: String? = nil
        /// y-coordinate from the top left of the landmark expressed as the ration of the height of the image. For example, if the images is 700x200 and the y-coordinate of the landmark is at 100 pixels, this value is 0.5.
        public var y: Float? = nil

        public init() {}

        public init(x: Float? = nil, type: String? = nil, y: Float? = nil) {
            self.x = x
            self.type = type
            self.y = y
        }

        public init(dictionary: [String: Any]) throws {
            self.x = dictionary["X"] as? Float
            self.type = dictionary["Type"] as? String
            self.y = dictionary["Y"] as? Float
        }
    }

    public struct SearchFacesByImageResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The level of confidence that the searchedFaceBoundingBox, contains a face.
        public var searchedFaceConfidence: Float? = nil
        /// An array of faces that match the input face, along with the confidence in the match.
        public var faceMatches: [FaceMatch]? = nil
        /// The bounding box around the face in the input image that Amazon Rekognition used for the search.
        public var searchedFaceBoundingBox: BoundingBox? = nil

        public init() {}

        public init(searchedFaceConfidence: Float? = nil, faceMatches: [FaceMatch]? = nil, searchedFaceBoundingBox: BoundingBox? = nil) {
            self.searchedFaceConfidence = searchedFaceConfidence
            self.faceMatches = faceMatches
            self.searchedFaceBoundingBox = searchedFaceBoundingBox
        }

        public init(dictionary: [String: Any]) throws {
            self.searchedFaceConfidence = dictionary["SearchedFaceConfidence"] as? Float
            if let faceMatches = dictionary["FaceMatches"] as? [[String: Any]] {
                self.faceMatches = try faceMatches.map({ try FaceMatch(dictionary: $0) })
            }
            if let searchedFaceBoundingBox = dictionary["SearchedFaceBoundingBox"] as? [String: Any] { self.searchedFaceBoundingBox = try Rekognition.BoundingBox(dictionary: searchedFaceBoundingBox) }
        }
    }

    public struct DeleteCollectionResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// HTTP status code that indicates the result of the operation.
        public var statusCode: Int32? = nil

        public init() {}

        public init(statusCode: Int32? = nil) {
            self.statusCode = statusCode
        }

        public init(dictionary: [String: Any]) throws {
            self.statusCode = dictionary["StatusCode"] as? Int32
        }
    }

    public struct ListCollectionsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of collection IDs.
        public var collectionIds: [String]? = nil
        /// If the result is truncated, the response provides a NextToken that you can use in the subsequent request to fetch the next set of collection IDs.
        public var nextToken: String? = nil

        public init() {}

        public init(collectionIds: [String]? = nil, nextToken: String? = nil) {
            self.collectionIds = collectionIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let collectionIds = dictionary["CollectionIds"] as? [String] {
                self.collectionIds = collectionIds
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct Emotion: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Type of emotion detected.
        public var type: String? = nil

        public init() {}

        public init(confidence: Float? = nil, type: String? = nil) {
            self.confidence = confidence
            self.type = type
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.type = dictionary["Type"] as? String
        }
    }

    public struct DeleteFacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of face IDs to delete.
        public var faceIds: [String] = []
        /// Collection from which to remove the specific faces.
        public var collectionId: String = ""

        public init() {}

        public init(faceIds: [String], collectionId: String) {
            self.faceIds = faceIds
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let faceIds = dictionary["FaceIds"] as? [String] else { throw InitializableError.missingRequiredParam("FaceIds") }
            self.faceIds = faceIds
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct DeleteFacesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of strings (face IDs) of the faces that were deleted.
        public var deletedFaces: [String]? = nil

        public init() {}

        public init(deletedFaces: [String]? = nil) {
            self.deletedFaces = deletedFaces
        }

        public init(dictionary: [String: Any]) throws {
            if let deletedFaces = dictionary["DeletedFaces"] as? [String] {
                self.deletedFaces = deletedFaces
            }
        }
    }

    public struct BoundingBox: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Height of the bounding box as a ratio of the overall image height.
        public var height: Float? = nil
        /// Top coordinate of the bounding box as a ratio of overall image height.
        public var top: Float? = nil
        /// Left coordinate of the bounding box as a ratio of overall image width.
        public var left: Float? = nil
        /// Width of the bounding box as a ratio of the overall image width.
        public var width: Float? = nil

        public init() {}

        public init(height: Float? = nil, top: Float? = nil, left: Float? = nil, width: Float? = nil) {
            self.height = height
            self.top = top
            self.left = left
            self.width = width
        }

        public init(dictionary: [String: Any]) throws {
            self.height = dictionary["Height"] as? Float
            self.top = dictionary["Top"] as? Float
            self.left = dictionary["Left"] as? Float
            self.width = dictionary["Width"] as? Float
        }
    }

    public struct Pose: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Value representing the face rotation on the yaw axis.
        public var yaw: Float? = nil
        /// Value representing the face rotation on the roll axis.
        public var roll: Float? = nil
        /// Value representing the face rotation on the pitch axis.
        public var pitch: Float? = nil

        public init() {}

        public init(yaw: Float? = nil, roll: Float? = nil, pitch: Float? = nil) {
            self.yaw = yaw
            self.roll = roll
            self.pitch = pitch
        }

        public init(dictionary: [String: Any]) throws {
            self.yaw = dictionary["Yaw"] as? Float
            self.roll = dictionary["Roll"] as? Float
            self.pitch = dictionary["Pitch"] as? Float
        }
    }

    public struct ComparedFace: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence that what the bounding box contains is a face.
        public var confidence: Float? = nil
        public var boundingBox: BoundingBox? = nil

        public init() {}

        public init(confidence: Float? = nil, boundingBox: BoundingBox? = nil) {
            self.confidence = confidence
            self.boundingBox = boundingBox
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) }
        }
    }

    public struct SearchFacesByImageRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var image: Image = Image()
        /// (Optional) Specifies the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%.
        public var faceMatchThreshold: Float? = nil
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public var maxFaces: Int32? = nil
        /// ID of the collection to search.
        public var collectionId: String = ""

        public init() {}

        public init(image: Image, faceMatchThreshold: Float? = nil, maxFaces: Int32? = nil, collectionId: String) {
            self.image = image
            self.faceMatchThreshold = faceMatchThreshold
            self.maxFaces = maxFaces
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            self.faceMatchThreshold = dictionary["FaceMatchThreshold"] as? Float
            self.maxFaces = dictionary["MaxFaces"] as? Int32
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct FaceMatch: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var face: Face? = nil
        /// Confidence in the match of this face with the input face.
        public var similarity: Float? = nil

        public init() {}

        public init(face: Face? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        public init(dictionary: [String: Any]) throws {
            if let face = dictionary["Face"] as? [String: Any] { self.face = try Rekognition.Face(dictionary: face) }
            self.similarity = dictionary["Similarity"] as? Float
        }
    }

    public struct Gender: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Gender of the face.
        public var value: String? = nil

        public init() {}

        public init(confidence: Float? = nil, value: String? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? String
        }
    }

    public struct Smile: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the face is smiling or not.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct S3Object: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Name of the S3 bucket.
        public var bucket: String? = nil
        /// S3 object key name.
        public var name: String? = nil
        /// If the bucket is versioning enabled, you can specify the object version. 
        public var version: String? = nil

        public init() {}

        public init(bucket: String? = nil, name: String? = nil, version: String? = nil) {
            self.bucket = bucket
            self.name = name
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            self.bucket = dictionary["Bucket"] as? String
            self.name = dictionary["Name"] as? String
            self.version = dictionary["Version"] as? String
        }
    }

    public struct DetectFacesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The algorithm detects the image orientation. If it detects that the image was rotated, it returns the degrees of rotation. If your application is displaying the image, you can use this value to adjust the orientation.  For example, if the service detects that the input image was rotated by 90 degrees, it corrects orientation, performs face detection, and then returns the faces. That is, the bounding box coordinates in the response are based on the corrected orientation.   If the source image Exif metadata populates the orientation field, Amazon Rekognition does not perform orientation correction and the value of OrientationCorrection will be nil. 
        public var orientationCorrection: String? = nil
        /// Details of each face found in the image. 
        public var faceDetails: [FaceDetail]? = nil

        public init() {}

        public init(orientationCorrection: String? = nil, faceDetails: [FaceDetail]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.faceDetails = faceDetails
        }

        public init(dictionary: [String: Any]) throws {
            self.orientationCorrection = dictionary["OrientationCorrection"] as? String
            if let faceDetails = dictionary["FaceDetails"] as? [[String: Any]] {
                self.faceDetails = try faceDetails.map({ try FaceDetail(dictionary: $0) })
            }
        }
    }

    public struct IndexFacesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The algorithm detects the image orientation. If it detects that the image was rotated, it returns the degree of rotation. You can use this value to correct the orientation and also appropriately analyze the bounding box coordinates that are returned.   If the source image Exif metadata populates the orientation field, Amazon Rekognition does not perform orientation correction and the value of OrientationCorrection will be nil. 
        public var orientationCorrection: String? = nil
        /// An array of faces detected and added to the collection. For more information, see howitworks-index-faces. 
        public var faceRecords: [FaceRecord]? = nil

        public init() {}

        public init(orientationCorrection: String? = nil, faceRecords: [FaceRecord]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.faceRecords = faceRecords
        }

        public init(dictionary: [String: Any]) throws {
            self.orientationCorrection = dictionary["OrientationCorrection"] as? String
            if let faceRecords = dictionary["FaceRecords"] as? [[String: Any]] {
                self.faceRecords = try faceRecords.map({ try FaceRecord(dictionary: $0) })
            }
        }
    }

    public struct Label: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence.
        public var confidence: Float? = nil
        /// The name (label) of the object.
        public var name: String? = nil

        public init() {}

        public init(confidence: Float? = nil, name: String? = nil) {
            self.confidence = confidence
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.name = dictionary["Name"] as? String
        }
    }

    public struct FaceDetail: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates whether or not the face is wearing sunglasses, and the confidence level in the determination.
        public var sunglasses: Sunglasses? = nil
        /// Gender of the face and the confidence level in the determination.
        public var gender: Gender? = nil
        /// Indicates whether or not the eyes on the face are open, and the confidence level in the determination.
        public var eyesOpen: EyeOpen? = nil
        /// Indicates whether or not the face is smiling, and the confidence level in the determination.
        public var smile: Smile? = nil
        /// Indicates whether or not the mouth on the face is open, and the confidence level in the determination.
        public var mouthOpen: MouthOpen? = nil
        /// Bounding box of the face.
        public var boundingBox: BoundingBox? = nil
        /// Indicates the pose of the face as determined by pitch, roll, and the yaw.
        public var pose: Pose? = nil
        /// The estimated age range, in years, for the face. Low represents the lowest estimated age and High represents the highest estimated age.
        public var ageRange: AgeRange? = nil
        /// Indicates whether or not the face is wearing eye glasses, and the confidence level in the determination.
        public var eyeglasses: Eyeglasses? = nil
        /// Indicates the location of the landmark on the face.
        public var landmarks: [Landmark]? = nil
        /// Indicates whether or not the face has a beard, and the confidence level in the determination.
        public var beard: Beard? = nil
        /// Identifies image brightness and sharpness.
        public var quality: ImageQuality? = nil
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree).
        public var confidence: Float? = nil
        /// Indicates whether or not the face has a mustache, and the confidence level in the determination.
        public var mustache: Mustache? = nil
        /// The emotions detected on the face, and the confidence level in the determination. For example, HAPPY, SAD, and ANGRY. 
        public var emotions: [Emotion]? = nil

        public init() {}

        public init(sunglasses: Sunglasses? = nil, gender: Gender? = nil, eyesOpen: EyeOpen? = nil, smile: Smile? = nil, mouthOpen: MouthOpen? = nil, boundingBox: BoundingBox? = nil, pose: Pose? = nil, ageRange: AgeRange? = nil, eyeglasses: Eyeglasses? = nil, landmarks: [Landmark]? = nil, beard: Beard? = nil, quality: ImageQuality? = nil, confidence: Float? = nil, mustache: Mustache? = nil, emotions: [Emotion]? = nil) {
            self.sunglasses = sunglasses
            self.gender = gender
            self.eyesOpen = eyesOpen
            self.smile = smile
            self.mouthOpen = mouthOpen
            self.boundingBox = boundingBox
            self.pose = pose
            self.ageRange = ageRange
            self.eyeglasses = eyeglasses
            self.landmarks = landmarks
            self.beard = beard
            self.quality = quality
            self.confidence = confidence
            self.mustache = mustache
            self.emotions = emotions
        }

        public init(dictionary: [String: Any]) throws {
            if let sunglasses = dictionary["Sunglasses"] as? [String: Any] { self.sunglasses = try Rekognition.Sunglasses(dictionary: sunglasses) }
            if let gender = dictionary["Gender"] as? [String: Any] { self.gender = try Rekognition.Gender(dictionary: gender) }
            if let eyesOpen = dictionary["EyesOpen"] as? [String: Any] { self.eyesOpen = try Rekognition.EyeOpen(dictionary: eyesOpen) }
            if let smile = dictionary["Smile"] as? [String: Any] { self.smile = try Rekognition.Smile(dictionary: smile) }
            if let mouthOpen = dictionary["MouthOpen"] as? [String: Any] { self.mouthOpen = try Rekognition.MouthOpen(dictionary: mouthOpen) }
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) }
            if let pose = dictionary["Pose"] as? [String: Any] { self.pose = try Rekognition.Pose(dictionary: pose) }
            if let ageRange = dictionary["AgeRange"] as? [String: Any] { self.ageRange = try Rekognition.AgeRange(dictionary: ageRange) }
            if let eyeglasses = dictionary["Eyeglasses"] as? [String: Any] { self.eyeglasses = try Rekognition.Eyeglasses(dictionary: eyeglasses) }
            if let landmarks = dictionary["Landmarks"] as? [[String: Any]] {
                self.landmarks = try landmarks.map({ try Landmark(dictionary: $0) })
            }
            if let beard = dictionary["Beard"] as? [String: Any] { self.beard = try Rekognition.Beard(dictionary: beard) }
            if let quality = dictionary["Quality"] as? [String: Any] { self.quality = try Rekognition.ImageQuality(dictionary: quality) }
            self.confidence = dictionary["Confidence"] as? Float
            if let mustache = dictionary["Mustache"] as? [String: Any] { self.mustache = try Rekognition.Mustache(dictionary: mustache) }
            if let emotions = dictionary["Emotions"] as? [[String: Any]] {
                self.emotions = try emotions.map({ try Emotion(dictionary: $0) })
            }
        }
    }

    public struct CompareFacesMatch: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Provides face metadata (bounding box and confidence that the bounding box actually contains a face).
        public var face: ComparedFace? = nil
        /// Level of confidence that the faces match.
        public var similarity: Float? = nil

        public init() {}

        public init(face: ComparedFace? = nil, similarity: Float? = nil) {
            self.face = face
            self.similarity = similarity
        }

        public init(dictionary: [String: Any]) throws {
            if let face = dictionary["Face"] as? [String: Any] { self.face = try Rekognition.ComparedFace(dictionary: face) }
            self.similarity = dictionary["Similarity"] as? Float
        }
    }

    public struct SearchFacesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of faces that matched the input face, along with the confidence in the match.
        public var faceMatches: [FaceMatch]? = nil
        /// ID of the face that was searched for matches in a collection.
        public var searchedFaceId: String? = nil

        public init() {}

        public init(faceMatches: [FaceMatch]? = nil, searchedFaceId: String? = nil) {
            self.faceMatches = faceMatches
            self.searchedFaceId = searchedFaceId
        }

        public init(dictionary: [String: Any]) throws {
            if let faceMatches = dictionary["FaceMatches"] as? [[String: Any]] {
                self.faceMatches = try faceMatches.map({ try FaceMatch(dictionary: $0) })
            }
            self.searchedFaceId = dictionary["SearchedFaceId"] as? String
        }
    }

    public struct SearchFacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Optional value specifying the minimum confidence in the face match to return. For example, don't return any matches where confidence in matches is less than 70%.
        public var faceMatchThreshold: Float? = nil
        /// Maximum number of faces to return. The operation returns the maximum number of faces with the highest confidence in the match.
        public var maxFaces: Int32? = nil
        /// ID of the collection the face belongs to.
        public var collectionId: String = ""
        /// ID of a face to find matches for in the collection.
        public var faceId: String = ""

        public init() {}

        public init(faceMatchThreshold: Float? = nil, maxFaces: Int32? = nil, collectionId: String, faceId: String) {
            self.faceMatchThreshold = faceMatchThreshold
            self.maxFaces = maxFaces
            self.collectionId = collectionId
            self.faceId = faceId
        }

        public init(dictionary: [String: Any]) throws {
            self.faceMatchThreshold = dictionary["FaceMatchThreshold"] as? Float
            self.maxFaces = dictionary["MaxFaces"] as? Int32
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
            guard let faceId = dictionary["FaceId"] as? String else { throw InitializableError.missingRequiredParam("FaceId") }
            self.faceId = faceId
        }
    }

    public struct Mustache: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the face has mustache or not.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct ListCollectionsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Pagination token from the previous response.
        public var nextToken: String? = nil
        /// Maximum number of collection IDs to return.
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct EyeOpen: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the eyes on the face are open.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct DetectLabelsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The input image. You can provide a blob of image bytes or an S3 object.
        public var image: Image = Image()
        /// Maximum number of labels you want the service to return in the response. The service returns the specified number of highest confidence labels. 
        public var maxLabels: Int32? = nil
        /// Specifies the minimum confidence level for the labels to return. Amazon Rekognition doesn't return any labels with confidence lower than this specified value. If minConfidence is not specified, the operation returns labels with a confidence values greater than or equal to 50 percent.
        public var minConfidence: Float? = nil

        public init() {}

        public init(image: Image, maxLabels: Int32? = nil, minConfidence: Float? = nil) {
            self.image = image
            self.maxLabels = maxLabels
            self.minConfidence = minConfidence
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            self.maxLabels = dictionary["MaxLabels"] as? Int32
            self.minConfidence = dictionary["MinConfidence"] as? Float
        }
    }

    public struct CreateCollectionResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Amazon Resource Name (ARN) of the collection. You can use this to manage permissions on your resources. 
        public var collectionArn: String? = nil
        /// HTTP status code indicating the result of the operation.
        public var statusCode: Int32? = nil

        public init() {}

        public init(collectionArn: String? = nil, statusCode: Int32? = nil) {
            self.collectionArn = collectionArn
            self.statusCode = statusCode
        }

        public init(dictionary: [String: Any]) throws {
            self.collectionArn = dictionary["CollectionArn"] as? String
            self.statusCode = dictionary["StatusCode"] as? Int32
        }
    }

    public struct DetectFacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The image in which you want to detect faces. You can specify a blob or an S3 object. 
        public var image: Image = Image()
        /// A list of facial attributes you would like to be returned. By default, the API returns subset of facial attributes.  For example, you can specify the value as, ["ALL"] or ["DEFAULT"]. If you provide both, ["ALL", "DEFAULT"], the service uses a logical AND operator to determine which attributes to return (in this case, it is all attributes). If you specify all attributes, Amazon Rekognition performs additional detection. 
        public var attributes: [String]? = nil

        public init() {}

        public init(image: Image, attributes: [String]? = nil) {
            self.image = image
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            if let attributes = dictionary["Attributes"] as? [String] {
                self.attributes = attributes
            }
        }
    }

    public struct FaceRecord: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var face: Face? = nil
        public var faceDetail: FaceDetail? = nil

        public init() {}

        public init(face: Face? = nil, faceDetail: FaceDetail? = nil) {
            self.face = face
            self.faceDetail = faceDetail
        }

        public init(dictionary: [String: Any]) throws {
            if let face = dictionary["Face"] as? [String: Any] { self.face = try Rekognition.Face(dictionary: face) }
            if let faceDetail = dictionary["FaceDetail"] as? [String: Any] { self.faceDetail = try Rekognition.FaceDetail(dictionary: faceDetail) }
        }
    }

    public struct Beard: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the face has beard or not.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct Face: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var boundingBox: BoundingBox? = nil
        /// Identifier that you assign to all the faces in the input image.
        public var externalImageId: String? = nil
        /// Confidence level that the bounding box contains a face (and not a different object such as a tree).
        public var confidence: Float? = nil
        /// Unique identifier that Amazon Rekognition assigns to the face.
        public var faceId: String? = nil
        /// Unique identifier that Amazon Rekognition assigns to the source image.
        public var imageId: String? = nil

        public init() {}

        public init(boundingBox: BoundingBox? = nil, externalImageId: String? = nil, confidence: Float? = nil, faceId: String? = nil, imageId: String? = nil) {
            self.boundingBox = boundingBox
            self.externalImageId = externalImageId
            self.confidence = confidence
            self.faceId = faceId
            self.imageId = imageId
        }

        public init(dictionary: [String: Any]) throws {
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) }
            self.externalImageId = dictionary["ExternalImageId"] as? String
            self.confidence = dictionary["Confidence"] as? Float
            self.faceId = dictionary["FaceId"] as? String
            self.imageId = dictionary["ImageId"] as? String
        }
    }

    public struct CompareFacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Source image either as bytes or an S3 object
        public var sourceImage: Image = Image()
        /// Target image either as bytes or an S3 object
        public var targetImage: Image = Image()
        /// The minimum level of confidence in the match you want included in the result.
        public var similarityThreshold: Float? = nil

        public init() {}

        public init(sourceImage: Image, targetImage: Image, similarityThreshold: Float? = nil) {
            self.sourceImage = sourceImage
            self.targetImage = targetImage
            self.similarityThreshold = similarityThreshold
        }

        public init(dictionary: [String: Any]) throws {
            guard let sourceImage = dictionary["SourceImage"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SourceImage") }
            self.sourceImage = try Rekognition.Image(dictionary: sourceImage)
            guard let targetImage = dictionary["TargetImage"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TargetImage") }
            self.targetImage = try Rekognition.Image(dictionary: targetImage)
            self.similarityThreshold = dictionary["SimilarityThreshold"] as? Float
        }
    }

    public struct Sunglasses: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the face is wearing sunglasses or not.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct MouthOpen: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the mouth on the face is open or not.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct Image: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Blob of image bytes up to 5 MBs.
        public var bytes: Data? = nil
        /// Identifies an S3 object as the image source.
        public var s3Object: S3Object? = nil

        public init() {}

        public init(bytes: Data? = nil, s3Object: S3Object? = nil) {
            self.bytes = bytes
            self.s3Object = s3Object
        }

        public init(dictionary: [String: Any]) throws {
            self.bytes = dictionary["Bytes"] as? Data
            if let s3Object = dictionary["S3Object"] as? [String: Any] { self.s3Object = try Rekognition.S3Object(dictionary: s3Object) }
        }
    }

    public struct CompareFacesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Provides an array of CompareFacesMatch objects. Each object provides the bounding box, confidence that the bounding box contains a face, and the similarity between the face in the bounding box and the face in the source image.
        public var faceMatches: [CompareFacesMatch]? = nil
        /// The face from the source image that was used for comparison.
        public var sourceImageFace: ComparedSourceImageFace? = nil

        public init() {}

        public init(faceMatches: [CompareFacesMatch]? = nil, sourceImageFace: ComparedSourceImageFace? = nil) {
            self.faceMatches = faceMatches
            self.sourceImageFace = sourceImageFace
        }

        public init(dictionary: [String: Any]) throws {
            if let faceMatches = dictionary["FaceMatches"] as? [[String: Any]] {
                self.faceMatches = try faceMatches.map({ try CompareFacesMatch(dictionary: $0) })
            }
            if let sourceImageFace = dictionary["SourceImageFace"] as? [String: Any] { self.sourceImageFace = try Rekognition.ComparedSourceImageFace(dictionary: sourceImageFace) }
        }
    }

    public struct AgeRange: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The highest estimated age.
        public var high: Int32? = nil
        /// The lowest estimated age.
        public var low: Int32? = nil

        public init() {}

        public init(high: Int32? = nil, low: Int32? = nil) {
            self.high = high
            self.low = low
        }

        public init(dictionary: [String: Any]) throws {
            self.high = dictionary["High"] as? Int32
            self.low = dictionary["Low"] as? Int32
        }
    }

    public struct Eyeglasses: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Level of confidence in the determination.
        public var confidence: Float? = nil
        /// Boolean value that indicates whether the face is wearing eye glasses or not.
        public var value: Bool? = nil

        public init() {}

        public init(confidence: Float? = nil, value: Bool? = nil) {
            self.confidence = confidence
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            self.value = dictionary["Value"] as? Bool
        }
    }

    public struct DeleteCollectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ID of the collection to delete.
        public var collectionId: String = ""

        public init() {}

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct CreateCollectionRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ID for the collection that you are creating.
        public var collectionId: String = ""

        public init() {}

        public init(collectionId: String) {
            self.collectionId = collectionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
        }
    }

    public struct ListFacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Rekognition returns a pagination token in the response. You can use this pagination token to retrieve the next set of faces.
        public var nextToken: String? = nil
        /// ID of the collection from which to list the faces.
        public var collectionId: String = ""
        /// Maximum number of faces to return.
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, collectionId: String, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.collectionId = collectionId
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ImageQuality: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Value representing sharpness of the face.
        public var sharpness: Float? = nil
        /// Value representing brightness of the face. The service returns a value between 0 and 1 (inclusive).
        public var brightness: Float? = nil

        public init() {}

        public init(sharpness: Float? = nil, brightness: Float? = nil) {
            self.sharpness = sharpness
            self.brightness = brightness
        }

        public init(dictionary: [String: Any]) throws {
            self.sharpness = dictionary["Sharpness"] as? Float
            self.brightness = dictionary["Brightness"] as? Float
        }
    }

    public struct DetectLabelsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Amazon Rekognition returns the orientation of the input image that was detected (clockwise direction). If your application displays the image, you can use this value to correct the orientation. If Amazon Rekognition detects that the input image was rotated (for example, by 90 degrees), it first corrects the orientation before detecting the labels.   If the source image Exif metadata populates the orientation field, Amazon Rekognition does not perform orientation correction and the value of OrientationCorrection will be nil. 
        public var orientationCorrection: String? = nil
        /// An array of labels for the real-world objects detected. 
        public var labels: [Label]? = nil

        public init() {}

        public init(orientationCorrection: String? = nil, labels: [Label]? = nil) {
            self.orientationCorrection = orientationCorrection
            self.labels = labels
        }

        public init(dictionary: [String: Any]) throws {
            self.orientationCorrection = dictionary["OrientationCorrection"] as? String
            if let labels = dictionary["Labels"] as? [[String: Any]] {
                self.labels = try labels.map({ try Label(dictionary: $0) })
            }
        }
    }

    public struct ListFacesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An array of Face objects. 
        public var faces: [Face]? = nil
        /// If the response is truncated, Amazon Rekognition returns this token that you can use in the subsequent request to retrieve the next set of faces.
        public var nextToken: String? = nil

        public init() {}

        public init(faces: [Face]? = nil, nextToken: String? = nil) {
            self.faces = faces
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let faces = dictionary["Faces"] as? [[String: Any]] {
                self.faces = try faces.map({ try Face(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct IndexFacesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var image: Image = Image()
        /// ID you want to assign to all the faces detected in the image.
        public var externalImageId: String? = nil
        /// ID of an existing collection to which you want to add the faces that are detected in the input images.
        public var collectionId: String = ""
        /// (Optional) Returns detailed attributes of indexed faces. By default, the operation returns a subset of the facial attributes.  For example, you can specify the value as, ["ALL"] or ["DEFAULT"]. If you provide both, ["ALL", "DEFAULT"], Amazon Rekognition uses the logical AND operator to determine which attributes to return (in this case, it is all attributes). If you specify all attributes, the service performs additional detection, in addition to the default. 
        public var detectionAttributes: [String]? = nil

        public init() {}

        public init(image: Image, externalImageId: String? = nil, collectionId: String, detectionAttributes: [String]? = nil) {
            self.image = image
            self.externalImageId = externalImageId
            self.collectionId = collectionId
            self.detectionAttributes = detectionAttributes
        }

        public init(dictionary: [String: Any]) throws {
            guard let image = dictionary["Image"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Image") }
            self.image = try Rekognition.Image(dictionary: image)
            self.externalImageId = dictionary["ExternalImageId"] as? String
            guard let collectionId = dictionary["CollectionId"] as? String else { throw InitializableError.missingRequiredParam("CollectionId") }
            self.collectionId = collectionId
            if let detectionAttributes = dictionary["DetectionAttributes"] as? [String] {
                self.detectionAttributes = detectionAttributes
            }
        }
    }

    public struct ComparedSourceImageFace: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Confidence level that the selected bounding box contains a face.
        public var confidence: Float? = nil
        public var boundingBox: BoundingBox? = nil

        public init() {}

        public init(confidence: Float? = nil, boundingBox: BoundingBox? = nil) {
            self.confidence = confidence
            self.boundingBox = boundingBox
        }

        public init(dictionary: [String: Any]) throws {
            self.confidence = dictionary["Confidence"] as? Float
            if let boundingBox = dictionary["BoundingBox"] as? [String: Any] { self.boundingBox = try Rekognition.BoundingBox(dictionary: boundingBox) }
        }
    }

}