// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Sdb {

    public struct ReplaceableAttribute: Serializable, Initializable {
        /// The value of the replaceable attribute.
        var value: String = ""
        /// The name of the replaceable attribute.
        var name: String = ""
        /// A flag specifying whether or not to replace the attribute/value pair or to add a new attribute/value pair. The default setting is false.
        var replace: Bool? = nil

        public init() {}

        public init(value: String, name: String, replace: Bool? = nil) {
            self.value = value
            self.name = name
            self.replace = replace
        }

    }

    public struct GetAttributesRequest: Serializable, Initializable {
        /// Determines whether or not strong consistency should be enforced when data is read from SimpleDB. If true, any data previously written to SimpleDB will be returned. Otherwise, results will be consistent eventually, and the client may not see data that was written immediately before your read.
        var consistentRead: Bool? = nil
        /// The name of the item.
        var itemName: String = ""
        /// The name of the domain in which to perform the operation.
        var domainName: String = ""
        /// The names of the attributes.
        var attributeNames: [String]? = nil

        public init() {}

        public init(consistentRead: Bool? = nil, itemName: String, domainName: String, attributeNames: [String]? = nil) {
            self.consistentRead = consistentRead
            self.itemName = itemName
            self.domainName = domainName
            self.attributeNames = attributeNames
        }

    }

    public struct ListDomainsRequest: Serializable, Initializable {
        /// The maximum number of domain names you want returned. The range is 1 to 100. The default setting is 100.
        var maxNumberOfDomains: Int32? = nil
        /// A string informing Amazon SimpleDB where to start the next list of domain names.
        var nextToken: String? = nil

        public init() {}

        public init(maxNumberOfDomains: Int32? = nil, nextToken: String? = nil) {
            self.maxNumberOfDomains = maxNumberOfDomains
            self.nextToken = nextToken
        }

    }

    public struct GetAttributesResult: Serializable, Initializable {
        /// The list of attributes returned by the operation.
        var attributes: [Attribute]? = nil

        public init() {}

        public init(attributes: [Attribute]? = nil) {
            self.attributes = attributes
        }

    }

    public struct SelectRequest: Serializable, Initializable {
        /// Determines whether or not strong consistency should be enforced when data is read from SimpleDB. If true, any data previously written to SimpleDB will be returned. Otherwise, results will be consistent eventually, and the client may not see data that was written immediately before your read.
        var consistentRead: Bool? = nil
        /// A string informing Amazon SimpleDB where to start the next list of ItemNames.
        var nextToken: String? = nil
        /// The expression used to query the domain.
        var selectExpression: String = ""

        public init() {}

        public init(consistentRead: Bool? = nil, nextToken: String? = nil, selectExpression: String) {
            self.consistentRead = consistentRead
            self.nextToken = nextToken
            self.selectExpression = selectExpression
        }

    }

    public struct BatchDeleteAttributesRequest: Serializable, Initializable {
        /// A list of items on which to perform the operation.
        var items: [DeletableItem] = []
        /// The name of the domain in which the attributes are being deleted.
        var domainName: String = ""

        public init() {}

        public init(items: [DeletableItem], domainName: String) {
            self.items = items
            self.domainName = domainName
        }

    }

    public struct DomainMetadataResult: Serializable, Initializable {
        /// The data and time when metadata was calculated, in Epoch (UNIX) seconds.
        var timestamp: Int32? = nil
        /// The total size of all unique attribute names in the domain, in bytes.
        var attributeNamesSizeBytes: Int64? = nil
        /// The total size of all attribute values in the domain, in bytes.
        var attributeValuesSizeBytes: Int64? = nil
        /// The number of all items in the domain.
        var itemCount: Int32? = nil
        /// The number of all attribute name/value pairs in the domain.
        var attributeValueCount: Int32? = nil
        /// The number of unique attribute names in the domain.
        var attributeNameCount: Int32? = nil
        /// The total size of all item names in the domain, in bytes.
        var itemNamesSizeBytes: Int64? = nil

        public init() {}

        public init(timestamp: Int32? = nil, attributeNamesSizeBytes: Int64? = nil, attributeValuesSizeBytes: Int64? = nil, itemCount: Int32? = nil, attributeValueCount: Int32? = nil, attributeNameCount: Int32? = nil, itemNamesSizeBytes: Int64? = nil) {
            self.timestamp = timestamp
            self.attributeNamesSizeBytes = attributeNamesSizeBytes
            self.attributeValuesSizeBytes = attributeValuesSizeBytes
            self.itemCount = itemCount
            self.attributeValueCount = attributeValueCount
            self.attributeNameCount = attributeNameCount
            self.itemNamesSizeBytes = itemNamesSizeBytes
        }

    }

    public struct Item: Serializable, Initializable {
        var alternateNameEncoding: String? = nil
        /// The name of the item.
        var name: String = ""
        /// A list of attributes.
        var attributes: [Attribute] = []

        public init() {}

        public init(alternateNameEncoding: String? = nil, name: String, attributes: [Attribute]) {
            self.alternateNameEncoding = alternateNameEncoding
            self.name = name
            self.attributes = attributes
        }

    }

    public struct Attribute: Serializable, Initializable {
        var alternateNameEncoding: String? = nil
        var alternateValueEncoding: String? = nil
        /// The name of the attribute.
        var name: String = ""
        /// The value of the attribute.
        var value: String = ""

        public init() {}

        public init(alternateNameEncoding: String? = nil, alternateValueEncoding: String? = nil, name: String, value: String) {
            self.alternateNameEncoding = alternateNameEncoding
            self.alternateValueEncoding = alternateValueEncoding
            self.name = name
            self.value = value
        }

    }

    public struct DomainMetadataRequest: Serializable, Initializable {
        /// The name of the domain for which to display the metadata of.
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

    public struct DeleteDomainRequest: Serializable, Initializable {
        /// The name of the domain to delete.
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

    public struct BatchPutAttributesRequest: Serializable, Initializable {
        /// A list of items on which to perform the operation.
        var items: [ReplaceableItem] = []
        /// The name of the domain in which the attributes are being stored.
        var domainName: String = ""

        public init() {}

        public init(items: [ReplaceableItem], domainName: String) {
            self.items = items
            self.domainName = domainName
        }

    }

    public struct ReplaceableItem: Serializable, Initializable {
        /// The name of the replaceable item.
        var name: String = ""
        /// The list of attributes for a replaceable item.
        var attributes: [ReplaceableAttribute] = []

        public init() {}

        public init(name: String, attributes: [ReplaceableAttribute]) {
            self.name = name
            self.attributes = attributes
        }

    }

    public struct DeletableItem: Serializable, Initializable {
        var name: String = ""
        var attributes: [DeletableAttribute]? = nil

        public init() {}

        public init(name: String, attributes: [DeletableAttribute]? = nil) {
            self.name = name
            self.attributes = attributes
        }

    }

    public struct UpdateCondition: Serializable, Initializable {
        /// The value of an attribute. This value can only be specified when the Exists parameter is equal to true.
        var value: String? = nil
        /// The name of the attribute involved in the condition.
        var name: String? = nil
        /// A value specifying whether or not the specified attribute must exist with the specified value in order for the update condition to be satisfied. Specify true if the attribute must exist for the update condition to be satisfied. Specify false if the attribute should not exist in order for the update condition to be satisfied.
        var exists: Bool? = nil

        public init() {}

        public init(value: String? = nil, name: String? = nil, exists: Bool? = nil) {
            self.value = value
            self.name = name
            self.exists = exists
        }

    }

    public struct PutAttributesRequest: Serializable, Initializable {
        /// The name of the item.
        var itemName: String = ""
        /// The list of attributes.
        var attributes: [ReplaceableAttribute] = []
        /// The name of the domain in which to perform the operation.
        var domainName: String = ""
        /// The update condition which, if specified, determines whether the specified attributes will be updated or not. The update condition must be satisfied in order for this request to be processed and the attributes to be updated.
        var expected: UpdateCondition? = nil

        public init() {}

        public init(itemName: String, attributes: [ReplaceableAttribute], domainName: String, expected: UpdateCondition? = nil) {
            self.itemName = itemName
            self.attributes = attributes
            self.domainName = domainName
            self.expected = expected
        }

    }

    public struct DeletableAttribute: Serializable, Initializable {
        /// The value of the attribute.
        var value: String? = nil
        /// The name of the attribute.
        var name: String = ""

        public init() {}

        public init(value: String? = nil, name: String) {
            self.value = value
            self.name = name
        }

    }

    public struct DeleteAttributesRequest: Serializable, Initializable {
        /// The name of the item. Similar to rows on a spreadsheet, items represent individual objects that contain one or more value-attribute pairs.
        var itemName: String = ""
        /// A list of Attributes. Similar to columns on a spreadsheet, attributes represent categories of data that can be assigned to items.
        var attributes: [DeletableAttribute]? = nil
        /// The name of the domain in which to perform the operation.
        var domainName: String = ""
        /// The update condition which, if specified, determines whether the specified attributes will be deleted or not. The update condition must be satisfied in order for this request to be processed and the attributes to be deleted.
        var expected: UpdateCondition? = nil

        public init() {}

        public init(itemName: String, attributes: [DeletableAttribute]? = nil, domainName: String, expected: UpdateCondition? = nil) {
            self.itemName = itemName
            self.attributes = attributes
            self.domainName = domainName
            self.expected = expected
        }

    }

    public struct ListDomainsResult: Serializable, Initializable {
        /// An opaque token indicating that there are more domains than the specified MaxNumberOfDomains still available.
        var nextToken: String? = nil
        /// A list of domain names that match the expression.
        var domainNames: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, domainNames: [String]? = nil) {
            self.nextToken = nextToken
            self.domainNames = domainNames
        }

    }

    public struct SelectResult: Serializable, Initializable {
        /// A list of items that match the select expression.
        var items: [Item]? = nil
        /// An opaque token indicating that more items than MaxNumberOfItems were matched, the response size exceeded 1 megabyte, or the execution time exceeded 5 seconds.
        var nextToken: String? = nil

        public init() {}

        public init(items: [Item]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

    }

    public struct CreateDomainRequest: Serializable, Initializable {
        /// The name of the domain to create. The name can range between 3 and 255 characters and can contain the following characters: a-z, A-Z, 0-9, '_', '-', and '.'.
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

}