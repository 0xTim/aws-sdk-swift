// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Dms {

    public struct ModifyReplicationSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The modified replication subnet group.
        public var replicationSubnetGroup: ReplicationSubnetGroup? = nil

        public init() {}

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationSubnetGroup = dictionary["ReplicationSubnetGroup"] as? [String: Any] { self.replicationSubnetGroup = try Dms.ReplicationSubnetGroup(dictionary: replicationSubnetGroup) }
        }
    }

    public struct CreateReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication task that was created.
        public var replicationTask: ReplicationTask? = nil

        public init() {}

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationTask = dictionary["ReplicationTask"] as? [String: Any] { self.replicationTask = try Dms.ReplicationTask(dictionary: replicationTask) }
        }
    }

    public struct CreateReplicationSubnetGroupMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The EC2 subnet IDs for the subnet group.
        public var subnetIds: [String] = []
        /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup 
        public var replicationSubnetGroupIdentifier: String = ""
        /// The description for the subnet group.
        public var replicationSubnetGroupDescription: String = ""
        /// The tag to be assigned to the subnet group.
        public var tags: [Tag]? = nil

        public init() {}

        public init(subnetIds: [String], replicationSubnetGroupIdentifier: String, replicationSubnetGroupDescription: String, tags: [Tag]? = nil) {
            self.subnetIds = subnetIds
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetIds = dictionary["SubnetIds"] as? [String] else { throw InitializableError.missingRequiredParam("SubnetIds") }
            self.subnetIds = subnetIds
            guard let replicationSubnetGroupIdentifier = dictionary["ReplicationSubnetGroupIdentifier"] as? String else { throw InitializableError.missingRequiredParam("ReplicationSubnetGroupIdentifier") }
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            guard let replicationSubnetGroupDescription = dictionary["ReplicationSubnetGroupDescription"] as? String else { throw InitializableError.missingRequiredParam("ReplicationSubnetGroupDescription") }
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
        }
    }

    public struct ModifyEndpointResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The modified endpoint.
        public var endpoint: Endpoint? = nil

        public init() {}

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        public init(dictionary: [String: Any]) throws {
            if let endpoint = dictionary["Endpoint"] as? [String: Any] { self.endpoint = try Dms.Endpoint(dictionary: endpoint) }
        }
    }

    public struct DescribeReplicationSubnetGroupsMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Filters applied to the describe action.
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct DescribeEndpointsMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Filters applied to the describe action. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct DeleteEndpointMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String = ""

        public init() {}

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let endpointArn = dictionary["EndpointArn"] as? String else { throw InitializableError.missingRequiredParam("EndpointArn") }
            self.endpointArn = endpointArn
        }
    }

    public struct Endpoint: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The KMS key identifier that will be used to encrypt the connection parameters. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public var kmsKeyId: String? = nil
        /// The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: String? = nil
        /// The user name used to connect to the endpoint.
        public var username: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String? = nil
        /// The status of the endpoint.
        public var status: String? = nil
        /// The type of endpoint.
        public var endpointType: String? = nil
        /// The name of the server at the endpoint.
        public var serverName: String? = nil
        /// The name of the database at the endpoint.
        public var databaseName: String? = nil
        /// The SSL mode used to connect to the endpoint. SSL mode can be one of four values: none, require, verify-ca, verify-full.  The default value is none.
        public var sslMode: String? = nil
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public var certificateArn: String? = nil
        /// The database engine name. Valid values include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, SYBASE, and SQLSERVER.
        public var engineName: String? = nil
        /// The port value used to access the endpoint.
        public var port: Int32? = nil
        /// Additional connection attributes used to connect to the endpoint.
        public var extraConnectionAttributes: String? = nil

        public init() {}

        public init(kmsKeyId: String? = nil, endpointIdentifier: String? = nil, username: String? = nil, endpointArn: String? = nil, status: String? = nil, endpointType: String? = nil, serverName: String? = nil, databaseName: String? = nil, sslMode: String? = nil, certificateArn: String? = nil, engineName: String? = nil, port: Int32? = nil, extraConnectionAttributes: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.endpointIdentifier = endpointIdentifier
            self.username = username
            self.endpointArn = endpointArn
            self.status = status
            self.endpointType = endpointType
            self.serverName = serverName
            self.databaseName = databaseName
            self.sslMode = sslMode
            self.certificateArn = certificateArn
            self.engineName = engineName
            self.port = port
            self.extraConnectionAttributes = extraConnectionAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
            self.endpointIdentifier = dictionary["EndpointIdentifier"] as? String
            self.username = dictionary["Username"] as? String
            self.endpointArn = dictionary["EndpointArn"] as? String
            self.status = dictionary["Status"] as? String
            self.endpointType = dictionary["EndpointType"] as? String
            self.serverName = dictionary["ServerName"] as? String
            self.databaseName = dictionary["DatabaseName"] as? String
            self.sslMode = dictionary["SslMode"] as? String
            self.certificateArn = dictionary["CertificateArn"] as? String
            self.engineName = dictionary["EngineName"] as? String
            self.port = dictionary["Port"] as? Int32
            self.extraConnectionAttributes = dictionary["ExtraConnectionAttributes"] as? String
        }
    }

    public struct DescribeOrderableReplicationInstancesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The order-able replication instances available.
        public var orderableReplicationInstances: [OrderableReplicationInstance]? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil

        public init() {}

        public init(orderableReplicationInstances: [OrderableReplicationInstance]? = nil, marker: String? = nil) {
            self.orderableReplicationInstances = orderableReplicationInstances
            self.marker = marker
        }

        public init(dictionary: [String: Any]) throws {
            if let orderableReplicationInstances = dictionary["OrderableReplicationInstances"] as? [[String: Any]] {
                self.orderableReplicationInstances = try orderableReplicationInstances.map({ try OrderableReplicationInstance(dictionary: $0) })
            }
            self.marker = dictionary["Marker"] as? String
        }
    }

    public struct DescribeTableStatisticsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// The table statistics.
        public var tableStatistics: [TableStatistics]? = nil
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: String? = nil

        public init() {}

        public init(marker: String? = nil, tableStatistics: [TableStatistics]? = nil, replicationTaskArn: String? = nil) {
            self.marker = marker
            self.tableStatistics = tableStatistics
            self.replicationTaskArn = replicationTaskArn
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let tableStatistics = dictionary["TableStatistics"] as? [[String: Any]] {
                self.tableStatistics = try tableStatistics.map({ try TableStatistics(dictionary: $0) })
            }
            self.replicationTaskArn = dictionary["ReplicationTaskArn"] as? String
        }
    }

    public struct DescribeEndpointTypesMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Filters applied to the describe action. Valid filter names: engine-name | endpoint-type
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct DeleteReplicationInstanceMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
        public var replicationInstanceArn: String = ""

        public init() {}

        public init(replicationInstanceArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceArn") }
            self.replicationInstanceArn = replicationInstanceArn
        }
    }

    public struct SupportedEndpointType: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The database engine name. Valid values include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, SYBASE, and SQLSERVER.
        public var engineName: String? = nil
        /// The type of endpoint.
        public var endpointType: String? = nil
        /// Indicates if Change Data Capture (CDC) is supported.
        public var supportsCDC: Bool? = nil

        public init() {}

        public init(engineName: String? = nil, endpointType: String? = nil, supportsCDC: Bool? = nil) {
            self.engineName = engineName
            self.endpointType = endpointType
            self.supportsCDC = supportsCDC
        }

        public init(dictionary: [String: Any]) throws {
            self.engineName = dictionary["EngineName"] as? String
            self.endpointType = dictionary["EndpointType"] as? String
            self.supportsCDC = dictionary["SupportsCDC"] as? Bool
        }
    }

    public struct DescribeCertificatesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var marker: String? = nil
        /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
        public var certificates: [Certificate]? = nil

        public init() {}

        public init(marker: String? = nil, certificates: [Certificate]? = nil) {
            self.marker = marker
            self.certificates = certificates
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let certificates = dictionary["Certificates"] as? [[String: Any]] {
                self.certificates = try certificates.map({ try Certificate(dictionary: $0) })
            }
        }
    }

    public struct RemoveTagsFromResourceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeReplicationTasksMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Filters applied to the describe action. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct DeleteReplicationInstanceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication instance that was deleted.
        public var replicationInstance: ReplicationInstance? = nil

        public init() {}

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationInstance = dictionary["ReplicationInstance"] as? [String: Any] { self.replicationInstance = try Dms.ReplicationInstance(dictionary: replicationInstance) }
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var value: String? = nil
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var key: String? = nil

        public init() {}

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct AddTagsToResourceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListTagsForResourceMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the AWS DMS resource.
        public var resourceArn: String = ""

        public init() {}

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["ResourceArn"] as? String else { throw InitializableError.missingRequiredParam("ResourceArn") }
            self.resourceArn = resourceArn
        }
    }

    public struct DescribeEndpointTypesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// The type of endpoints that are supported.
        public var supportedEndpointTypes: [SupportedEndpointType]? = nil

        public init() {}

        public init(marker: String? = nil, supportedEndpointTypes: [SupportedEndpointType]? = nil) {
            self.marker = marker
            self.supportedEndpointTypes = supportedEndpointTypes
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let supportedEndpointTypes = dictionary["SupportedEndpointTypes"] as? [[String: Any]] {
                self.supportedEndpointTypes = try supportedEndpointTypes.map({ try SupportedEndpointType(dictionary: $0) })
            }
        }
    }

    public struct StartReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Number (ARN) of the replication task to be started.
        public var replicationTaskArn: String = ""
        /// The start time for the Change Data Capture (CDC) operation.
        public var cdcStartTime: Date? = nil
        /// The type of replication task.
        public var startReplicationTaskType: String = ""

        public init() {}

        public init(replicationTaskArn: String, cdcStartTime: Date? = nil, startReplicationTaskType: String) {
            self.replicationTaskArn = replicationTaskArn
            self.cdcStartTime = cdcStartTime
            self.startReplicationTaskType = startReplicationTaskType
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationTaskArn = dictionary["ReplicationTaskArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationTaskArn") }
            self.replicationTaskArn = replicationTaskArn
            self.cdcStartTime = dictionary["CdcStartTime"] as? Date
            guard let startReplicationTaskType = dictionary["StartReplicationTaskType"] as? String else { throw InitializableError.missingRequiredParam("StartReplicationTaskType") }
            self.startReplicationTaskType = startReplicationTaskType
        }
    }

    public struct CreateReplicationInstanceMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public var multiAZ: Bool? = nil
        /// Tags to be associated with the replication instance.
        public var tags: [Tag]? = nil
        /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
        public var allocatedStorage: Int32? = nil
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. 
        public var vpcSecurityGroupIds: [String]? = nil
        /// The EC2 Availability Zone that the replication instance will be created in. Default: A random, system-chosen Availability Zone in the endpoint's region.  Example: us-east-1d 
        public var availabilityZone: String? = nil
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true. 
        public var publiclyAccessible: Bool? = nil
        /// Indicates that minor engine upgrades will be applied automatically to the replication instance during the maintenance window. Default: true 
        public var autoMinorVersionUpgrade: Bool? = nil
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance 
        public var replicationInstanceIdentifier: String = ""
        /// The engine version number of the replication instance.
        public var engineVersion: String? = nil
        /// The compute and memory capacity of the replication instance as specified by the replication instance class.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public var replicationInstanceClass: String = ""
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).  Format: ddd:hh24:mi-ddd:hh24:mi  Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
        public var preferredMaintenanceWindow: String? = nil
        /// A subnet group to associate with the replication instance.
        public var replicationSubnetGroupIdentifier: String? = nil
        /// The KMS key identifier that will be used to encrypt the content on the replication instance. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public var kmsKeyId: String? = nil

        public init() {}

        public init(multiAZ: Bool? = nil, tags: [Tag]? = nil, allocatedStorage: Int32? = nil, vpcSecurityGroupIds: [String]? = nil, availabilityZone: String? = nil, publiclyAccessible: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil, replicationInstanceIdentifier: String, engineVersion: String? = nil, replicationInstanceClass: String, preferredMaintenanceWindow: String? = nil, replicationSubnetGroupIdentifier: String? = nil, kmsKeyId: String? = nil) {
            self.multiAZ = multiAZ
            self.tags = tags
            self.allocatedStorage = allocatedStorage
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.availabilityZone = availabilityZone
            self.publiclyAccessible = publiclyAccessible
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            self.multiAZ = dictionary["MultiAZ"] as? Bool
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.allocatedStorage = dictionary["AllocatedStorage"] as? Int32
            if let vpcSecurityGroupIds = dictionary["VpcSecurityGroupIds"] as? [String] {
                self.vpcSecurityGroupIds = vpcSecurityGroupIds
            }
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.publiclyAccessible = dictionary["PubliclyAccessible"] as? Bool
            self.autoMinorVersionUpgrade = dictionary["AutoMinorVersionUpgrade"] as? Bool
            guard let replicationInstanceIdentifier = dictionary["ReplicationInstanceIdentifier"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceIdentifier") }
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.engineVersion = dictionary["EngineVersion"] as? String
            guard let replicationInstanceClass = dictionary["ReplicationInstanceClass"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceClass") }
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = dictionary["PreferredMaintenanceWindow"] as? String
            self.replicationSubnetGroupIdentifier = dictionary["ReplicationSubnetGroupIdentifier"] as? String
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct DeleteCertificateResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Secure Sockets Layer (SSL) certificate.
        public var certificate: Certificate? = nil

        public init() {}

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        public init(dictionary: [String: Any]) throws {
            if let certificate = dictionary["Certificate"] as? [String: Any] { self.certificate = try Dms.Certificate(dictionary: certificate) }
        }
    }

    public struct DescribeConnectionsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// A description of the connections.
        public var connections: [Connection]? = nil

        public init() {}

        public init(marker: String? = nil, connections: [Connection]? = nil) {
            self.marker = marker
            self.connections = connections
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let connections = dictionary["Connections"] as? [[String: Any]] {
                self.connections = try connections.map({ try Connection(dictionary: $0) })
            }
        }
    }

    public struct DescribeTableStatisticsMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: String = ""

        public init() {}

        public init(marker: String? = nil, maxRecords: Int32? = nil, replicationTaskArn: String) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            guard let replicationTaskArn = dictionary["ReplicationTaskArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationTaskArn") }
            self.replicationTaskArn = replicationTaskArn
        }
    }

    public struct DescribeRefreshSchemasStatusMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String = ""

        public init() {}

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let endpointArn = dictionary["EndpointArn"] as? String else { throw InitializableError.missingRequiredParam("EndpointArn") }
            self.endpointArn = endpointArn
        }
    }

    public struct RemoveTagsFromResourceMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// &gt;The Amazon Resource Name (ARN) of the AWS DMS resource the tag is to be removed from.
        public var resourceArn: String = ""
        /// The tag key (name) of the tag to be removed.
        public var tagKeys: [String] = []

        public init() {}

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["ResourceArn"] as? String else { throw InitializableError.missingRequiredParam("ResourceArn") }
            self.resourceArn = resourceArn
            guard let tagKeys = dictionary["TagKeys"] as? [String] else { throw InitializableError.missingRequiredParam("TagKeys") }
            self.tagKeys = tagKeys
        }
    }

    public struct ModifyReplicationInstanceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The modified replication instance.
        public var replicationInstance: ReplicationInstance? = nil

        public init() {}

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationInstance = dictionary["ReplicationInstance"] as? [String: Any] { self.replicationInstance = try Dms.ReplicationInstance(dictionary: replicationInstance) }
        }
    }

    public struct DescribeReplicationSubnetGroupsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// A description of the replication subnet groups.
        public var replicationSubnetGroups: [ReplicationSubnetGroup]? = nil

        public init() {}

        public init(marker: String? = nil, replicationSubnetGroups: [ReplicationSubnetGroup]? = nil) {
            self.marker = marker
            self.replicationSubnetGroups = replicationSubnetGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let replicationSubnetGroups = dictionary["ReplicationSubnetGroups"] as? [[String: Any]] {
                self.replicationSubnetGroups = try replicationSubnetGroups.map({ try ReplicationSubnetGroup(dictionary: $0) })
            }
        }
    }

    public struct DescribeAccountAttributesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Account quota information.
        public var accountQuotas: [AccountQuota]? = nil

        public init() {}

        public init(accountQuotas: [AccountQuota]? = nil) {
            self.accountQuotas = accountQuotas
        }

        public init(dictionary: [String: Any]) throws {
            if let accountQuotas = dictionary["AccountQuotas"] as? [[String: Any]] {
                self.accountQuotas = try accountQuotas.map({ try AccountQuota(dictionary: $0) })
            }
        }
    }

    public struct DescribeSchemasResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// The described schema.
        public var schemas: [String]? = nil

        public init() {}

        public init(marker: String? = nil, schemas: [String]? = nil) {
            self.marker = marker
            self.schemas = schemas
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let schemas = dictionary["Schemas"] as? [String] {
                self.schemas = schemas
            }
        }
    }

    public struct DescribeAccountAttributesMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct Certificate: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The beginning date that the certificate is valid.
        public var validFromDate: Date? = nil
        /// The key length of the cryptographic algorithm being used.
        public var keyLength: Int32? = nil
        /// The signing algorithm for the certificate.
        public var signingAlgorithm: String? = nil
        /// The location of the imported Oracle Wallet certificate for use with SSL.
        public var certificateWallet: Data? = nil
        /// The Amazon Resource Name (ARN) for the certificate.
        public var certificateArn: String? = nil
        /// The contents of the .pem X.509 certificate file for the certificate.
        public var certificatePem: String? = nil
        /// The final date that the certificate is valid.
        public var validToDate: Date? = nil
        /// The owner of the certificate.
        public var certificateOwner: String? = nil
        /// The customer-assigned name of the certificate. Valid characters are A-z and 0-9.
        public var certificateIdentifier: String? = nil
        /// The date that the certificate was created.
        public var certificateCreationDate: Date? = nil

        public init() {}

        public init(validFromDate: Date? = nil, keyLength: Int32? = nil, signingAlgorithm: String? = nil, certificateWallet: Data? = nil, certificateArn: String? = nil, certificatePem: String? = nil, validToDate: Date? = nil, certificateOwner: String? = nil, certificateIdentifier: String? = nil, certificateCreationDate: Date? = nil) {
            self.validFromDate = validFromDate
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.certificateWallet = certificateWallet
            self.certificateArn = certificateArn
            self.certificatePem = certificatePem
            self.validToDate = validToDate
            self.certificateOwner = certificateOwner
            self.certificateIdentifier = certificateIdentifier
            self.certificateCreationDate = certificateCreationDate
        }

        public init(dictionary: [String: Any]) throws {
            self.validFromDate = dictionary["ValidFromDate"] as? Date
            self.keyLength = dictionary["KeyLength"] as? Int32
            self.signingAlgorithm = dictionary["SigningAlgorithm"] as? String
            self.certificateWallet = dictionary["CertificateWallet"] as? Data
            self.certificateArn = dictionary["CertificateArn"] as? String
            self.certificatePem = dictionary["CertificatePem"] as? String
            self.validToDate = dictionary["ValidToDate"] as? Date
            self.certificateOwner = dictionary["CertificateOwner"] as? String
            self.certificateIdentifier = dictionary["CertificateIdentifier"] as? String
            self.certificateCreationDate = dictionary["CertificateCreationDate"] as? Date
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of tags for the resource.
        public var tagList: [Tag]? = nil

        public init() {}

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        public init(dictionary: [String: Any]) throws {
            if let tagList = dictionary["TagList"] as? [[String: Any]] {
                self.tagList = try tagList.map({ try Tag(dictionary: $0) })
            }
        }
    }

    public struct Subnet: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The subnet identifier.
        public var subnetIdentifier: String? = nil
        /// The Availability Zone of the subnet.
        public var subnetAvailabilityZone: AvailabilityZone? = nil
        /// The status of the subnet.
        public var subnetStatus: String? = nil

        public init() {}

        public init(subnetIdentifier: String? = nil, subnetAvailabilityZone: AvailabilityZone? = nil, subnetStatus: String? = nil) {
            self.subnetIdentifier = subnetIdentifier
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetStatus = subnetStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetIdentifier = dictionary["SubnetIdentifier"] as? String
            if let subnetAvailabilityZone = dictionary["SubnetAvailabilityZone"] as? [String: Any] { self.subnetAvailabilityZone = try Dms.AvailabilityZone(dictionary: subnetAvailabilityZone) }
            self.subnetStatus = dictionary["SubnetStatus"] as? String
        }
    }

    public struct StartReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication task started.
        public var replicationTask: ReplicationTask? = nil

        public init() {}

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationTask = dictionary["ReplicationTask"] as? [String: Any] { self.replicationTask = try Dms.ReplicationTask(dictionary: replicationTask) }
        }
    }

    public struct AvailabilityZone: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the availability zone.
        public var name: String? = nil

        public init() {}

        public init(name: String? = nil) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
        }
    }

    public struct Connection: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The error message when the connection last failed.
        public var lastFailureMessage: String? = nil
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public var replicationInstanceIdentifier: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String? = nil
        /// The connection status.
        public var status: String? = nil
        /// The identifier of the endpoint. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String? = nil

        public init() {}

        public init(lastFailureMessage: String? = nil, replicationInstanceIdentifier: String? = nil, replicationInstanceArn: String? = nil, status: String? = nil, endpointIdentifier: String? = nil, endpointArn: String? = nil) {
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
            self.endpointIdentifier = endpointIdentifier
            self.endpointArn = endpointArn
        }

        public init(dictionary: [String: Any]) throws {
            self.lastFailureMessage = dictionary["LastFailureMessage"] as? String
            self.replicationInstanceIdentifier = dictionary["ReplicationInstanceIdentifier"] as? String
            self.replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String
            self.status = dictionary["Status"] as? String
            self.endpointIdentifier = dictionary["EndpointIdentifier"] as? String
            self.endpointArn = dictionary["EndpointArn"] as? String
        }
    }

    public struct RefreshSchemasStatus: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The last failure message for the schema.
        public var lastFailureMessage: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String? = nil
        /// The status of the schema.
        public var status: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String? = nil
        /// The date the schema was last refreshed.
        public var lastRefreshDate: Date? = nil

        public init() {}

        public init(lastFailureMessage: String? = nil, replicationInstanceArn: String? = nil, status: String? = nil, endpointArn: String? = nil, lastRefreshDate: Date? = nil) {
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
            self.endpointArn = endpointArn
            self.lastRefreshDate = lastRefreshDate
        }

        public init(dictionary: [String: Any]) throws {
            self.lastFailureMessage = dictionary["LastFailureMessage"] as? String
            self.replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String
            self.status = dictionary["Status"] as? String
            self.endpointArn = dictionary["EndpointArn"] as? String
            self.lastRefreshDate = dictionary["LastRefreshDate"] as? Date
        }
    }

    public struct DeleteReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the replication task to be deleted.
        public var replicationTaskArn: String = ""

        public init() {}

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationTaskArn = dictionary["ReplicationTaskArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationTaskArn") }
            self.replicationTaskArn = replicationTaskArn
        }
    }

    public struct DescribeReplicationInstancesMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Filters applied to the describe action. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct RefreshSchemasMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String = ""
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String = ""

        public init() {}

        public init(replicationInstanceArn: String, endpointArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
            self.endpointArn = endpointArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceArn") }
            self.replicationInstanceArn = replicationInstanceArn
            guard let endpointArn = dictionary["EndpointArn"] as? String else { throw InitializableError.missingRequiredParam("EndpointArn") }
            self.endpointArn = endpointArn
        }
    }

    public struct ModifyReplicationInstanceMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible. Constraints: This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
        public var allowMajorVersionUpgrade: Bool? = nil
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public var replicationInstanceIdentifier: String? = nil
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public var multiAZ: Bool? = nil
        /// The engine version number of the replication instance.
        public var engineVersion: String? = nil
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public var replicationInstanceClass: String? = nil
        /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
        public var preferredMaintenanceWindow: String? = nil
        /// The amount of storage (in gigabytes) to be allocated for the replication instance.
        public var allocatedStorage: Int32? = nil
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. 
        public var vpcSecurityGroupIds: [String]? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String = ""
        /// Indicates whether the changes should be applied immediately or during the next maintenance window.
        public var applyImmediately: Bool? = nil
        ///  Indicates that minor version upgrades will be applied automatically to the replication instance during the maintenance window. Changing this parameter does not result in an outage except in the following case and the change is asynchronously applied as soon as possible. An outage will result if this parameter is set to true during the maintenance window, and a newer minor version is available, and AWS DMS has enabled auto patching for that engine version. 
        public var autoMinorVersionUpgrade: Bool? = nil

        public init() {}

        public init(allowMajorVersionUpgrade: Bool? = nil, replicationInstanceIdentifier: String? = nil, multiAZ: Bool? = nil, engineVersion: String? = nil, replicationInstanceClass: String? = nil, preferredMaintenanceWindow: String? = nil, allocatedStorage: Int32? = nil, vpcSecurityGroupIds: [String]? = nil, replicationInstanceArn: String, applyImmediately: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil) {
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.multiAZ = multiAZ
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.allocatedStorage = allocatedStorage
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.replicationInstanceArn = replicationInstanceArn
            self.applyImmediately = applyImmediately
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        }

        public init(dictionary: [String: Any]) throws {
            self.allowMajorVersionUpgrade = dictionary["AllowMajorVersionUpgrade"] as? Bool
            self.replicationInstanceIdentifier = dictionary["ReplicationInstanceIdentifier"] as? String
            self.multiAZ = dictionary["MultiAZ"] as? Bool
            self.engineVersion = dictionary["EngineVersion"] as? String
            self.replicationInstanceClass = dictionary["ReplicationInstanceClass"] as? String
            self.preferredMaintenanceWindow = dictionary["PreferredMaintenanceWindow"] as? String
            self.allocatedStorage = dictionary["AllocatedStorage"] as? Int32
            if let vpcSecurityGroupIds = dictionary["VpcSecurityGroupIds"] as? [String] {
                self.vpcSecurityGroupIds = vpcSecurityGroupIds
            }
            guard let replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceArn") }
            self.replicationInstanceArn = replicationInstanceArn
            self.applyImmediately = dictionary["ApplyImmediately"] as? Bool
            self.autoMinorVersionUpgrade = dictionary["AutoMinorVersionUpgrade"] as? Bool
        }
    }

    public struct AccountQuota: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum allowed value for the quota.
        public var max: Int64? = nil
        /// The amount currently used toward the quota maximum.
        public var used: Int64? = nil
        /// The name of the AWS DMS quota for this AWS account.
        public var accountQuotaName: String? = nil

        public init() {}

        public init(max: Int64? = nil, used: Int64? = nil, accountQuotaName: String? = nil) {
            self.max = max
            self.used = used
            self.accountQuotaName = accountQuotaName
        }

        public init(dictionary: [String: Any]) throws {
            self.max = dictionary["Max"] as? Int64
            self.used = dictionary["Used"] as? Int64
            self.accountQuotaName = dictionary["AccountQuotaName"] as? String
        }
    }

    public struct DescribeCertificatesMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 10
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Filters applied to the certificate described in the form of key-value pairs.
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct CreateEndpointMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The KMS key identifier that will be used to encrypt the connection parameters. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public var kmsKeyId: String? = nil
        /// The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: String = ""
        /// Tags to be added to the endpoint.
        public var tags: [Tag]? = nil
        /// The user name to be used to login to the endpoint database.
        public var username: String? = nil
        /// The type of endpoint.
        public var endpointType: String = ""
        /// The name of the server where the endpoint database resides.
        public var serverName: String? = nil
        /// The name of the endpoint database.
        public var databaseName: String? = nil
        /// The SSL mode to use for the SSL connection. SSL mode can be one of four values: none, require, verify-ca, verify-full.  The default value is none.
        public var sslMode: String? = nil
        /// The Amazon Resource Number (ARN) for the certificate.
        public var certificateArn: String? = nil
        /// The type of engine for the endpoint. Valid values include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, SYBASE, and SQLSERVER.
        public var engineName: String = ""
        /// The password to be used to login to the endpoint database.
        public var password: String? = nil
        /// The port used by the endpoint database.
        public var port: Int32? = nil
        /// Additional attributes associated with the connection.
        public var extraConnectionAttributes: String? = nil

        public init() {}

        public init(kmsKeyId: String? = nil, endpointIdentifier: String, tags: [Tag]? = nil, username: String? = nil, endpointType: String, serverName: String? = nil, databaseName: String? = nil, sslMode: String? = nil, certificateArn: String? = nil, engineName: String, password: String? = nil, port: Int32? = nil, extraConnectionAttributes: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.endpointIdentifier = endpointIdentifier
            self.tags = tags
            self.username = username
            self.endpointType = endpointType
            self.serverName = serverName
            self.databaseName = databaseName
            self.sslMode = sslMode
            self.certificateArn = certificateArn
            self.engineName = engineName
            self.password = password
            self.port = port
            self.extraConnectionAttributes = extraConnectionAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
            guard let endpointIdentifier = dictionary["EndpointIdentifier"] as? String else { throw InitializableError.missingRequiredParam("EndpointIdentifier") }
            self.endpointIdentifier = endpointIdentifier
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            self.username = dictionary["Username"] as? String
            guard let endpointType = dictionary["EndpointType"] as? String else { throw InitializableError.missingRequiredParam("EndpointType") }
            self.endpointType = endpointType
            self.serverName = dictionary["ServerName"] as? String
            self.databaseName = dictionary["DatabaseName"] as? String
            self.sslMode = dictionary["SslMode"] as? String
            self.certificateArn = dictionary["CertificateArn"] as? String
            guard let engineName = dictionary["EngineName"] as? String else { throw InitializableError.missingRequiredParam("EngineName") }
            self.engineName = engineName
            self.password = dictionary["Password"] as? String
            self.port = dictionary["Port"] as? Int32
            self.extraConnectionAttributes = dictionary["ExtraConnectionAttributes"] as? String
        }
    }

    public struct ReplicationSubnetGroup: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the subnet group.
        public var subnetGroupStatus: String? = nil
        /// The subnets that are in the subnet group.
        public var subnets: [Subnet]? = nil
        /// The identifier of the replication instance subnet group.
        public var replicationSubnetGroupIdentifier: String? = nil
        /// The description of the replication subnet group.
        public var replicationSubnetGroupDescription: String? = nil
        /// The ID of the VPC.
        public var vpcId: String? = nil

        public init() {}

        public init(subnetGroupStatus: String? = nil, subnets: [Subnet]? = nil, replicationSubnetGroupIdentifier: String? = nil, replicationSubnetGroupDescription: String? = nil, vpcId: String? = nil) {
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.vpcId = vpcId
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetGroupStatus = dictionary["SubnetGroupStatus"] as? String
            if let subnets = dictionary["Subnets"] as? [[String: Any]] {
                self.subnets = try subnets.map({ try Subnet(dictionary: $0) })
            }
            self.replicationSubnetGroupIdentifier = dictionary["ReplicationSubnetGroupIdentifier"] as? String
            self.replicationSubnetGroupDescription = dictionary["ReplicationSubnetGroupDescription"] as? String
            self.vpcId = dictionary["VpcId"] as? String
        }
    }

    public struct TestConnectionResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The connection tested.
        public var connection: Connection? = nil

        public init() {}

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        public init(dictionary: [String: Any]) throws {
            if let connection = dictionary["Connection"] as? [String: Any] { self.connection = try Dms.Connection(dictionary: connection) }
        }
    }

    public struct DeleteReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The deleted replication task.
        public var replicationTask: ReplicationTask? = nil

        public init() {}

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationTask = dictionary["ReplicationTask"] as? [String: Any] { self.replicationTask = try Dms.ReplicationTask(dictionary: replicationTask) }
        }
    }

    public struct CreateReplicationSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication subnet group that was created.
        public var replicationSubnetGroup: ReplicationSubnetGroup? = nil

        public init() {}

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationSubnetGroup = dictionary["ReplicationSubnetGroup"] as? [String: Any] { self.replicationSubnetGroup = try Dms.ReplicationSubnetGroup(dictionary: replicationSubnetGroup) }
        }
    }

    public struct TableStatistics: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of delete actions performed on a table.
        public var deletes: Int64? = nil
        /// The number of update actions performed on a table.
        public var updates: Int64? = nil
        /// The state of the table.
        public var tableState: String? = nil
        /// The schema name.
        public var schemaName: String? = nil
        /// The number of rows added during the Full Load operation.
        public var fullLoadRows: Int64? = nil
        /// The number of insert actions performed on a table.
        public var inserts: Int64? = nil
        /// The name of the table.
        public var tableName: String? = nil
        /// The last time the table was updated.
        public var lastUpdateTime: Date? = nil
        /// The Data Definition Language (DDL) used to build and modify the structure of your tables.
        public var ddls: Int64? = nil

        public init() {}

        public init(deletes: Int64? = nil, updates: Int64? = nil, tableState: String? = nil, schemaName: String? = nil, fullLoadRows: Int64? = nil, inserts: Int64? = nil, tableName: String? = nil, lastUpdateTime: Date? = nil, ddls: Int64? = nil) {
            self.deletes = deletes
            self.updates = updates
            self.tableState = tableState
            self.schemaName = schemaName
            self.fullLoadRows = fullLoadRows
            self.inserts = inserts
            self.tableName = tableName
            self.lastUpdateTime = lastUpdateTime
            self.ddls = ddls
        }

        public init(dictionary: [String: Any]) throws {
            self.deletes = dictionary["Deletes"] as? Int64
            self.updates = dictionary["Updates"] as? Int64
            self.tableState = dictionary["TableState"] as? String
            self.schemaName = dictionary["SchemaName"] as? String
            self.fullLoadRows = dictionary["FullLoadRows"] as? Int64
            self.inserts = dictionary["Inserts"] as? Int64
            self.tableName = dictionary["TableName"] as? String
            self.lastUpdateTime = dictionary["LastUpdateTime"] as? Date
            self.ddls = dictionary["Ddls"] as? Int64
        }
    }

    public struct ImportCertificateMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The location of the imported Oracle Wallet certificate for use with SSL.
        public var certificateWallet: Data? = nil
        /// The customer-assigned name of the certificate. Valid characters are A-z and 0-9.
        public var certificateIdentifier: String = ""
        /// The contents of the .pem X.509 certificate file for the certificate.
        public var certificatePem: String? = nil

        public init() {}

        public init(certificateWallet: Data? = nil, certificateIdentifier: String, certificatePem: String? = nil) {
            self.certificateWallet = certificateWallet
            self.certificateIdentifier = certificateIdentifier
            self.certificatePem = certificatePem
        }

        public init(dictionary: [String: Any]) throws {
            self.certificateWallet = dictionary["CertificateWallet"] as? Data
            guard let certificateIdentifier = dictionary["CertificateIdentifier"] as? String else { throw InitializableError.missingRequiredParam("CertificateIdentifier") }
            self.certificateIdentifier = certificateIdentifier
            self.certificatePem = dictionary["CertificatePem"] as? String
        }
    }

    public struct TestConnectionMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String = ""
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String = ""

        public init() {}

        public init(replicationInstanceArn: String, endpointArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
            self.endpointArn = endpointArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceArn") }
            self.replicationInstanceArn = replicationInstanceArn
            guard let endpointArn = dictionary["EndpointArn"] as? String else { throw InitializableError.missingRequiredParam("EndpointArn") }
            self.endpointArn = endpointArn
        }
    }

    public struct CreateEndpointResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The endpoint that was created.
        public var endpoint: Endpoint? = nil

        public init() {}

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        public init(dictionary: [String: Any]) throws {
            if let endpoint = dictionary["Endpoint"] as? [String: Any] { self.endpoint = try Dms.Endpoint(dictionary: endpoint) }
        }
    }

    public struct CreateReplicationInstanceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication instance that was created.
        public var replicationInstance: ReplicationInstance? = nil

        public init() {}

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationInstance = dictionary["ReplicationInstance"] as? [String: Any] { self.replicationInstance = try Dms.ReplicationInstance(dictionary: replicationInstance) }
        }
    }

    public struct ModifyReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The path of the JSON file that contains the table mappings. Preceed the path with "file://". For example, --table-mappings file://mappingfile.json
        public var tableMappings: String? = nil
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: String = ""
        /// The replication task identifier. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public var replicationTaskIdentifier: String? = nil
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
        public var migrationType: String? = nil
        /// The start time for the Change Data Capture (CDC) operation.
        public var cdcStartTime: Date? = nil
        /// JSON file that contains settings for the task, such as target metadata settings.
        public var replicationTaskSettings: String? = nil

        public init() {}

        public init(tableMappings: String? = nil, replicationTaskArn: String, replicationTaskIdentifier: String? = nil, migrationType: String? = nil, cdcStartTime: Date? = nil, replicationTaskSettings: String? = nil) {
            self.tableMappings = tableMappings
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.migrationType = migrationType
            self.cdcStartTime = cdcStartTime
            self.replicationTaskSettings = replicationTaskSettings
        }

        public init(dictionary: [String: Any]) throws {
            self.tableMappings = dictionary["TableMappings"] as? String
            guard let replicationTaskArn = dictionary["ReplicationTaskArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationTaskArn") }
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = dictionary["ReplicationTaskIdentifier"] as? String
            self.migrationType = dictionary["MigrationType"] as? String
            self.cdcStartTime = dictionary["CdcStartTime"] as? Date
            self.replicationTaskSettings = dictionary["ReplicationTaskSettings"] as? String
        }
    }

    public struct ModifyReplicationSubnetGroupMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A list of subnet IDs.
        public var subnetIds: [String] = []
        /// The name of the replication instance subnet group.
        public var replicationSubnetGroupIdentifier: String = ""
        /// The description of the replication instance subnet group.
        public var replicationSubnetGroupDescription: String? = nil

        public init() {}

        public init(subnetIds: [String], replicationSubnetGroupIdentifier: String, replicationSubnetGroupDescription: String? = nil) {
            self.subnetIds = subnetIds
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetIds = dictionary["SubnetIds"] as? [String] else { throw InitializableError.missingRequiredParam("SubnetIds") }
            self.subnetIds = subnetIds
            guard let replicationSubnetGroupIdentifier = dictionary["ReplicationSubnetGroupIdentifier"] as? String else { throw InitializableError.missingRequiredParam("ReplicationSubnetGroupIdentifier") }
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = dictionary["ReplicationSubnetGroupDescription"] as? String
        }
    }

    public struct OrderableReplicationInstance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The version of the replication engine.
        public var engineVersion: String? = nil
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public var replicationInstanceClass: String? = nil
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public var defaultAllocatedStorage: Int32? = nil
        /// The type of storage used by the replication instance.
        public var storageType: String? = nil
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var minAllocatedStorage: Int32? = nil
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var includedAllocatedStorage: Int32? = nil
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var maxAllocatedStorage: Int32? = nil

        public init() {}

        public init(engineVersion: String? = nil, replicationInstanceClass: String? = nil, defaultAllocatedStorage: Int32? = nil, storageType: String? = nil, minAllocatedStorage: Int32? = nil, includedAllocatedStorage: Int32? = nil, maxAllocatedStorage: Int32? = nil) {
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.storageType = storageType
            self.minAllocatedStorage = minAllocatedStorage
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
        }

        public init(dictionary: [String: Any]) throws {
            self.engineVersion = dictionary["EngineVersion"] as? String
            self.replicationInstanceClass = dictionary["ReplicationInstanceClass"] as? String
            self.defaultAllocatedStorage = dictionary["DefaultAllocatedStorage"] as? Int32
            self.storageType = dictionary["StorageType"] as? String
            self.minAllocatedStorage = dictionary["MinAllocatedStorage"] as? Int32
            self.includedAllocatedStorage = dictionary["IncludedAllocatedStorage"] as? Int32
            self.maxAllocatedStorage = dictionary["MaxAllocatedStorage"] as? Int32
        }
    }

    public struct ReplicationTaskStats: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The number of tables loaded for this task.
        public var tablesLoaded: Int32? = nil
        /// The elapsed time of the task, in milliseconds.
        public var elapsedTimeMillis: Int64? = nil
        /// The percent complete for the full load migration task.
        public var fullLoadProgressPercent: Int32? = nil
        /// The number of tables queued for this task.
        public var tablesQueued: Int32? = nil
        /// The number of errors that have occurred during this task.
        public var tablesErrored: Int32? = nil
        /// The number of tables currently loading for this task.
        public var tablesLoading: Int32? = nil

        public init() {}

        public init(tablesLoaded: Int32? = nil, elapsedTimeMillis: Int64? = nil, fullLoadProgressPercent: Int32? = nil, tablesQueued: Int32? = nil, tablesErrored: Int32? = nil, tablesLoading: Int32? = nil) {
            self.tablesLoaded = tablesLoaded
            self.elapsedTimeMillis = elapsedTimeMillis
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.tablesQueued = tablesQueued
            self.tablesErrored = tablesErrored
            self.tablesLoading = tablesLoading
        }

        public init(dictionary: [String: Any]) throws {
            self.tablesLoaded = dictionary["TablesLoaded"] as? Int32
            self.elapsedTimeMillis = dictionary["ElapsedTimeMillis"] as? Int64
            self.fullLoadProgressPercent = dictionary["FullLoadProgressPercent"] as? Int32
            self.tablesQueued = dictionary["TablesQueued"] as? Int32
            self.tablesErrored = dictionary["TablesErrored"] as? Int32
            self.tablesLoading = dictionary["TablesLoading"] as? Int32
        }
    }

    public struct ModifyReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication task that was modified.
        public var replicationTask: ReplicationTask? = nil

        public init() {}

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationTask = dictionary["ReplicationTask"] as? [String: Any] { self.replicationTask = try Dms.ReplicationTask(dictionary: replicationTask) }
        }
    }

    public struct DeleteEndpointResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The endpoint that was deleted.
        public var endpoint: Endpoint? = nil

        public init() {}

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        public init(dictionary: [String: Any]) throws {
            if let endpoint = dictionary["Endpoint"] as? [String: Any] { self.endpoint = try Dms.Endpoint(dictionary: endpoint) }
        }
    }

    public struct StopReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The replication task stopped.
        public var replicationTask: ReplicationTask? = nil

        public init() {}

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationTask = dictionary["ReplicationTask"] as? [String: Any] { self.replicationTask = try Dms.ReplicationTask(dictionary: replicationTask) }
        }
    }

    public struct ReplicationTask: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public var replicationTaskStats: ReplicationTaskStats? = nil
        /// The last error (failure) message generated for the replication instance.
        public var lastFailureMessage: String? = nil
        /// The date the replication task is scheduled to start.
        public var replicationTaskStartDate: Date? = nil
        /// The date the replication task was created.
        public var replicationTaskCreationDate: Date? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var sourceEndpointArn: String? = nil
        /// Table mappings specified in the task.
        public var tableMappings: String? = nil
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: String? = nil
        /// The status of the replication task.
        public var status: String? = nil
        /// The reason the replication task was stopped.
        public var stopReason: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String? = nil
        /// The replication task identifier. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public var replicationTaskIdentifier: String? = nil
        /// The type of migration.
        public var migrationType: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var targetEndpointArn: String? = nil
        /// The settings for the replication task.
        public var replicationTaskSettings: String? = nil

        public init() {}

        public init(replicationTaskStats: ReplicationTaskStats? = nil, lastFailureMessage: String? = nil, replicationTaskStartDate: Date? = nil, replicationTaskCreationDate: Date? = nil, sourceEndpointArn: String? = nil, tableMappings: String? = nil, replicationTaskArn: String? = nil, status: String? = nil, stopReason: String? = nil, replicationInstanceArn: String? = nil, replicationTaskIdentifier: String? = nil, migrationType: String? = nil, targetEndpointArn: String? = nil, replicationTaskSettings: String? = nil) {
            self.replicationTaskStats = replicationTaskStats
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.replicationTaskArn = replicationTaskArn
            self.status = status
            self.stopReason = stopReason
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.migrationType = migrationType
            self.targetEndpointArn = targetEndpointArn
            self.replicationTaskSettings = replicationTaskSettings
        }

        public init(dictionary: [String: Any]) throws {
            if let replicationTaskStats = dictionary["ReplicationTaskStats"] as? [String: Any] { self.replicationTaskStats = try Dms.ReplicationTaskStats(dictionary: replicationTaskStats) }
            self.lastFailureMessage = dictionary["LastFailureMessage"] as? String
            self.replicationTaskStartDate = dictionary["ReplicationTaskStartDate"] as? Date
            self.replicationTaskCreationDate = dictionary["ReplicationTaskCreationDate"] as? Date
            self.sourceEndpointArn = dictionary["SourceEndpointArn"] as? String
            self.tableMappings = dictionary["TableMappings"] as? String
            self.replicationTaskArn = dictionary["ReplicationTaskArn"] as? String
            self.status = dictionary["Status"] as? String
            self.stopReason = dictionary["StopReason"] as? String
            self.replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String
            self.replicationTaskIdentifier = dictionary["ReplicationTaskIdentifier"] as? String
            self.migrationType = dictionary["MigrationType"] as? String
            self.targetEndpointArn = dictionary["TargetEndpointArn"] as? String
            self.replicationTaskSettings = dictionary["ReplicationTaskSettings"] as? String
        }
    }

    public struct RefreshSchemasResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the refreshed schema.
        public var refreshSchemasStatus: RefreshSchemasStatus? = nil

        public init() {}

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let refreshSchemasStatus = dictionary["RefreshSchemasStatus"] as? [String: Any] { self.refreshSchemasStatus = try Dms.RefreshSchemasStatus(dictionary: refreshSchemasStatus) }
        }
    }

    public struct DeleteCertificateMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the deleted certificate.
        public var certificateArn: String = ""

        public init() {}

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let certificateArn = dictionary["CertificateArn"] as? String else { throw InitializableError.missingRequiredParam("CertificateArn") }
            self.certificateArn = certificateArn
        }
    }

    public struct DescribeRefreshSchemasStatusResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the schema.
        public var refreshSchemasStatus: RefreshSchemasStatus? = nil

        public init() {}

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let refreshSchemasStatus = dictionary["RefreshSchemasStatus"] as? [String: Any] { self.refreshSchemasStatus = try Dms.RefreshSchemasStatus(dictionary: refreshSchemasStatus) }
        }
    }

    public struct DescribeSchemasMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String = ""
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil

        public init() {}

        public init(marker: String? = nil, endpointArn: String, maxRecords: Int32? = nil) {
            self.marker = marker
            self.endpointArn = endpointArn
            self.maxRecords = maxRecords
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            guard let endpointArn = dictionary["EndpointArn"] as? String else { throw InitializableError.missingRequiredParam("EndpointArn") }
            self.endpointArn = endpointArn
            self.maxRecords = dictionary["MaxRecords"] as? Int32
        }
    }

    public struct StopReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Number(ARN) of the replication task to be stopped.
        public var replicationTaskArn: String = ""

        public init() {}

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationTaskArn = dictionary["ReplicationTaskArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationTaskArn") }
            self.replicationTaskArn = replicationTaskArn
        }
    }

    public struct DescribeReplicationTasksResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// A description of the replication tasks.
        public var replicationTasks: [ReplicationTask]? = nil

        public init() {}

        public init(marker: String? = nil, replicationTasks: [ReplicationTask]? = nil) {
            self.marker = marker
            self.replicationTasks = replicationTasks
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let replicationTasks = dictionary["ReplicationTasks"] as? [[String: Any]] {
                self.replicationTasks = try replicationTasks.map({ try ReplicationTask(dictionary: $0) })
            }
        }
    }

    public struct AddTagsToResourceMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the AWS DMS resource the tag is to be added to. AWS DMS resources include a replication instance, endpoint, and a replication task.
        public var resourceArn: String = ""
        /// The tag to be assigned to the DMS resource.
        public var tags: [Tag] = []

        public init() {}

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["ResourceArn"] as? String else { throw InitializableError.missingRequiredParam("ResourceArn") }
            self.resourceArn = resourceArn
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct DescribeConnectionsMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
        public var filters: [Filter]? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: [Filter]? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
            if let filters = dictionary["Filters"] as? [[String: Any]] {
                self.filters = try filters.map({ try Filter(dictionary: $0) })
            }
        }
    }

    public struct DeleteReplicationSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteReplicationSubnetGroupMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The subnet group name of the replication instance.
        public var replicationSubnetGroupIdentifier: String = ""

        public init() {}

        public init(replicationSubnetGroupIdentifier: String) {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            guard let replicationSubnetGroupIdentifier = dictionary["ReplicationSubnetGroupIdentifier"] as? String else { throw InitializableError.missingRequiredParam("ReplicationSubnetGroupIdentifier") }
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }
    }

    public struct ReplicationPendingModifiedValues: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public var multiAZ: Bool? = nil
        /// The engine version number of the replication instance.
        public var engineVersion: String? = nil
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public var replicationInstanceClass: String? = nil
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Int32? = nil

        public init() {}

        public init(multiAZ: Bool? = nil, engineVersion: String? = nil, replicationInstanceClass: String? = nil, allocatedStorage: Int32? = nil) {
            self.multiAZ = multiAZ
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.allocatedStorage = allocatedStorage
        }

        public init(dictionary: [String: Any]) throws {
            self.multiAZ = dictionary["MultiAZ"] as? Bool
            self.engineVersion = dictionary["EngineVersion"] as? String
            self.replicationInstanceClass = dictionary["ReplicationInstanceClass"] as? String
            self.allocatedStorage = dictionary["AllocatedStorage"] as? Int32
        }
    }

    public struct ReplicationInstance: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The time the replication instance was created.
        public var instanceCreateTime: Date? = nil
        /// The pending modification values.
        public var pendingModifiedValues: ReplicationPendingModifiedValues? = nil
        /// The status of the replication instance.
        public var replicationInstanceStatus: String? = nil
        /// The VPC security group for the instance.
        public var vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public var multiAZ: Bool? = nil
        /// The public IP address of the replication instance.
        public var replicationInstancePublicIpAddresses: [String]? = nil
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Int32? = nil
        /// The subnet group for the replication instance.
        public var replicationSubnetGroup: ReplicationSubnetGroup? = nil
        /// The private IP address of the replication instance.
        public var replicationInstancePrivateIpAddress: String? = nil
        /// The Availability Zone for the instance.
        public var availabilityZone: String? = nil
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public var autoMinorVersionUpgrade: Bool? = nil
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true. 
        public var publiclyAccessible: Bool? = nil
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance 
        public var replicationInstanceIdentifier: String? = nil
        /// The private IP address of the replication instance.
        public var replicationInstancePrivateIpAddresses: [String]? = nil
        /// The engine version number of the replication instance.
        public var engineVersion: String? = nil
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public var replicationInstanceClass: String? = nil
        /// The maintenance window times for the replication instance.
        public var preferredMaintenanceWindow: String? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String? = nil
        /// The public IP address of the replication instance.
        public var replicationInstancePublicIpAddress: String? = nil
        /// The availability zone of the standby replication instance in a Multi-AZ deployment.
        public var secondaryAvailabilityZone: String? = nil
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public var kmsKeyId: String? = nil

        public init() {}

        public init(instanceCreateTime: Date? = nil, pendingModifiedValues: ReplicationPendingModifiedValues? = nil, replicationInstanceStatus: String? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil, multiAZ: Bool? = nil, replicationInstancePublicIpAddresses: [String]? = nil, allocatedStorage: Int32? = nil, replicationSubnetGroup: ReplicationSubnetGroup? = nil, replicationInstancePrivateIpAddress: String? = nil, availabilityZone: String? = nil, autoMinorVersionUpgrade: Bool? = nil, publiclyAccessible: Bool? = nil, replicationInstanceIdentifier: String? = nil, replicationInstancePrivateIpAddresses: [String]? = nil, engineVersion: String? = nil, replicationInstanceClass: String? = nil, preferredMaintenanceWindow: String? = nil, replicationInstanceArn: String? = nil, replicationInstancePublicIpAddress: String? = nil, secondaryAvailabilityZone: String? = nil, kmsKeyId: String? = nil) {
            self.instanceCreateTime = instanceCreateTime
            self.pendingModifiedValues = pendingModifiedValues
            self.replicationInstanceStatus = replicationInstanceStatus
            self.vpcSecurityGroups = vpcSecurityGroups
            self.multiAZ = multiAZ
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.allocatedStorage = allocatedStorage
            self.replicationSubnetGroup = replicationSubnetGroup
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.availabilityZone = availabilityZone
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.kmsKeyId = kmsKeyId
        }

        public init(dictionary: [String: Any]) throws {
            self.instanceCreateTime = dictionary["InstanceCreateTime"] as? Date
            if let pendingModifiedValues = dictionary["PendingModifiedValues"] as? [String: Any] { self.pendingModifiedValues = try Dms.ReplicationPendingModifiedValues(dictionary: pendingModifiedValues) }
            self.replicationInstanceStatus = dictionary["ReplicationInstanceStatus"] as? String
            if let vpcSecurityGroups = dictionary["VpcSecurityGroups"] as? [[String: Any]] {
                self.vpcSecurityGroups = try vpcSecurityGroups.map({ try VpcSecurityGroupMembership(dictionary: $0) })
            }
            self.multiAZ = dictionary["MultiAZ"] as? Bool
            if let replicationInstancePublicIpAddresses = dictionary["ReplicationInstancePublicIpAddresses"] as? [String] {
                self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            }
            self.allocatedStorage = dictionary["AllocatedStorage"] as? Int32
            if let replicationSubnetGroup = dictionary["ReplicationSubnetGroup"] as? [String: Any] { self.replicationSubnetGroup = try Dms.ReplicationSubnetGroup(dictionary: replicationSubnetGroup) }
            self.replicationInstancePrivateIpAddress = dictionary["ReplicationInstancePrivateIpAddress"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.autoMinorVersionUpgrade = dictionary["AutoMinorVersionUpgrade"] as? Bool
            self.publiclyAccessible = dictionary["PubliclyAccessible"] as? Bool
            self.replicationInstanceIdentifier = dictionary["ReplicationInstanceIdentifier"] as? String
            if let replicationInstancePrivateIpAddresses = dictionary["ReplicationInstancePrivateIpAddresses"] as? [String] {
                self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            }
            self.engineVersion = dictionary["EngineVersion"] as? String
            self.replicationInstanceClass = dictionary["ReplicationInstanceClass"] as? String
            self.preferredMaintenanceWindow = dictionary["PreferredMaintenanceWindow"] as? String
            self.replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String
            self.replicationInstancePublicIpAddress = dictionary["ReplicationInstancePublicIpAddress"] as? String
            self.secondaryAvailabilityZone = dictionary["SecondaryAvailabilityZone"] as? String
            self.kmsKeyId = dictionary["KmsKeyId"] as? String
        }
    }

    public struct ImportCertificateResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The certificate to be uploaded.
        public var certificate: Certificate? = nil

        public init() {}

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        public init(dictionary: [String: Any]) throws {
            if let certificate = dictionary["Certificate"] as? [String: Any] { self.certificate = try Dms.Certificate(dictionary: certificate) }
        }
    }

    public struct DescribeEndpointsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// Endpoint description.
        public var endpoints: [Endpoint]? = nil

        public init() {}

        public init(marker: String? = nil, endpoints: [Endpoint]? = nil) {
            self.marker = marker
            self.endpoints = endpoints
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let endpoints = dictionary["Endpoints"] as? [[String: Any]] {
                self.endpoints = try endpoints.map({ try Endpoint(dictionary: $0) })
            }
        }
    }

    public struct ModifyEndpointMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of endpoint.
        public var endpointType: String? = nil
        /// The name of the server where the endpoint database resides.
        public var serverName: String? = nil
        /// The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: String? = nil
        /// The name of the endpoint database.
        public var databaseName: String? = nil
        /// The user name to be used to login to the endpoint database.
        public var username: String? = nil
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: String = ""
        /// The SSL mode to be used. SSL mode can be one of four values: none, require, verify-ca, verify-full.  The default value is none.
        public var sslMode: String? = nil
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: String? = nil
        /// The type of engine for the endpoint. Valid values include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, SYBASE, and SQLSERVER.
        public var engineName: String? = nil
        /// The password to be used to login to the endpoint database.
        public var password: String? = nil
        /// The port used by the endpoint database.
        public var port: Int32? = nil
        /// Additional attributes associated with the connection.
        public var extraConnectionAttributes: String? = nil

        public init() {}

        public init(endpointType: String? = nil, serverName: String? = nil, endpointIdentifier: String? = nil, databaseName: String? = nil, username: String? = nil, endpointArn: String, sslMode: String? = nil, certificateArn: String? = nil, engineName: String? = nil, password: String? = nil, port: Int32? = nil, extraConnectionAttributes: String? = nil) {
            self.endpointType = endpointType
            self.serverName = serverName
            self.endpointIdentifier = endpointIdentifier
            self.databaseName = databaseName
            self.username = username
            self.endpointArn = endpointArn
            self.sslMode = sslMode
            self.certificateArn = certificateArn
            self.engineName = engineName
            self.password = password
            self.port = port
            self.extraConnectionAttributes = extraConnectionAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.endpointType = dictionary["EndpointType"] as? String
            self.serverName = dictionary["ServerName"] as? String
            self.endpointIdentifier = dictionary["EndpointIdentifier"] as? String
            self.databaseName = dictionary["DatabaseName"] as? String
            self.username = dictionary["Username"] as? String
            guard let endpointArn = dictionary["EndpointArn"] as? String else { throw InitializableError.missingRequiredParam("EndpointArn") }
            self.endpointArn = endpointArn
            self.sslMode = dictionary["SslMode"] as? String
            self.certificateArn = dictionary["CertificateArn"] as? String
            self.engineName = dictionary["EngineName"] as? String
            self.password = dictionary["Password"] as? String
            self.port = dictionary["Port"] as? Int32
            self.extraConnectionAttributes = dictionary["ExtraConnectionAttributes"] as? String
        }
    }

    public struct DescribeOrderableReplicationInstancesMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public var maxRecords: Int32? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil

        public init() {}

        public init(maxRecords: Int32? = nil, marker: String? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
        }

        public init(dictionary: [String: Any]) throws {
            self.maxRecords = dictionary["MaxRecords"] as? Int32
            self.marker = dictionary["Marker"] as? String
        }
    }

    public struct VpcSecurityGroupMembership: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The status of the VPC security group.
        public var status: String? = nil
        /// The VPC security group Id.
        public var vpcSecurityGroupId: String? = nil

        public init() {}

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.vpcSecurityGroupId = dictionary["VpcSecurityGroupId"] as? String
        }
    }

    public struct CreateReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The path of the JSON file that contains the table mappings. Preceed the path with "file://". For example, --table-mappings file://mappingfile.json
        public var tableMappings: String = ""
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var sourceEndpointArn: String = ""
        /// Tags to be added to the replication instance.
        public var tags: [Tag]? = nil
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: String = ""
        /// The replication task identifier. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public var replicationTaskIdentifier: String = ""
        /// The migration type.
        public var migrationType: String = ""
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var targetEndpointArn: String = ""
        /// The start time for the Change Data Capture (CDC) operation.
        public var cdcStartTime: Date? = nil
        /// Settings for the task, such as target metadata settings. For a complete list of task settings, see Task Settings for AWS Database Migration Service Tasks.
        public var replicationTaskSettings: String? = nil

        public init() {}

        public init(tableMappings: String, sourceEndpointArn: String, tags: [Tag]? = nil, replicationInstanceArn: String, replicationTaskIdentifier: String, migrationType: String, targetEndpointArn: String, cdcStartTime: Date? = nil, replicationTaskSettings: String? = nil) {
            self.tableMappings = tableMappings
            self.sourceEndpointArn = sourceEndpointArn
            self.tags = tags
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.migrationType = migrationType
            self.targetEndpointArn = targetEndpointArn
            self.cdcStartTime = cdcStartTime
            self.replicationTaskSettings = replicationTaskSettings
        }

        public init(dictionary: [String: Any]) throws {
            guard let tableMappings = dictionary["TableMappings"] as? String else { throw InitializableError.missingRequiredParam("TableMappings") }
            self.tableMappings = tableMappings
            guard let sourceEndpointArn = dictionary["SourceEndpointArn"] as? String else { throw InitializableError.missingRequiredParam("SourceEndpointArn") }
            self.sourceEndpointArn = sourceEndpointArn
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
            guard let replicationInstanceArn = dictionary["ReplicationInstanceArn"] as? String else { throw InitializableError.missingRequiredParam("ReplicationInstanceArn") }
            self.replicationInstanceArn = replicationInstanceArn
            guard let replicationTaskIdentifier = dictionary["ReplicationTaskIdentifier"] as? String else { throw InitializableError.missingRequiredParam("ReplicationTaskIdentifier") }
            self.replicationTaskIdentifier = replicationTaskIdentifier
            guard let migrationType = dictionary["MigrationType"] as? String else { throw InitializableError.missingRequiredParam("MigrationType") }
            self.migrationType = migrationType
            guard let targetEndpointArn = dictionary["TargetEndpointArn"] as? String else { throw InitializableError.missingRequiredParam("TargetEndpointArn") }
            self.targetEndpointArn = targetEndpointArn
            self.cdcStartTime = dictionary["CdcStartTime"] as? Date
            self.replicationTaskSettings = dictionary["ReplicationTaskSettings"] as? String
        }
    }

    public struct Filter: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the filter.
        public var name: String = ""
        /// The filter value.
        public var values: [String] = []

        public init() {}

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let values = dictionary["Values"] as? [String] else { throw InitializableError.missingRequiredParam("Values") }
            self.values = values
        }
    }

    public struct DescribeReplicationInstancesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public var marker: String? = nil
        /// The replication instances described.
        public var replicationInstances: [ReplicationInstance]? = nil

        public init() {}

        public init(marker: String? = nil, replicationInstances: [ReplicationInstance]? = nil) {
            self.marker = marker
            self.replicationInstances = replicationInstances
        }

        public init(dictionary: [String: Any]) throws {
            self.marker = dictionary["Marker"] as? String
            if let replicationInstances = dictionary["ReplicationInstances"] as? [[String: Any]] {
                self.replicationInstances = try replicationInstances.map({ try ReplicationInstance(dictionary: $0) })
            }
        }
    }

}