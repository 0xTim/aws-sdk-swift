// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Dms {

    public struct ModifyReplicationSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .structure)
        ]
        /// The modified replication subnet group.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct CreateReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]
        /// The replication task that was created.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct CreateReplicationSubnetGroupMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetIds", required: true, type: .structure), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupDescription", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .structure)
        ]
        /// The EC2 subnet IDs for the subnet group.
        public let subnetIds: SubnetIdentifierList
        /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup 
        public let replicationSubnetGroupIdentifier: String
        /// The description for the subnet group.
        public let replicationSubnetGroupDescription: String
        /// The tag to be assigned to the subnet group.
        public let tags: TagList?

        public init(subnetIds: SubnetIdentifierList, replicationSubnetGroupIdentifier: String, replicationSubnetGroupDescription: String, tags: TagList? = nil) {
            self.subnetIds = subnetIds
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIds = "SubnetIds"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case tags = "Tags"
        }
    }

    public struct ModifyEndpointResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure)
        ]
        /// The modified endpoint.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct ReplicationTaskList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .list)
        ]
        public let replicationTask: [ReplicationTask]?

        public init(replicationTask: [ReplicationTask]? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DescribeReplicationSubnetGroupsMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Filters applied to the describe action.
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct FilterList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filter", required: false, type: .list)
        ]
        public let filter: [Filter]?

        public init(filter: [Filter]? = nil) {
            self.filter = filter
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
        }
    }

    public struct DescribeEndpointsMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Filters applied to the describe action. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct DeleteEndpointMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct EventCategoriesList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventCategory", required: false, type: .list)
        ]
        public let eventCategory: [String]?

        public init(eventCategory: [String]? = nil) {
            self.eventCategory = eventCategory
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategory = "EventCategory"
        }
    }

    public struct S3Settings: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "CsvRowDelimiter", required: false, type: .string), 
            AWSShapeMember(label: "CompressionType", required: false, type: .enum), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "BucketName", required: false, type: .string), 
            AWSShapeMember(label: "BucketFolder", required: false, type: .string), 
            AWSShapeMember(label: "ExternalTableDefinition", required: false, type: .string), 
            AWSShapeMember(label: "CsvDelimiter", required: false, type: .string)
        ]
        ///  The delimiter used to separate rows in the source files. The default is a carriage return (\n). 
        public let csvRowDelimiter: String?
        ///  An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Set to NONE (the default) or do not use to leave the files uncompressed. 
        public let compressionType: CompressionTypeValue?
        ///  The Amazon Resource Name (ARN) used by the service access IAM role. 
        public let serviceAccessRoleArn: String?
        ///  The name of the S3 bucket. 
        public let bucketName: String?
        ///  An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path &lt;bucketFolder&gt;/&lt;schema_name&gt;/&lt;table_name&gt;/. If this parameter is not specified, then the path used is &lt;schema_name&gt;/&lt;table_name&gt;/. 
        public let bucketFolder: String?
        ///  
        public let externalTableDefinition: String?
        ///  The delimiter used to separate columns in the source files. The default is a comma. 
        public let csvDelimiter: String?

        public init(csvRowDelimiter: String? = nil, compressionType: CompressionTypeValue? = nil, serviceAccessRoleArn: String? = nil, bucketName: String? = nil, bucketFolder: String? = nil, externalTableDefinition: String? = nil, csvDelimiter: String? = nil) {
            self.csvRowDelimiter = csvRowDelimiter
            self.compressionType = compressionType
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.bucketName = bucketName
            self.bucketFolder = bucketFolder
            self.externalTableDefinition = externalTableDefinition
            self.csvDelimiter = csvDelimiter
        }

        private enum CodingKeys: String, CodingKey {
            case csvRowDelimiter = "CsvRowDelimiter"
            case compressionType = "CompressionType"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case bucketName = "BucketName"
            case bucketFolder = "BucketFolder"
            case externalTableDefinition = "ExternalTableDefinition"
            case csvDelimiter = "CsvDelimiter"
        }
    }

    public struct ReplicationSubnetGroups: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .list)
        ]
        public let replicationSubnetGroup: [ReplicationSubnetGroup]?

        public init(replicationSubnetGroup: [ReplicationSubnetGroup]? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct FilterValueList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .list)
        ]
        public let value: [String]?

        public init(value: [String]? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct Endpoint: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExtraConnectionAttributes", required: false, type: .string), 
            AWSShapeMember(label: "EndpointIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string), 
            AWSShapeMember(label: "EndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "DynamoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MongoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "EndpointType", required: false, type: .enum), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "S3Settings", required: false, type: .structure), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "SslMode", required: false, type: .enum), 
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "EngineName", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string)
        ]
        /// Additional connection attributes used to connect to the endpoint.
        public let extraConnectionAttributes: String?
        /// The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The user name used to connect to the endpoint.
        public let username: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The settings for the target DynamoDB database. For more information, see the DynamoDBSettings structure.
        public let dynamoDbSettings: DynamoDbSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public let mongoDbSettings: MongoDbSettings?
        /// The status of the endpoint.
        public let status: String?
        /// The type of endpoint.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The name of the server at the endpoint.
        public let serverName: String?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public let s3Settings: S3Settings?
        /// The name of the database at the endpoint.
        public let databaseName: String?
        ///  Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account. 
        public let externalId: String?
        /// The SSL mode used to connect to the endpoint. SSL mode can be one of four values: none, require, verify-ca, verify-full.  The default value is none.
        public let sslMode: DmsSslModeValue?
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public let certificateArn: String?
        /// The database engine name. Valid values, depending on the EndPointType, include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, S3, SYBASE, DYNAMODB, MONGODB, and SQLSERVER.
        public let engineName: String?
        /// The port value used to access the endpoint.
        public let port: Int32?
        /// The KMS key identifier that will be used to encrypt the connection parameters. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public let kmsKeyId: String?

        public init(extraConnectionAttributes: String? = nil, endpointIdentifier: String? = nil, username: String? = nil, endpointArn: String? = nil, dynamoDbSettings: DynamoDbSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, status: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, serverName: String? = nil, s3Settings: S3Settings? = nil, databaseName: String? = nil, externalId: String? = nil, sslMode: DmsSslModeValue? = nil, certificateArn: String? = nil, engineName: String? = nil, port: Int32? = nil, kmsKeyId: String? = nil) {
            self.extraConnectionAttributes = extraConnectionAttributes
            self.endpointIdentifier = endpointIdentifier
            self.username = username
            self.endpointArn = endpointArn
            self.dynamoDbSettings = dynamoDbSettings
            self.mongoDbSettings = mongoDbSettings
            self.status = status
            self.endpointType = endpointType
            self.serverName = serverName
            self.s3Settings = s3Settings
            self.databaseName = databaseName
            self.externalId = externalId
            self.sslMode = sslMode
            self.certificateArn = certificateArn
            self.engineName = engineName
            self.port = port
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case endpointIdentifier = "EndpointIdentifier"
            case username = "Username"
            case endpointArn = "EndpointArn"
            case dynamoDbSettings = "DynamoDbSettings"
            case mongoDbSettings = "MongoDbSettings"
            case status = "Status"
            case endpointType = "EndpointType"
            case serverName = "ServerName"
            case s3Settings = "S3Settings"
            case databaseName = "DatabaseName"
            case externalId = "ExternalId"
            case sslMode = "SslMode"
            case certificateArn = "CertificateArn"
            case engineName = "EngineName"
            case port = "Port"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct DescribeOrderableReplicationInstancesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "OrderableReplicationInstances", required: false, type: .structure), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]
        /// The order-able replication instances available.
        public let orderableReplicationInstances: OrderableReplicationInstanceList?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(orderableReplicationInstances: OrderableReplicationInstanceList? = nil, marker: String? = nil) {
            self.orderableReplicationInstances = orderableReplicationInstances
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case orderableReplicationInstances = "OrderableReplicationInstances"
            case marker = "Marker"
        }
    }

    public struct DescribeTableStatisticsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "TableStatistics", required: false, type: .list), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The table statistics.
        public let tableStatistics: [TableStatistics]?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?

        public init(marker: String? = nil, tableStatistics: [TableStatistics]? = nil, replicationTaskArn: String? = nil) {
            self.marker = marker
            self.tableStatistics = tableStatistics
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case tableStatistics = "TableStatistics"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct EventSubscription: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "SnsTopicArn", required: false, type: .string), 
            AWSShapeMember(label: "SourceIdsList", required: false, type: .structure), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "CustSubscriptionId", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "CustomerAwsId", required: false, type: .string), 
            AWSShapeMember(label: "EventCategoriesList", required: false, type: .structure), 
            AWSShapeMember(label: "SubscriptionCreationTime", required: false, type: .string)
        ]
        /// The status of the AWS DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that AWS DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public let status: String?
        /// The topic ARN of the AWS DMS event notification subscription.
        public let snsTopicArn: String?
        /// A list of source Ids for the event subscription.
        public let sourceIdsList: SourceIdsList?
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | migration-task
        public let sourceType: String?
        /// The AWS DMS event notification subscription Id.
        public let custSubscriptionId: String?
        /// Boolean value that indicates if the event subscription is enabled.
        public let enabled: Bool?
        /// The AWS customer account associated with the AWS DMS event notification subscription.
        public let customerAwsId: String?
        /// A lists of event categories.
        public let eventCategoriesList: EventCategoriesList?
        /// The time the RDS event notification subscription was created.
        public let subscriptionCreationTime: String?

        public init(status: String? = nil, snsTopicArn: String? = nil, sourceIdsList: SourceIdsList? = nil, sourceType: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, customerAwsId: String? = nil, eventCategoriesList: EventCategoriesList? = nil, subscriptionCreationTime: String? = nil) {
            self.status = status
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.customerAwsId = customerAwsId
            self.eventCategoriesList = eventCategoriesList
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case customerAwsId = "CustomerAwsId"
            case eventCategoriesList = "EventCategoriesList"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct DescribeEndpointTypesMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Filters applied to the describe action. Valid filter names: engine-name | endpoint-type
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct VpcSecurityGroupMembershipList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "VpcSecurityGroupMembership", required: false, type: .list)
        ]
        public let vpcSecurityGroupMembership: [VpcSecurityGroupMembership]?

        public init(vpcSecurityGroupMembership: [VpcSecurityGroupMembership]? = nil) {
            self.vpcSecurityGroupMembership = vpcSecurityGroupMembership
        }

        private enum CodingKeys: String, CodingKey {
            case vpcSecurityGroupMembership = "VpcSecurityGroupMembership"
        }
    }

    public struct TagList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tag", required: false, type: .list)
        ]
        public let tag: [Tag]?

        public init(tag: [Tag]? = nil) {
            self.tag = tag
        }

        private enum CodingKeys: String, CodingKey {
            case tag = "Tag"
        }
    }

    public enum DmsSslModeValue: String, CustomStringConvertible, Codable {
        case none = "none"
        case require = "require"
        case verify_ca = "verify-ca"
        case verify_full = "verify-full"
        public var description: String { return self.rawValue }
    }

    public struct DeleteReplicationInstanceMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
        public let replicationInstanceArn: String

        public init(replicationInstanceArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct SupportedEndpointType: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EngineName", required: false, type: .string), 
            AWSShapeMember(label: "EndpointType", required: false, type: .enum), 
            AWSShapeMember(label: "SupportsCDC", required: false, type: .boolean)
        ]
        /// The database engine name. Valid values, depending on the EndPointType, include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, S3, SYBASE, DYNAMODB, MONGODB, and SQLSERVER.
        public let engineName: String?
        /// The type of endpoint.
        public let endpointType: ReplicationEndpointTypeValue?
        /// Indicates if Change Data Capture (CDC) is supported.
        public let supportsCDC: Bool?

        public init(engineName: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, supportsCDC: Bool? = nil) {
            self.engineName = engineName
            self.endpointType = endpointType
            self.supportsCDC = supportsCDC
        }

        private enum CodingKeys: String, CodingKey {
            case engineName = "EngineName"
            case endpointType = "EndpointType"
            case supportsCDC = "SupportsCDC"
        }
    }

    public struct DeleteEventSubscriptionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .structure)
        ]
        /// The event subscription that was deleted.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public enum MigrationTypeValue: String, CustomStringConvertible, Codable {
        case full_load = "full-load"
        case cdc = "cdc"
        case full_load_and_cdc = "full-load-and-cdc"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEventCategoriesMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | migration-task
        public let sourceType: String?
        /// Filters applied to the action.
        public let filters: FilterList?

        public init(sourceType: String? = nil, filters: FilterList? = nil) {
            self.sourceType = sourceType
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case sourceType = "SourceType"
            case filters = "Filters"
        }
    }

    public struct DescribeCertificatesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Certificates", required: false, type: .structure)
        ]
        /// The pagination token.
        public let marker: String?
        /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
        public let certificates: CertificateList?

        public init(marker: String? = nil, certificates: CertificateList? = nil) {
            self.marker = marker
            self.certificates = certificates
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case certificates = "Certificates"
        }
    }

    public struct RemoveTagsFromResourceResponse: AWSShape {
        /// The key for the payload

    }

    public struct DescribeReplicationTasksMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Filters applied to the describe action. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct DeleteReplicationInstanceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]
        /// The replication instance that was deleted.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .string), 
            AWSShapeMember(label: "Key", required: false, type: .string)
        ]
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and cannot be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let value: String?
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and cannot be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let key: String?

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case key = "Key"
        }
    }

    public struct AddTagsToResourceResponse: AWSShape {
        /// The key for the payload

    }

    public struct ReloadTablesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the replication task. 
        public let replicationTaskArn: String?

        public init(replicationTaskArn: String? = nil) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeEndpointTypesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "SupportedEndpointTypes", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The type of endpoints that are supported.
        public let supportedEndpointTypes: SupportedEndpointTypeList?

        public init(marker: String? = nil, supportedEndpointTypes: SupportedEndpointTypeList? = nil) {
            self.marker = marker
            self.supportedEndpointTypes = supportedEndpointTypes
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case supportedEndpointTypes = "SupportedEndpointTypes"
        }
    }

    public struct ListTagsForResourceMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) string that uniquely identifies the AWS DMS resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct CreateEventSubscriptionMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SnsTopicArn", required: true, type: .string), 
            AWSShapeMember(label: "SubscriptionName", required: true, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .structure), 
            AWSShapeMember(label: "EventCategories", required: false, type: .structure), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceIds", required: false, type: .structure)
        ]
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it. 
        public let snsTopicArn: String
        /// The name of the DMS event notification subscription.  Constraints: The name must be less than 255 characters. 
        public let subscriptionName: String
        ///  The type of AWS DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value is not specified, all events are returned.  Valid values: replication-instance | migration-task
        public let sourceType: String?
        /// A tag to be attached to the event subscription.
        public let tags: TagList?
        ///  A list of event categories for a source type that you want to subscribe to. You can see a list of the categories for a given source type by calling the DescribeEventCategories action or in the topic  Working with Events and Notifications in the AWS Database Migration Service User Guide. 
        public let eventCategories: EventCategoriesList?
        ///  A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it. 
        public let enabled: Bool?
        ///  The list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it cannot end with a hyphen or contain two consecutive hyphens. 
        public let sourceIds: SourceIdsList?

        public init(snsTopicArn: String, subscriptionName: String, sourceType: String? = nil, tags: TagList? = nil, eventCategories: EventCategoriesList? = nil, enabled: Bool? = nil, sourceIds: SourceIdsList? = nil) {
            self.snsTopicArn = snsTopicArn
            self.subscriptionName = subscriptionName
            self.sourceType = sourceType
            self.tags = tags
            self.eventCategories = eventCategories
            self.enabled = enabled
            self.sourceIds = sourceIds
        }

        private enum CodingKeys: String, CodingKey {
            case snsTopicArn = "SnsTopicArn"
            case subscriptionName = "SubscriptionName"
            case sourceType = "SourceType"
            case tags = "Tags"
            case eventCategories = "EventCategories"
            case enabled = "Enabled"
            case sourceIds = "SourceIds"
        }
    }

    public struct StartReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "CdcStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "StartReplicationTaskType", required: true, type: .enum)
        ]
        /// The Amazon Resource Number (ARN) of the replication task to be started.
        public let replicationTaskArn: String
        /// The start time for the Change Data Capture (CDC) operation.
        public let cdcStartTime: TimeStamp?
        /// The type of replication task.
        public let startReplicationTaskType: StartReplicationTaskTypeValue

        public init(replicationTaskArn: String, cdcStartTime: TimeStamp? = nil, startReplicationTaskType: StartReplicationTaskTypeValue) {
            self.replicationTaskArn = replicationTaskArn
            self.cdcStartTime = cdcStartTime
            self.startReplicationTaskType = startReplicationTaskType
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
            case cdcStartTime = "CdcStartTime"
            case startReplicationTaskType = "StartReplicationTaskType"
        }
    }

    public struct CreateReplicationInstanceMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "Tags", required: false, type: .structure), 
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "VpcSecurityGroupIds", required: false, type: .structure), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "PubliclyAccessible", required: false, type: .boolean), 
            AWSShapeMember(label: "AutoMinorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: true, type: .string), 
            AWSShapeMember(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string)
        ]
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// Tags to be associated with the replication instance.
        public let tags: TagList?
        /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
        public let allocatedStorage: Int32?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. 
        public let vpcSecurityGroupIds: VpcSecurityGroupIdList?
        /// The EC2 Availability Zone that the replication instance will be created in. Default: A random, system-chosen Availability Zone in the endpoint's region.  Example: us-east-1d 
        public let availabilityZone: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true. 
        public let publiclyAccessible: Bool?
        /// Indicates that minor engine upgrades will be applied automatically to the replication instance during the maintenance window. Default: true 
        public let autoMinorVersionUpgrade: Bool?
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance 
        public let replicationInstanceIdentifier: String
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        /// The compute and memory capacity of the replication instance as specified by the replication instance class.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public let replicationInstanceClass: String
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).  Format: ddd:hh24:mi-ddd:hh24:mi  Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
        public let preferredMaintenanceWindow: String?
        /// A subnet group to associate with the replication instance.
        public let replicationSubnetGroupIdentifier: String?
        /// The KMS key identifier that will be used to encrypt the content on the replication instance. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public let kmsKeyId: String?

        public init(multiAZ: Bool? = nil, tags: TagList? = nil, allocatedStorage: Int32? = nil, vpcSecurityGroupIds: VpcSecurityGroupIdList? = nil, availabilityZone: String? = nil, publiclyAccessible: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil, replicationInstanceIdentifier: String, engineVersion: String? = nil, replicationInstanceClass: String, preferredMaintenanceWindow: String? = nil, replicationSubnetGroupIdentifier: String? = nil, kmsKeyId: String? = nil) {
            self.multiAZ = multiAZ
            self.tags = tags
            self.allocatedStorage = allocatedStorage
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.availabilityZone = availabilityZone
            self.publiclyAccessible = publiclyAccessible
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case multiAZ = "MultiAZ"
            case tags = "Tags"
            case allocatedStorage = "AllocatedStorage"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
            case availabilityZone = "AvailabilityZone"
            case publiclyAccessible = "PubliclyAccessible"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case engineVersion = "EngineVersion"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public enum SourceType: String, CustomStringConvertible, Codable {
        case replication_instance = "replication-instance"
        public var description: String { return self.rawValue }
    }

    public struct DeleteCertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .structure)
        ]
        /// The Secure Sockets Layer (SSL) certificate.
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct DescribeConnectionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Connections", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// A description of the connections.
        public let connections: ConnectionList?

        public init(marker: String? = nil, connections: ConnectionList? = nil) {
            self.marker = marker
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case connections = "Connections"
        }
    }

    public struct DescribeEventsMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum), 
            AWSShapeMember(label: "EventCategories", required: false, type: .structure), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Filters", required: false, type: .structure), 
            AWSShapeMember(label: "SourceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Duration", required: false, type: .integer)
        ]
        /// The start time for the events to be listed.
        public let startTime: TimeStamp?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The type of AWS DMS resource that generates events. Valid values: replication-instance | migration-task
        public let sourceType: SourceType?
        /// A list of event categories for a source type that you want to subscribe to.
        public let eventCategories: EventCategoriesList?
        /// The end time for the events to be listed.
        public let endTime: TimeStamp?
        /// Filters applied to the action.
        public let filters: FilterList?
        ///  The identifier of the event source. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It cannot end with a hyphen or contain two consecutive hyphens. 
        public let sourceIdentifier: String?
        /// The duration of the events to be listed.
        public let duration: Int32?

        public init(startTime: TimeStamp? = nil, maxRecords: Int32? = nil, marker: String? = nil, sourceType: SourceType? = nil, eventCategories: EventCategoriesList? = nil, endTime: TimeStamp? = nil, filters: FilterList? = nil, sourceIdentifier: String? = nil, duration: Int32? = nil) {
            self.startTime = startTime
            self.maxRecords = maxRecords
            self.marker = marker
            self.sourceType = sourceType
            self.eventCategories = eventCategories
            self.endTime = endTime
            self.filters = filters
            self.sourceIdentifier = sourceIdentifier
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "StartTime"
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case sourceType = "SourceType"
            case eventCategories = "EventCategories"
            case endTime = "EndTime"
            case filters = "Filters"
            case sourceIdentifier = "SourceIdentifier"
            case duration = "Duration"
        }
    }

    public struct VpcSecurityGroupIdList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "VpcSecurityGroupId", required: false, type: .list)
        ]
        public let vpcSecurityGroupId: [String]?

        public init(vpcSecurityGroupId: [String]? = nil) {
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public enum NestingLevelValue: String, CustomStringConvertible, Codable {
        case none = "none"
        case one = "one"
        public var description: String { return self.rawValue }
    }

    public struct DescribeTableStatisticsMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String

        public init(marker: String? = nil, maxRecords: Int32? = nil, replicationTaskArn: String) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeRefreshSchemasStatusMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct RemoveTagsFromResourceMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", required: true, type: .list)
        ]
        /// &gt;The Amazon Resource Name (ARN) of the AWS DMS resource the tag is to be removed from.
        public let resourceArn: String
        /// The tag key (name) of the tag to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public enum AuthTypeValue: String, CustomStringConvertible, Codable {
        case no = "no"
        case password = "password"
        public var description: String { return self.rawValue }
    }

    public struct MongoDbSettings: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthType", required: false, type: .enum), 
            AWSShapeMember(label: "AuthSource", required: false, type: .string), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "DocsToInvestigate", required: false, type: .string), 
            AWSShapeMember(label: "NestingLevel", required: false, type: .enum), 
            AWSShapeMember(label: "Username", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "ExtractDocId", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "AuthMechanism", required: false, type: .enum)
        ]
        ///  The authentication type you use to access the MongoDB source endpoint. Valid values: NO, PASSWORD  When NO is selected, user name and password parameters are not used and can be empty. 
        public let authType: AuthTypeValue?
        ///  The MongoDB database name. This attribute is not used when authType=NO.  The default is admin.
        public let authSource: String?
        ///  The name of the server on the MongoDB source endpoint. 
        public let serverName: String?
        ///  Indicates the number of documents to preview to determine the document organization. Use this attribute when NestingLevel is set to ONE.  Must be a positive value greater than 0. Default value is 1000.
        public let docsToInvestigate: String?
        ///  Specifies either document or table mode.  Valid values: NONE, ONE Default value is NONE. Specify NONE to use document mode. Specify ONE to use table mode.
        public let nestingLevel: NestingLevelValue?
        /// The user name you use to access the MongoDB source endpoint. 
        public let username: String?
        ///  The database name on the MongoDB source endpoint. 
        public let databaseName: String?
        ///  Specifies the document ID. Use this attribute when NestingLevel is set to NONE.  Default value is false. 
        public let extractDocId: String?
        ///  The password for the user account you use to access the MongoDB source endpoint. 
        public let password: String?
        ///  The port value for the MongoDB source endpoint. 
        public let port: Int32?
        ///  The authentication mechanism you use to access the MongoDB source endpoint. Valid values: DEFAULT, MONGODB_CR, SCRAM_SHA_1  DEFAULT – For MongoDB version 2.x, use MONGODB_CR. For MongoDB version 3.x, use SCRAM_SHA_1. This attribute is not used when authType=No.
        public let authMechanism: AuthMechanismValue?

        public init(authType: AuthTypeValue? = nil, authSource: String? = nil, serverName: String? = nil, docsToInvestigate: String? = nil, nestingLevel: NestingLevelValue? = nil, username: String? = nil, databaseName: String? = nil, extractDocId: String? = nil, password: String? = nil, port: Int32? = nil, authMechanism: AuthMechanismValue? = nil) {
            self.authType = authType
            self.authSource = authSource
            self.serverName = serverName
            self.docsToInvestigate = docsToInvestigate
            self.nestingLevel = nestingLevel
            self.username = username
            self.databaseName = databaseName
            self.extractDocId = extractDocId
            self.password = password
            self.port = port
            self.authMechanism = authMechanism
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "AuthType"
            case authSource = "AuthSource"
            case serverName = "ServerName"
            case docsToInvestigate = "DocsToInvestigate"
            case nestingLevel = "NestingLevel"
            case username = "Username"
            case databaseName = "DatabaseName"
            case extractDocId = "ExtractDocId"
            case password = "Password"
            case port = "Port"
            case authMechanism = "AuthMechanism"
        }
    }

    public struct ModifyReplicationInstanceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]
        /// The modified replication instance.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct DescribeEventCategoriesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventCategoryGroupList", required: false, type: .structure)
        ]
        /// A list of event categories.
        public let eventCategoryGroupList: EventCategoryGroupList?

        public init(eventCategoryGroupList: EventCategoryGroupList? = nil) {
            self.eventCategoryGroupList = eventCategoryGroupList
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategoryGroupList = "EventCategoryGroupList"
        }
    }

    public struct EventList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Event", required: false, type: .list)
        ]
        public let event: [Event]?

        public init(event: [Event]? = nil) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "Event"
        }
    }

    public struct DescribeReplicationSubnetGroupsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroups", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// A description of the replication subnet groups.
        public let replicationSubnetGroups: ReplicationSubnetGroups?

        public init(marker: String? = nil, replicationSubnetGroups: ReplicationSubnetGroups? = nil) {
            self.marker = marker
            self.replicationSubnetGroups = replicationSubnetGroups
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationSubnetGroups = "ReplicationSubnetGroups"
        }
    }

    public struct DescribeAccountAttributesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountQuotas", required: false, type: .structure)
        ]
        /// Account quota information.
        public let accountQuotas: AccountQuotaList?

        public init(accountQuotas: AccountQuotaList? = nil) {
            self.accountQuotas = accountQuotas
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotas = "AccountQuotas"
        }
    }

    public struct DescribeEventsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Events", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The events described.
        public let events: EventList?

        public init(marker: String? = nil, events: EventList? = nil) {
            self.marker = marker
            self.events = events
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case events = "Events"
        }
    }

    public struct DeleteEventSubscriptionMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubscriptionName", required: true, type: .string)
        ]
        /// The name of the DMS event notification subscription to be deleted.
        public let subscriptionName: String

        public init(subscriptionName: String) {
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionName = "SubscriptionName"
        }
    }

    public enum StartReplicationTaskTypeValue: String, CustomStringConvertible, Codable {
        case start_replication = "start-replication"
        case resume_processing = "resume-processing"
        case reload_target = "reload-target"
        public var description: String { return self.rawValue }
    }

    public struct DescribeSchemasResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Schemas", required: false, type: .list)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The described schema.
        public let schemas: [String]?

        public init(marker: String? = nil, schemas: [String]? = nil) {
            self.marker = marker
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case schemas = "Schemas"
        }
    }

    public struct DescribeAccountAttributesMessage: AWSShape {
        /// The key for the payload

    }

    public struct SourceIdsList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceId", required: false, type: .list)
        ]
        public let sourceId: [String]?

        public init(sourceId: [String]? = nil) {
            self.sourceId = sourceId
        }

        private enum CodingKeys: String, CodingKey {
            case sourceId = "SourceId"
        }
    }

    public struct SubnetIdentifierList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetIdentifier", required: false, type: .list)
        ]
        public let subnetIdentifier: [String]?

        public init(subnetIdentifier: [String]? = nil) {
            self.subnetIdentifier = subnetIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIdentifier = "SubnetIdentifier"
        }
    }

    public struct TableToReload: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SchemaName", required: false, type: .string), 
            AWSShapeMember(label: "TableName", required: false, type: .string)
        ]
        /// The schema name of the table to be reloaded.
        public let schemaName: String?
        /// The table name of the table to be reloaded.
        public let tableName: String?

        public init(schemaName: String? = nil, tableName: String? = nil) {
            self.schemaName = schemaName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case schemaName = "SchemaName"
            case tableName = "TableName"
        }
    }

    public struct CertificateList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .list)
        ]
        public let certificate: [Certificate]?

        public init(certificate: [Certificate]? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct Certificate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ValidFromDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "KeyLength", required: false, type: .integer), 
            AWSShapeMember(label: "SigningAlgorithm", required: false, type: .string), 
            AWSShapeMember(label: "CertificateWallet", required: false, type: .blob), 
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "CertificatePem", required: false, type: .string), 
            AWSShapeMember(label: "ValidToDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "CertificateOwner", required: false, type: .string), 
            AWSShapeMember(label: "CertificateIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "CertificateCreationDate", required: false, type: .timestamp)
        ]
        /// The beginning date that the certificate is valid.
        public let validFromDate: TimeStamp?
        /// The key length of the cryptographic algorithm being used.
        public let keyLength: Int32?
        /// The signing algorithm for the certificate.
        public let signingAlgorithm: String?
        /// The location of the imported Oracle Wallet certificate for use with SSL.
        public let certificateWallet: Data?
        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The contents of the .pem X.509 certificate file for the certificate.
        public let certificatePem: String?
        /// The final date that the certificate is valid.
        public let validToDate: TimeStamp?
        /// The owner of the certificate.
        public let certificateOwner: String?
        /// The customer-assigned name of the certificate. Valid characters are A-z and 0-9.
        public let certificateIdentifier: String?
        /// The date that the certificate was created.
        public let certificateCreationDate: TimeStamp?

        public init(validFromDate: TimeStamp? = nil, keyLength: Int32? = nil, signingAlgorithm: String? = nil, certificateWallet: Data? = nil, certificateArn: String? = nil, certificatePem: String? = nil, validToDate: TimeStamp? = nil, certificateOwner: String? = nil, certificateIdentifier: String? = nil, certificateCreationDate: TimeStamp? = nil) {
            self.validFromDate = validFromDate
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.certificateWallet = certificateWallet
            self.certificateArn = certificateArn
            self.certificatePem = certificatePem
            self.validToDate = validToDate
            self.certificateOwner = certificateOwner
            self.certificateIdentifier = certificateIdentifier
            self.certificateCreationDate = certificateCreationDate
        }

        private enum CodingKeys: String, CodingKey {
            case validFromDate = "ValidFromDate"
            case keyLength = "KeyLength"
            case signingAlgorithm = "SigningAlgorithm"
            case certificateWallet = "CertificateWallet"
            case certificateArn = "CertificateArn"
            case certificatePem = "CertificatePem"
            case validToDate = "ValidToDate"
            case certificateOwner = "CertificateOwner"
            case certificateIdentifier = "CertificateIdentifier"
            case certificateCreationDate = "CertificateCreationDate"
        }
    }

    public struct ReplicationInstanceList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .list)
        ]
        public let replicationInstance: [ReplicationInstance]?

        public init(replicationInstance: [ReplicationInstance]? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagList", required: false, type: .structure)
        ]
        /// A list of tags for the resource.
        public let tagList: TagList?

        public init(tagList: TagList? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct ModifyEventSubscriptionMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SnsTopicArn", required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionName", required: true, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "EventCategories", required: false, type: .structure), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean)
        ]
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String?
        /// The name of the AWS DMS event notification subscription to be modified.
        public let subscriptionName: String
        ///  The type of AWS DMS resource that generates the events you want to subscribe to.  Valid values: replication-instance | migration-task
        public let sourceType: String?
        ///  A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories. 
        public let eventCategories: EventCategoriesList?
        ///  A Boolean value; set to true to activate the subscription. 
        public let enabled: Bool?

        public init(snsTopicArn: String? = nil, subscriptionName: String, sourceType: String? = nil, eventCategories: EventCategoriesList? = nil, enabled: Bool? = nil) {
            self.snsTopicArn = snsTopicArn
            self.subscriptionName = subscriptionName
            self.sourceType = sourceType
            self.eventCategories = eventCategories
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case snsTopicArn = "SnsTopicArn"
            case subscriptionName = "SubscriptionName"
            case sourceType = "SourceType"
            case eventCategories = "EventCategories"
            case enabled = "Enabled"
        }
    }

    public struct AvailabilityZone: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The name of the availability zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public enum AuthMechanismValue: String, CustomStringConvertible, Codable {
        case `default` = "default"
        case mongodb_cr = "mongodb_cr"
        case scram_sha_1 = "scram_sha_1"
        public var description: String { return self.rawValue }
    }

    public struct ModifyReplicationInstanceMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllowMajorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "VpcSecurityGroupIds", required: false, type: .structure), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "ApplyImmediately", required: false, type: .boolean), 
            AWSShapeMember(label: "AutoMinorVersionUpgrade", required: false, type: .boolean)
        ]
        /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage and the change is asynchronously applied as soon as possible. Constraints: This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
        public let allowMajorVersionUpgrade: Bool?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public let replicationInstanceClass: String?
        /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
        public let preferredMaintenanceWindow: String?
        /// The amount of storage (in gigabytes) to be allocated for the replication instance.
        public let allocatedStorage: Int32?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. 
        public let vpcSecurityGroupIds: VpcSecurityGroupIdList?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// Indicates whether the changes should be applied immediately or during the next maintenance window.
        public let applyImmediately: Bool?
        ///  Indicates that minor version upgrades will be applied automatically to the replication instance during the maintenance window. Changing this parameter does not result in an outage except in the following case and the change is asynchronously applied as soon as possible. An outage will result if this parameter is set to true during the maintenance window, and a newer minor version is available, and AWS DMS has enabled auto patching for that engine version. 
        public let autoMinorVersionUpgrade: Bool?

        public init(allowMajorVersionUpgrade: Bool? = nil, replicationInstanceIdentifier: String? = nil, multiAZ: Bool? = nil, engineVersion: String? = nil, replicationInstanceClass: String? = nil, preferredMaintenanceWindow: String? = nil, allocatedStorage: Int32? = nil, vpcSecurityGroupIds: VpcSecurityGroupIdList? = nil, replicationInstanceArn: String, applyImmediately: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil) {
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.multiAZ = multiAZ
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.allocatedStorage = allocatedStorage
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.replicationInstanceArn = replicationInstanceArn
            self.applyImmediately = applyImmediately
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        }

        private enum CodingKeys: String, CodingKey {
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case multiAZ = "MultiAZ"
            case engineVersion = "EngineVersion"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case allocatedStorage = "AllocatedStorage"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case applyImmediately = "ApplyImmediately"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        }
    }

    public struct Connection: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "EndpointIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "EndpointArn", required: false, type: .string)
        ]
        /// The error message when the connection last failed.
        public let lastFailureMessage: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The connection status.
        public let status: String?
        /// The identifier of the endpoint. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?

        public init(lastFailureMessage: String? = nil, replicationInstanceIdentifier: String? = nil, replicationInstanceArn: String? = nil, status: String? = nil, endpointIdentifier: String? = nil, endpointArn: String? = nil) {
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
            self.endpointIdentifier = endpointIdentifier
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case lastFailureMessage = "LastFailureMessage"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case status = "Status"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointArn = "EndpointArn"
        }
    }

    public struct RefreshSchemasStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "EndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "LastRefreshDate", required: false, type: .timestamp)
        ]
        /// The last failure message for the schema.
        public let lastFailureMessage: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The status of the schema.
        public let status: RefreshSchemasStatusTypeValue?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The date the schema was last refreshed.
        public let lastRefreshDate: TimeStamp?

        public init(lastFailureMessage: String? = nil, replicationInstanceArn: String? = nil, status: RefreshSchemasStatusTypeValue? = nil, endpointArn: String? = nil, lastRefreshDate: TimeStamp? = nil) {
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
            self.endpointArn = endpointArn
            self.lastRefreshDate = lastRefreshDate
        }

        private enum CodingKeys: String, CodingKey {
            case lastFailureMessage = "LastFailureMessage"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case status = "Status"
            case endpointArn = "EndpointArn"
            case lastRefreshDate = "LastRefreshDate"
        }
    }

    public struct DescribeReplicationInstancesMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Filters applied to the describe action. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct DescribeEventSubscriptionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscriptionsList", required: false, type: .structure), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]
        /// A list of event subscriptions.
        public let eventSubscriptionsList: EventSubscriptionsList?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(eventSubscriptionsList: EventSubscriptionsList? = nil, marker: String? = nil) {
            self.eventSubscriptionsList = eventSubscriptionsList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscriptionsList = "EventSubscriptionsList"
            case marker = "Marker"
        }
    }

    public struct ConnectionList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connection", required: false, type: .list)
        ]
        public let connection: [Connection]?

        public init(connection: [Connection]? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct AccountQuota: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Max", required: false, type: .long), 
            AWSShapeMember(label: "Used", required: false, type: .long), 
            AWSShapeMember(label: "AccountQuotaName", required: false, type: .string)
        ]
        /// The maximum allowed value for the quota.
        public let max: Int64?
        /// The amount currently used toward the quota maximum.
        public let used: Int64?
        /// The name of the AWS DMS quota for this AWS account.
        public let accountQuotaName: String?

        public init(max: Int64? = nil, used: Int64? = nil, accountQuotaName: String? = nil) {
            self.max = max
            self.used = used
            self.accountQuotaName = accountQuotaName
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case used = "Used"
            case accountQuotaName = "AccountQuotaName"
        }
    }

    public struct DescribeCertificatesMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 10
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Filters applied to the certificate described in the form of key-value pairs.
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct ReloadTablesMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "TablesToReload", required: true, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the replication instance. 
        public let replicationTaskArn: String
        /// The name and schema of the table to be reloaded. 
        public let tablesToReload: [TableToReload]

        public init(replicationTaskArn: String, tablesToReload: [TableToReload]) {
            self.replicationTaskArn = replicationTaskArn
            self.tablesToReload = tablesToReload
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
            case tablesToReload = "TablesToReload"
        }
    }

    public struct RefreshSchemasMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(replicationInstanceArn: String, endpointArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceArn = "ReplicationInstanceArn"
            case endpointArn = "EndpointArn"
        }
    }

    public struct ModifyEventSubscriptionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .structure)
        ]
        /// The modified event subscription.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct StartReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]
        /// The replication task started.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DeleteReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the replication task to be deleted.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct Subnet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "SubnetAvailabilityZone", required: false, type: .structure), 
            AWSShapeMember(label: "SubnetStatus", required: false, type: .string)
        ]
        /// The subnet identifier.
        public let subnetIdentifier: String?
        /// The Availability Zone of the subnet.
        public let subnetAvailabilityZone: AvailabilityZone?
        /// The status of the subnet.
        public let subnetStatus: String?

        public init(subnetIdentifier: String? = nil, subnetAvailabilityZone: AvailabilityZone? = nil, subnetStatus: String? = nil) {
            self.subnetIdentifier = subnetIdentifier
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetStatus = subnetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIdentifier = "SubnetIdentifier"
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct CreateEndpointMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "EndpointIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .structure), 
            AWSShapeMember(label: "Username", required: false, type: .string), 
            AWSShapeMember(label: "MongoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "DynamoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "EndpointType", required: true, type: .enum), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "S3Settings", required: false, type: .structure), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "SslMode", required: false, type: .enum), 
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "EngineName", required: true, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ExtraConnectionAttributes", required: false, type: .string)
        ]
        /// The KMS key identifier that will be used to encrypt the connection parameters. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public let kmsKeyId: String?
        /// The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String
        /// Tags to be added to the endpoint.
        public let tags: TagList?
        /// The user name to be used to login to the endpoint database.
        public let username: String?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the Configuration Properties When Using MongoDB as a Source for AWS Database Migration Service section at  Using Amazon S3 as a Target for AWS Database Migration Service. 
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For more information about the available settings, see the Using Object Mapping to Migrate Data to DynamoDB section at  Using an Amazon DynamoDB Database as a Target for AWS Database Migration Service. 
        public let dynamoDbSettings: DynamoDbSettings?
        /// The type of endpoint.
        public let endpointType: ReplicationEndpointTypeValue
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        /// Settings in JSON format for the target S3 endpoint. For more information about the available settings, see the Extra Connection Attributes section at  Using Amazon S3 as a Target for AWS Database Migration Service. 
        public let s3Settings: S3Settings?
        /// The name of the endpoint database.
        public let databaseName: String?
        /// The SSL mode to use for the SSL connection. SSL mode can be one of four values: none, require, verify-ca, verify-full.  The default value is none.
        public let sslMode: DmsSslModeValue?
        /// The Amazon Resource Number (ARN) for the certificate.
        public let certificateArn: String?
        /// The type of engine for the endpoint. Valid values, depending on the EndPointType, include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, S3, SYBASE, DYNAMODB, MONGODB, and SQLSERVER.
        public let engineName: String
        /// The password to be used to login to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int32?
        /// Additional attributes associated with the connection.
        public let extraConnectionAttributes: String?

        public init(kmsKeyId: String? = nil, endpointIdentifier: String, tags: TagList? = nil, username: String? = nil, mongoDbSettings: MongoDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, endpointType: ReplicationEndpointTypeValue, serverName: String? = nil, s3Settings: S3Settings? = nil, databaseName: String? = nil, sslMode: DmsSslModeValue? = nil, certificateArn: String? = nil, engineName: String, password: String? = nil, port: Int32? = nil, extraConnectionAttributes: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.endpointIdentifier = endpointIdentifier
            self.tags = tags
            self.username = username
            self.mongoDbSettings = mongoDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.endpointType = endpointType
            self.serverName = serverName
            self.s3Settings = s3Settings
            self.databaseName = databaseName
            self.sslMode = sslMode
            self.certificateArn = certificateArn
            self.engineName = engineName
            self.password = password
            self.port = port
            self.extraConnectionAttributes = extraConnectionAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case endpointIdentifier = "EndpointIdentifier"
            case tags = "Tags"
            case username = "Username"
            case mongoDbSettings = "MongoDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case endpointType = "EndpointType"
            case serverName = "ServerName"
            case s3Settings = "S3Settings"
            case databaseName = "DatabaseName"
            case sslMode = "SslMode"
            case certificateArn = "CertificateArn"
            case engineName = "EngineName"
            case password = "Password"
            case port = "Port"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
        }
    }

    public struct EventCategoryGroup: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "EventCategories", required: false, type: .structure)
        ]
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | migration-task
        public let sourceType: String?
        ///  A list of event categories for a SourceType that you want to subscribe to. 
        public let eventCategories: EventCategoriesList?

        public init(sourceType: String? = nil, eventCategories: EventCategoriesList? = nil) {
            self.sourceType = sourceType
            self.eventCategories = eventCategories
        }

        private enum CodingKeys: String, CodingKey {
            case sourceType = "SourceType"
            case eventCategories = "EventCategories"
        }
    }

    public struct ReplicationSubnetGroup: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetGroupStatus", required: false, type: .string), 
            AWSShapeMember(label: "Subnets", required: false, type: .structure), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupDescription", required: false, type: .string), 
            AWSShapeMember(label: "VpcId", required: false, type: .string)
        ]
        /// The status of the subnet group.
        public let subnetGroupStatus: String?
        /// The subnets that are in the subnet group.
        public let subnets: SubnetList?
        /// The identifier of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String?
        /// The description of the replication subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(subnetGroupStatus: String? = nil, subnets: SubnetList? = nil, replicationSubnetGroupIdentifier: String? = nil, replicationSubnetGroupDescription: String? = nil, vpcId: String? = nil) {
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case vpcId = "VpcId"
        }
    }

    public struct Event: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "SourceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Date", required: false, type: .timestamp), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum), 
            AWSShapeMember(label: "EventCategories", required: false, type: .structure)
        ]
        /// The event message.
        public let message: String?
        ///  The identifier of the event source. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it cannot end with a hyphen or contain two consecutive hyphens.  Constraints:replication instance, endpoint, migration task
        public let sourceIdentifier: String?
        /// The date of the event.
        public let date: TimeStamp?
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | endpoint | migration-task
        public let sourceType: SourceType?
        /// The event categories available for the specified source type.
        public let eventCategories: EventCategoriesList?

        public init(message: String? = nil, sourceIdentifier: String? = nil, date: TimeStamp? = nil, sourceType: SourceType? = nil, eventCategories: EventCategoriesList? = nil) {
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.date = date
            self.sourceType = sourceType
            self.eventCategories = eventCategories
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case sourceIdentifier = "SourceIdentifier"
            case date = "Date"
            case sourceType = "SourceType"
            case eventCategories = "EventCategories"
        }
    }

    public struct TestConnectionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connection", required: false, type: .structure)
        ]
        /// The connection tested.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DescribeEventSubscriptionsMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Filters", required: false, type: .structure), 
            AWSShapeMember(label: "SubscriptionName", required: false, type: .string), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        /// Filters applied to the action.
        public let filters: FilterList?
        /// The name of the AWS DMS event subscription to be described.
        public let subscriptionName: String?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(maxRecords: Int32? = nil, filters: FilterList? = nil, subscriptionName: String? = nil, marker: String? = nil) {
            self.maxRecords = maxRecords
            self.filters = filters
            self.subscriptionName = subscriptionName
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case filters = "Filters"
            case subscriptionName = "SubscriptionName"
            case marker = "Marker"
        }
    }

    public struct TableStatistics: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deletes", required: false, type: .long), 
            AWSShapeMember(label: "Updates", required: false, type: .long), 
            AWSShapeMember(label: "TableState", required: false, type: .string), 
            AWSShapeMember(label: "SchemaName", required: false, type: .string), 
            AWSShapeMember(label: "FullLoadCondtnlChkFailedRows", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadRows", required: false, type: .long), 
            AWSShapeMember(label: "Inserts", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadErrorRows", required: false, type: .long), 
            AWSShapeMember(label: "TableName", required: false, type: .string), 
            AWSShapeMember(label: "LastUpdateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Ddls", required: false, type: .long)
        ]
        /// The number of delete actions performed on a table.
        public let deletes: Int64?
        /// The number of update actions performed on a table.
        public let updates: Int64?
        /// The state of the table.
        public let tableState: String?
        /// The schema name.
        public let schemaName: String?
        /// The number of rows that failed conditional checks during the Full Load operation (valid only for DynamoDB as a target migrations).
        public let fullLoadCondtnlChkFailedRows: Int64?
        /// The number of rows added during the Full Load operation.
        public let fullLoadRows: Int64?
        /// The number of insert actions performed on a table.
        public let inserts: Int64?
        /// The number of rows that failed to load during the Full Load operation (valid only for DynamoDB as a target migrations).
        public let fullLoadErrorRows: Int64?
        /// The name of the table.
        public let tableName: String?
        /// The last time the table was updated.
        public let lastUpdateTime: TimeStamp?
        /// The Data Definition Language (DDL) used to build and modify the structure of your tables.
        public let ddls: Int64?

        public init(deletes: Int64? = nil, updates: Int64? = nil, tableState: String? = nil, schemaName: String? = nil, fullLoadCondtnlChkFailedRows: Int64? = nil, fullLoadRows: Int64? = nil, inserts: Int64? = nil, fullLoadErrorRows: Int64? = nil, tableName: String? = nil, lastUpdateTime: TimeStamp? = nil, ddls: Int64? = nil) {
            self.deletes = deletes
            self.updates = updates
            self.tableState = tableState
            self.schemaName = schemaName
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadRows = fullLoadRows
            self.inserts = inserts
            self.fullLoadErrorRows = fullLoadErrorRows
            self.tableName = tableName
            self.lastUpdateTime = lastUpdateTime
            self.ddls = ddls
        }

        private enum CodingKeys: String, CodingKey {
            case deletes = "Deletes"
            case updates = "Updates"
            case tableState = "TableState"
            case schemaName = "SchemaName"
            case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
            case fullLoadRows = "FullLoadRows"
            case inserts = "Inserts"
            case fullLoadErrorRows = "FullLoadErrorRows"
            case tableName = "TableName"
            case lastUpdateTime = "LastUpdateTime"
            case ddls = "Ddls"
        }
    }

    public struct CreateReplicationSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .structure)
        ]
        /// The replication subnet group that was created.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct ImportCertificateMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateWallet", required: false, type: .blob), 
            AWSShapeMember(label: "CertificatePem", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .structure), 
            AWSShapeMember(label: "CertificateIdentifier", required: true, type: .string)
        ]
        /// The location of the imported Oracle Wallet certificate for use with SSL.
        public let certificateWallet: Data?
        /// The contents of the .pem X.509 certificate file for the certificate.
        public let certificatePem: String?
        /// The tags associated with the certificate.
        public let tags: TagList?
        /// The customer-assigned name of the certificate. Valid characters are A-z and 0-9.
        public let certificateIdentifier: String

        public init(certificateWallet: Data? = nil, certificatePem: String? = nil, tags: TagList? = nil, certificateIdentifier: String) {
            self.certificateWallet = certificateWallet
            self.certificatePem = certificatePem
            self.tags = tags
            self.certificateIdentifier = certificateIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case certificateWallet = "CertificateWallet"
            case certificatePem = "CertificatePem"
            case tags = "Tags"
            case certificateIdentifier = "CertificateIdentifier"
        }
    }

    public struct TestConnectionMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(replicationInstanceArn: String, endpointArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceArn = "ReplicationInstanceArn"
            case endpointArn = "EndpointArn"
        }
    }

    public struct DeleteReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]
        /// The deleted replication task.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct CreateEndpointResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure)
        ]
        /// The endpoint that was created.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct CreateReplicationInstanceResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]
        /// The replication instance that was created.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct SubnetList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Subnet", required: false, type: .list)
        ]
        public let subnet: [Subnet]?

        public init(subnet: [Subnet]? = nil) {
            self.subnet = subnet
        }

        private enum CodingKeys: String, CodingKey {
            case subnet = "Subnet"
        }
    }

    public struct EndpointList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .list)
        ]
        public let endpoint: [Endpoint]?

        public init(endpoint: [Endpoint]? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct ModifyReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableMappings", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "MigrationType", required: false, type: .enum), 
            AWSShapeMember(label: "CdcStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReplicationTaskSettings", required: false, type: .string)
        ]
        /// When using the AWS CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with "file://". When working with the DMS API, provide the JSON as the parameter value. For example, --table-mappings file://mappingfile.json
        public let tableMappings: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String
        /// The replication task identifier. Constraints:   Must contain from 1 to 255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public let replicationTaskIdentifier: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
        public let migrationType: MigrationTypeValue?
        /// The start time for the Change Data Capture (CDC) operation.
        public let cdcStartTime: TimeStamp?
        /// JSON file that contains settings for the task, such as target metadata settings.
        public let replicationTaskSettings: String?

        public init(tableMappings: String? = nil, replicationTaskArn: String, replicationTaskIdentifier: String? = nil, migrationType: MigrationTypeValue? = nil, cdcStartTime: TimeStamp? = nil, replicationTaskSettings: String? = nil) {
            self.tableMappings = tableMappings
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.migrationType = migrationType
            self.cdcStartTime = cdcStartTime
            self.replicationTaskSettings = replicationTaskSettings
        }

        private enum CodingKeys: String, CodingKey {
            case tableMappings = "TableMappings"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case migrationType = "MigrationType"
            case cdcStartTime = "CdcStartTime"
            case replicationTaskSettings = "ReplicationTaskSettings"
        }
    }

    public struct ModifyReplicationSubnetGroupMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetIds", required: true, type: .structure), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupDescription", required: false, type: .string)
        ]
        /// A list of subnet IDs.
        public let subnetIds: SubnetIdentifierList
        /// The name of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String
        /// The description of the replication instance subnet group.
        public let replicationSubnetGroupDescription: String?

        public init(subnetIds: SubnetIdentifierList, replicationSubnetGroupIdentifier: String, replicationSubnetGroupDescription: String? = nil) {
            self.subnetIds = subnetIds
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        }

        private enum CodingKeys: String, CodingKey {
            case subnetIds = "SubnetIds"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        }
    }

    public struct OrderableReplicationInstance: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "StorageType", required: false, type: .string), 
            AWSShapeMember(label: "MinAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "IncludedAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "MaxAllocatedStorage", required: false, type: .integer)
        ]
        /// The version of the replication engine.
        public let engineVersion: String?
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public let replicationInstanceClass: String?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public let defaultAllocatedStorage: Int32?
        /// The type of storage used by the replication instance.
        public let storageType: String?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let minAllocatedStorage: Int32?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let includedAllocatedStorage: Int32?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let maxAllocatedStorage: Int32?

        public init(engineVersion: String? = nil, replicationInstanceClass: String? = nil, defaultAllocatedStorage: Int32? = nil, storageType: String? = nil, minAllocatedStorage: Int32? = nil, includedAllocatedStorage: Int32? = nil, maxAllocatedStorage: Int32? = nil) {
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.storageType = storageType
            self.minAllocatedStorage = minAllocatedStorage
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
        }

        private enum CodingKeys: String, CodingKey {
            case engineVersion = "EngineVersion"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case defaultAllocatedStorage = "DefaultAllocatedStorage"
            case storageType = "StorageType"
            case minAllocatedStorage = "MinAllocatedStorage"
            case includedAllocatedStorage = "IncludedAllocatedStorage"
            case maxAllocatedStorage = "MaxAllocatedStorage"
        }
    }

    public struct ReplicationTaskStats: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TablesLoaded", required: false, type: .integer), 
            AWSShapeMember(label: "ElapsedTimeMillis", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadProgressPercent", required: false, type: .integer), 
            AWSShapeMember(label: "TablesQueued", required: false, type: .integer), 
            AWSShapeMember(label: "TablesErrored", required: false, type: .integer), 
            AWSShapeMember(label: "TablesLoading", required: false, type: .integer)
        ]
        /// The number of tables loaded for this task.
        public let tablesLoaded: Int32?
        /// The elapsed time of the task, in milliseconds.
        public let elapsedTimeMillis: Int64?
        /// The percent complete for the full load migration task.
        public let fullLoadProgressPercent: Int32?
        /// The number of tables queued for this task.
        public let tablesQueued: Int32?
        /// The number of errors that have occurred during this task.
        public let tablesErrored: Int32?
        /// The number of tables currently loading for this task.
        public let tablesLoading: Int32?

        public init(tablesLoaded: Int32? = nil, elapsedTimeMillis: Int64? = nil, fullLoadProgressPercent: Int32? = nil, tablesQueued: Int32? = nil, tablesErrored: Int32? = nil, tablesLoading: Int32? = nil) {
            self.tablesLoaded = tablesLoaded
            self.elapsedTimeMillis = elapsedTimeMillis
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.tablesQueued = tablesQueued
            self.tablesErrored = tablesErrored
            self.tablesLoading = tablesLoading
        }

        private enum CodingKeys: String, CodingKey {
            case tablesLoaded = "TablesLoaded"
            case elapsedTimeMillis = "ElapsedTimeMillis"
            case fullLoadProgressPercent = "FullLoadProgressPercent"
            case tablesQueued = "TablesQueued"
            case tablesErrored = "TablesErrored"
            case tablesLoading = "TablesLoading"
        }
    }

    public struct DeleteEndpointResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure)
        ]
        /// The endpoint that was deleted.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct ModifyReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]
        /// The replication task that was modified.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct SupportedEndpointTypeList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SupportedEndpointType", required: false, type: .list)
        ]
        public let supportedEndpointType: [SupportedEndpointType]?

        public init(supportedEndpointType: [SupportedEndpointType]? = nil) {
            self.supportedEndpointType = supportedEndpointType
        }

        private enum CodingKeys: String, CodingKey {
            case supportedEndpointType = "SupportedEndpointType"
        }
    }

    public struct ReplicationTask: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskStats", required: false, type: .structure), 
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskStartDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReplicationTaskCreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "SourceEndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "TableMappings", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "StopReason", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "MigrationType", required: false, type: .enum), 
            AWSShapeMember(label: "TargetEndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskSettings", required: false, type: .string)
        ]
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public let replicationTaskStats: ReplicationTaskStats?
        /// The last error (failure) message generated for the replication instance.
        public let lastFailureMessage: String?
        /// The date the replication task is scheduled to start.
        public let replicationTaskStartDate: TimeStamp?
        /// The date the replication task was created.
        public let replicationTaskCreationDate: TimeStamp?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let sourceEndpointArn: String?
        /// Table mappings specified in the task.
        public let tableMappings: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The status of the replication task.
        public let status: String?
        /// The reason the replication task was stopped.
        public let stopReason: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The replication task identifier. Constraints:   Must contain from 1 to 255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public let replicationTaskIdentifier: String?
        /// The type of migration.
        public let migrationType: MigrationTypeValue?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let targetEndpointArn: String?
        /// The settings for the replication task.
        public let replicationTaskSettings: String?

        public init(replicationTaskStats: ReplicationTaskStats? = nil, lastFailureMessage: String? = nil, replicationTaskStartDate: TimeStamp? = nil, replicationTaskCreationDate: TimeStamp? = nil, sourceEndpointArn: String? = nil, tableMappings: String? = nil, replicationTaskArn: String? = nil, status: String? = nil, stopReason: String? = nil, replicationInstanceArn: String? = nil, replicationTaskIdentifier: String? = nil, migrationType: MigrationTypeValue? = nil, targetEndpointArn: String? = nil, replicationTaskSettings: String? = nil) {
            self.replicationTaskStats = replicationTaskStats
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.replicationTaskArn = replicationTaskArn
            self.status = status
            self.stopReason = stopReason
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.migrationType = migrationType
            self.targetEndpointArn = targetEndpointArn
            self.replicationTaskSettings = replicationTaskSettings
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskStats = "ReplicationTaskStats"
            case lastFailureMessage = "LastFailureMessage"
            case replicationTaskStartDate = "ReplicationTaskStartDate"
            case replicationTaskCreationDate = "ReplicationTaskCreationDate"
            case sourceEndpointArn = "SourceEndpointArn"
            case tableMappings = "TableMappings"
            case replicationTaskArn = "ReplicationTaskArn"
            case status = "Status"
            case stopReason = "StopReason"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case migrationType = "MigrationType"
            case targetEndpointArn = "TargetEndpointArn"
            case replicationTaskSettings = "ReplicationTaskSettings"
        }
    }

    public struct StopReplicationTaskResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]
        /// The replication task stopped.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct RefreshSchemasResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "RefreshSchemasStatus", required: false, type: .structure)
        ]
        /// The status of the refreshed schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct DeleteCertificateMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the deleted certificate.
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
        }
    }

    public struct DynamoDbSettings: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceAccessRoleArn", required: true, type: .string)
        ]
        ///  The Amazon Resource Name (ARN) used by the service access IAM role. 
        public let serviceAccessRoleArn: String

        public init(serviceAccessRoleArn: String) {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct DescribeRefreshSchemasStatusResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "RefreshSchemasStatus", required: false, type: .structure)
        ]
        /// The status of the schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct DescribeSchemasMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?

        public init(marker: String? = nil, endpointArn: String, maxRecords: Int32? = nil) {
            self.marker = marker
            self.endpointArn = endpointArn
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case endpointArn = "EndpointArn"
            case maxRecords = "MaxRecords"
        }
    }

    public struct StopReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]
        /// The Amazon Resource Number(ARN) of the replication task to be stopped.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct CreateEventSubscriptionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .structure)
        ]
        /// The event subscription that was created.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public enum RefreshSchemasStatusTypeValue: String, CustomStringConvertible, Codable {
        case successful = "successful"
        case failed = "failed"
        case refreshing = "refreshing"
        public var description: String { return self.rawValue }
    }

    public struct OrderableReplicationInstanceList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "OrderableReplicationInstance", required: false, type: .list)
        ]
        public let orderableReplicationInstance: [OrderableReplicationInstance]?

        public init(orderableReplicationInstance: [OrderableReplicationInstance]? = nil) {
            self.orderableReplicationInstance = orderableReplicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case orderableReplicationInstance = "OrderableReplicationInstance"
        }
    }

    public struct EventCategoryGroupList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventCategoryGroup", required: false, type: .list)
        ]
        public let eventCategoryGroup: [EventCategoryGroup]?

        public init(eventCategoryGroup: [EventCategoryGroup]? = nil) {
            self.eventCategoryGroup = eventCategoryGroup
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategoryGroup = "EventCategoryGroup"
        }
    }

    public struct DescribeReplicationTasksResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTasks", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// A description of the replication tasks.
        public let replicationTasks: ReplicationTaskList?

        public init(marker: String? = nil, replicationTasks: ReplicationTaskList? = nil) {
            self.marker = marker
            self.replicationTasks = replicationTasks
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTasks = "ReplicationTasks"
        }
    }

    public struct AddTagsToResourceMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .structure)
        ]
        /// The Amazon Resource Name (ARN) of the AWS DMS resource the tag is to be added to. AWS DMS resources include a replication instance, endpoint, and a replication task.
        public let resourceArn: String
        /// The tag to be assigned to the DMS resource.
        public let tags: TagList

        public init(resourceArn: String, tags: TagList) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct DescribeConnectionsMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Filters", required: false, type: .structure)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
        public let filters: FilterList?

        public init(maxRecords: Int32? = nil, marker: String? = nil, filters: FilterList? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
            case filters = "Filters"
        }
    }

    public struct AccountQuotaList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountQuota", required: false, type: .list)
        ]
        public let accountQuota: [AccountQuota]?

        public init(accountQuota: [AccountQuota]? = nil) {
            self.accountQuota = accountQuota
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuota = "AccountQuota"
        }
    }

    public struct DeleteReplicationSubnetGroupResponse: AWSShape {
        /// The key for the payload

    }

    public struct DeleteReplicationSubnetGroupMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: true, type: .string)
        ]
        /// The subnet group name of the replication instance.
        public let replicationSubnetGroupIdentifier: String

        public init(replicationSubnetGroupIdentifier: String) {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        }
    }

    public enum CompressionTypeValue: String, CustomStringConvertible, Codable {
        case none = "none"
        case gzip = "gzip"
        public var description: String { return self.rawValue }
    }

    public struct ReplicationPendingModifiedValues: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer)
        ]
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public let replicationInstanceClass: String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int32?

        public init(multiAZ: Bool? = nil, engineVersion: String? = nil, replicationInstanceClass: String? = nil, allocatedStorage: Int32? = nil) {
            self.multiAZ = multiAZ
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.allocatedStorage = allocatedStorage
        }

        private enum CodingKeys: String, CodingKey {
            case multiAZ = "MultiAZ"
            case engineVersion = "EngineVersion"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case allocatedStorage = "AllocatedStorage"
        }
    }

    public struct EventSubscriptionsList: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .list)
        ]
        public let eventSubscription: [EventSubscription]?

        public init(eventSubscription: [EventSubscription]? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct ReplicationInstance: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "InstanceCreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "PendingModifiedValues", required: false, type: .structure), 
            AWSShapeMember(label: "ReplicationInstanceStatus", required: false, type: .string), 
            AWSShapeMember(label: "VpcSecurityGroups", required: false, type: .structure), 
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstancePublicIpAddresses", required: false, type: .list), 
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .structure), 
            AWSShapeMember(label: "ReplicationInstancePrivateIpAddress", required: false, type: .string), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "AutoMinorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "PubliclyAccessible", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstancePrivateIpAddresses", required: false, type: .list), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstancePublicIpAddress", required: false, type: .string), 
            AWSShapeMember(label: "SecondaryAvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string)
        ]
        /// The time the replication instance was created.
        public let instanceCreateTime: TimeStamp?
        /// The pending modification values.
        public let pendingModifiedValues: ReplicationPendingModifiedValues?
        /// The status of the replication instance.
        public let replicationInstanceStatus: String?
        /// The VPC security group for the instance.
        public let vpcSecurityGroups: VpcSecurityGroupMembershipList?
        ///  Specifies if the replication instance is a Multi-AZ deployment. You cannot set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The public IP address of the replication instance.
        public let replicationInstancePublicIpAddresses: [String]?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int32?
        /// The subnet group for the replication instance.
        public let replicationSubnetGroup: ReplicationSubnetGroup?
        /// The private IP address of the replication instance.
        public let replicationInstancePrivateIpAddress: String?
        /// The Availability Zone for the instance.
        public let availabilityZone: String?
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public let autoMinorVersionUpgrade: Bool?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true. 
        public let publiclyAccessible: Bool?
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain from 1 to 63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance 
        public let replicationInstanceIdentifier: String?
        /// The private IP address of the replication instance.
        public let replicationInstancePrivateIpAddresses: [String]?
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        /// The compute and memory capacity of the replication instance.  Valid Values: dms.t2.micro | dms.t2.small | dms.t2.medium | dms.t2.large | dms.c4.large | dms.c4.xlarge | dms.c4.2xlarge | dms.c4.4xlarge  
        public let replicationInstanceClass: String?
        /// The maintenance window times for the replication instance.
        public let preferredMaintenanceWindow: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The public IP address of the replication instance.
        public let replicationInstancePublicIpAddress: String?
        /// The availability zone of the standby replication instance in a Multi-AZ deployment.
        public let secondaryAvailabilityZone: String?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you do not specify a value for the KmsKeyId parameter, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
        public let kmsKeyId: String?

        public init(instanceCreateTime: TimeStamp? = nil, pendingModifiedValues: ReplicationPendingModifiedValues? = nil, replicationInstanceStatus: String? = nil, vpcSecurityGroups: VpcSecurityGroupMembershipList? = nil, multiAZ: Bool? = nil, replicationInstancePublicIpAddresses: [String]? = nil, allocatedStorage: Int32? = nil, replicationSubnetGroup: ReplicationSubnetGroup? = nil, replicationInstancePrivateIpAddress: String? = nil, availabilityZone: String? = nil, autoMinorVersionUpgrade: Bool? = nil, publiclyAccessible: Bool? = nil, replicationInstanceIdentifier: String? = nil, replicationInstancePrivateIpAddresses: [String]? = nil, engineVersion: String? = nil, replicationInstanceClass: String? = nil, preferredMaintenanceWindow: String? = nil, replicationInstanceArn: String? = nil, replicationInstancePublicIpAddress: String? = nil, secondaryAvailabilityZone: String? = nil, kmsKeyId: String? = nil) {
            self.instanceCreateTime = instanceCreateTime
            self.pendingModifiedValues = pendingModifiedValues
            self.replicationInstanceStatus = replicationInstanceStatus
            self.vpcSecurityGroups = vpcSecurityGroups
            self.multiAZ = multiAZ
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.allocatedStorage = allocatedStorage
            self.replicationSubnetGroup = replicationSubnetGroup
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.availabilityZone = availabilityZone
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.engineVersion = engineVersion
            self.replicationInstanceClass = replicationInstanceClass
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCreateTime = "InstanceCreateTime"
            case pendingModifiedValues = "PendingModifiedValues"
            case replicationInstanceStatus = "ReplicationInstanceStatus"
            case vpcSecurityGroups = "VpcSecurityGroups"
            case multiAZ = "MultiAZ"
            case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
            case allocatedStorage = "AllocatedStorage"
            case replicationSubnetGroup = "ReplicationSubnetGroup"
            case replicationInstancePrivateIpAddress = "ReplicationInstancePrivateIpAddress"
            case availabilityZone = "AvailabilityZone"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
            case engineVersion = "EngineVersion"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstancePublicIpAddress = "ReplicationInstancePublicIpAddress"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct ImportCertificateResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .structure)
        ]
        /// The certificate to be uploaded.
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct DescribeEndpointsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Endpoints", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// Endpoint description.
        public let endpoints: EndpointList?

        public init(marker: String? = nil, endpoints: EndpointList? = nil) {
            self.marker = marker
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case endpoints = "Endpoints"
        }
    }

    public struct ModifyEndpointMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "DynamoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MongoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "EndpointType", required: false, type: .enum), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "S3Settings", required: false, type: .structure), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "SslMode", required: false, type: .enum), 
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "EngineName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ExtraConnectionAttributes", required: false, type: .string)
        ]
        /// The database endpoint identifier. Identifiers must begin with a letter; must contain only ASCII letters, digits, and hyphens; and must not end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The user name to be used to login to the endpoint database.
        public let username: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For more information about the available settings, see the Using Object Mapping to Migrate Data to DynamoDB section at  Using an Amazon DynamoDB Database as a Target for AWS Database Migration Service. 
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the Configuration Properties When Using MongoDB as a Source for AWS Database Migration Service section at  Using Amazon S3 as a Target for AWS Database Migration Service. 
        public let mongoDbSettings: MongoDbSettings?
        /// The type of endpoint.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        /// Settings in JSON format for the target S3 endpoint. For more information about the available settings, see the Extra Connection Attributes section at  Using Amazon S3 as a Target for AWS Database Migration Service. 
        public let s3Settings: S3Settings?
        /// The name of the endpoint database.
        public let databaseName: String?
        /// The SSL mode to be used. SSL mode can be one of four values: none, require, verify-ca, verify-full.  The default value is none.
        public let sslMode: DmsSslModeValue?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The type of engine for the endpoint. Valid values, depending on the EndPointType, include MYSQL, ORACLE, POSTGRES, MARIADB, AURORA, REDSHIFT, S3, DYNAMODB, MONGODB, SYBASE, and SQLSERVER.
        public let engineName: String?
        /// The password to be used to login to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int32?
        /// Additional attributes associated with the connection.
        public let extraConnectionAttributes: String?

        public init(endpointIdentifier: String? = nil, username: String? = nil, endpointArn: String, dynamoDbSettings: DynamoDbSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, endpointType: ReplicationEndpointTypeValue? = nil, serverName: String? = nil, s3Settings: S3Settings? = nil, databaseName: String? = nil, sslMode: DmsSslModeValue? = nil, certificateArn: String? = nil, engineName: String? = nil, password: String? = nil, port: Int32? = nil, extraConnectionAttributes: String? = nil) {
            self.endpointIdentifier = endpointIdentifier
            self.username = username
            self.endpointArn = endpointArn
            self.dynamoDbSettings = dynamoDbSettings
            self.mongoDbSettings = mongoDbSettings
            self.endpointType = endpointType
            self.serverName = serverName
            self.s3Settings = s3Settings
            self.databaseName = databaseName
            self.sslMode = sslMode
            self.certificateArn = certificateArn
            self.engineName = engineName
            self.password = password
            self.port = port
            self.extraConnectionAttributes = extraConnectionAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case endpointIdentifier = "EndpointIdentifier"
            case username = "Username"
            case endpointArn = "EndpointArn"
            case dynamoDbSettings = "DynamoDbSettings"
            case mongoDbSettings = "MongoDbSettings"
            case endpointType = "EndpointType"
            case serverName = "ServerName"
            case s3Settings = "S3Settings"
            case databaseName = "DatabaseName"
            case sslMode = "SslMode"
            case certificateArn = "CertificateArn"
            case engineName = "EngineName"
            case password = "Password"
            case port = "Port"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
        }
    }

    public struct VpcSecurityGroupMembership: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "VpcSecurityGroupId", required: false, type: .string)
        ]
        /// The status of the VPC security group.
        public let status: String?
        /// The VPC security group Id.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct DescribeOrderableReplicationInstancesMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int32?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(maxRecords: Int32? = nil, marker: String? = nil) {
            self.maxRecords = maxRecords
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case marker = "Marker"
        }
    }

    public struct CreateReplicationTaskMessage: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "TableMappings", required: true, type: .string), 
            AWSShapeMember(label: "SourceEndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .structure), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "MigrationType", required: true, type: .enum), 
            AWSShapeMember(label: "TargetEndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "CdcStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReplicationTaskSettings", required: false, type: .string)
        ]
        /// When using the AWS CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with "file://". When working with the DMS API, provide the JSON as the parameter value. For example, --table-mappings file://mappingfile.json
        public let tableMappings: String
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let sourceEndpointArn: String
        /// Tags to be added to the replication instance.
        public let tags: TagList?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// The replication task identifier. Constraints:   Must contain from 1 to 255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public let replicationTaskIdentifier: String
        /// The migration type.
        public let migrationType: MigrationTypeValue
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let targetEndpointArn: String
        /// The start time for the Change Data Capture (CDC) operation.
        public let cdcStartTime: TimeStamp?
        /// Settings for the task, such as target metadata settings. For a complete list of task settings, see Task Settings for AWS Database Migration Service Tasks.
        public let replicationTaskSettings: String?

        public init(tableMappings: String, sourceEndpointArn: String, tags: TagList? = nil, replicationInstanceArn: String, replicationTaskIdentifier: String, migrationType: MigrationTypeValue, targetEndpointArn: String, cdcStartTime: TimeStamp? = nil, replicationTaskSettings: String? = nil) {
            self.tableMappings = tableMappings
            self.sourceEndpointArn = sourceEndpointArn
            self.tags = tags
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.migrationType = migrationType
            self.targetEndpointArn = targetEndpointArn
            self.cdcStartTime = cdcStartTime
            self.replicationTaskSettings = replicationTaskSettings
        }

        private enum CodingKeys: String, CodingKey {
            case tableMappings = "TableMappings"
            case sourceEndpointArn = "SourceEndpointArn"
            case tags = "Tags"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case migrationType = "MigrationType"
            case targetEndpointArn = "TargetEndpointArn"
            case cdcStartTime = "CdcStartTime"
            case replicationTaskSettings = "ReplicationTaskSettings"
        }
    }

    public enum ReplicationEndpointTypeValue: String, CustomStringConvertible, Codable {
        case source = "source"
        case target = "target"
        public var description: String { return self.rawValue }
    }

    public struct Filter: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Values", required: true, type: .structure)
        ]
        /// The name of the filter.
        public let name: String
        /// The filter value.
        public let values: FilterValueList

        public init(name: String, values: FilterValueList) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct DescribeReplicationInstancesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstances", required: false, type: .structure)
        ]
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The replication instances described.
        public let replicationInstances: ReplicationInstanceList?

        public init(marker: String? = nil, replicationInstances: ReplicationInstanceList? = nil) {
            self.marker = marker
            self.replicationInstances = replicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstances = "ReplicationInstances"
        }
    }

}