// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Athena {

    public enum ColumnNullable: String, CustomStringConvertible {
        case not_null = "NOT_NULL"
        case nullable = "NULLABLE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public struct ListNamedQueriesInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// The token that specifies where to start pagination if a previous request was truncated.
        public let nextToken: String?
        /// The maximum number of queries to return in this request.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct StopQueryExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutionId", required: true, type: .string)
        ]
        /// The unique ID of the query execution to stop.
        public let queryExecutionId: String

        public init(queryExecutionId: String) {
            self.queryExecutionId = queryExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let queryExecutionId = dictionary["QueryExecutionId"] as? String else { throw InitializableError.missingRequiredParam("QueryExecutionId") }
            self.queryExecutionId = queryExecutionId
        }
    }

    public struct BatchGetNamedQueryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NamedQueries", required: false, type: .list), 
            AWSShapeProperty(label: "UnprocessedNamedQueryIds", required: false, type: .list)
        ]
        /// Information about the named query IDs submitted.
        public let namedQueries: [NamedQuery]?
        /// Information about provided query IDs.
        public let unprocessedNamedQueryIds: [UnprocessedNamedQueryId]?

        public init(namedQueries: [NamedQuery]? = nil, unprocessedNamedQueryIds: [UnprocessedNamedQueryId]? = nil) {
            self.namedQueries = namedQueries
            self.unprocessedNamedQueryIds = unprocessedNamedQueryIds
        }

        public init(dictionary: [String: Any]) throws {
            if let namedQueries = dictionary["NamedQueries"] as? [[String: Any]] {
                self.namedQueries = try namedQueries.map({ try NamedQuery(dictionary: $0) })
            } else { 
                self.namedQueries = nil
            }
            if let unprocessedNamedQueryIds = dictionary["UnprocessedNamedQueryIds"] as? [[String: Any]] {
                self.unprocessedNamedQueryIds = try unprocessedNamedQueryIds.map({ try UnprocessedNamedQueryId(dictionary: $0) })
            } else { 
                self.unprocessedNamedQueryIds = nil
            }
        }
    }

    public struct ResultConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "OutputLocation", required: true, type: .string), 
            AWSShapeProperty(label: "EncryptionConfiguration", required: false, type: .structure)
        ]
        /// The location in S3 where query results are stored.
        public let outputLocation: String
        /// If query results are encrypted in S3, indicates the S3 encryption option used (for example, SSE-KMS or CSE-KMS and key information.
        public let encryptionConfiguration: EncryptionConfiguration?

        public init(outputLocation: String, encryptionConfiguration: EncryptionConfiguration? = nil) {
            self.outputLocation = outputLocation
            self.encryptionConfiguration = encryptionConfiguration
        }

        public init(dictionary: [String: Any]) throws {
            guard let outputLocation = dictionary["OutputLocation"] as? String else { throw InitializableError.missingRequiredParam("OutputLocation") }
            self.outputLocation = outputLocation
            if let encryptionConfiguration = dictionary["EncryptionConfiguration"] as? [String: Any] { self.encryptionConfiguration = try Athena.EncryptionConfiguration(dictionary: encryptionConfiguration) } else { self.encryptionConfiguration = nil }
        }
    }

    public struct ListQueryExecutionsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutionIds", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// The unique IDs of each query execution as an array of strings.
        public let queryExecutionIds: [String]?
        /// A token to be used by the next request if this request is truncated.
        public let nextToken: String?

        public init(queryExecutionIds: [String]? = nil, nextToken: String? = nil) {
            self.queryExecutionIds = queryExecutionIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.queryExecutionIds = dictionary["QueryExecutionIds"] as? [String]
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct GetNamedQueryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NamedQuery", required: false, type: .structure)
        ]
        /// Information about the query.
        public let namedQuery: NamedQuery?

        public init(namedQuery: NamedQuery? = nil) {
            self.namedQuery = namedQuery
        }

        public init(dictionary: [String: Any]) throws {
            if let namedQuery = dictionary["NamedQuery"] as? [String: Any] { self.namedQuery = try Athena.NamedQuery(dictionary: namedQuery) } else { self.namedQuery = nil }
        }
    }

    public struct StartQueryExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ResultConfiguration", required: true, type: .structure), 
            AWSShapeProperty(label: "QueryString", required: true, type: .string), 
            AWSShapeProperty(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeProperty(label: "QueryExecutionContext", required: false, type: .structure)
        ]
        /// Specifies information about where and how to save the results of the query execution.
        public let resultConfiguration: ResultConfiguration
        /// The SQL query statements to be executed.
        public let queryString: String
        /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another StartQueryExecution request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned.  This token is listed as not required because AWS SDKs (for example the AWS SDK for Java) auto-generate the token for users. If you are not using the AWS SDK or the AWS CLI, you must provide this token or the action will fail. 
        public let clientRequestToken: String?
        /// The database within which the query executes.
        public let queryExecutionContext: QueryExecutionContext?

        public init(resultConfiguration: ResultConfiguration, queryString: String, clientRequestToken: String? = nil, queryExecutionContext: QueryExecutionContext? = nil) {
            self.resultConfiguration = resultConfiguration
            self.queryString = queryString
            self.clientRequestToken = clientRequestToken
            self.queryExecutionContext = queryExecutionContext
        }

        public init(dictionary: [String: Any]) throws {
            guard let resultConfiguration = dictionary["ResultConfiguration"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ResultConfiguration") }
            self.resultConfiguration = try Athena.ResultConfiguration(dictionary: resultConfiguration)
            guard let queryString = dictionary["QueryString"] as? String else { throw InitializableError.missingRequiredParam("QueryString") }
            self.queryString = queryString
            self.clientRequestToken = dictionary["ClientRequestToken"] as? String
            if let queryExecutionContext = dictionary["QueryExecutionContext"] as? [String: Any] { self.queryExecutionContext = try Athena.QueryExecutionContext(dictionary: queryExecutionContext) } else { self.queryExecutionContext = nil }
        }
    }

    public struct CreateNamedQueryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NamedQueryId", required: false, type: .string)
        ]
        /// The unique ID of the query.
        public let namedQueryId: String?

        public init(namedQueryId: String? = nil) {
            self.namedQueryId = namedQueryId
        }

        public init(dictionary: [String: Any]) throws {
            self.namedQueryId = dictionary["NamedQueryId"] as? String
        }
    }

    public struct UnprocessedQueryExecutionId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeProperty(label: "ErrorCode", required: false, type: .string), 
            AWSShapeProperty(label: "QueryExecutionId", required: false, type: .string)
        ]
        /// The error message returned when the query execution failed to process, if applicable.
        public let errorMessage: String?
        /// The error code returned when the query execution failed to process, if applicable.
        public let errorCode: String?
        /// The unique identifier of the query execution.
        public let queryExecutionId: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil, queryExecutionId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.queryExecutionId = queryExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.queryExecutionId = dictionary["QueryExecutionId"] as? String
        }
    }

    public struct ResultSetMetadata: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ColumnInfo", required: false, type: .list)
        ]
        /// Information about the columns in a query execution result.
        public let columnInfo: [ColumnInfo]?

        public init(columnInfo: [ColumnInfo]? = nil) {
            self.columnInfo = columnInfo
        }

        public init(dictionary: [String: Any]) throws {
            if let columnInfo = dictionary["ColumnInfo"] as? [[String: Any]] {
                self.columnInfo = try columnInfo.map({ try ColumnInfo(dictionary: $0) })
            } else { 
                self.columnInfo = nil
            }
        }
    }

    public struct GetQueryExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecution", required: false, type: .structure)
        ]
        /// Information about the query execution.
        public let queryExecution: QueryExecution?

        public init(queryExecution: QueryExecution? = nil) {
            self.queryExecution = queryExecution
        }

        public init(dictionary: [String: Any]) throws {
            if let queryExecution = dictionary["QueryExecution"] as? [String: Any] { self.queryExecution = try Athena.QueryExecution(dictionary: queryExecution) } else { self.queryExecution = nil }
        }
    }

    public struct BatchGetQueryExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutions", required: false, type: .list), 
            AWSShapeProperty(label: "UnprocessedQueryExecutionIds", required: false, type: .list)
        ]
        /// Information about a query execution.
        public let queryExecutions: [QueryExecution]?
        /// Information about the query executions that failed to run.
        public let unprocessedQueryExecutionIds: [UnprocessedQueryExecutionId]?

        public init(queryExecutions: [QueryExecution]? = nil, unprocessedQueryExecutionIds: [UnprocessedQueryExecutionId]? = nil) {
            self.queryExecutions = queryExecutions
            self.unprocessedQueryExecutionIds = unprocessedQueryExecutionIds
        }

        public init(dictionary: [String: Any]) throws {
            if let queryExecutions = dictionary["QueryExecutions"] as? [[String: Any]] {
                self.queryExecutions = try queryExecutions.map({ try QueryExecution(dictionary: $0) })
            } else { 
                self.queryExecutions = nil
            }
            if let unprocessedQueryExecutionIds = dictionary["UnprocessedQueryExecutionIds"] as? [[String: Any]] {
                self.unprocessedQueryExecutionIds = try unprocessedQueryExecutionIds.map({ try UnprocessedQueryExecutionId(dictionary: $0) })
            } else { 
                self.unprocessedQueryExecutionIds = nil
            }
        }
    }

    public enum QueryExecutionState: String, CustomStringConvertible {
        case queued = "QUEUED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        case cancelled = "CANCELLED"
        public var description: String { return self.rawValue }
    }

    public struct StartQueryExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutionId", required: false, type: .string)
        ]
        /// The unique ID of the query that ran as a result of this request.
        public let queryExecutionId: String?

        public init(queryExecutionId: String? = nil) {
            self.queryExecutionId = queryExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            self.queryExecutionId = dictionary["QueryExecutionId"] as? String
        }
    }

    public struct ResultSet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Rows", required: false, type: .list), 
            AWSShapeProperty(label: "ResultSetMetadata", required: false, type: .structure)
        ]
        /// The rows in the table.
        public let rows: [Row]?
        /// The metadata that describes the column structure and data types of a table of query results.
        public let resultSetMetadata: ResultSetMetadata?

        public init(rows: [Row]? = nil, resultSetMetadata: ResultSetMetadata? = nil) {
            self.rows = rows
            self.resultSetMetadata = resultSetMetadata
        }

        public init(dictionary: [String: Any]) throws {
            if let rows = dictionary["Rows"] as? [[String: Any]] {
                self.rows = try rows.map({ try Row(dictionary: $0) })
            } else { 
                self.rows = nil
            }
            if let resultSetMetadata = dictionary["ResultSetMetadata"] as? [String: Any] { self.resultSetMetadata = try Athena.ResultSetMetadata(dictionary: resultSetMetadata) } else { self.resultSetMetadata = nil }
        }
    }

    public struct GetQueryResultsOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "ResultSet", required: false, type: .structure)
        ]
        /// A token to be used by the next request if this request is truncated.
        public let nextToken: String?
        /// The results of the query execution.
        public let resultSet: ResultSet?

        public init(nextToken: String? = nil, resultSet: ResultSet? = nil) {
            self.nextToken = nextToken
            self.resultSet = resultSet
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let resultSet = dictionary["ResultSet"] as? [String: Any] { self.resultSet = try Athena.ResultSet(dictionary: resultSet) } else { self.resultSet = nil }
        }
    }

    public struct ColumnInfo: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Nullable", required: false, type: .enum), 
            AWSShapeProperty(label: "CatalogName", required: false, type: .string), 
            AWSShapeProperty(label: "SchemaName", required: false, type: .string), 
            AWSShapeProperty(label: "Name", required: true, type: .string), 
            AWSShapeProperty(label: "Precision", required: false, type: .integer), 
            AWSShapeProperty(label: "TableName", required: false, type: .string), 
            AWSShapeProperty(label: "Scale", required: false, type: .integer), 
            AWSShapeProperty(label: "Type", required: true, type: .string), 
            AWSShapeProperty(label: "CaseSensitive", required: false, type: .boolean), 
            AWSShapeProperty(label: "Label", required: false, type: .string)
        ]
        /// Indicates the column's nullable status.
        public let nullable: ColumnNullable?
        /// The catalog to which the query results belong.
        public let catalogName: String?
        /// The schema name (database name) to which the query results belong.
        public let schemaName: String?
        /// The name of the column.
        public let name: String
        /// For DECIMAL data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.
        public let precision: Int32?
        /// The table name for the query results.
        public let tableName: String?
        /// For DECIMAL data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.
        public let scale: Int32?
        /// The data type of the column.
        public let `type`: String
        /// Indicates whether values in the column are case-sensitive.
        public let caseSensitive: Bool?
        /// A column label.
        public let label: String?

        public init(nullable: ColumnNullable? = nil, catalogName: String? = nil, schemaName: String? = nil, name: String, precision: Int32? = nil, tableName: String? = nil, scale: Int32? = nil, type: String, caseSensitive: Bool? = nil, label: String? = nil) {
            self.nullable = nullable
            self.catalogName = catalogName
            self.schemaName = schemaName
            self.name = name
            self.precision = precision
            self.tableName = tableName
            self.scale = scale
            self.`type` = `type`
            self.caseSensitive = caseSensitive
            self.label = label
        }

        public init(dictionary: [String: Any]) throws {
            if let nullable = dictionary["Nullable"] as? String { self.nullable = ColumnNullable(rawValue: nullable) } else { self.nullable = nil }
            self.catalogName = dictionary["CatalogName"] as? String
            self.schemaName = dictionary["SchemaName"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.precision = dictionary["Precision"] as? Int32
            self.tableName = dictionary["TableName"] as? String
            self.scale = dictionary["Scale"] as? Int32
            guard let `type` = dictionary["Type"] as? String else { throw InitializableError.missingRequiredParam("Type") }
            self.`type` = `type`
            self.caseSensitive = dictionary["CaseSensitive"] as? Bool
            self.label = dictionary["Label"] as? String
        }
    }

    public struct StopQueryExecutionOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct Row: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Data", required: false, type: .list)
        ]
        /// The data that populates a row in a query result table.
        public let data: [Datum]?

        public init(data: [Datum]? = nil) {
            self.data = data
        }

        public init(dictionary: [String: Any]) throws {
            if let data = dictionary["Data"] as? [[String: Any]] {
                self.data = try data.map({ try Datum(dictionary: $0) })
            } else { 
                self.data = nil
            }
        }
    }

    public enum ThrottleReason: String, CustomStringConvertible {
        case concurrent_query_limit_exceeded = "CONCURRENT_QUERY_LIMIT_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public struct GetNamedQueryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NamedQueryId", required: true, type: .string)
        ]
        /// The unique ID of the query. Use ListNamedQueries to get query IDs.
        public let namedQueryId: String

        public init(namedQueryId: String) {
            self.namedQueryId = namedQueryId
        }

        public init(dictionary: [String: Any]) throws {
            guard let namedQueryId = dictionary["NamedQueryId"] as? String else { throw InitializableError.missingRequiredParam("NamedQueryId") }
            self.namedQueryId = namedQueryId
        }
    }

    public enum EncryptionOption: String, CustomStringConvertible {
        case sse_s3 = "SSE_S3"
        case sse_kms = "SSE_KMS"
        case cse_kms = "CSE_KMS"
        public var description: String { return self.rawValue }
    }

    public struct Datum: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "VarCharValue", required: false, type: .string)
        ]
        /// The value of the datum.
        public let varCharValue: String?

        public init(varCharValue: String? = nil) {
            self.varCharValue = varCharValue
        }

        public init(dictionary: [String: Any]) throws {
            self.varCharValue = dictionary["VarCharValue"] as? String
        }
    }

    public struct UnprocessedNamedQueryId: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeProperty(label: "ErrorCode", required: false, type: .string), 
            AWSShapeProperty(label: "NamedQueryId", required: false, type: .string)
        ]
        /// The error message returned when the processing request for the named query failed, if applicable.
        public let errorMessage: String?
        /// The error code returned when the processing request for the named query failed, if applicable.
        public let errorCode: String?
        /// The unique identifier of the named query.
        public let namedQueryId: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil, namedQueryId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.namedQueryId = namedQueryId
        }

        public init(dictionary: [String: Any]) throws {
            self.errorMessage = dictionary["ErrorMessage"] as? String
            self.errorCode = dictionary["ErrorCode"] as? String
            self.namedQueryId = dictionary["NamedQueryId"] as? String
        }
    }

    public struct NamedQuery: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Description", required: false, type: .string), 
            AWSShapeProperty(label: "QueryString", required: true, type: .string), 
            AWSShapeProperty(label: "NamedQueryId", required: false, type: .string), 
            AWSShapeProperty(label: "Name", required: true, type: .string), 
            AWSShapeProperty(label: "Database", required: true, type: .string)
        ]
        /// A brief description of the query.
        public let description: String?
        /// The SQL query statements that comprise the query.
        public let queryString: String
        /// The unique identifier of the query.
        public let namedQueryId: String?
        /// The plain-language name of the query.
        public let name: String
        /// The database to which the query belongs.
        public let database: String

        public init(description: String? = nil, queryString: String, namedQueryId: String? = nil, name: String, database: String) {
            self.description = description
            self.queryString = queryString
            self.namedQueryId = namedQueryId
            self.name = name
            self.database = database
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            guard let queryString = dictionary["QueryString"] as? String else { throw InitializableError.missingRequiredParam("QueryString") }
            self.queryString = queryString
            self.namedQueryId = dictionary["NamedQueryId"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let database = dictionary["Database"] as? String else { throw InitializableError.missingRequiredParam("Database") }
            self.database = database
        }
    }

    public struct GetQueryExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutionId", required: true, type: .string)
        ]
        /// The unique ID of the query execution.
        public let queryExecutionId: String

        public init(queryExecutionId: String) {
            self.queryExecutionId = queryExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            guard let queryExecutionId = dictionary["QueryExecutionId"] as? String else { throw InitializableError.missingRequiredParam("QueryExecutionId") }
            self.queryExecutionId = queryExecutionId
        }
    }

    public struct ListQueryExecutionsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// The token that specifies where to start pagination if a previous request was truncated.
        public let nextToken: String?
        /// The maximum number of query executions to return in this request.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BatchGetQueryExecutionInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutionIds", required: true, type: .list)
        ]
        /// An array of query execution IDs.
        public let queryExecutionIds: [String]

        public init(queryExecutionIds: [String]) {
            self.queryExecutionIds = queryExecutionIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let queryExecutionIds = dictionary["QueryExecutionIds"] as? [String] else { throw InitializableError.missingRequiredParam("QueryExecutionIds") }
            self.queryExecutionIds = queryExecutionIds
        }
    }

    public struct DeleteNamedQueryOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateNamedQueryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryString", required: true, type: .string), 
            AWSShapeProperty(label: "ClientRequestToken", required: false, type: .string), 
            AWSShapeProperty(label: "Name", required: true, type: .string), 
            AWSShapeProperty(label: "Database", required: true, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// The text of the query itself. In other words, all query statements.
        public let queryString: String
        /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another CreateNamedQuery request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned.  This token is listed as not required because AWS SDKs (for example the AWS SDK for Java) auto-generate the token for users. If you are not using the AWS SDK or the AWS CLI, you must provide this token or the action will fail. 
        public let clientRequestToken: String?
        /// The plain language name for the query.
        public let name: String
        /// The database to which the query belongs.
        public let database: String
        /// A brief explanation of the query.
        public let description: String?

        public init(queryString: String, clientRequestToken: String? = nil, name: String, database: String, description: String? = nil) {
            self.queryString = queryString
            self.clientRequestToken = clientRequestToken
            self.name = name
            self.database = database
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let queryString = dictionary["QueryString"] as? String else { throw InitializableError.missingRequiredParam("QueryString") }
            self.queryString = queryString
            self.clientRequestToken = dictionary["ClientRequestToken"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let database = dictionary["Database"] as? String else { throw InitializableError.missingRequiredParam("Database") }
            self.database = database
            self.description = dictionary["Description"] as? String
        }
    }

    public struct GetQueryResultsInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "QueryExecutionId", required: true, type: .string), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// The unique ID of the query execution.
        public let queryExecutionId: String
        /// The token that specifies where to start pagination if a previous request was truncated.
        public let nextToken: String?
        /// The maximum number of results (rows) to return in this request.
        public let maxResults: Int32?

        public init(queryExecutionId: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.queryExecutionId = queryExecutionId
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let queryExecutionId = dictionary["QueryExecutionId"] as? String else { throw InitializableError.missingRequiredParam("QueryExecutionId") }
            self.queryExecutionId = queryExecutionId
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct QueryExecutionStatistics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EngineExecutionTimeInMillis", required: false, type: .long), 
            AWSShapeProperty(label: "DataScannedInBytes", required: false, type: .long)
        ]
        /// The number of milliseconds that the query took to execute.
        public let engineExecutionTimeInMillis: Int64?
        /// The number of bytes in the data that was queried.
        public let dataScannedInBytes: Int64?

        public init(engineExecutionTimeInMillis: Int64? = nil, dataScannedInBytes: Int64? = nil) {
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.dataScannedInBytes = dataScannedInBytes
        }

        public init(dictionary: [String: Any]) throws {
            self.engineExecutionTimeInMillis = dictionary["EngineExecutionTimeInMillis"] as? Int64
            self.dataScannedInBytes = dictionary["DataScannedInBytes"] as? Int64
        }
    }

    public struct ListNamedQueriesOutput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "NamedQueryIds", required: false, type: .list)
        ]
        /// A token to be used by the next request if this request is truncated.
        public let nextToken: String?
        /// The list of unique query IDs.
        public let namedQueryIds: [String]?

        public init(nextToken: String? = nil, namedQueryIds: [String]? = nil) {
            self.nextToken = nextToken
            self.namedQueryIds = namedQueryIds
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.namedQueryIds = dictionary["NamedQueryIds"] as? [String]
        }
    }

    public struct QueryExecutionStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StateChangeReason", required: false, type: .string), 
            AWSShapeProperty(label: "CompletionDateTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "State", required: false, type: .enum), 
            AWSShapeProperty(label: "SubmissionDateTime", required: false, type: .timestamp)
        ]
        /// Further detail about the status of the query.
        public let stateChangeReason: String?
        /// The date and time that the query completed.
        public let completionDateTime: String?
        /// The state of query execution. SUBMITTED indicates that the query is queued for execution. RUNNING indicates that the query is scanning data and returning results. SUCCEEDED indicates that the query completed without error. FAILED indicates that the query experienced an error and did not complete processing. CANCELLED indicates that user input interrupted query execution.
        public let state: QueryExecutionState?
        /// The date and time that the query was submitted.
        public let submissionDateTime: String?

        public init(stateChangeReason: String? = nil, completionDateTime: String? = nil, state: QueryExecutionState? = nil, submissionDateTime: String? = nil) {
            self.stateChangeReason = stateChangeReason
            self.completionDateTime = completionDateTime
            self.state = state
            self.submissionDateTime = submissionDateTime
        }

        public init(dictionary: [String: Any]) throws {
            self.stateChangeReason = dictionary["StateChangeReason"] as? String
            self.completionDateTime = dictionary["CompletionDateTime"] as? String
            if let state = dictionary["State"] as? String { self.state = QueryExecutionState(rawValue: state) } else { self.state = nil }
            self.submissionDateTime = dictionary["SubmissionDateTime"] as? String
        }
    }

    public struct BatchGetNamedQueryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NamedQueryIds", required: true, type: .list)
        ]
        /// An array of query IDs.
        public let namedQueryIds: [String]

        public init(namedQueryIds: [String]) {
            self.namedQueryIds = namedQueryIds
        }

        public init(dictionary: [String: Any]) throws {
            guard let namedQueryIds = dictionary["NamedQueryIds"] as? [String] else { throw InitializableError.missingRequiredParam("NamedQueryIds") }
            self.namedQueryIds = namedQueryIds
        }
    }

    public struct DeleteNamedQueryInput: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NamedQueryId", required: true, type: .string)
        ]
        /// The unique ID of the query to delete.
        public let namedQueryId: String

        public init(namedQueryId: String) {
            self.namedQueryId = namedQueryId
        }

        public init(dictionary: [String: Any]) throws {
            guard let namedQueryId = dictionary["NamedQueryId"] as? String else { throw InitializableError.missingRequiredParam("NamedQueryId") }
            self.namedQueryId = namedQueryId
        }
    }

    public struct EncryptionConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EncryptionOption", required: true, type: .enum), 
            AWSShapeProperty(label: "KmsKey", required: false, type: .string)
        ]
        /// Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE-S3), server-side encryption with KMS-managed keys (SSE-KMS), or client-side encryption with KMS-managed keys (CSE-KMS) is used.
        public let encryptionOption: EncryptionOption
        /// For SSE-KMS and CSE-KMS, this is the KMS key ARN or ID.
        public let kmsKey: String?

        public init(encryptionOption: EncryptionOption, kmsKey: String? = nil) {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }

        public init(dictionary: [String: Any]) throws {
            guard let rawEncryptionOption = dictionary["EncryptionOption"] as? String, let encryptionOption = EncryptionOption(rawValue: rawEncryptionOption) else { throw InitializableError.missingRequiredParam("EncryptionOption") }
            self.encryptionOption = encryptionOption
            self.kmsKey = dictionary["KmsKey"] as? String
        }
    }

    public struct QueryExecution: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ResultConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "Status", required: false, type: .structure), 
            AWSShapeProperty(label: "Query", required: false, type: .string), 
            AWSShapeProperty(label: "QueryExecutionContext", required: false, type: .structure), 
            AWSShapeProperty(label: "Statistics", required: false, type: .structure), 
            AWSShapeProperty(label: "QueryExecutionId", required: false, type: .string)
        ]
        /// The location in Amazon S3 where query results were stored and the encryption option, if any, used for query results.
        public let resultConfiguration: ResultConfiguration?
        /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
        public let status: QueryExecutionStatus?
        /// The SQL query statements which the query execution ran.
        public let query: String?
        /// The database in which the query execution occurred.
        public let queryExecutionContext: QueryExecutionContext?
        /// The amount of data scanned during the query execution and the amount of time that it took to execute.
        public let statistics: QueryExecutionStatistics?
        /// The unique identifier for each query execution.
        public let queryExecutionId: String?

        public init(resultConfiguration: ResultConfiguration? = nil, status: QueryExecutionStatus? = nil, query: String? = nil, queryExecutionContext: QueryExecutionContext? = nil, statistics: QueryExecutionStatistics? = nil, queryExecutionId: String? = nil) {
            self.resultConfiguration = resultConfiguration
            self.status = status
            self.query = query
            self.queryExecutionContext = queryExecutionContext
            self.statistics = statistics
            self.queryExecutionId = queryExecutionId
        }

        public init(dictionary: [String: Any]) throws {
            if let resultConfiguration = dictionary["ResultConfiguration"] as? [String: Any] { self.resultConfiguration = try Athena.ResultConfiguration(dictionary: resultConfiguration) } else { self.resultConfiguration = nil }
            if let status = dictionary["Status"] as? [String: Any] { self.status = try Athena.QueryExecutionStatus(dictionary: status) } else { self.status = nil }
            self.query = dictionary["Query"] as? String
            if let queryExecutionContext = dictionary["QueryExecutionContext"] as? [String: Any] { self.queryExecutionContext = try Athena.QueryExecutionContext(dictionary: queryExecutionContext) } else { self.queryExecutionContext = nil }
            if let statistics = dictionary["Statistics"] as? [String: Any] { self.statistics = try Athena.QueryExecutionStatistics(dictionary: statistics) } else { self.statistics = nil }
            self.queryExecutionId = dictionary["QueryExecutionId"] as? String
        }
    }

    public struct QueryExecutionContext: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Database", required: false, type: .string)
        ]
        /// The name of the database.
        public let database: String?

        public init(database: String? = nil) {
            self.database = database
        }

        public init(dictionary: [String: Any]) throws {
            self.database = dictionary["Database"] as? String
        }
    }

}