// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Pinpoint {

    public struct GetCampaignActivitiesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let pageSize: String?
        public let campaignId: String
        public let applicationId: String
        public let token: String?

        public init(pageSize: String? = nil, campaignId: String, applicationId: String, token: String? = nil) {
            self.pageSize = pageSize
            self.campaignId = campaignId
            self.applicationId = applicationId
            self.token = token
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            guard let campaignId = dictionary["campaign-id"] as? String else { throw InitializableError.missingRequiredParam("campaign-id") }
            self.campaignId = campaignId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            self.token = dictionary["token"] as? String
        }
    }

    public struct SendMessagesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "MessageResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "MessageResponse", required: true, type: .structure)
        ]
        public let messageResponse: MessageResponse

        public init(messageResponse: MessageResponse) {
            self.messageResponse = messageResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let messageResponse = dictionary["MessageResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("MessageResponse") }
            self.messageResponse = try Pinpoint.MessageResponse(dictionary: messageResponse)
        }
    }

    public struct UpdateEndpointsBatchResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "MessageBody"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "MessageBody", required: true, type: .structure)
        ]
        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        public init(dictionary: [String: Any]) throws {
            guard let messageBody = dictionary["MessageBody"] as? [String: Any] else { throw InitializableError.missingRequiredParam("MessageBody") }
            self.messageBody = try Pinpoint.MessageBody(dictionary: messageBody)
        }
    }

    public struct EndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeProperty(label: "OptOut", required: false, type: .string), 
            AWSShapeProperty(label: "Metrics", required: false, type: .map), 
            AWSShapeProperty(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeProperty(label: "Address", required: false, type: .string), 
            AWSShapeProperty(label: "Location", required: false, type: .structure), 
            AWSShapeProperty(label: "Demographic", required: false, type: .structure), 
            AWSShapeProperty(label: "Attributes", required: false, type: .map), 
            AWSShapeProperty(label: "RequestId", required: false, type: .string), 
            AWSShapeProperty(label: "User", required: false, type: .structure), 
            AWSShapeProperty(label: "ChannelType", required: false, type: .enum)
        ]
        /// The endpoint status. Can be either ACTIVE or INACTIVE. Will be set to INACTIVE if a delivery fails. Will be set to ACTIVE if the address is updated.
        public let endpointStatus: String?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL – User receives all messages.
        /// NONE – User receives no messages.
        public let optOut: String?
        public let metrics: [String: Double]?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// The address or token of the endpoint as provided by your push provider (e.g. DeviceToken or RegistrationId).
        public let address: String?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        public let attributes: [String: [String]]?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?
        /// The channel type.
        /// Valid values: APNS, GCM
        public let channelType: ChannelType?

        public init(endpointStatus: String? = nil, optOut: String? = nil, metrics: [String: Double]? = nil, effectiveDate: String? = nil, address: String? = nil, location: EndpointLocation? = nil, demographic: EndpointDemographic? = nil, attributes: [String: [String]]? = nil, requestId: String? = nil, user: EndpointUser? = nil, channelType: ChannelType? = nil) {
            self.endpointStatus = endpointStatus
            self.optOut = optOut
            self.metrics = metrics
            self.effectiveDate = effectiveDate
            self.address = address
            self.location = location
            self.demographic = demographic
            self.attributes = attributes
            self.requestId = requestId
            self.user = user
            self.channelType = channelType
        }

        public init(dictionary: [String: Any]) throws {
            self.endpointStatus = dictionary["EndpointStatus"] as? String
            self.optOut = dictionary["OptOut"] as? String
            if let metrics = dictionary["Metrics"] as? [String: Double] {
                self.metrics = metrics
            } else { 
                self.metrics = nil
            }
            self.effectiveDate = dictionary["EffectiveDate"] as? String
            self.address = dictionary["Address"] as? String
            if let location = dictionary["Location"] as? [String: Any] { self.location = try Pinpoint.EndpointLocation(dictionary: location) } else { self.location = nil }
            if let demographic = dictionary["Demographic"] as? [String: Any] { self.demographic = try Pinpoint.EndpointDemographic(dictionary: demographic) } else { self.demographic = nil }
            if let attributes = dictionary["Attributes"] as? [String: Any] {
                var attributesDict: [String: [String]] = [:]
                for (key, value) in attributes {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    attributesDict[key] = listOfString
                }
                self.attributes = attributesDict
            } else { 
                self.attributes = nil
            }
            self.requestId = dictionary["RequestId"] as? String
            if let user = dictionary["User"] as? [String: Any] { self.user = try Pinpoint.EndpointUser(dictionary: user) } else { self.user = nil }
            if let channelType = dictionary["ChannelType"] as? String { self.channelType = ChannelType(rawValue: channelType) } else { self.channelType = nil }
        }
    }

    public struct UpdateApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ApplicationSettingsResource"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]
        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationSettingsResource = dictionary["ApplicationSettingsResource"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ApplicationSettingsResource") }
            self.applicationSettingsResource = try Pinpoint.ApplicationSettingsResource(dictionary: applicationSettingsResource)
        }
    }

    public struct EndpointBatchRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Item", required: false, type: .list)
        ]
        /// List of items to update. Maximum 100 items
        public let item: [EndpointBatchItem]?

        public init(item: [EndpointBatchItem]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try EndpointBatchItem(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct GCMChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApiKey", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean)
        ]
        /// Platform credential API key from Google.
        public let apiKey: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(apiKey: String? = nil, enabled: Bool? = nil) {
            self.apiKey = apiKey
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.apiKey = dictionary["ApiKey"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
        }
    }

    public enum Format: String, CustomStringConvertible {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public struct GetGcmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct CreateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "WriteCampaignRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "WriteCampaignRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeCampaignRequest: WriteCampaignRequest

        public init(applicationId: String, writeCampaignRequest: WriteCampaignRequest) {
            self.applicationId = applicationId
            self.writeCampaignRequest = writeCampaignRequest
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let writeCampaignRequest = dictionary["WriteCampaignRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WriteCampaignRequest") }
            self.writeCampaignRequest = try Pinpoint.WriteCampaignRequest(dictionary: writeCampaignRequest)
        }
    }

    public struct GetSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let segmentId: String
        public let applicationId: String

        public init(segmentId: String, applicationId: String) {
            self.segmentId = segmentId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentId = dictionary["segment-id"] as? String else { throw InitializableError.missingRequiredParam("segment-id") }
            self.segmentId = segmentId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct QuietTime: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "End", required: false, type: .string), 
            AWSShapeProperty(label: "Start", required: false, type: .string)
        ]
        /// The default end time for quiet time in ISO 8601 format.
        public let end: String?
        /// The default start time for quiet time in ISO 8601 format.
        public let start: String?

        public init(end: String? = nil, start: String? = nil) {
            self.end = end
            self.start = start
        }

        public init(dictionary: [String: Any]) throws {
            self.end = dictionary["End"] as? String
            self.start = dictionary["Start"] as? String
        }
    }

    public struct DeleteApnsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct DeleteCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let campaignId: String
        public let applicationId: String

        public init(campaignId: String, applicationId: String) {
            self.campaignId = campaignId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignId = dictionary["campaign-id"] as? String else { throw InitializableError.missingRequiredParam("campaign-id") }
            self.campaignId = campaignId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public enum Action: String, CustomStringConvertible {
        case open_app = "OPEN_APP"
        case deep_link = "DEEP_LINK"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public struct EmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "FromAddress", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "Identity", required: false, type: .string)
        ]
        /// The email address used to send emails from.
        public let fromAddress: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The ARN of an IAM Role used to submit events to Mobile Analytics' event ingestion service
        public let roleArn: String?
        /// The ARN of an identity verified with SES.
        public let identity: String?

        public init(fromAddress: String? = nil, enabled: Bool? = nil, roleArn: String? = nil, identity: String? = nil) {
            self.fromAddress = fromAddress
            self.enabled = enabled
            self.roleArn = roleArn
            self.identity = identity
        }

        public init(dictionary: [String: Any]) throws {
            self.fromAddress = dictionary["FromAddress"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.roleArn = dictionary["RoleArn"] as? String
            self.identity = dictionary["Identity"] as? String
        }
    }

    public struct DeleteGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "GCMChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let gCMChannelResponse = dictionary["GCMChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("GCMChannelResponse") }
            self.gCMChannelResponse = try Pinpoint.GCMChannelResponse(dictionary: gCMChannelResponse)
        }
    }

    public struct UpdateSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SMSChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let sMSChannelResponse = dictionary["SMSChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SMSChannelResponse") }
            self.sMSChannelResponse = try Pinpoint.SMSChannelResponse(dictionary: sMSChannelResponse)
        }
    }

    public struct GetImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ImportJobResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ImportJobResponse", required: true, type: .structure)
        ]
        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let importJobResponse = dictionary["ImportJobResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ImportJobResponse") }
            self.importJobResponse = try Pinpoint.ImportJobResponse(dictionary: importJobResponse)
        }
    }

    public struct GetSegmentsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let pageSize: String?
        public let applicationId: String
        public let token: String?

        public init(pageSize: String? = nil, applicationId: String, token: String? = nil) {
            self.pageSize = pageSize
            self.applicationId = applicationId
            self.token = token
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            self.token = dictionary["token"] as? String
        }
    }

    public struct CreateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "WriteSegmentRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "WriteSegmentRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let writeSegmentRequest: WriteSegmentRequest

        public init(applicationId: String, writeSegmentRequest: WriteSegmentRequest) {
            self.applicationId = applicationId
            self.writeSegmentRequest = writeSegmentRequest
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let writeSegmentRequest = dictionary["WriteSegmentRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WriteSegmentRequest") }
            self.writeSegmentRequest = try Pinpoint.WriteSegmentRequest(dictionary: writeSegmentRequest)
        }
    }

    public struct GetSegmentVersionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string)
        ]
        public let pageSize: String?
        public let token: String?
        public let applicationId: String
        public let segmentId: String

        public init(pageSize: String? = nil, token: String? = nil, applicationId: String, segmentId: String) {
            self.pageSize = pageSize
            self.token = token
            self.applicationId = applicationId
            self.segmentId = segmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            self.token = dictionary["token"] as? String
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let segmentId = dictionary["segment-id"] as? String else { throw InitializableError.missingRequiredParam("segment-id") }
            self.segmentId = segmentId
        }
    }

    public struct UpdateApnsSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSSandboxChannelRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSSandboxChannelRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSSandboxChannelRequest: APNSSandboxChannelRequest
        public let applicationId: String

        public init(aPNSSandboxChannelRequest: APNSSandboxChannelRequest, applicationId: String) {
            self.aPNSSandboxChannelRequest = aPNSSandboxChannelRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSSandboxChannelRequest = dictionary["APNSSandboxChannelRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSSandboxChannelRequest") }
            self.aPNSSandboxChannelRequest = try Pinpoint.APNSSandboxChannelRequest(dictionary: aPNSSandboxChannelRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct AddressConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TitleOverride", required: false, type: .string), 
            AWSShapeProperty(label: "Context", required: false, type: .map), 
            AWSShapeProperty(label: "BodyOverride", required: false, type: .string), 
            AWSShapeProperty(label: "RawContent", required: false, type: .string), 
            AWSShapeProperty(label: "ChannelType", required: false, type: .enum), 
            AWSShapeProperty(label: "Substitutions", required: false, type: .map)
        ]
        /// Title override. If specified will override default title if applicable.
        public let titleOverride: String?
        public let context: [String: String]?
        /// Body override. If specified will override default body.
        public let bodyOverride: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Type of channel of this address
        public let channelType: ChannelType?
        public let substitutions: [String: [String]]?

        public init(titleOverride: String? = nil, context: [String: String]? = nil, bodyOverride: String? = nil, rawContent: String? = nil, channelType: ChannelType? = nil, substitutions: [String: [String]]? = nil) {
            self.titleOverride = titleOverride
            self.context = context
            self.bodyOverride = bodyOverride
            self.rawContent = rawContent
            self.channelType = channelType
            self.substitutions = substitutions
        }

        public init(dictionary: [String: Any]) throws {
            self.titleOverride = dictionary["TitleOverride"] as? String
            if let context = dictionary["Context"] as? [String: String] {
                self.context = context
            } else { 
                self.context = nil
            }
            self.bodyOverride = dictionary["BodyOverride"] as? String
            self.rawContent = dictionary["RawContent"] as? String
            if let channelType = dictionary["ChannelType"] as? String { self.channelType = ChannelType(rawValue: channelType) } else { self.channelType = nil }
            if let substitutions = dictionary["Substitutions"] as? [String: Any] {
                var substitutionsDict: [String: [String]] = [:]
                for (key, value) in substitutions {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    substitutionsDict[key] = listOfString
                }
                self.substitutions = substitutionsDict
            } else { 
                self.substitutions = nil
            }
        }
    }

    public struct Message: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ImageSmallIconUrl", required: false, type: .string), 
            AWSShapeProperty(label: "Action", required: false, type: .enum), 
            AWSShapeProperty(label: "Url", required: false, type: .string), 
            AWSShapeProperty(label: "MediaUrl", required: false, type: .string), 
            AWSShapeProperty(label: "Title", required: false, type: .string), 
            AWSShapeProperty(label: "ImageUrl", required: false, type: .string), 
            AWSShapeProperty(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeProperty(label: "JsonBody", required: false, type: .string), 
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "ImageIconUrl", required: false, type: .string)
        ]
        /// The URL that points to the small icon image for the push notification icon, for example, the app icon.
        public let imageSmallIconUrl: String?
        /// The action that occurs if the user taps a push notification delivered by the campaign:
        /// OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action.
        /// DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app.
        /// URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify.
        public let action: Action?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The URL that points to the media resource, for example a .mp4 or .gif file.
        public let mediaUrl: String?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// Indicates if the message should display on the users device.
        /// Silent pushes can be used for Remote Configuration and Phone Home use cases. 
        public let silentPush: Bool?
        /// The JSON payload used for a silent push.
        public let jsonBody: String?
        /// The message body. Can include up to 140 characters.
        public let body: String?
        /// The URL that points to the icon image for the push notification icon, for example, the app icon.
        public let imageIconUrl: String?

        public init(imageSmallIconUrl: String? = nil, action: Action? = nil, url: String? = nil, mediaUrl: String? = nil, title: String? = nil, imageUrl: String? = nil, silentPush: Bool? = nil, jsonBody: String? = nil, body: String? = nil, imageIconUrl: String? = nil) {
            self.imageSmallIconUrl = imageSmallIconUrl
            self.action = action
            self.url = url
            self.mediaUrl = mediaUrl
            self.title = title
            self.imageUrl = imageUrl
            self.silentPush = silentPush
            self.jsonBody = jsonBody
            self.body = body
            self.imageIconUrl = imageIconUrl
        }

        public init(dictionary: [String: Any]) throws {
            self.imageSmallIconUrl = dictionary["ImageSmallIconUrl"] as? String
            if let action = dictionary["Action"] as? String { self.action = Action(rawValue: action) } else { self.action = nil }
            self.url = dictionary["Url"] as? String
            self.mediaUrl = dictionary["MediaUrl"] as? String
            self.title = dictionary["Title"] as? String
            self.imageUrl = dictionary["ImageUrl"] as? String
            self.silentPush = dictionary["SilentPush"] as? Bool
            self.jsonBody = dictionary["JsonBody"] as? String
            self.body = dictionary["Body"] as? String
            self.imageIconUrl = dictionary["ImageIconUrl"] as? String
        }
    }

    public struct SMSChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ShortCode", required: false, type: .string), 
            AWSShapeProperty(label: "Platform", required: false, type: .string), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "SenderId", required: false, type: .string), 
            AWSShapeProperty(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeProperty(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// The short code registered with the phone provider.
        public let shortCode: String?
        /// Platform type. Will be "SMS"
        public let platform: String?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// Application id
        public let applicationId: String?
        /// Sender identifier of your messages.
        public let senderId: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(shortCode: String? = nil, platform: String? = nil, id: String? = nil, version: Int32? = nil, enabled: Bool? = nil, lastModifiedDate: String? = nil, creationDate: String? = nil, applicationId: String? = nil, senderId: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil) {
            self.shortCode = shortCode
            self.platform = platform
            self.id = id
            self.version = version
            self.enabled = enabled
            self.lastModifiedDate = lastModifiedDate
            self.creationDate = creationDate
            self.applicationId = applicationId
            self.senderId = senderId
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
        }

        public init(dictionary: [String: Any]) throws {
            self.shortCode = dictionary["ShortCode"] as? String
            self.platform = dictionary["Platform"] as? String
            self.id = dictionary["Id"] as? String
            self.version = dictionary["Version"] as? Int32
            self.enabled = dictionary["Enabled"] as? Bool
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.senderId = dictionary["SenderId"] as? String
            self.isArchived = dictionary["IsArchived"] as? Bool
            self.lastModifiedBy = dictionary["LastModifiedBy"] as? String
        }
    }

    public struct UpdateEmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EmailChannelRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EmailChannelRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let emailChannelRequest: EmailChannelRequest
        public let applicationId: String

        public init(emailChannelRequest: EmailChannelRequest, applicationId: String) {
            self.emailChannelRequest = emailChannelRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let emailChannelRequest = dictionary["EmailChannelRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EmailChannelRequest") }
            self.emailChannelRequest = try Pinpoint.EmailChannelRequest(dictionary: emailChannelRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct GetApplicationSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct GetSegmentVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Version", location: .uri(locationName: "version"), required: true, type: .string)
        ]
        public let applicationId: String
        public let segmentId: String
        public let version: String

        public init(applicationId: String, segmentId: String, version: String) {
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let segmentId = dictionary["segment-id"] as? String else { throw InitializableError.missingRequiredParam("segment-id") }
            self.segmentId = segmentId
            guard let version = dictionary["version"] as? String else { throw InitializableError.missingRequiredParam("version") }
            self.version = version
        }
    }

    public struct SegmentLocation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Country", required: false, type: .structure)
        ]
        /// The country filter according to ISO 3166-1 Alpha-2 codes.
        public let country: SetDimension?

        public init(country: SetDimension? = nil) {
            self.country = country
        }

        public init(dictionary: [String: Any]) throws {
            if let country = dictionary["Country"] as? [String: Any] { self.country = try Pinpoint.SetDimension(dictionary: country) } else { self.country = nil }
        }
    }

    public struct SMSChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SenderId", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean)
        ]
        /// Sender identifier of your messages.
        public let senderId: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?

        public init(senderId: String? = nil, enabled: Bool? = nil) {
            self.senderId = senderId
            self.enabled = enabled
        }

        public init(dictionary: [String: Any]) throws {
            self.senderId = dictionary["SenderId"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
        }
    }

    public struct WriteCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TreatmentName", required: false, type: .string), 
            AWSShapeProperty(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeProperty(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeProperty(label: "Name", required: false, type: .string), 
            AWSShapeProperty(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeProperty(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeProperty(label: "Limits", required: false, type: .structure), 
            AWSShapeProperty(label: "Schedule", required: false, type: .structure), 
            AWSShapeProperty(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "SegmentId", required: false, type: .string), 
            AWSShapeProperty(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The version of the segment to which the campaign sends messages.
        public let segmentVersion: Int32?
        /// Treatments that are defined in addition to the default treatment.
        public let additionalTreatments: [WriteTreatmentResource]?
        /// The custom name of the campaign.
        public let name: String?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The allocated percentage of end users who will not receive messages from this campaign.
        public let holdoutPercent: Int32?
        /// The campaign limits settings.
        public let limits: CampaignLimits?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The ID of the segment to which the campaign sends messages.
        public let segmentId: String?
        /// Indicates whether the campaign is paused. A paused campaign does not send messages unless you resume it by setting IsPaused to false.
        public let isPaused: Bool?
        /// A description of the campaign.
        public let description: String?

        public init(treatmentName: String? = nil, segmentVersion: Int32? = nil, additionalTreatments: [WriteTreatmentResource]? = nil, name: String? = nil, treatmentDescription: String? = nil, holdoutPercent: Int32? = nil, limits: CampaignLimits? = nil, schedule: Schedule? = nil, messageConfiguration: MessageConfiguration? = nil, segmentId: String? = nil, isPaused: Bool? = nil, description: String? = nil) {
            self.treatmentName = treatmentName
            self.segmentVersion = segmentVersion
            self.additionalTreatments = additionalTreatments
            self.name = name
            self.treatmentDescription = treatmentDescription
            self.holdoutPercent = holdoutPercent
            self.limits = limits
            self.schedule = schedule
            self.messageConfiguration = messageConfiguration
            self.segmentId = segmentId
            self.isPaused = isPaused
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.treatmentName = dictionary["TreatmentName"] as? String
            self.segmentVersion = dictionary["SegmentVersion"] as? Int32
            if let additionalTreatments = dictionary["AdditionalTreatments"] as? [[String: Any]] {
                self.additionalTreatments = try additionalTreatments.map({ try WriteTreatmentResource(dictionary: $0) })
            } else { 
                self.additionalTreatments = nil
            }
            self.name = dictionary["Name"] as? String
            self.treatmentDescription = dictionary["TreatmentDescription"] as? String
            self.holdoutPercent = dictionary["HoldoutPercent"] as? Int32
            if let limits = dictionary["Limits"] as? [String: Any] { self.limits = try Pinpoint.CampaignLimits(dictionary: limits) } else { self.limits = nil }
            if let schedule = dictionary["Schedule"] as? [String: Any] { self.schedule = try Pinpoint.Schedule(dictionary: schedule) } else { self.schedule = nil }
            if let messageConfiguration = dictionary["MessageConfiguration"] as? [String: Any] { self.messageConfiguration = try Pinpoint.MessageConfiguration(dictionary: messageConfiguration) } else { self.messageConfiguration = nil }
            self.segmentId = dictionary["SegmentId"] as? String
            self.isPaused = dictionary["IsPaused"] as? Bool
            self.description = dictionary["Description"] as? String
        }
    }

    public struct UpdateApplicationSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "WriteApplicationSettingsRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "WriteApplicationSettingsRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let writeApplicationSettingsRequest: WriteApplicationSettingsRequest
        public let applicationId: String

        public init(writeApplicationSettingsRequest: WriteApplicationSettingsRequest, applicationId: String) {
            self.writeApplicationSettingsRequest = writeApplicationSettingsRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let writeApplicationSettingsRequest = dictionary["WriteApplicationSettingsRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WriteApplicationSettingsRequest") }
            self.writeApplicationSettingsRequest = try Pinpoint.WriteApplicationSettingsRequest(dictionary: writeApplicationSettingsRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct WriteTreatmentResource: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Schedule", required: false, type: .structure), 
            AWSShapeProperty(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeProperty(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "SizePercent", required: false, type: .integer), 
            AWSShapeProperty(label: "TreatmentName", required: false, type: .string)
        ]
        /// The campaign schedule.
        public let schedule: Schedule?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The allocated percentage of users for this treatment.
        public let sizePercent: Int32?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?

        public init(schedule: Schedule? = nil, treatmentDescription: String? = nil, messageConfiguration: MessageConfiguration? = nil, sizePercent: Int32? = nil, treatmentName: String? = nil) {
            self.schedule = schedule
            self.treatmentDescription = treatmentDescription
            self.messageConfiguration = messageConfiguration
            self.sizePercent = sizePercent
            self.treatmentName = treatmentName
        }

        public init(dictionary: [String: Any]) throws {
            if let schedule = dictionary["Schedule"] as? [String: Any] { self.schedule = try Pinpoint.Schedule(dictionary: schedule) } else { self.schedule = nil }
            self.treatmentDescription = dictionary["TreatmentDescription"] as? String
            if let messageConfiguration = dictionary["MessageConfiguration"] as? [String: Any] { self.messageConfiguration = try Pinpoint.MessageConfiguration(dictionary: messageConfiguration) } else { self.messageConfiguration = nil }
            self.sizePercent = dictionary["SizePercent"] as? Int32
            self.treatmentName = dictionary["TreatmentName"] as? String
        }
    }

    public struct TreatmentResource: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TreatmentName", required: false, type: .string), 
            AWSShapeProperty(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeProperty(label: "SizePercent", required: false, type: .integer), 
            AWSShapeProperty(label: "State", required: false, type: .structure), 
            AWSShapeProperty(label: "Schedule", required: false, type: .structure), 
            AWSShapeProperty(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "Id", required: false, type: .string)
        ]
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// The allocated percentage of users for this treatment.
        public let sizePercent: Int32?
        /// The treatment status.
        public let state: CampaignState?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The unique treatment ID.
        public let id: String?

        public init(treatmentName: String? = nil, treatmentDescription: String? = nil, sizePercent: Int32? = nil, state: CampaignState? = nil, schedule: Schedule? = nil, messageConfiguration: MessageConfiguration? = nil, id: String? = nil) {
            self.treatmentName = treatmentName
            self.treatmentDescription = treatmentDescription
            self.sizePercent = sizePercent
            self.state = state
            self.schedule = schedule
            self.messageConfiguration = messageConfiguration
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            self.treatmentName = dictionary["TreatmentName"] as? String
            self.treatmentDescription = dictionary["TreatmentDescription"] as? String
            self.sizePercent = dictionary["SizePercent"] as? Int32
            if let state = dictionary["State"] as? [String: Any] { self.state = try Pinpoint.CampaignState(dictionary: state) } else { self.state = nil }
            if let schedule = dictionary["Schedule"] as? [String: Any] { self.schedule = try Pinpoint.Schedule(dictionary: schedule) } else { self.schedule = nil }
            if let messageConfiguration = dictionary["MessageConfiguration"] as? [String: Any] { self.messageConfiguration = try Pinpoint.MessageConfiguration(dictionary: messageConfiguration) } else { self.messageConfiguration = nil }
            self.id = dictionary["Id"] as? String
        }
    }

    public struct EventStream: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ExternalId", required: false, type: .string), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "DestinationStreamArn", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "LastUpdatedBy", required: false, type: .string)
        ]
        /// The external ID assigned the IAM role that authorizes Amazon Pinpoint to publish to the stream.
        public let externalId: String?
        /// The date the event stream was last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis stream or Firehose delivery stream to which you want to publish events.
        ///  Firehose ARN: arn:aws:firehose:REGION:ACCOUNT_ID:deliverystream/STREAM_NAME
        ///  Kinesis ARN: arn:aws:kinesis:REGION:ACCOUNT_ID:stream/STREAM_NAME
        public let destinationStreamArn: String?
        /// The ID of the application from which events should be published.
        public let applicationId: String?
        /// The IAM role that authorizes Amazon Pinpoint to publish events to the stream in your account.
        public let roleArn: String?
        /// The IAM user who last modified the event stream.
        public let lastUpdatedBy: String?

        public init(externalId: String? = nil, lastModifiedDate: String? = nil, destinationStreamArn: String? = nil, applicationId: String? = nil, roleArn: String? = nil, lastUpdatedBy: String? = nil) {
            self.externalId = externalId
            self.lastModifiedDate = lastModifiedDate
            self.destinationStreamArn = destinationStreamArn
            self.applicationId = applicationId
            self.roleArn = roleArn
            self.lastUpdatedBy = lastUpdatedBy
        }

        public init(dictionary: [String: Any]) throws {
            self.externalId = dictionary["ExternalId"] as? String
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.destinationStreamArn = dictionary["DestinationStreamArn"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.lastUpdatedBy = dictionary["LastUpdatedBy"] as? String
        }
    }

    public struct EndpointResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "User", required: false, type: .structure), 
            AWSShapeProperty(label: "ShardId", required: false, type: .string), 
            AWSShapeProperty(label: "OptOut", required: false, type: .string), 
            AWSShapeProperty(label: "Metrics", required: false, type: .map), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "CohortId", required: false, type: .string), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeProperty(label: "Location", required: false, type: .structure), 
            AWSShapeProperty(label: "Address", required: false, type: .string), 
            AWSShapeProperty(label: "Demographic", required: false, type: .structure), 
            AWSShapeProperty(label: "Attributes", required: false, type: .map), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "RequestId", required: false, type: .string), 
            AWSShapeProperty(label: "ChannelType", required: false, type: .enum), 
            AWSShapeProperty(label: "EndpointStatus", required: false, type: .string)
        ]
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?
        public let shardId: String?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL – User receives all messages.
        /// NONE – User receives no messages.
        public let optOut: String?
        public let metrics: [String: Double]?
        /// The last time the endpoint was created. Provided in ISO 8601 format.
        public let creationDate: String?
        /// A number from 0 - 99 that represents the cohort the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an app. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for a campaign.
        public let cohortId: String?
        /// The unique ID that you assigned to the endpoint. The ID should be a globally unique identifier (GUID) to ensure that it is unique compared to all other endpoints for the application.
        public let id: String?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// The address or token of the endpoint as provided by your push provider (e.g. DeviceToken or RegistrationId).
        public let address: String?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        public let attributes: [String: [String]]?
        /// The ID of the application associated with the endpoint.
        public let applicationId: String?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// The channel type.
        /// Valid values: APNS, GCM
        public let channelType: ChannelType?
        /// The endpoint status. Can be either ACTIVE or INACTIVE. Will be set to INACTIVE if a delivery fails. Will be set to ACTIVE if the address is updated.
        public let endpointStatus: String?

        public init(user: EndpointUser? = nil, shardId: String? = nil, optOut: String? = nil, metrics: [String: Double]? = nil, creationDate: String? = nil, cohortId: String? = nil, id: String? = nil, effectiveDate: String? = nil, location: EndpointLocation? = nil, address: String? = nil, demographic: EndpointDemographic? = nil, attributes: [String: [String]]? = nil, applicationId: String? = nil, requestId: String? = nil, channelType: ChannelType? = nil, endpointStatus: String? = nil) {
            self.user = user
            self.shardId = shardId
            self.optOut = optOut
            self.metrics = metrics
            self.creationDate = creationDate
            self.cohortId = cohortId
            self.id = id
            self.effectiveDate = effectiveDate
            self.location = location
            self.address = address
            self.demographic = demographic
            self.attributes = attributes
            self.applicationId = applicationId
            self.requestId = requestId
            self.channelType = channelType
            self.endpointStatus = endpointStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let user = dictionary["User"] as? [String: Any] { self.user = try Pinpoint.EndpointUser(dictionary: user) } else { self.user = nil }
            self.shardId = dictionary["ShardId"] as? String
            self.optOut = dictionary["OptOut"] as? String
            if let metrics = dictionary["Metrics"] as? [String: Double] {
                self.metrics = metrics
            } else { 
                self.metrics = nil
            }
            self.creationDate = dictionary["CreationDate"] as? String
            self.cohortId = dictionary["CohortId"] as? String
            self.id = dictionary["Id"] as? String
            self.effectiveDate = dictionary["EffectiveDate"] as? String
            if let location = dictionary["Location"] as? [String: Any] { self.location = try Pinpoint.EndpointLocation(dictionary: location) } else { self.location = nil }
            self.address = dictionary["Address"] as? String
            if let demographic = dictionary["Demographic"] as? [String: Any] { self.demographic = try Pinpoint.EndpointDemographic(dictionary: demographic) } else { self.demographic = nil }
            if let attributes = dictionary["Attributes"] as? [String: Any] {
                var attributesDict: [String: [String]] = [:]
                for (key, value) in attributes {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    attributesDict[key] = listOfString
                }
                self.attributes = attributesDict
            } else { 
                self.attributes = nil
            }
            self.applicationId = dictionary["ApplicationId"] as? String
            self.requestId = dictionary["RequestId"] as? String
            if let channelType = dictionary["ChannelType"] as? String { self.channelType = ChannelType(rawValue: channelType) } else { self.channelType = nil }
            self.endpointStatus = dictionary["EndpointStatus"] as? String
        }
    }

    public struct DeleteSmsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct GetImportJobRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "JobId", location: .uri(locationName: "job-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let jobId: String
        public let applicationId: String

        public init(jobId: String, applicationId: String) {
            self.jobId = jobId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let jobId = dictionary["job-id"] as? String else { throw InitializableError.missingRequiredParam("job-id") }
            self.jobId = jobId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct SMSMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SenderId", required: false, type: .string), 
            AWSShapeProperty(label: "MessageType", required: false, type: .enum), 
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "Substitutions", required: false, type: .map)
        ]
        /// Sender ID of sent message.
        public let senderId: String?
        /// Is this a transaction priority message or lower priority.
        public let messageType: MessageType?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        public let substitutions: [String: [String]]?

        public init(senderId: String? = nil, messageType: MessageType? = nil, body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.senderId = senderId
            self.messageType = messageType
            self.body = body
            self.substitutions = substitutions
        }

        public init(dictionary: [String: Any]) throws {
            self.senderId = dictionary["SenderId"] as? String
            if let messageType = dictionary["MessageType"] as? String { self.messageType = MessageType(rawValue: messageType) } else { self.messageType = nil }
            self.body = dictionary["Body"] as? String
            if let substitutions = dictionary["Substitutions"] as? [String: Any] {
                var substitutionsDict: [String: [String]] = [:]
                for (key, value) in substitutions {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    substitutionsDict[key] = listOfString
                }
                self.substitutions = substitutionsDict
            } else { 
                self.substitutions = nil
            }
        }
    }

    public struct DeleteApnsSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct DeleteSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SMSChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let sMSChannelResponse = dictionary["SMSChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SMSChannelResponse") }
            self.sMSChannelResponse = try Pinpoint.SMSChannelResponse(dictionary: sMSChannelResponse)
        }
    }

    public struct CampaignResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Limits", required: false, type: .structure), 
            AWSShapeProperty(label: "TreatmentName", required: false, type: .string), 
            AWSShapeProperty(label: "SegmentVersion", required: false, type: .integer), 
            AWSShapeProperty(label: "State", required: false, type: .structure), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "Schedule", required: false, type: .structure), 
            AWSShapeProperty(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "SegmentId", required: false, type: .string), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string), 
            AWSShapeProperty(label: "TreatmentDescription", required: false, type: .string), 
            AWSShapeProperty(label: "AdditionalTreatments", required: false, type: .list), 
            AWSShapeProperty(label: "Name", required: false, type: .string), 
            AWSShapeProperty(label: "HoldoutPercent", required: false, type: .integer), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "IsPaused", required: false, type: .boolean), 
            AWSShapeProperty(label: "DefaultState", required: false, type: .structure)
        ]
        /// The campaign limits settings.
        public let limits: CampaignLimits?
        /// The custom name of a variation of the campaign used for A/B testing.
        public let treatmentName: String?
        /// The version of the segment to which the campaign sends messages.
        public let segmentVersion: Int32?
        /// The campaign status.
        /// An A/B test campaign will have a status of COMPLETED only when all treatments have a status of COMPLETED.
        public let state: CampaignState?
        /// The date the campaign was created in ISO 8601 format.
        public let creationDate: String?
        /// The campaign schedule.
        public let schedule: Schedule?
        /// The message configuration settings.
        public let messageConfiguration: MessageConfiguration?
        /// The ID of the segment to which the campaign sends messages.
        public let segmentId: String?
        /// The unique campaign ID.
        public let id: String?
        /// A description of the campaign.
        public let description: String?
        /// A custom description for the treatment.
        public let treatmentDescription: String?
        /// Treatments that are defined in addition to the default treatment.
        public let additionalTreatments: [TreatmentResource]?
        /// The custom name of the campaign.
        public let name: String?
        /// The allocated percentage of end users who will not receive messages from this campaign.
        public let holdoutPercent: Int32?
        /// The campaign version number.
        public let version: Int32?
        /// The date the campaign was last updated in ISO 8601 format.	
        public let lastModifiedDate: String?
        /// The ID of the application to which the campaign applies.
        public let applicationId: String?
        /// Indicates whether the campaign is paused. A paused campaign does not send messages unless you resume it by setting IsPaused to false.
        public let isPaused: Bool?
        /// The status of the campaign's default treatment. Only present for A/B test campaigns.
        public let defaultState: CampaignState?

        public init(limits: CampaignLimits? = nil, treatmentName: String? = nil, segmentVersion: Int32? = nil, state: CampaignState? = nil, creationDate: String? = nil, schedule: Schedule? = nil, messageConfiguration: MessageConfiguration? = nil, segmentId: String? = nil, id: String? = nil, description: String? = nil, treatmentDescription: String? = nil, additionalTreatments: [TreatmentResource]? = nil, name: String? = nil, holdoutPercent: Int32? = nil, version: Int32? = nil, lastModifiedDate: String? = nil, applicationId: String? = nil, isPaused: Bool? = nil, defaultState: CampaignState? = nil) {
            self.limits = limits
            self.treatmentName = treatmentName
            self.segmentVersion = segmentVersion
            self.state = state
            self.creationDate = creationDate
            self.schedule = schedule
            self.messageConfiguration = messageConfiguration
            self.segmentId = segmentId
            self.id = id
            self.description = description
            self.treatmentDescription = treatmentDescription
            self.additionalTreatments = additionalTreatments
            self.name = name
            self.holdoutPercent = holdoutPercent
            self.version = version
            self.lastModifiedDate = lastModifiedDate
            self.applicationId = applicationId
            self.isPaused = isPaused
            self.defaultState = defaultState
        }

        public init(dictionary: [String: Any]) throws {
            if let limits = dictionary["Limits"] as? [String: Any] { self.limits = try Pinpoint.CampaignLimits(dictionary: limits) } else { self.limits = nil }
            self.treatmentName = dictionary["TreatmentName"] as? String
            self.segmentVersion = dictionary["SegmentVersion"] as? Int32
            if let state = dictionary["State"] as? [String: Any] { self.state = try Pinpoint.CampaignState(dictionary: state) } else { self.state = nil }
            self.creationDate = dictionary["CreationDate"] as? String
            if let schedule = dictionary["Schedule"] as? [String: Any] { self.schedule = try Pinpoint.Schedule(dictionary: schedule) } else { self.schedule = nil }
            if let messageConfiguration = dictionary["MessageConfiguration"] as? [String: Any] { self.messageConfiguration = try Pinpoint.MessageConfiguration(dictionary: messageConfiguration) } else { self.messageConfiguration = nil }
            self.segmentId = dictionary["SegmentId"] as? String
            self.id = dictionary["Id"] as? String
            self.description = dictionary["Description"] as? String
            self.treatmentDescription = dictionary["TreatmentDescription"] as? String
            if let additionalTreatments = dictionary["AdditionalTreatments"] as? [[String: Any]] {
                self.additionalTreatments = try additionalTreatments.map({ try TreatmentResource(dictionary: $0) })
            } else { 
                self.additionalTreatments = nil
            }
            self.name = dictionary["Name"] as? String
            self.holdoutPercent = dictionary["HoldoutPercent"] as? Int32
            self.version = dictionary["Version"] as? Int32
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.isPaused = dictionary["IsPaused"] as? Bool
            if let defaultState = dictionary["DefaultState"] as? [String: Any] { self.defaultState = try Pinpoint.CampaignState(dictionary: defaultState) } else { self.defaultState = nil }
        }
    }

    public enum Frequency: String, CustomStringConvertible {
        case once = "ONCE"
        case hourly = "HOURLY"
        case daily = "DAILY"
        case weekly = "WEEKLY"
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public struct GetSmsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct MessageRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "MessageConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "Context", required: false, type: .map), 
            AWSShapeProperty(label: "Addresses", required: false, type: .map)
        ]
        /// Message configuration.
        public let messageConfiguration: DirectMessageConfiguration?
        public let context: [String: String]?
        /// A map of destination addresses, with the address as the key(Email address, phone number or push token) and the Address Configuration as the value.
        public let addresses: [String: AddressConfiguration]?

        public init(messageConfiguration: DirectMessageConfiguration? = nil, context: [String: String]? = nil, addresses: [String: AddressConfiguration]? = nil) {
            self.messageConfiguration = messageConfiguration
            self.context = context
            self.addresses = addresses
        }

        public init(dictionary: [String: Any]) throws {
            if let messageConfiguration = dictionary["MessageConfiguration"] as? [String: Any] { self.messageConfiguration = try Pinpoint.DirectMessageConfiguration(dictionary: messageConfiguration) } else { self.messageConfiguration = nil }
            if let context = dictionary["Context"] as? [String: String] {
                self.context = context
            } else { 
                self.context = nil
            }
            if let addresses = dictionary["Addresses"] as? [String: Any] {
                var addressesDict: [String: AddressConfiguration] = [:]
                for (key, value) in addresses {
                    guard let addressConfigurationDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    addressesDict[key] = try AddressConfiguration(dictionary: addressConfigurationDict)
                }
                self.addresses = addressesDict
            } else { 
                self.addresses = nil
            }
        }
    }

    public struct GetCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let campaignId: String
        public let applicationId: String

        public init(campaignId: String, applicationId: String) {
            self.campaignId = campaignId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignId = dictionary["campaign-id"] as? String else { throw InitializableError.missingRequiredParam("campaign-id") }
            self.campaignId = campaignId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct WriteApplicationSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Limits", required: false, type: .structure), 
            AWSShapeProperty(label: "QuietTime", required: false, type: .structure)
        ]
        /// The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own.
        public let limits: CampaignLimits?
        /// The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own.
        public let quietTime: QuietTime?

        public init(limits: CampaignLimits? = nil, quietTime: QuietTime? = nil) {
            self.limits = limits
            self.quietTime = quietTime
        }

        public init(dictionary: [String: Any]) throws {
            if let limits = dictionary["Limits"] as? [String: Any] { self.limits = try Pinpoint.CampaignLimits(dictionary: limits) } else { self.limits = nil }
            if let quietTime = dictionary["QuietTime"] as? [String: Any] { self.quietTime = try Pinpoint.QuietTime(dictionary: quietTime) } else { self.quietTime = nil }
        }
    }

    public struct UpdateGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "GCMChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let gCMChannelResponse = dictionary["GCMChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("GCMChannelResponse") }
            self.gCMChannelResponse = try Pinpoint.GCMChannelResponse(dictionary: gCMChannelResponse)
        }
    }

    public struct APNSMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ThreadId", required: false, type: .string), 
            AWSShapeProperty(label: "Data", required: false, type: .map), 
            AWSShapeProperty(label: "MediaUrl", required: false, type: .string), 
            AWSShapeProperty(label: "Title", required: false, type: .string), 
            AWSShapeProperty(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeProperty(label: "Badge", required: false, type: .integer), 
            AWSShapeProperty(label: "Action", required: false, type: .enum), 
            AWSShapeProperty(label: "Url", required: false, type: .string), 
            AWSShapeProperty(label: "RawContent", required: false, type: .string), 
            AWSShapeProperty(label: "Category", required: false, type: .string), 
            AWSShapeProperty(label: "Sound", required: false, type: .string), 
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "Substitutions", required: false, type: .map)
        ]
        /// Provide this key with a string value that represents the app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.
        public let threadId: String?
        public let data: [String: String]?
        /// The URL that points to a video used in the push notification.
        public let mediaUrl: String?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// Include this key when you want the system to modify the badge of your app icon. If this key is not included in the dictionary, the badge is not changed. To remove the badge, set the value of this key to 0.
        public let badge: Int32?
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Provide this key with a string value that represents the notification's type. This value corresponds to the value in the identifier property of one of your app's registered categories.
        public let category: String?
        /// Include this key when you want the system to play a sound. The value of this key is the name of a sound file in your app's main bundle or in the Library/Sounds folder of your app's data container. If the sound file cannot be found, or if you specify defaultfor the value, the system plays the default alert sound.
        public let sound: String?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        public let substitutions: [String: [String]]?

        public init(threadId: String? = nil, data: [String: String]? = nil, mediaUrl: String? = nil, title: String? = nil, silentPush: Bool? = nil, badge: Int32? = nil, action: Action? = nil, url: String? = nil, rawContent: String? = nil, category: String? = nil, sound: String? = nil, body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.threadId = threadId
            self.data = data
            self.mediaUrl = mediaUrl
            self.title = title
            self.silentPush = silentPush
            self.badge = badge
            self.action = action
            self.url = url
            self.rawContent = rawContent
            self.category = category
            self.sound = sound
            self.body = body
            self.substitutions = substitutions
        }

        public init(dictionary: [String: Any]) throws {
            self.threadId = dictionary["ThreadId"] as? String
            if let data = dictionary["Data"] as? [String: String] {
                self.data = data
            } else { 
                self.data = nil
            }
            self.mediaUrl = dictionary["MediaUrl"] as? String
            self.title = dictionary["Title"] as? String
            self.silentPush = dictionary["SilentPush"] as? Bool
            self.badge = dictionary["Badge"] as? Int32
            if let action = dictionary["Action"] as? String { self.action = Action(rawValue: action) } else { self.action = nil }
            self.url = dictionary["Url"] as? String
            self.rawContent = dictionary["RawContent"] as? String
            self.category = dictionary["Category"] as? String
            self.sound = dictionary["Sound"] as? String
            self.body = dictionary["Body"] as? String
            if let substitutions = dictionary["Substitutions"] as? [String: Any] {
                var substitutionsDict: [String: [String]] = [:]
                for (key, value) in substitutions {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    substitutionsDict[key] = listOfString
                }
                self.substitutions = substitutionsDict
            } else { 
                self.substitutions = nil
            }
        }
    }

    public struct GetSegmentImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ImportJobsResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ImportJobsResponse", required: true, type: .structure)
        ]
        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let importJobsResponse = dictionary["ImportJobsResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ImportJobsResponse") }
            self.importJobsResponse = try Pinpoint.ImportJobsResponse(dictionary: importJobsResponse)
        }
    }

    public struct UpdateEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EndpointRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EndpointRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointRequest: EndpointRequest
        public let endpointId: String
        public let applicationId: String

        public init(endpointRequest: EndpointRequest, endpointId: String, applicationId: String) {
            self.endpointRequest = endpointRequest
            self.endpointId = endpointId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let endpointRequest = dictionary["EndpointRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EndpointRequest") }
            self.endpointRequest = try Pinpoint.EndpointRequest(dictionary: endpointRequest)
            guard let endpointId = dictionary["endpoint-id"] as? String else { throw InitializableError.missingRequiredParam("endpoint-id") }
            self.endpointId = endpointId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct DefaultPushNotificationMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Action", required: false, type: .enum), 
            AWSShapeProperty(label: "Url", required: false, type: .string), 
            AWSShapeProperty(label: "Data", required: false, type: .map), 
            AWSShapeProperty(label: "Title", required: false, type: .string), 
            AWSShapeProperty(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "Substitutions", required: false, type: .map)
        ]
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        public let data: [String: String]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        public let substitutions: [String: [String]]?

        public init(action: Action? = nil, url: String? = nil, data: [String: String]? = nil, title: String? = nil, silentPush: Bool? = nil, body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.action = action
            self.url = url
            self.data = data
            self.title = title
            self.silentPush = silentPush
            self.body = body
            self.substitutions = substitutions
        }

        public init(dictionary: [String: Any]) throws {
            if let action = dictionary["Action"] as? String { self.action = Action(rawValue: action) } else { self.action = nil }
            self.url = dictionary["Url"] as? String
            if let data = dictionary["Data"] as? [String: String] {
                self.data = data
            } else { 
                self.data = nil
            }
            self.title = dictionary["Title"] as? String
            self.silentPush = dictionary["SilentPush"] as? Bool
            self.body = dictionary["Body"] as? String
            if let substitutions = dictionary["Substitutions"] as? [String: Any] {
                var substitutionsDict: [String: [String]] = [:]
                for (key, value) in substitutions {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    substitutionsDict[key] = listOfString
                }
                self.substitutions = substitutionsDict
            } else { 
                self.substitutions = nil
            }
        }
    }

    public enum Duration: String, CustomStringConvertible {
        case hr_24 = "HR_24"
        case day_7 = "DAY_7"
        case day_14 = "DAY_14"
        case day_30 = "DAY_30"
        public var description: String { return self.rawValue }
    }

    public enum ChannelType: String, CustomStringConvertible {
        case gcm = "GCM"
        case apns = "APNS"
        case apns_sandbox = "APNS_SANDBOX"
        case adm = "ADM"
        case sms = "SMS"
        case email = "EMAIL"
        public var description: String { return self.rawValue }
    }

    public struct GetSmsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SMSChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SMSChannelResponse", required: true, type: .structure)
        ]
        public let sMSChannelResponse: SMSChannelResponse

        public init(sMSChannelResponse: SMSChannelResponse) {
            self.sMSChannelResponse = sMSChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let sMSChannelResponse = dictionary["SMSChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SMSChannelResponse") }
            self.sMSChannelResponse = try Pinpoint.SMSChannelResponse(dictionary: sMSChannelResponse)
        }
    }

    public struct MessageResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Result", required: false, type: .map), 
            AWSShapeProperty(label: "RequestId", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string)
        ]
        /// A map containing a multi part response for each address, with the address as the key(Email address, phone number or push token) and the result as the value.
        public let result: [String: MessageResult]?
        /// Original request Id for which this message was delivered.
        public let requestId: String?
        /// Application id of the message.
        public let applicationId: String?

        public init(result: [String: MessageResult]? = nil, requestId: String? = nil, applicationId: String? = nil) {
            self.result = result
            self.requestId = requestId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            if let result = dictionary["Result"] as? [String: Any] {
                var resultDict: [String: MessageResult] = [:]
                for (key, value) in result {
                    guard let messageResultDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    resultDict[key] = try MessageResult(dictionary: messageResultDict)
                }
                self.result = resultDict
            } else { 
                self.result = nil
            }
            self.requestId = dictionary["RequestId"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
        }
    }

    public struct UpdateEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EmailChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let emailChannelResponse = dictionary["EmailChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EmailChannelResponse") }
            self.emailChannelResponse = try Pinpoint.EmailChannelResponse(dictionary: emailChannelResponse)
        }
    }

    public enum AttributeType: String, CustomStringConvertible {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct CampaignsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Item", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// A list of campaigns.
        public let item: [CampaignResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [CampaignResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try CampaignResponse(dictionary: $0) })
            } else { 
                self.item = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct GCMChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Platform", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "Credential", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeProperty(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// The platform type. Will be GCM
        public let platform: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Version of channel
        public let version: Int32?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The GCM API key from Google.
        public let credential: String?
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// When was this segment created
        public let creationDate: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(id: String? = nil, platform: String? = nil, enabled: Bool? = nil, version: Int32? = nil, lastModifiedDate: String? = nil, credential: String? = nil, applicationId: String? = nil, creationDate: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil) {
            self.id = id
            self.platform = platform
            self.enabled = enabled
            self.version = version
            self.lastModifiedDate = lastModifiedDate
            self.credential = credential
            self.applicationId = applicationId
            self.creationDate = creationDate
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.platform = dictionary["Platform"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.version = dictionary["Version"] as? Int32
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.credential = dictionary["Credential"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            self.isArchived = dictionary["IsArchived"] as? Bool
            self.lastModifiedBy = dictionary["LastModifiedBy"] as? String
        }
    }

    public struct DefaultMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "Substitutions", required: false, type: .map)
        ]
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        public let substitutions: [String: [String]]?

        public init(body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.body = body
            self.substitutions = substitutions
        }

        public init(dictionary: [String: Any]) throws {
            self.body = dictionary["Body"] as? String
            if let substitutions = dictionary["Substitutions"] as? [String: Any] {
                var substitutionsDict: [String: [String]] = [:]
                for (key, value) in substitutions {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    substitutionsDict[key] = listOfString
                }
                self.substitutions = substitutionsDict
            } else { 
                self.substitutions = nil
            }
        }
    }

    public struct ActivitiesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Item", required: false, type: .list)
        ]
        /// List of campaign activities
        public let item: [ActivityResponse]?

        public init(item: [ActivityResponse]? = nil) {
            self.item = item
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ActivityResponse(dictionary: $0) })
            } else { 
                self.item = nil
            }
        }
    }

    public struct RecencyDimension: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Duration", required: false, type: .enum), 
            AWSShapeProperty(label: "RecencyType", required: false, type: .enum)
        ]
        /// The length of time during which users have been active or inactive with your app.
        /// Valid values: HR_24, DAY_7, DAY_14, DAY_30
        public let duration: Duration?
        /// The recency dimension type:
        /// ACTIVE - Users who have used your app within the specified duration are included in the segment.
        /// INACTIVE - Users who have not used your app within the specified duration are included in the segment.
        public let recencyType: RecencyType?

        public init(duration: Duration? = nil, recencyType: RecencyType? = nil) {
            self.duration = duration
            self.recencyType = recencyType
        }

        public init(dictionary: [String: Any]) throws {
            if let duration = dictionary["Duration"] as? String { self.duration = Duration(rawValue: duration) } else { self.duration = nil }
            if let recencyType = dictionary["RecencyType"] as? String { self.recencyType = RecencyType(rawValue: recencyType) } else { self.recencyType = nil }
        }
    }

    public struct EndpointLocation: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Longitude", required: false, type: .double), 
            AWSShapeProperty(label: "Country", required: false, type: .string), 
            AWSShapeProperty(label: "PostalCode", required: false, type: .string), 
            AWSShapeProperty(label: "City", required: false, type: .string), 
            AWSShapeProperty(label: "Latitude", required: false, type: .double), 
            AWSShapeProperty(label: "Region", required: false, type: .string)
        ]
        /// The longitude of the endpoint location. Rounded to one decimal (Roughly corresponding to a mile).
        public let longitude: Double?
        /// Country according to ISO 3166-1 Alpha-2 codes. For example, US.
        public let country: String?
        /// The postal code or zip code of the endpoint.
        public let postalCode: String?
        /// The city where the endpoint is located.
        public let city: String?
        /// The latitude of the endpoint location. Rounded to one decimal (Roughly corresponding to a mile).
        public let latitude: Double?
        /// The region of the endpoint location. For example, corresponds to a state in US.
        public let region: String?

        public init(longitude: Double? = nil, country: String? = nil, postalCode: String? = nil, city: String? = nil, latitude: Double? = nil, region: String? = nil) {
            self.longitude = longitude
            self.country = country
            self.postalCode = postalCode
            self.city = city
            self.latitude = latitude
            self.region = region
        }

        public init(dictionary: [String: Any]) throws {
            self.longitude = dictionary["Longitude"] as? Double
            self.country = dictionary["Country"] as? String
            self.postalCode = dictionary["PostalCode"] as? String
            self.city = dictionary["City"] as? String
            self.latitude = dictionary["Latitude"] as? Double
            self.region = dictionary["Region"] as? String
        }
    }

    public struct Schedule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StartTime", required: false, type: .string), 
            AWSShapeProperty(label: "EndTime", required: false, type: .string), 
            AWSShapeProperty(label: "Frequency", required: false, type: .enum), 
            AWSShapeProperty(label: "QuietTime", required: false, type: .structure), 
            AWSShapeProperty(label: "IsLocalTime", required: false, type: .boolean), 
            AWSShapeProperty(label: "Timezone", required: false, type: .string)
        ]
        /// The scheduled time that the campaign begins in ISO 8601 format.
        public let startTime: String?
        /// The scheduled time that the campaign ends in ISO 8601 format.
        public let endTime: String?
        /// How often the campaign delivers messages.
        /// Valid values: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY
        public let frequency: Frequency?
        /// The time during which the campaign sends no messages.
        public let quietTime: QuietTime?
        /// Indicates whether the campaign schedule takes effect according to each user's local time.
        public let isLocalTime: Bool?
        /// The starting UTC offset for the schedule if the value for isLocalTime is true
        /// Valid values: 
        /// UTC
        /// UTC+01
        /// UTC+02
        /// UTC+03
        /// UTC+03:30
        /// UTC+04
        /// UTC+04:30
        /// UTC+05
        /// UTC+05:30
        /// UTC+05:45
        /// UTC+06
        /// UTC+06:30
        /// UTC+07
        /// UTC+08
        /// UTC+09
        /// UTC+09:30
        /// UTC+10
        /// UTC+10:30
        /// UTC+11
        /// UTC+12
        /// UTC+13
        /// UTC-02
        /// UTC-03
        /// UTC-04
        /// UTC-05
        /// UTC-06
        /// UTC-07
        /// UTC-08
        /// UTC-09
        /// UTC-10
        /// UTC-11
        public let timezone: String?

        public init(startTime: String? = nil, endTime: String? = nil, frequency: Frequency? = nil, quietTime: QuietTime? = nil, isLocalTime: Bool? = nil, timezone: String? = nil) {
            self.startTime = startTime
            self.endTime = endTime
            self.frequency = frequency
            self.quietTime = quietTime
            self.isLocalTime = isLocalTime
            self.timezone = timezone
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? String
            self.endTime = dictionary["EndTime"] as? String
            if let frequency = dictionary["Frequency"] as? String { self.frequency = Frequency(rawValue: frequency) } else { self.frequency = nil }
            if let quietTime = dictionary["QuietTime"] as? [String: Any] { self.quietTime = try Pinpoint.QuietTime(dictionary: quietTime) } else { self.quietTime = nil }
            self.isLocalTime = dictionary["IsLocalTime"] as? Bool
            self.timezone = dictionary["Timezone"] as? String
        }
    }

    public struct GetEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EndpointResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EndpointResponse", required: true, type: .structure)
        ]
        public let endpointResponse: EndpointResponse

        public init(endpointResponse: EndpointResponse) {
            self.endpointResponse = endpointResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let endpointResponse = dictionary["EndpointResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EndpointResponse") }
            self.endpointResponse = try Pinpoint.EndpointResponse(dictionary: endpointResponse)
        }
    }

    public struct EndpointBatchItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ChannelType", required: false, type: .enum), 
            AWSShapeProperty(label: "User", required: false, type: .structure), 
            AWSShapeProperty(label: "EffectiveDate", required: false, type: .string), 
            AWSShapeProperty(label: "OptOut", required: false, type: .string), 
            AWSShapeProperty(label: "Metrics", required: false, type: .map), 
            AWSShapeProperty(label: "Location", required: false, type: .structure), 
            AWSShapeProperty(label: "Address", required: false, type: .string), 
            AWSShapeProperty(label: "Demographic", required: false, type: .structure), 
            AWSShapeProperty(label: "Attributes", required: false, type: .map), 
            AWSShapeProperty(label: "RequestId", required: false, type: .string), 
            AWSShapeProperty(label: "EndpointStatus", required: false, type: .string), 
            AWSShapeProperty(label: "Id", required: false, type: .string)
        ]
        /// The channel type.
        /// Valid values: APNS, GCM
        public let channelType: ChannelType?
        /// Custom user-specific attributes that your app reports to Amazon Pinpoint.
        public let user: EndpointUser?
        /// The last time the endpoint was updated. Provided in ISO 8601 format.
        public let effectiveDate: String?
        /// Indicates whether a user has opted out of receiving messages with one of the following values:
        /// ALL – User receives all messages.
        /// NONE – User receives no messages.
        public let optOut: String?
        public let metrics: [String: Double]?
        /// The endpoint location attributes.
        public let location: EndpointLocation?
        /// The address or token of the endpoint as provided by your push provider (e.g. DeviceToken or RegistrationId).
        public let address: String?
        /// The endpoint demographic attributes.
        public let demographic: EndpointDemographic?
        public let attributes: [String: [String]]?
        /// The unique ID for the most recent request to update the endpoint.
        public let requestId: String?
        /// The endpoint status. Can be either ACTIVE or INACTIVE. Will be set to INACTIVE if a delivery fails. Will be set to ACTIVE if the address is updated.
        public let endpointStatus: String?
        /// The unique Id for the Endpoint in the batch.
        public let id: String?

        public init(channelType: ChannelType? = nil, user: EndpointUser? = nil, effectiveDate: String? = nil, optOut: String? = nil, metrics: [String: Double]? = nil, location: EndpointLocation? = nil, address: String? = nil, demographic: EndpointDemographic? = nil, attributes: [String: [String]]? = nil, requestId: String? = nil, endpointStatus: String? = nil, id: String? = nil) {
            self.channelType = channelType
            self.user = user
            self.effectiveDate = effectiveDate
            self.optOut = optOut
            self.metrics = metrics
            self.location = location
            self.address = address
            self.demographic = demographic
            self.attributes = attributes
            self.requestId = requestId
            self.endpointStatus = endpointStatus
            self.id = id
        }

        public init(dictionary: [String: Any]) throws {
            if let channelType = dictionary["ChannelType"] as? String { self.channelType = ChannelType(rawValue: channelType) } else { self.channelType = nil }
            if let user = dictionary["User"] as? [String: Any] { self.user = try Pinpoint.EndpointUser(dictionary: user) } else { self.user = nil }
            self.effectiveDate = dictionary["EffectiveDate"] as? String
            self.optOut = dictionary["OptOut"] as? String
            if let metrics = dictionary["Metrics"] as? [String: Double] {
                self.metrics = metrics
            } else { 
                self.metrics = nil
            }
            if let location = dictionary["Location"] as? [String: Any] { self.location = try Pinpoint.EndpointLocation(dictionary: location) } else { self.location = nil }
            self.address = dictionary["Address"] as? String
            if let demographic = dictionary["Demographic"] as? [String: Any] { self.demographic = try Pinpoint.EndpointDemographic(dictionary: demographic) } else { self.demographic = nil }
            if let attributes = dictionary["Attributes"] as? [String: Any] {
                var attributesDict: [String: [String]] = [:]
                for (key, value) in attributes {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    attributesDict[key] = listOfString
                }
                self.attributes = attributesDict
            } else { 
                self.attributes = nil
            }
            self.requestId = dictionary["RequestId"] as? String
            self.endpointStatus = dictionary["EndpointStatus"] as? String
            self.id = dictionary["Id"] as? String
        }
    }

    public struct GetApnsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct GetApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSChannelResponse = dictionary["APNSChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSChannelResponse") }
            self.aPNSChannelResponse = try Pinpoint.APNSChannelResponse(dictionary: aPNSChannelResponse)
        }
    }

    public struct SegmentImportResource: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ExternalId", required: false, type: .string), 
            AWSShapeProperty(label: "Format", required: false, type: .enum), 
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "ChannelCounts", required: false, type: .map), 
            AWSShapeProperty(label: "S3Url", required: false, type: .string), 
            AWSShapeProperty(label: "Size", required: false, type: .integer)
        ]
        /// A unique, custom ID assigned to the IAM role that restricts who can assume the role.
        public let externalId: String?
        /// The format of the endpoint files that were imported to create this segment.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the endpoints in Amazon S3.
        public let roleArn: String?
        public let channelCounts: [String: Int32]?
        /// A URL that points to the Amazon S3 location from which the endpoints for this segment were imported.
        public let s3Url: String?
        /// The number of endpoints that were successfully imported to create this segment.
        public let size: Int32?

        public init(externalId: String? = nil, format: Format? = nil, roleArn: String? = nil, channelCounts: [String: Int32]? = nil, s3Url: String? = nil, size: Int32? = nil) {
            self.externalId = externalId
            self.format = format
            self.roleArn = roleArn
            self.channelCounts = channelCounts
            self.s3Url = s3Url
            self.size = size
        }

        public init(dictionary: [String: Any]) throws {
            self.externalId = dictionary["ExternalId"] as? String
            if let format = dictionary["Format"] as? String { self.format = Format(rawValue: format) } else { self.format = nil }
            self.roleArn = dictionary["RoleArn"] as? String
            if let channelCounts = dictionary["ChannelCounts"] as? [String: Int32] {
                self.channelCounts = channelCounts
            } else { 
                self.channelCounts = nil
            }
            self.s3Url = dictionary["S3Url"] as? String
            self.size = dictionary["Size"] as? Int32
        }
    }

    public enum DimensionType: String, CustomStringConvertible {
        case inclusive = "INCLUSIVE"
        case exclusive = "EXCLUSIVE"
        public var description: String { return self.rawValue }
    }

    public struct ImportJobRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "S3Url", required: false, type: .string), 
            AWSShapeProperty(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeProperty(label: "Format", required: false, type: .enum), 
            AWSShapeProperty(label: "ExternalId", required: false, type: .string), 
            AWSShapeProperty(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeProperty(label: "SegmentName", required: false, type: .string), 
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "SegmentId", required: false, type: .string)
        ]
        /// A URL that points to the location within an Amazon S3 bucket that contains the endpoints to import. The location can be a folder or a single file.
        /// The URL should follow this format: s3://bucket-name/folder-name/file-name
        /// Amazon Pinpoint will import endpoints from this location and any subfolders it contains.
        public let s3Url: String?
        /// Sets whether the endpoints create a segment when they are imported.
        public let defineSegment: Bool?
        /// The format of the files that contain the endpoint definitions.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// A unique, custom ID assigned to the IAM role that restricts who can assume the role.	
        public let externalId: String?
        /// Sets whether the endpoints are registered with Amazon Pinpoint when they are imported.
        public let registerEndpoints: Bool?
        /// A custom name for the segment created by the import job. Use if DefineSegment is true.
        public let segmentName: String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that contains the endpoints to import.
        public let roleArn: String?
        /// The ID of the segment to update if the import job is meant to update an existing segment.
        public let segmentId: String?

        public init(s3Url: String? = nil, defineSegment: Bool? = nil, format: Format? = nil, externalId: String? = nil, registerEndpoints: Bool? = nil, segmentName: String? = nil, roleArn: String? = nil, segmentId: String? = nil) {
            self.s3Url = s3Url
            self.defineSegment = defineSegment
            self.format = format
            self.externalId = externalId
            self.registerEndpoints = registerEndpoints
            self.segmentName = segmentName
            self.roleArn = roleArn
            self.segmentId = segmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Url = dictionary["S3Url"] as? String
            self.defineSegment = dictionary["DefineSegment"] as? Bool
            if let format = dictionary["Format"] as? String { self.format = Format(rawValue: format) } else { self.format = nil }
            self.externalId = dictionary["ExternalId"] as? String
            self.registerEndpoints = dictionary["RegisterEndpoints"] as? Bool
            self.segmentName = dictionary["SegmentName"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.segmentId = dictionary["SegmentId"] as? String
        }
    }

    public struct GetEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EmailChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let emailChannelResponse = dictionary["EmailChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EmailChannelResponse") }
            self.emailChannelResponse = try Pinpoint.EmailChannelResponse(dictionary: emailChannelResponse)
        }
    }

    public struct SendMessagesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "MessageRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "MessageRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let messageRequest: MessageRequest

        public init(applicationId: String, messageRequest: MessageRequest) {
            self.applicationId = applicationId
            self.messageRequest = messageRequest
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let messageRequest = dictionary["MessageRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("MessageRequest") }
            self.messageRequest = try Pinpoint.MessageRequest(dictionary: messageRequest)
        }
    }

    public struct PutEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EventStream"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        public init(dictionary: [String: Any]) throws {
            guard let eventStream = dictionary["EventStream"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EventStream") }
            self.eventStream = try Pinpoint.EventStream(dictionary: eventStream)
        }
    }

    public enum DeliveryStatus: String, CustomStringConvertible {
        case successful = "SUCCESSFUL"
        case throttled = "THROTTLED"
        case temporary_failure = "TEMPORARY_FAILURE"
        case permanent_failure = "PERMANENT_FAILURE"
        public var description: String { return self.rawValue }
    }

    public struct GetCampaignsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let pageSize: String?
        public let applicationId: String
        public let token: String?

        public init(pageSize: String? = nil, applicationId: String, token: String? = nil) {
            self.pageSize = pageSize
            self.applicationId = applicationId
            self.token = token
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            self.token = dictionary["token"] as? String
        }
    }

    public enum CampaignStatus: String, CustomStringConvertible {
        case scheduled = "SCHEDULED"
        case executing = "EXECUTING"
        case pending_next_run = "PENDING_NEXT_RUN"
        case completed = "COMPLETED"
        case paused = "PAUSED"
        public var description: String { return self.rawValue }
    }

    public struct SetDimension: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "DimensionType", required: false, type: .enum), 
            AWSShapeProperty(label: "Values", required: false, type: .list)
        ]
        /// The type of dimension:
        /// INCLUSIVE - Endpoints that match the criteria are included in the segment.
        /// EXCLUSIVE - Endpoints that match the criteria are excluded from the segment.
        public let dimensionType: DimensionType?
        public let values: [String]?

        public init(dimensionType: DimensionType? = nil, values: [String]? = nil) {
            self.dimensionType = dimensionType
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            if let dimensionType = dictionary["DimensionType"] as? String { self.dimensionType = DimensionType(rawValue: dimensionType) } else { self.dimensionType = nil }
            self.values = dictionary["Values"] as? [String]
        }
    }

    public struct ImportJobResource: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "S3Url", required: false, type: .string), 
            AWSShapeProperty(label: "DefineSegment", required: false, type: .boolean), 
            AWSShapeProperty(label: "Format", required: false, type: .enum), 
            AWSShapeProperty(label: "ExternalId", required: false, type: .string), 
            AWSShapeProperty(label: "RegisterEndpoints", required: false, type: .boolean), 
            AWSShapeProperty(label: "SegmentName", required: false, type: .string), 
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "SegmentId", required: false, type: .string)
        ]
        /// A URL that points to the location within an Amazon S3 bucket that contains the endpoints to import. The location can be a folder or a single file.
        /// The URL should follow this format: s3://bucket-name/folder-name/file-name
        /// Amazon Pinpoint will import endpoints from this location and any subfolders it contains.
        public let s3Url: String?
        /// Sets whether the endpoints create a segment when they are imported.
        public let defineSegment: Bool?
        /// The format of the files that contain the endpoint definitions.
        /// Valid values: CSV, JSON
        public let format: Format?
        /// A unique, custom ID assigned to the IAM role that restricts who can assume the role.	
        public let externalId: String?
        /// Sets whether the endpoints are registered with Amazon Pinpoint when they are imported.
        public let registerEndpoints: Bool?
        /// A custom name for the segment created by the import job. Use if DefineSegment is true.
        public let segmentName: String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon Pinpoint access to the Amazon S3 location that contains the endpoints to import.
        public let roleArn: String?
        /// The ID of the segment to update if the import job is meant to update an existing segment.
        public let segmentId: String?

        public init(s3Url: String? = nil, defineSegment: Bool? = nil, format: Format? = nil, externalId: String? = nil, registerEndpoints: Bool? = nil, segmentName: String? = nil, roleArn: String? = nil, segmentId: String? = nil) {
            self.s3Url = s3Url
            self.defineSegment = defineSegment
            self.format = format
            self.externalId = externalId
            self.registerEndpoints = registerEndpoints
            self.segmentName = segmentName
            self.roleArn = roleArn
            self.segmentId = segmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.s3Url = dictionary["S3Url"] as? String
            self.defineSegment = dictionary["DefineSegment"] as? Bool
            if let format = dictionary["Format"] as? String { self.format = Format(rawValue: format) } else { self.format = nil }
            self.externalId = dictionary["ExternalId"] as? String
            self.registerEndpoints = dictionary["RegisterEndpoints"] as? Bool
            self.segmentName = dictionary["SegmentName"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.segmentId = dictionary["SegmentId"] as? String
        }
    }

    public struct GetCampaignVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignResponse = dictionary["CampaignResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignResponse") }
            self.campaignResponse = try Pinpoint.CampaignResponse(dictionary: campaignResponse)
        }
    }

    public struct CreateImportJobRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ImportJobRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ImportJobRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let importJobRequest: ImportJobRequest
        public let applicationId: String

        public init(importJobRequest: ImportJobRequest, applicationId: String) {
            self.importJobRequest = importJobRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let importJobRequest = dictionary["ImportJobRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ImportJobRequest") }
            self.importJobRequest = try Pinpoint.ImportJobRequest(dictionary: importJobRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct APNSChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Certificate", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "PrivateKey", required: false, type: .string)
        ]
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The certificate private key.
        public let privateKey: String?

        public init(certificate: String? = nil, enabled: Bool? = nil, privateKey: String? = nil) {
            self.certificate = certificate
            self.enabled = enabled
            self.privateKey = privateKey
        }

        public init(dictionary: [String: Any]) throws {
            self.certificate = dictionary["Certificate"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.privateKey = dictionary["PrivateKey"] as? String
        }
    }

    public enum RecencyType: String, CustomStringConvertible {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible {
        case created = "CREATED"
        case initializing = "INITIALIZING"
        case processing = "PROCESSING"
        case completing = "COMPLETING"
        case completed = "COMPLETED"
        case failing = "FAILING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public struct EndpointUser: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "UserId", required: false, type: .string), 
            AWSShapeProperty(label: "UserAttributes", required: false, type: .map)
        ]
        /// The unique ID of the user.
        public let userId: String?
        public let userAttributes: [String: [String]]?

        public init(userId: String? = nil, userAttributes: [String: [String]]? = nil) {
            self.userId = userId
            self.userAttributes = userAttributes
        }

        public init(dictionary: [String: Any]) throws {
            self.userId = dictionary["UserId"] as? String
            if let userAttributes = dictionary["UserAttributes"] as? [String: Any] {
                var userAttributesDict: [String: [String]] = [:]
                for (key, value) in userAttributes {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    userAttributesDict[key] = listOfString
                }
                self.userAttributes = userAttributesDict
            } else { 
                self.userAttributes = nil
            }
        }
    }

    public struct CampaignEmailMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "Title", required: false, type: .string), 
            AWSShapeProperty(label: "HtmlBody", required: false, type: .string)
        ]
        /// The email text body.
        public let body: String?
        /// The email title (Or subject).
        public let title: String?
        /// The email html body.
        public let htmlBody: String?

        public init(body: String? = nil, title: String? = nil, htmlBody: String? = nil) {
            self.body = body
            self.title = title
            self.htmlBody = htmlBody
        }

        public init(dictionary: [String: Any]) throws {
            self.body = dictionary["Body"] as? String
            self.title = dictionary["Title"] as? String
            self.htmlBody = dictionary["HtmlBody"] as? String
        }
    }

    public struct SegmentDimensions: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Demographic", required: false, type: .structure), 
            AWSShapeProperty(label: "Behavior", required: false, type: .structure), 
            AWSShapeProperty(label: "Attributes", required: false, type: .map), 
            AWSShapeProperty(label: "Location", required: false, type: .structure), 
            AWSShapeProperty(label: "UserAttributes", required: false, type: .map)
        ]
        /// The segment demographics attributes.
        public let demographic: SegmentDemographics?
        /// The segment behaviors attributes.
        public let behavior: SegmentBehaviors?
        /// Custom segment attributes.
        public let attributes: [String: AttributeDimension]?
        /// The segment location attributes.
        public let location: SegmentLocation?
        /// Custom segment user attributes.
        public let userAttributes: [String: AttributeDimension]?

        public init(demographic: SegmentDemographics? = nil, behavior: SegmentBehaviors? = nil, attributes: [String: AttributeDimension]? = nil, location: SegmentLocation? = nil, userAttributes: [String: AttributeDimension]? = nil) {
            self.demographic = demographic
            self.behavior = behavior
            self.attributes = attributes
            self.location = location
            self.userAttributes = userAttributes
        }

        public init(dictionary: [String: Any]) throws {
            if let demographic = dictionary["Demographic"] as? [String: Any] { self.demographic = try Pinpoint.SegmentDemographics(dictionary: demographic) } else { self.demographic = nil }
            if let behavior = dictionary["Behavior"] as? [String: Any] { self.behavior = try Pinpoint.SegmentBehaviors(dictionary: behavior) } else { self.behavior = nil }
            if let attributes = dictionary["Attributes"] as? [String: Any] {
                var attributesDict: [String: AttributeDimension] = [:]
                for (key, value) in attributes {
                    guard let attributeDimensionDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    attributesDict[key] = try AttributeDimension(dictionary: attributeDimensionDict)
                }
                self.attributes = attributesDict
            } else { 
                self.attributes = nil
            }
            if let location = dictionary["Location"] as? [String: Any] { self.location = try Pinpoint.SegmentLocation(dictionary: location) } else { self.location = nil }
            if let userAttributes = dictionary["UserAttributes"] as? [String: Any] {
                var userAttributesDict: [String: AttributeDimension] = [:]
                for (key, value) in userAttributes {
                    guard let attributeDimensionDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    userAttributesDict[key] = try AttributeDimension(dictionary: attributeDimensionDict)
                }
                self.userAttributes = userAttributesDict
            } else { 
                self.userAttributes = nil
            }
        }
    }

    public struct GetSegmentVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentsResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentsResponse", required: true, type: .structure)
        ]
        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentsResponse = dictionary["SegmentsResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentsResponse") }
            self.segmentsResponse = try Pinpoint.SegmentsResponse(dictionary: segmentsResponse)
        }
    }

    public struct GetEventStreamRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        /// Application Id.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct MessageBody: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "RequestID", required: false, type: .string), 
            AWSShapeProperty(label: "Message", required: false, type: .string)
        ]
        /// The unique message body ID.
        public let requestID: String?
        /// The error message returned from the API.
        public let message: String?

        public init(requestID: String? = nil, message: String? = nil) {
            self.requestID = requestID
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.requestID = dictionary["RequestID"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct GetGcmChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "GCMChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "GCMChannelResponse", required: true, type: .structure)
        ]
        public let gCMChannelResponse: GCMChannelResponse

        public init(gCMChannelResponse: GCMChannelResponse) {
            self.gCMChannelResponse = gCMChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let gCMChannelResponse = dictionary["GCMChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("GCMChannelResponse") }
            self.gCMChannelResponse = try Pinpoint.GCMChannelResponse(dictionary: gCMChannelResponse)
        }
    }

    public struct ApplicationSettingsResource: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "Limits", required: false, type: .structure), 
            AWSShapeProperty(label: "QuietTime", required: false, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string)
        ]
        /// The date that the settings were last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The default campaign limits for the app. These limits apply to each campaign for the app, unless the campaign overrides the default with limits of its own.
        public let limits: CampaignLimits?
        /// The default quiet time for the app. Each campaign for this app sends no messages during this time unless the campaign overrides the default with a quiet time of its own.
        public let quietTime: QuietTime?
        /// The unique ID for the application.
        public let applicationId: String?

        public init(lastModifiedDate: String? = nil, limits: CampaignLimits? = nil, quietTime: QuietTime? = nil, applicationId: String? = nil) {
            self.lastModifiedDate = lastModifiedDate
            self.limits = limits
            self.quietTime = quietTime
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            if let limits = dictionary["Limits"] as? [String: Any] { self.limits = try Pinpoint.CampaignLimits(dictionary: limits) } else { self.limits = nil }
            if let quietTime = dictionary["QuietTime"] as? [String: Any] { self.quietTime = try Pinpoint.QuietTime(dictionary: quietTime) } else { self.quietTime = nil }
            self.applicationId = dictionary["ApplicationId"] as? String
        }
    }

    public struct UpdateEndpointResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "MessageBody"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "MessageBody", required: true, type: .structure)
        ]
        public let messageBody: MessageBody

        public init(messageBody: MessageBody) {
            self.messageBody = messageBody
        }

        public init(dictionary: [String: Any]) throws {
            guard let messageBody = dictionary["MessageBody"] as? [String: Any] else { throw InitializableError.missingRequiredParam("MessageBody") }
            self.messageBody = try Pinpoint.MessageBody(dictionary: messageBody)
        }
    }

    public struct GetCampaignActivitiesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ActivitiesResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ActivitiesResponse", required: true, type: .structure)
        ]
        public let activitiesResponse: ActivitiesResponse

        public init(activitiesResponse: ActivitiesResponse) {
            self.activitiesResponse = activitiesResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let activitiesResponse = dictionary["ActivitiesResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ActivitiesResponse") }
            self.activitiesResponse = try Pinpoint.ActivitiesResponse(dictionary: activitiesResponse)
        }
    }

    public struct GetCampaignVersionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let pageSize: String?
        public let campaignId: String
        public let applicationId: String
        public let token: String?

        public init(pageSize: String? = nil, campaignId: String, applicationId: String, token: String? = nil) {
            self.pageSize = pageSize
            self.campaignId = campaignId
            self.applicationId = applicationId
            self.token = token
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            guard let campaignId = dictionary["campaign-id"] as? String else { throw InitializableError.missingRequiredParam("campaign-id") }
            self.campaignId = campaignId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            self.token = dictionary["token"] as? String
        }
    }

    public struct UpdateEndpointsBatchRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EndpointBatchRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EndpointBatchRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointBatchRequest: EndpointBatchRequest
        public let applicationId: String

        public init(endpointBatchRequest: EndpointBatchRequest, applicationId: String) {
            self.endpointBatchRequest = endpointBatchRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let endpointBatchRequest = dictionary["EndpointBatchRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EndpointBatchRequest") }
            self.endpointBatchRequest = try Pinpoint.EndpointBatchRequest(dictionary: endpointBatchRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct AttributeDimension: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "AttributeType", required: false, type: .enum), 
            AWSShapeProperty(label: "Values", required: false, type: .list)
        ]
        /// The type of dimension:
        /// INCLUSIVE - Endpoints that match the criteria are included in the segment.
        /// EXCLUSIVE - Endpoints that match the criteria are excluded from the segment.
        public let attributeType: AttributeType?
        public let values: [String]?

        public init(attributeType: AttributeType? = nil, values: [String]? = nil) {
            self.attributeType = attributeType
            self.values = values
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeType = dictionary["AttributeType"] as? String { self.attributeType = AttributeType(rawValue: attributeType) } else { self.attributeType = nil }
            self.values = dictionary["Values"] as? [String]
        }
    }

    public struct APNSChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Platform", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeProperty(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Version of channel
        public let version: Int32?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// When was this segment created
        public let creationDate: String?
        /// The ID of the application to which the channel applies.
        public let applicationId: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(id: String? = nil, platform: String? = nil, enabled: Bool? = nil, version: Int32? = nil, lastModifiedDate: String? = nil, creationDate: String? = nil, applicationId: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil) {
            self.id = id
            self.platform = platform
            self.enabled = enabled
            self.version = version
            self.lastModifiedDate = lastModifiedDate
            self.creationDate = creationDate
            self.applicationId = applicationId
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.platform = dictionary["Platform"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.version = dictionary["Version"] as? Int32
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.isArchived = dictionary["IsArchived"] as? Bool
            self.lastModifiedBy = dictionary["LastModifiedBy"] as? String
        }
    }

    public struct UpdateApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSSandboxChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSSandboxChannelResponse = dictionary["APNSSandboxChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSSandboxChannelResponse") }
            self.aPNSSandboxChannelResponse = try Pinpoint.APNSSandboxChannelResponse(dictionary: aPNSSandboxChannelResponse)
        }
    }

    public struct DeleteEventStreamRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        /// Application Id.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct SegmentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Item", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// The list of segments.
        public let item: [SegmentResponse]?
        /// An identifier used to retrieve the next page of results. The token is null if no additional pages exist.
        public let nextToken: String?

        public init(item: [SegmentResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try SegmentResponse(dictionary: $0) })
            } else { 
                self.item = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct SegmentResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Name", required: false, type: .string), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "Dimensions", required: false, type: .structure), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "ImportDefinition", required: false, type: .structure), 
            AWSShapeProperty(label: "SegmentType", required: false, type: .enum)
        ]
        /// The unique segment ID.
        public let id: String?
        /// The name of segment
        public let name: String?
        /// The segment version number.
        public let version: Int32?
        /// The segment dimensions attributes.
        public let dimensions: SegmentDimensions?
        /// The date the segment was created in ISO 8601 format.
        public let creationDate: String?
        /// The ID of the application to which the segment applies.
        public let applicationId: String?
        /// The date the segment was last updated in ISO 8601 format.
        public let lastModifiedDate: String?
        /// The import job settings.
        public let importDefinition: SegmentImportResource?
        /// The segment type:
        /// DIMENSIONAL - A dynamic segment built from selection criteria based on endpoint data reported by your app. You create this type of segment by using the segment builder in the Amazon Pinpoint console or by making a POST request to the segments resource.
        /// IMPORT - A static segment built from an imported set of endpoint definitions. You create this type of segment by importing a segment in the Amazon Pinpoint console or by making a POST request to the jobs/import resource.
        public let segmentType: SegmentType?

        public init(id: String? = nil, name: String? = nil, version: Int32? = nil, dimensions: SegmentDimensions? = nil, creationDate: String? = nil, applicationId: String? = nil, lastModifiedDate: String? = nil, importDefinition: SegmentImportResource? = nil, segmentType: SegmentType? = nil) {
            self.id = id
            self.name = name
            self.version = version
            self.dimensions = dimensions
            self.creationDate = creationDate
            self.applicationId = applicationId
            self.lastModifiedDate = lastModifiedDate
            self.importDefinition = importDefinition
            self.segmentType = segmentType
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.name = dictionary["Name"] as? String
            self.version = dictionary["Version"] as? Int32
            if let dimensions = dictionary["Dimensions"] as? [String: Any] { self.dimensions = try Pinpoint.SegmentDimensions(dictionary: dimensions) } else { self.dimensions = nil }
            self.creationDate = dictionary["CreationDate"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            if let importDefinition = dictionary["ImportDefinition"] as? [String: Any] { self.importDefinition = try Pinpoint.SegmentImportResource(dictionary: importDefinition) } else { self.importDefinition = nil }
            if let segmentType = dictionary["SegmentType"] as? String { self.segmentType = SegmentType(rawValue: segmentType) } else { self.segmentType = nil }
        }
    }

    public struct ImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CompletionDate", required: false, type: .string), 
            AWSShapeProperty(label: "Definition", required: false, type: .structure), 
            AWSShapeProperty(label: "FailedPieces", required: false, type: .integer), 
            AWSShapeProperty(label: "TotalPieces", required: false, type: .integer), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "JobStatus", required: false, type: .enum), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "TotalProcessed", required: false, type: .integer), 
            AWSShapeProperty(label: "CompletedPieces", required: false, type: .integer), 
            AWSShapeProperty(label: "TotalFailures", required: false, type: .integer), 
            AWSShapeProperty(label: "Failures", required: false, type: .list), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "Type", required: false, type: .string)
        ]
        /// The date the import job completed in ISO 8601 format.
        public let completionDate: String?
        /// The import job settings.
        public let definition: ImportJobResource?
        /// The number of pieces that have failed to import as of the time of the request.
        public let failedPieces: Int32?
        /// The total number of pieces that must be imported to finish the job. Each piece is an approximately equal portion of the endpoints to import.
        public let totalPieces: Int32?
        /// The date the import job was created in ISO 8601 format.
        public let creationDate: String?
        /// The status of the import job.
        /// Valid values: CREATED, INITIALIZING, PROCESSING, COMPLETING, COMPLETED, FAILING, FAILED
        /// The job status is FAILED if one or more pieces failed to import.
        public let jobStatus: JobStatus?
        /// The unique ID of the import job.
        public let id: String?
        /// The number of endpoints that were processed by the import job.
        public let totalProcessed: Int32?
        /// The number of pieces that have successfully imported as of the time of the request.
        public let completedPieces: Int32?
        /// The number of endpoints that failed to import; for example, because of syntax errors.
        public let totalFailures: Int32?
        public let failures: [String]?
        /// The unique ID of the application to which the import job applies.
        public let applicationId: String?
        /// The job type. Will be Import.
        public let `type`: String?

        public init(completionDate: String? = nil, definition: ImportJobResource? = nil, failedPieces: Int32? = nil, totalPieces: Int32? = nil, creationDate: String? = nil, jobStatus: JobStatus? = nil, id: String? = nil, totalProcessed: Int32? = nil, completedPieces: Int32? = nil, totalFailures: Int32? = nil, failures: [String]? = nil, applicationId: String? = nil, type: String? = nil) {
            self.completionDate = completionDate
            self.definition = definition
            self.failedPieces = failedPieces
            self.totalPieces = totalPieces
            self.creationDate = creationDate
            self.jobStatus = jobStatus
            self.id = id
            self.totalProcessed = totalProcessed
            self.completedPieces = completedPieces
            self.totalFailures = totalFailures
            self.failures = failures
            self.applicationId = applicationId
            self.`type` = `type`
        }

        public init(dictionary: [String: Any]) throws {
            self.completionDate = dictionary["CompletionDate"] as? String
            if let definition = dictionary["Definition"] as? [String: Any] { self.definition = try Pinpoint.ImportJobResource(dictionary: definition) } else { self.definition = nil }
            self.failedPieces = dictionary["FailedPieces"] as? Int32
            self.totalPieces = dictionary["TotalPieces"] as? Int32
            self.creationDate = dictionary["CreationDate"] as? String
            if let jobStatus = dictionary["JobStatus"] as? String { self.jobStatus = JobStatus(rawValue: jobStatus) } else { self.jobStatus = nil }
            self.id = dictionary["Id"] as? String
            self.totalProcessed = dictionary["TotalProcessed"] as? Int32
            self.completedPieces = dictionary["CompletedPieces"] as? Int32
            self.totalFailures = dictionary["TotalFailures"] as? Int32
            self.failures = dictionary["Failures"] as? [String]
            self.applicationId = dictionary["ApplicationId"] as? String
            self.`type` = dictionary["Type"] as? String
        }
    }

    public struct CreateImportJobResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ImportJobResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ImportJobResponse", required: true, type: .structure)
        ]
        public let importJobResponse: ImportJobResponse

        public init(importJobResponse: ImportJobResponse) {
            self.importJobResponse = importJobResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let importJobResponse = dictionary["ImportJobResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ImportJobResponse") }
            self.importJobResponse = try Pinpoint.ImportJobResponse(dictionary: importJobResponse)
        }
    }

    public struct GetEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EventStream"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        public init(dictionary: [String: Any]) throws {
            guard let eventStream = dictionary["EventStream"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EventStream") }
            self.eventStream = try Pinpoint.EventStream(dictionary: eventStream)
        }
    }

    public struct GetApplicationSettingsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ApplicationSettingsResource"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationSettingsResource", required: true, type: .structure)
        ]
        public let applicationSettingsResource: ApplicationSettingsResource

        public init(applicationSettingsResource: ApplicationSettingsResource) {
            self.applicationSettingsResource = applicationSettingsResource
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationSettingsResource = dictionary["ApplicationSettingsResource"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ApplicationSettingsResource") }
            self.applicationSettingsResource = try Pinpoint.ApplicationSettingsResource(dictionary: applicationSettingsResource)
        }
    }

    public struct GetImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "ImportJobsResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ImportJobsResponse", required: true, type: .structure)
        ]
        public let importJobsResponse: ImportJobsResponse

        public init(importJobsResponse: ImportJobsResponse) {
            self.importJobsResponse = importJobsResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let importJobsResponse = dictionary["ImportJobsResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ImportJobsResponse") }
            self.importJobsResponse = try Pinpoint.ImportJobsResponse(dictionary: importJobsResponse)
        }
    }

    public struct GetCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignResponse = dictionary["CampaignResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignResponse") }
            self.campaignResponse = try Pinpoint.CampaignResponse(dictionary: campaignResponse)
        }
    }

    public struct UpdateSmsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SMSChannelRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SMSChannelRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let sMSChannelRequest: SMSChannelRequest
        public let applicationId: String

        public init(sMSChannelRequest: SMSChannelRequest, applicationId: String) {
            self.sMSChannelRequest = sMSChannelRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let sMSChannelRequest = dictionary["SMSChannelRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SMSChannelRequest") }
            self.sMSChannelRequest = try Pinpoint.SMSChannelRequest(dictionary: sMSChannelRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct UpdateSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "WriteSegmentRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeProperty(label: "WriteSegmentRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let segmentId: String
        public let writeSegmentRequest: WriteSegmentRequest

        public init(applicationId: String, segmentId: String, writeSegmentRequest: WriteSegmentRequest) {
            self.applicationId = applicationId
            self.segmentId = segmentId
            self.writeSegmentRequest = writeSegmentRequest
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let segmentId = dictionary["segment-id"] as? String else { throw InitializableError.missingRequiredParam("segment-id") }
            self.segmentId = segmentId
            guard let writeSegmentRequest = dictionary["WriteSegmentRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WriteSegmentRequest") }
            self.writeSegmentRequest = try Pinpoint.WriteSegmentRequest(dictionary: writeSegmentRequest)
        }
    }

    public struct DeleteGcmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct APNSSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Platform", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeProperty(label: "LastModifiedBy", required: false, type: .string)
        ]
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// The platform type. Will be APNS.
        public let platform: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Version of channel
        public let version: Int32?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// When was this segment created
        public let creationDate: String?
        /// Application id
        public let applicationId: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// Who last updated this entry
        public let lastModifiedBy: String?

        public init(id: String? = nil, platform: String? = nil, enabled: Bool? = nil, version: Int32? = nil, lastModifiedDate: String? = nil, creationDate: String? = nil, applicationId: String? = nil, isArchived: Bool? = nil, lastModifiedBy: String? = nil) {
            self.id = id
            self.platform = platform
            self.enabled = enabled
            self.version = version
            self.lastModifiedDate = lastModifiedDate
            self.creationDate = creationDate
            self.applicationId = applicationId
            self.isArchived = isArchived
            self.lastModifiedBy = lastModifiedBy
        }

        public init(dictionary: [String: Any]) throws {
            self.id = dictionary["Id"] as? String
            self.platform = dictionary["Platform"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.version = dictionary["Version"] as? Int32
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.isArchived = dictionary["IsArchived"] as? Bool
            self.lastModifiedBy = dictionary["LastModifiedBy"] as? String
        }
    }

    public struct WriteEventStream: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "DestinationStreamArn", required: false, type: .string)
        ]
        /// The IAM role that authorizes Amazon Pinpoint to publish events to the stream in your account.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis stream or Firehose delivery stream to which you want to publish events.
        ///  Firehose ARN: arn:aws:firehose:REGION:ACCOUNT_ID:deliverystream/STREAM_NAME
        ///  Kinesis ARN: arn:aws:kinesis:REGION:ACCOUNT_ID:stream/STREAM_NAME
        public let destinationStreamArn: String?

        public init(roleArn: String? = nil, destinationStreamArn: String? = nil) {
            self.roleArn = roleArn
            self.destinationStreamArn = destinationStreamArn
        }

        public init(dictionary: [String: Any]) throws {
            self.roleArn = dictionary["RoleArn"] as? String
            self.destinationStreamArn = dictionary["DestinationStreamArn"] as? String
        }
    }

    public struct UpdateApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSChannelResponse = dictionary["APNSChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSChannelResponse") }
            self.aPNSChannelResponse = try Pinpoint.APNSChannelResponse(dictionary: aPNSChannelResponse)
        }
    }

    public struct UpdateGcmChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "GCMChannelRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "GCMChannelRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let gCMChannelRequest: GCMChannelRequest
        public let applicationId: String

        public init(gCMChannelRequest: GCMChannelRequest, applicationId: String) {
            self.gCMChannelRequest = gCMChannelRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let gCMChannelRequest = dictionary["GCMChannelRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("GCMChannelRequest") }
            self.gCMChannelRequest = try Pinpoint.GCMChannelRequest(dictionary: gCMChannelRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct DeleteCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignResponse = dictionary["CampaignResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignResponse") }
            self.campaignResponse = try Pinpoint.CampaignResponse(dictionary: campaignResponse)
        }
    }

    public struct CampaignLimits: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Daily", required: false, type: .integer), 
            AWSShapeProperty(label: "Total", required: false, type: .integer)
        ]
        /// The maximum number of messages that the campaign can send daily.
        public let daily: Int32?
        /// The maximum total number of messages that the campaign can send.
        public let total: Int32?

        public init(daily: Int32? = nil, total: Int32? = nil) {
            self.daily = daily
            self.total = total
        }

        public init(dictionary: [String: Any]) throws {
            self.daily = dictionary["Daily"] as? Int32
            self.total = dictionary["Total"] as? Int32
        }
    }

    public struct SegmentDemographics: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Make", required: false, type: .structure), 
            AWSShapeProperty(label: "Platform", required: false, type: .structure), 
            AWSShapeProperty(label: "DeviceType", required: false, type: .structure), 
            AWSShapeProperty(label: "AppVersion", required: false, type: .structure), 
            AWSShapeProperty(label: "Channel", required: false, type: .structure), 
            AWSShapeProperty(label: "Model", required: false, type: .structure)
        ]
        /// The device make criteria for the segment.
        public let make: SetDimension?
        /// The device platform criteria for the segment.
        public let platform: SetDimension?
        /// The device type criteria for the segment.
        public let deviceType: SetDimension?
        /// The app version criteria for the segment.
        public let appVersion: SetDimension?
        /// The channel criteria for the segment.
        public let channel: SetDimension?
        /// The device model criteria for the segment.
        public let model: SetDimension?

        public init(make: SetDimension? = nil, platform: SetDimension? = nil, deviceType: SetDimension? = nil, appVersion: SetDimension? = nil, channel: SetDimension? = nil, model: SetDimension? = nil) {
            self.make = make
            self.platform = platform
            self.deviceType = deviceType
            self.appVersion = appVersion
            self.channel = channel
            self.model = model
        }

        public init(dictionary: [String: Any]) throws {
            if let make = dictionary["Make"] as? [String: Any] { self.make = try Pinpoint.SetDimension(dictionary: make) } else { self.make = nil }
            if let platform = dictionary["Platform"] as? [String: Any] { self.platform = try Pinpoint.SetDimension(dictionary: platform) } else { self.platform = nil }
            if let deviceType = dictionary["DeviceType"] as? [String: Any] { self.deviceType = try Pinpoint.SetDimension(dictionary: deviceType) } else { self.deviceType = nil }
            if let appVersion = dictionary["AppVersion"] as? [String: Any] { self.appVersion = try Pinpoint.SetDimension(dictionary: appVersion) } else { self.appVersion = nil }
            if let channel = dictionary["Channel"] as? [String: Any] { self.channel = try Pinpoint.SetDimension(dictionary: channel) } else { self.channel = nil }
            if let model = dictionary["Model"] as? [String: Any] { self.model = try Pinpoint.SetDimension(dictionary: model) } else { self.model = nil }
        }
    }

    public struct GetApnsSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct DeleteEventStreamResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EventStream"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EventStream", required: true, type: .structure)
        ]
        public let eventStream: EventStream

        public init(eventStream: EventStream) {
            self.eventStream = eventStream
        }

        public init(dictionary: [String: Any]) throws {
            guard let eventStream = dictionary["EventStream"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EventStream") }
            self.eventStream = try Pinpoint.EventStream(dictionary: eventStream)
        }
    }

    public struct EmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "LastModifiedBy", required: false, type: .string), 
            AWSShapeProperty(label: "Platform", required: false, type: .string), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "Version", required: false, type: .integer), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "LastModifiedDate", required: false, type: .string), 
            AWSShapeProperty(label: "CreationDate", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "RoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "IsArchived", required: false, type: .boolean), 
            AWSShapeProperty(label: "Identity", required: false, type: .string), 
            AWSShapeProperty(label: "FromAddress", required: false, type: .string)
        ]
        /// Who last updated this entry
        public let lastModifiedBy: String?
        /// Platform type. Will be "EMAIL"
        public let platform: String?
        /// Channel ID. Not used, only for backwards compatibility.
        public let id: String?
        /// Version of channel
        public let version: Int32?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// Last date this was updated
        public let lastModifiedDate: String?
        /// The date that the settings were last updated in ISO 8601 format.
        public let creationDate: String?
        /// Application id
        public let applicationId: String?
        /// The ARN of an IAM Role used to submit events to Mobile Analytics' event ingestion service
        public let roleArn: String?
        /// Is this channel archived
        public let isArchived: Bool?
        /// The ARN of an identity verified with SES.
        public let identity: String?
        /// The email address used to send emails from.
        public let fromAddress: String?

        public init(lastModifiedBy: String? = nil, platform: String? = nil, id: String? = nil, version: Int32? = nil, enabled: Bool? = nil, lastModifiedDate: String? = nil, creationDate: String? = nil, applicationId: String? = nil, roleArn: String? = nil, isArchived: Bool? = nil, identity: String? = nil, fromAddress: String? = nil) {
            self.lastModifiedBy = lastModifiedBy
            self.platform = platform
            self.id = id
            self.version = version
            self.enabled = enabled
            self.lastModifiedDate = lastModifiedDate
            self.creationDate = creationDate
            self.applicationId = applicationId
            self.roleArn = roleArn
            self.isArchived = isArchived
            self.identity = identity
            self.fromAddress = fromAddress
        }

        public init(dictionary: [String: Any]) throws {
            self.lastModifiedBy = dictionary["LastModifiedBy"] as? String
            self.platform = dictionary["Platform"] as? String
            self.id = dictionary["Id"] as? String
            self.version = dictionary["Version"] as? Int32
            self.enabled = dictionary["Enabled"] as? Bool
            self.lastModifiedDate = dictionary["LastModifiedDate"] as? String
            self.creationDate = dictionary["CreationDate"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.roleArn = dictionary["RoleArn"] as? String
            self.isArchived = dictionary["IsArchived"] as? Bool
            self.identity = dictionary["Identity"] as? String
            self.fromAddress = dictionary["FromAddress"] as? String
        }
    }

    public struct CreateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignResponse = dictionary["CampaignResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignResponse") }
            self.campaignResponse = try Pinpoint.CampaignResponse(dictionary: campaignResponse)
        }
    }

    public struct ActivityResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignId", required: false, type: .string), 
            AWSShapeProperty(label: "State", required: false, type: .string), 
            AWSShapeProperty(label: "TimezonesTotalCount", required: false, type: .integer), 
            AWSShapeProperty(label: "TotalEndpointCount", required: false, type: .integer), 
            AWSShapeProperty(label: "TimezonesCompletedCount", required: false, type: .integer), 
            AWSShapeProperty(label: "Id", required: false, type: .string), 
            AWSShapeProperty(label: "ScheduledStart", required: false, type: .string), 
            AWSShapeProperty(label: "Start", required: false, type: .string), 
            AWSShapeProperty(label: "End", required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", required: false, type: .string), 
            AWSShapeProperty(label: "TreatmentId", required: false, type: .string), 
            AWSShapeProperty(label: "Result", required: false, type: .string), 
            AWSShapeProperty(label: "SuccessfulEndpointCount", required: false, type: .integer)
        ]
        /// The ID of the campaign to which the activity applies.
        public let campaignId: String?
        /// The state of the activity.
        /// Valid values: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, COMPLETED
        public let state: String?
        /// The total number of unique timezones present in the segment.
        public let timezonesTotalCount: Int32?
        /// The total number of endpoints to which the campaign attempts to deliver messages.
        public let totalEndpointCount: Int32?
        /// The total number of timezones completed.
        public let timezonesCompletedCount: Int32?
        /// The unique activity ID.
        public let id: String?
        /// The scheduled start time for the activity in ISO 8601 format.
        public let scheduledStart: String?
        /// The actual start time of the activity in ISO 8601 format.
        public let start: String?
        /// The actual time the activity was marked CANCELLED or COMPLETED. Provided in ISO 8601 format.
        public let end: String?
        /// The ID of the application to which the campaign applies.
        public let applicationId: String?
        /// The ID of a variation of the campaign used for A/B testing.
        public let treatmentId: String?
        /// Indicates whether the activity succeeded.
        /// Valid values: SUCCESS, FAIL
        public let result: String?
        /// The total number of endpoints to which the campaign successfully delivered messages.
        public let successfulEndpointCount: Int32?

        public init(campaignId: String? = nil, state: String? = nil, timezonesTotalCount: Int32? = nil, totalEndpointCount: Int32? = nil, timezonesCompletedCount: Int32? = nil, id: String? = nil, scheduledStart: String? = nil, start: String? = nil, end: String? = nil, applicationId: String? = nil, treatmentId: String? = nil, result: String? = nil, successfulEndpointCount: Int32? = nil) {
            self.campaignId = campaignId
            self.state = state
            self.timezonesTotalCount = timezonesTotalCount
            self.totalEndpointCount = totalEndpointCount
            self.timezonesCompletedCount = timezonesCompletedCount
            self.id = id
            self.scheduledStart = scheduledStart
            self.start = start
            self.end = end
            self.applicationId = applicationId
            self.treatmentId = treatmentId
            self.result = result
            self.successfulEndpointCount = successfulEndpointCount
        }

        public init(dictionary: [String: Any]) throws {
            self.campaignId = dictionary["CampaignId"] as? String
            self.state = dictionary["State"] as? String
            self.timezonesTotalCount = dictionary["TimezonesTotalCount"] as? Int32
            self.totalEndpointCount = dictionary["TotalEndpointCount"] as? Int32
            self.timezonesCompletedCount = dictionary["TimezonesCompletedCount"] as? Int32
            self.id = dictionary["Id"] as? String
            self.scheduledStart = dictionary["ScheduledStart"] as? String
            self.start = dictionary["Start"] as? String
            self.end = dictionary["End"] as? String
            self.applicationId = dictionary["ApplicationId"] as? String
            self.treatmentId = dictionary["TreatmentId"] as? String
            self.result = dictionary["Result"] as? String
            self.successfulEndpointCount = dictionary["SuccessfulEndpointCount"] as? Int32
        }
    }

    public struct CreateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentResponse = dictionary["SegmentResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentResponse") }
            self.segmentResponse = try Pinpoint.SegmentResponse(dictionary: segmentResponse)
        }
    }

    public struct GetSegmentImportJobsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string)
        ]
        public let pageSize: String?
        public let token: String?
        public let applicationId: String
        public let segmentId: String

        public init(pageSize: String? = nil, token: String? = nil, applicationId: String, segmentId: String) {
            self.pageSize = pageSize
            self.token = token
            self.applicationId = applicationId
            self.segmentId = segmentId
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            self.token = dictionary["token"] as? String
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let segmentId = dictionary["segment-id"] as? String else { throw InitializableError.missingRequiredParam("segment-id") }
            self.segmentId = segmentId
        }
    }

    public struct UpdateApnsChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSChannelRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSChannelRequest", required: true, type: .structure), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let aPNSChannelRequest: APNSChannelRequest
        public let applicationId: String

        public init(aPNSChannelRequest: APNSChannelRequest, applicationId: String) {
            self.aPNSChannelRequest = aPNSChannelRequest
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSChannelRequest = dictionary["APNSChannelRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSChannelRequest") }
            self.aPNSChannelRequest = try Pinpoint.APNSChannelRequest(dictionary: aPNSChannelRequest)
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct GetCampaignVersionsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignsResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignsResponse", required: true, type: .structure)
        ]
        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignsResponse = dictionary["CampaignsResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignsResponse") }
            self.campaignsResponse = try Pinpoint.CampaignsResponse(dictionary: campaignsResponse)
        }
    }

    public struct GetSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentResponse = dictionary["SegmentResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentResponse") }
            self.segmentResponse = try Pinpoint.SegmentResponse(dictionary: segmentResponse)
        }
    }

    public struct GetSegmentsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentsResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentsResponse", required: true, type: .structure)
        ]
        public let segmentsResponse: SegmentsResponse

        public init(segmentsResponse: SegmentsResponse) {
            self.segmentsResponse = segmentsResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentsResponse = dictionary["SegmentsResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentsResponse") }
            self.segmentsResponse = try Pinpoint.SegmentsResponse(dictionary: segmentsResponse)
        }
    }

    public enum MessageType: String, CustomStringConvertible {
        case transactional = "TRANSACTIONAL"
        case promotional = "PROMOTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct UpdateCampaignRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "WriteCampaignRequest"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeProperty(label: "WriteCampaignRequest", required: true, type: .structure)
        ]
        public let applicationId: String
        public let campaignId: String
        public let writeCampaignRequest: WriteCampaignRequest

        public init(applicationId: String, campaignId: String, writeCampaignRequest: WriteCampaignRequest) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.writeCampaignRequest = writeCampaignRequest
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let campaignId = dictionary["campaign-id"] as? String else { throw InitializableError.missingRequiredParam("campaign-id") }
            self.campaignId = campaignId
            guard let writeCampaignRequest = dictionary["WriteCampaignRequest"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WriteCampaignRequest") }
            self.writeCampaignRequest = try Pinpoint.WriteCampaignRequest(dictionary: writeCampaignRequest)
        }
    }

    public struct DeleteSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentResponse = dictionary["SegmentResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentResponse") }
            self.segmentResponse = try Pinpoint.SegmentResponse(dictionary: segmentResponse)
        }
    }

    public struct PutEventStreamRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = "WriteEventStream"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "WriteEventStream", required: true, type: .structure)
        ]
        /// Application Id.
        public let applicationId: String
        /// Write event stream wrapper.
        public let writeEventStream: WriteEventStream

        public init(applicationId: String, writeEventStream: WriteEventStream) {
            self.applicationId = applicationId
            self.writeEventStream = writeEventStream
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let writeEventStream = dictionary["WriteEventStream"] as? [String: Any] else { throw InitializableError.missingRequiredParam("WriteEventStream") }
            self.writeEventStream = try Pinpoint.WriteEventStream(dictionary: writeEventStream)
        }
    }

    public struct GetCampaignsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignsResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignsResponse", required: true, type: .structure)
        ]
        public let campaignsResponse: CampaignsResponse

        public init(campaignsResponse: CampaignsResponse) {
            self.campaignsResponse = campaignsResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignsResponse = dictionary["CampaignsResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignsResponse") }
            self.campaignsResponse = try Pinpoint.CampaignsResponse(dictionary: campaignsResponse)
        }
    }

    public struct GetSegmentVersionResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentResponse = dictionary["SegmentResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentResponse") }
            self.segmentResponse = try Pinpoint.SegmentResponse(dictionary: segmentResponse)
        }
    }

    public struct GetEndpointRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EndpointId", location: .uri(locationName: "endpoint-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let endpointId: String
        public let applicationId: String

        public init(endpointId: String, applicationId: String) {
            self.endpointId = endpointId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let endpointId = dictionary["endpoint-id"] as? String else { throw InitializableError.missingRequiredParam("endpoint-id") }
            self.endpointId = endpointId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct APNSSandboxChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Certificate", required: false, type: .string), 
            AWSShapeProperty(label: "Enabled", required: false, type: .boolean), 
            AWSShapeProperty(label: "PrivateKey", required: false, type: .string)
        ]
        /// The distribution certificate from Apple.
        public let certificate: String?
        /// If the channel is enabled for sending messages.
        public let enabled: Bool?
        /// The certificate private key.
        public let privateKey: String?

        public init(certificate: String? = nil, enabled: Bool? = nil, privateKey: String? = nil) {
            self.certificate = certificate
            self.enabled = enabled
            self.privateKey = privateKey
        }

        public init(dictionary: [String: Any]) throws {
            self.certificate = dictionary["Certificate"] as? String
            self.enabled = dictionary["Enabled"] as? Bool
            self.privateKey = dictionary["PrivateKey"] as? String
        }
    }

    public struct GetCampaignVersionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "CampaignId", location: .uri(locationName: "campaign-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Version", location: .uri(locationName: "version"), required: true, type: .string)
        ]
        public let applicationId: String
        public let campaignId: String
        public let version: String

        public init(applicationId: String, campaignId: String, version: String) {
            self.applicationId = applicationId
            self.campaignId = campaignId
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            guard let campaignId = dictionary["campaign-id"] as? String else { throw InitializableError.missingRequiredParam("campaign-id") }
            self.campaignId = campaignId
            guard let version = dictionary["version"] as? String else { throw InitializableError.missingRequiredParam("version") }
            self.version = version
        }
    }

    public struct DeleteEmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct UpdateCampaignResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "CampaignResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignResponse", required: true, type: .structure)
        ]
        public let campaignResponse: CampaignResponse

        public init(campaignResponse: CampaignResponse) {
            self.campaignResponse = campaignResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let campaignResponse = dictionary["CampaignResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("CampaignResponse") }
            self.campaignResponse = try Pinpoint.CampaignResponse(dictionary: campaignResponse)
        }
    }

    public struct DeleteEmailChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "EmailChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "EmailChannelResponse", required: true, type: .structure)
        ]
        public let emailChannelResponse: EmailChannelResponse

        public init(emailChannelResponse: EmailChannelResponse) {
            self.emailChannelResponse = emailChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let emailChannelResponse = dictionary["EmailChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("EmailChannelResponse") }
            self.emailChannelResponse = try Pinpoint.EmailChannelResponse(dictionary: emailChannelResponse)
        }
    }

    public struct UpdateSegmentResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "SegmentResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentResponse", required: true, type: .structure)
        ]
        public let segmentResponse: SegmentResponse

        public init(segmentResponse: SegmentResponse) {
            self.segmentResponse = segmentResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentResponse = dictionary["SegmentResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SegmentResponse") }
            self.segmentResponse = try Pinpoint.SegmentResponse(dictionary: segmentResponse)
        }
    }

    public struct SegmentBehaviors: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Recency", required: false, type: .structure)
        ]
        /// The recency of use.
        public let recency: RecencyDimension?

        public init(recency: RecencyDimension? = nil) {
            self.recency = recency
        }

        public init(dictionary: [String: Any]) throws {
            if let recency = dictionary["Recency"] as? [String: Any] { self.recency = try Pinpoint.RecencyDimension(dictionary: recency) } else { self.recency = nil }
        }
    }

    public struct GetEmailChannelRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct GetApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSSandboxChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSSandboxChannelResponse = dictionary["APNSSandboxChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSSandboxChannelResponse") }
            self.aPNSSandboxChannelResponse = try Pinpoint.APNSSandboxChannelResponse(dictionary: aPNSSandboxChannelResponse)
        }
    }

    public struct MessageResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StatusCode", required: false, type: .integer), 
            AWSShapeProperty(label: "StatusMessage", required: false, type: .string), 
            AWSShapeProperty(label: "UpdatedToken", required: false, type: .string), 
            AWSShapeProperty(label: "DeliveryStatus", required: false, type: .enum)
        ]
        /// Downstream service status code.
        public let statusCode: Int32?
        /// Status message for message delivery.
        public let statusMessage: String?
        /// If token was updated as part of delivery. (This is GCM Specific)
        public let updatedToken: String?
        /// Delivery status of message.
        public let deliveryStatus: DeliveryStatus?

        public init(statusCode: Int32? = nil, statusMessage: String? = nil, updatedToken: String? = nil, deliveryStatus: DeliveryStatus? = nil) {
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updatedToken = updatedToken
            self.deliveryStatus = deliveryStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.statusCode = dictionary["StatusCode"] as? Int32
            self.statusMessage = dictionary["StatusMessage"] as? String
            self.updatedToken = dictionary["UpdatedToken"] as? String
            if let deliveryStatus = dictionary["DeliveryStatus"] as? String { self.deliveryStatus = DeliveryStatus(rawValue: deliveryStatus) } else { self.deliveryStatus = nil }
        }
    }

    public struct CampaignState: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "CampaignStatus", required: false, type: .enum)
        ]
        /// The status of the campaign, or the status of a treatment that belongs to an A/B test campaign.
        /// Valid values: SCHEDULED, EXECUTING, PENDING_NEXT_RUN, COMPLETED, PAUSED
        public let campaignStatus: CampaignStatus?

        public init(campaignStatus: CampaignStatus? = nil) {
            self.campaignStatus = campaignStatus
        }

        public init(dictionary: [String: Any]) throws {
            if let campaignStatus = dictionary["CampaignStatus"] as? String { self.campaignStatus = CampaignStatus(rawValue: campaignStatus) } else { self.campaignStatus = nil }
        }
    }

    public struct DeleteApnsChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSChannelResponse", required: true, type: .structure)
        ]
        public let aPNSChannelResponse: APNSChannelResponse

        public init(aPNSChannelResponse: APNSChannelResponse) {
            self.aPNSChannelResponse = aPNSChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSChannelResponse = dictionary["APNSChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSChannelResponse") }
            self.aPNSChannelResponse = try Pinpoint.APNSChannelResponse(dictionary: aPNSChannelResponse)
        }
    }

    public struct DeleteSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SegmentId", location: .uri(locationName: "segment-id"), required: true, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string)
        ]
        public let segmentId: String
        public let applicationId: String

        public init(segmentId: String, applicationId: String) {
            self.segmentId = segmentId
            self.applicationId = applicationId
        }

        public init(dictionary: [String: Any]) throws {
            guard let segmentId = dictionary["segment-id"] as? String else { throw InitializableError.missingRequiredParam("segment-id") }
            self.segmentId = segmentId
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
        }
    }

    public struct ImportJobsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Item", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// A list of import jobs for the application.
        public let item: [ImportJobResponse]?
        /// The string that you use in a subsequent request to get the next page of results in a paginated response.
        public let nextToken: String?

        public init(item: [ImportJobResponse]? = nil, nextToken: String? = nil) {
            self.item = item
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let item = dictionary["Item"] as? [[String: Any]] {
                self.item = try item.map({ try ImportJobResponse(dictionary: $0) })
            } else { 
                self.item = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct GetImportJobsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "PageSize", location: .querystring(locationName: "page-size"), required: false, type: .string), 
            AWSShapeProperty(label: "ApplicationId", location: .uri(locationName: "application-id"), required: true, type: .string), 
            AWSShapeProperty(label: "Token", location: .querystring(locationName: "token"), required: false, type: .string)
        ]
        public let pageSize: String?
        public let applicationId: String
        public let token: String?

        public init(pageSize: String? = nil, applicationId: String, token: String? = nil) {
            self.pageSize = pageSize
            self.applicationId = applicationId
            self.token = token
        }

        public init(dictionary: [String: Any]) throws {
            self.pageSize = dictionary["page-size"] as? String
            guard let applicationId = dictionary["application-id"] as? String else { throw InitializableError.missingRequiredParam("application-id") }
            self.applicationId = applicationId
            self.token = dictionary["token"] as? String
        }
    }

    public struct CampaignSmsMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "SenderId", required: false, type: .string), 
            AWSShapeProperty(label: "MessageType", required: false, type: .enum)
        ]
        /// The SMS text body.
        public let body: String?
        /// Sender ID of sent message.
        public let senderId: String?
        /// Is this is a transactional SMS message, otherwise a promotional message.
        public let messageType: MessageType?

        public init(body: String? = nil, senderId: String? = nil, messageType: MessageType? = nil) {
            self.body = body
            self.senderId = senderId
            self.messageType = messageType
        }

        public init(dictionary: [String: Any]) throws {
            self.body = dictionary["Body"] as? String
            self.senderId = dictionary["SenderId"] as? String
            if let messageType = dictionary["MessageType"] as? String { self.messageType = MessageType(rawValue: messageType) } else { self.messageType = nil }
        }
    }

    public struct DirectMessageConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "GCMMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "SMSMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "DefaultPushNotificationMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "DefaultMessage", required: false, type: .structure)
        ]
        /// The message to GCM channels. Overrides the default push notification message.
        public let gCMMessage: GCMMessage?
        /// The message to SMS channels. Overrides the default message.
        public let sMSMessage: SMSMessage?
        /// The default push notification message for all push channels.
        public let defaultPushNotificationMessage: DefaultPushNotificationMessage?
        /// The message to APNS channels. Overrides the default push notification message.
        public let aPNSMessage: APNSMessage?
        /// The default message for all channels.
        public let defaultMessage: DefaultMessage?

        public init(gCMMessage: GCMMessage? = nil, sMSMessage: SMSMessage? = nil, defaultPushNotificationMessage: DefaultPushNotificationMessage? = nil, aPNSMessage: APNSMessage? = nil, defaultMessage: DefaultMessage? = nil) {
            self.gCMMessage = gCMMessage
            self.sMSMessage = sMSMessage
            self.defaultPushNotificationMessage = defaultPushNotificationMessage
            self.aPNSMessage = aPNSMessage
            self.defaultMessage = defaultMessage
        }

        public init(dictionary: [String: Any]) throws {
            if let gCMMessage = dictionary["GCMMessage"] as? [String: Any] { self.gCMMessage = try Pinpoint.GCMMessage(dictionary: gCMMessage) } else { self.gCMMessage = nil }
            if let sMSMessage = dictionary["SMSMessage"] as? [String: Any] { self.sMSMessage = try Pinpoint.SMSMessage(dictionary: sMSMessage) } else { self.sMSMessage = nil }
            if let defaultPushNotificationMessage = dictionary["DefaultPushNotificationMessage"] as? [String: Any] { self.defaultPushNotificationMessage = try Pinpoint.DefaultPushNotificationMessage(dictionary: defaultPushNotificationMessage) } else { self.defaultPushNotificationMessage = nil }
            if let aPNSMessage = dictionary["APNSMessage"] as? [String: Any] { self.aPNSMessage = try Pinpoint.APNSMessage(dictionary: aPNSMessage) } else { self.aPNSMessage = nil }
            if let defaultMessage = dictionary["DefaultMessage"] as? [String: Any] { self.defaultMessage = try Pinpoint.DefaultMessage(dictionary: defaultMessage) } else { self.defaultMessage = nil }
        }
    }

    public struct EndpointDemographic: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Locale", required: false, type: .string), 
            AWSShapeProperty(label: "Platform", required: false, type: .string), 
            AWSShapeProperty(label: "Timezone", required: false, type: .string), 
            AWSShapeProperty(label: "PlatformVersion", required: false, type: .string), 
            AWSShapeProperty(label: "Make", required: false, type: .string), 
            AWSShapeProperty(label: "AppVersion", required: false, type: .string), 
            AWSShapeProperty(label: "Model", required: false, type: .string), 
            AWSShapeProperty(label: "ModelVersion", required: false, type: .string)
        ]
        /// The endpoint locale in the following format: The ISO 639-1 alpha-2 code, followed by an underscore, followed by an ISO 3166-1 alpha-2 value.
        public let locale: String?
        /// The endpoint platform, such as ios or android.
        public let platform: String?
        /// The timezone of the endpoint. Specified as a tz database value, such as Americas/Los_Angeles.
        public let timezone: String?
        /// The endpoint platform version.
        public let platformVersion: String?
        /// The endpoint make, such as such as Apple or Samsung.
        public let make: String?
        /// The version of the application associated with the endpoint.
        public let appVersion: String?
        /// The endpoint model, such as iPhone.
        public let model: String?
        /// The endpoint model version.
        public let modelVersion: String?

        public init(locale: String? = nil, platform: String? = nil, timezone: String? = nil, platformVersion: String? = nil, make: String? = nil, appVersion: String? = nil, model: String? = nil, modelVersion: String? = nil) {
            self.locale = locale
            self.platform = platform
            self.timezone = timezone
            self.platformVersion = platformVersion
            self.make = make
            self.appVersion = appVersion
            self.model = model
            self.modelVersion = modelVersion
        }

        public init(dictionary: [String: Any]) throws {
            self.locale = dictionary["Locale"] as? String
            self.platform = dictionary["Platform"] as? String
            self.timezone = dictionary["Timezone"] as? String
            self.platformVersion = dictionary["PlatformVersion"] as? String
            self.make = dictionary["Make"] as? String
            self.appVersion = dictionary["AppVersion"] as? String
            self.model = dictionary["Model"] as? String
            self.modelVersion = dictionary["ModelVersion"] as? String
        }
    }

    public struct MessageConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SMSMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "EmailMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "GCMMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "APNSMessage", required: false, type: .structure), 
            AWSShapeProperty(label: "DefaultMessage", required: false, type: .structure)
        ]
        /// The SMS message configuration.
        public let sMSMessage: CampaignSmsMessage?
        /// The email message configuration.
        public let emailMessage: CampaignEmailMessage?
        /// The message that the campaign delivers to GCM channels. Overrides the default message.
        public let gCMMessage: Message?
        /// The message that the campaign delivers to APNS channels. Overrides the default message.
        public let aPNSMessage: Message?
        /// The default message for all channels.
        public let defaultMessage: Message?

        public init(sMSMessage: CampaignSmsMessage? = nil, emailMessage: CampaignEmailMessage? = nil, gCMMessage: Message? = nil, aPNSMessage: Message? = nil, defaultMessage: Message? = nil) {
            self.sMSMessage = sMSMessage
            self.emailMessage = emailMessage
            self.gCMMessage = gCMMessage
            self.aPNSMessage = aPNSMessage
            self.defaultMessage = defaultMessage
        }

        public init(dictionary: [String: Any]) throws {
            if let sMSMessage = dictionary["SMSMessage"] as? [String: Any] { self.sMSMessage = try Pinpoint.CampaignSmsMessage(dictionary: sMSMessage) } else { self.sMSMessage = nil }
            if let emailMessage = dictionary["EmailMessage"] as? [String: Any] { self.emailMessage = try Pinpoint.CampaignEmailMessage(dictionary: emailMessage) } else { self.emailMessage = nil }
            if let gCMMessage = dictionary["GCMMessage"] as? [String: Any] { self.gCMMessage = try Pinpoint.Message(dictionary: gCMMessage) } else { self.gCMMessage = nil }
            if let aPNSMessage = dictionary["APNSMessage"] as? [String: Any] { self.aPNSMessage = try Pinpoint.Message(dictionary: aPNSMessage) } else { self.aPNSMessage = nil }
            if let defaultMessage = dictionary["DefaultMessage"] as? [String: Any] { self.defaultMessage = try Pinpoint.Message(dictionary: defaultMessage) } else { self.defaultMessage = nil }
        }
    }

    public enum SegmentType: String, CustomStringConvertible {
        case dimensional = "DIMENSIONAL"
        case `import` = "IMPORT"
        public var description: String { return self.rawValue }
    }

    public struct GCMMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "RestrictedPackageName", required: false, type: .string), 
            AWSShapeProperty(label: "IconReference", required: false, type: .string), 
            AWSShapeProperty(label: "CollapseKey", required: false, type: .string), 
            AWSShapeProperty(label: "Data", required: false, type: .map), 
            AWSShapeProperty(label: "Title", required: false, type: .string), 
            AWSShapeProperty(label: "ImageIconUrl", required: false, type: .string), 
            AWSShapeProperty(label: "SilentPush", required: false, type: .boolean), 
            AWSShapeProperty(label: "SmallImageIconUrl", required: false, type: .string), 
            AWSShapeProperty(label: "Action", required: false, type: .enum), 
            AWSShapeProperty(label: "Url", required: false, type: .string), 
            AWSShapeProperty(label: "RawContent", required: false, type: .string), 
            AWSShapeProperty(label: "Sound", required: false, type: .string), 
            AWSShapeProperty(label: "ImageUrl", required: false, type: .string), 
            AWSShapeProperty(label: "Body", required: false, type: .string), 
            AWSShapeProperty(label: "Substitutions", required: false, type: .map)
        ]
        /// This parameter specifies the package name of the application where the registration tokens must match in order to receive the message.
        public let restrictedPackageName: String?
        /// The icon image name of the asset saved in your application.
        public let iconReference: String?
        /// This parameter identifies a group of messages (e.g., with collapse_key: "Updates Available") that can be collapsed, so that only the last message gets sent when delivery can be resumed. This is intended to avoid sending too many of the same messages when the device comes back online or becomes active.
        public let collapseKey: String?
        public let data: [String: String]?
        /// The message title that displays above the message on the user's device.
        public let title: String?
        /// The URL that points to an image used as the large icon to the notification content view.
        public let imageIconUrl: String?
        /// Indicates if the message should display on the users device. Silent pushes can be used for Remote Configuration and Phone Home use cases.
        public let silentPush: Bool?
        /// The URL that points to an image used as the small icon for the notification which will be used to represent the notification in the status bar and content view
        public let smallImageIconUrl: String?
        /// The action that occurs if the user taps a push notification delivered by the campaign: OPEN_APP - Your app launches, or it becomes the foreground app if it has been sent to the background. This is the default action. DEEP_LINK - Uses deep linking features in iOS and Android to open your app and display a designated user interface within the app. URL - The default mobile browser on the user's device launches and opens a web page at the URL you specify. Possible values include: OPEN_APP | DEEP_LINK | URL
        public let action: Action?
        /// The URL to open in the user's mobile browser. Used if the value for Action is URL.
        public let url: String?
        /// The Raw JSON formatted string to be used as the payload. This value overrides the message.
        public let rawContent: String?
        /// Indicates a sound to play when the device receives the notification. Supports default, or the filename of a sound resource bundled in the app. Android sound files must reside in /res/raw/
        public let sound: String?
        /// The URL that points to an image used in the push notification.
        public let imageUrl: String?
        /// The message body of the notification, the email body or the text message.
        public let body: String?
        public let substitutions: [String: [String]]?

        public init(restrictedPackageName: String? = nil, iconReference: String? = nil, collapseKey: String? = nil, data: [String: String]? = nil, title: String? = nil, imageIconUrl: String? = nil, silentPush: Bool? = nil, smallImageIconUrl: String? = nil, action: Action? = nil, url: String? = nil, rawContent: String? = nil, sound: String? = nil, imageUrl: String? = nil, body: String? = nil, substitutions: [String: [String]]? = nil) {
            self.restrictedPackageName = restrictedPackageName
            self.iconReference = iconReference
            self.collapseKey = collapseKey
            self.data = data
            self.title = title
            self.imageIconUrl = imageIconUrl
            self.silentPush = silentPush
            self.smallImageIconUrl = smallImageIconUrl
            self.action = action
            self.url = url
            self.rawContent = rawContent
            self.sound = sound
            self.imageUrl = imageUrl
            self.body = body
            self.substitutions = substitutions
        }

        public init(dictionary: [String: Any]) throws {
            self.restrictedPackageName = dictionary["RestrictedPackageName"] as? String
            self.iconReference = dictionary["IconReference"] as? String
            self.collapseKey = dictionary["CollapseKey"] as? String
            if let data = dictionary["Data"] as? [String: String] {
                self.data = data
            } else { 
                self.data = nil
            }
            self.title = dictionary["Title"] as? String
            self.imageIconUrl = dictionary["ImageIconUrl"] as? String
            self.silentPush = dictionary["SilentPush"] as? Bool
            self.smallImageIconUrl = dictionary["SmallImageIconUrl"] as? String
            if let action = dictionary["Action"] as? String { self.action = Action(rawValue: action) } else { self.action = nil }
            self.url = dictionary["Url"] as? String
            self.rawContent = dictionary["RawContent"] as? String
            self.sound = dictionary["Sound"] as? String
            self.imageUrl = dictionary["ImageUrl"] as? String
            self.body = dictionary["Body"] as? String
            if let substitutions = dictionary["Substitutions"] as? [String: Any] {
                var substitutionsDict: [String: [String]] = [:]
                for (key, value) in substitutions {
                    guard let listOfString = value as? [String] else { throw InitializableError.convertingError }
                    substitutionsDict[key] = listOfString
                }
                self.substitutions = substitutionsDict
            } else { 
                self.substitutions = nil
            }
        }
    }

    public struct DeleteApnsSandboxChannelResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = "APNSSandboxChannelResponse"
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "APNSSandboxChannelResponse", required: true, type: .structure)
        ]
        public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse

        public init(aPNSSandboxChannelResponse: APNSSandboxChannelResponse) {
            self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
        }

        public init(dictionary: [String: Any]) throws {
            guard let aPNSSandboxChannelResponse = dictionary["APNSSandboxChannelResponse"] as? [String: Any] else { throw InitializableError.missingRequiredParam("APNSSandboxChannelResponse") }
            self.aPNSSandboxChannelResponse = try Pinpoint.APNSSandboxChannelResponse(dictionary: aPNSSandboxChannelResponse)
        }
    }

    public struct WriteSegmentRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Name", required: false, type: .string), 
            AWSShapeProperty(label: "Dimensions", required: false, type: .structure)
        ]
        /// The name of segment
        public let name: String?
        /// The segment dimensions attributes.
        public let dimensions: SegmentDimensions?

        public init(name: String? = nil, dimensions: SegmentDimensions? = nil) {
            self.name = name
            self.dimensions = dimensions
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["Name"] as? String
            if let dimensions = dictionary["Dimensions"] as? [String: Any] { self.dimensions = try Pinpoint.SegmentDimensions(dictionary: dimensions) } else { self.dimensions = nil }
        }
    }

}