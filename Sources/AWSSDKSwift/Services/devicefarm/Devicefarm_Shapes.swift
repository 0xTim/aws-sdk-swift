// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Devicefarm {

    public struct DeleteUploadResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListDevicesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Amazon Resource Name (ARN) of the project.
        public var arn: String? = nil

        public init() {}

        public init(nextToken: String? = nil, arn: String? = nil) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct NetworkProfile: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var uplinkJitterMs: Int64? = nil
        /// The name of the network profile.
        public var name: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var downlinkJitterMs: Int64? = nil
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var downlinkDelayMs: Int64? = nil
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public var uplinkLossPercent: Int32? = nil
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public var downlinkLossPercent: Int32? = nil
        /// The description of the network profile.
        public var description: String? = nil
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var uplinkDelayMs: Int64? = nil
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var uplinkBandwidthBits: Int64? = nil
        /// The type of network profile. Valid values are listed below.
        public var type: String? = nil
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var downlinkBandwidthBits: Int64? = nil
        /// The Amazon Resource Name (ARN) of the network profile.
        public var arn: String? = nil

        public init() {}

        public init(uplinkJitterMs: Int64? = nil, name: String? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: String? = nil, downlinkBandwidthBits: Int64? = nil, arn: String? = nil) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.type = type
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.uplinkJitterMs = dictionary["uplinkJitterMs"] as? Int64
            self.name = dictionary["name"] as? String
            self.downlinkJitterMs = dictionary["downlinkJitterMs"] as? Int64
            self.downlinkDelayMs = dictionary["downlinkDelayMs"] as? Int64
            self.uplinkLossPercent = dictionary["uplinkLossPercent"] as? Int32
            self.downlinkLossPercent = dictionary["downlinkLossPercent"] as? Int32
            self.description = dictionary["description"] as? String
            self.uplinkDelayMs = dictionary["uplinkDelayMs"] as? Int64
            self.uplinkBandwidthBits = dictionary["uplinkBandwidthBits"] as? Int64
            self.type = dictionary["type"] as? String
            self.downlinkBandwidthBits = dictionary["downlinkBandwidthBits"] as? Int64
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct GetTestResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A test condition that is evaluated.
        public var test: Test? = nil

        public init() {}

        public init(test: Test? = nil) {
            self.test = test
        }

        public init(dictionary: [String: Any]) throws {
            if let test = dictionary["test"] as? [String: Any] { self.test = try Devicefarm.Test(dictionary: test) }
        }
    }

    public struct Rule: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The rule's stringified attribute. For example, specify the value as "\"abc\"". Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).  
        public var attribute: String? = nil
        /// The rule's operator.   EQUALS: The equals operator.   GREATER_THAN: The greater-than operator.   IN: The in operator.   LESS_THAN: The less-than operator.   NOT_IN: The not-in operator.  
        public var `operator`: String? = nil
        /// The rule's value.
        public var value: String? = nil

        public init() {}

        public init(attribute: String? = nil, operator: String? = nil, value: String? = nil) {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }

        public init(dictionary: [String: Any]) throws {
            self.attribute = dictionary["attribute"] as? String
            self.`operator` = dictionary["operator"] as? String
            self.value = dictionary["value"] as? String
        }
    }

    public struct ListTestsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The tests' ARNs.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateRemoteAccessSessionConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Returns the billing method for purposes of configuring a remote access session.
        public var billingMethod: String? = nil

        public init() {}

        public init(billingMethod: String? = nil) {
            self.billingMethod = billingMethod
        }

        public init(dictionary: [String: Any]) throws {
            self.billingMethod = dictionary["billingMethod"] as? String
        }
    }

    public struct GetUploadResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An app or a set of one or more tests to upload or that have been uploaded.
        public var upload: Upload? = nil

        public init() {}

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        public init(dictionary: [String: Any]) throws {
            if let upload = dictionary["upload"] as? [String: Any] { self.upload = try Devicefarm.Upload(dictionary: upload) }
        }
    }

    public struct ListSuitesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the suites.
        public var suites: [Suite]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(suites: [Suite]? = nil, nextToken: String? = nil) {
            self.suites = suites
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let suites = dictionary["suites"] as? [[String: Any]] {
                self.suites = try suites.map({ try Suite(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListRemoteAccessSessionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// A container representing the metadata from the service about each remote access session you are requesting.
        public var remoteAccessSessions: [RemoteAccessSession]? = nil

        public init() {}

        public init(nextToken: String? = nil, remoteAccessSessions: [RemoteAccessSession]? = nil) {
            self.nextToken = nextToken
            self.remoteAccessSessions = remoteAccessSessions
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let remoteAccessSessions = dictionary["remoteAccessSessions"] as? [[String: Any]] {
                self.remoteAccessSessions = try remoteAccessSessions.map({ try RemoteAccessSession(dictionary: $0) })
            }
        }
    }

    public struct UpdateNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var uplinkJitterMs: Int64? = nil
        /// The name of the network profile about which you are returning information.
        public var name: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var downlinkJitterMs: Int64? = nil
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var downlinkDelayMs: Int64? = nil
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public var uplinkLossPercent: Int32? = nil
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public var downlinkLossPercent: Int32? = nil
        /// The descriptoin of the network profile about which you are returning information.
        public var description: String? = nil
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var uplinkDelayMs: Int64? = nil
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var uplinkBandwidthBits: Int64? = nil
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public var type: String? = nil
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var downlinkBandwidthBits: Int64? = nil
        /// The Amazon Resource Name (ARN) of the project that you wish to update network profile settings.
        public var arn: String = ""

        public init() {}

        public init(uplinkJitterMs: Int64? = nil, name: String? = nil, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: String? = nil, downlinkBandwidthBits: Int64? = nil, arn: String) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.type = type
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.uplinkJitterMs = dictionary["uplinkJitterMs"] as? Int64
            self.name = dictionary["name"] as? String
            self.downlinkJitterMs = dictionary["downlinkJitterMs"] as? Int64
            self.downlinkDelayMs = dictionary["downlinkDelayMs"] as? Int64
            self.uplinkLossPercent = dictionary["uplinkLossPercent"] as? Int32
            self.downlinkLossPercent = dictionary["downlinkLossPercent"] as? Int32
            self.description = dictionary["description"] as? String
            self.uplinkDelayMs = dictionary["uplinkDelayMs"] as? Int64
            self.uplinkBandwidthBits = dictionary["uplinkBandwidthBits"] as? Int64
            self.type = dictionary["type"] as? String
            self.downlinkBandwidthBits = dictionary["downlinkBandwidthBits"] as? Int64
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An object containing information about the requested device pool.
        public var devicePool: DevicePool? = nil

        public init() {}

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePool = dictionary["devicePool"] as? [String: Any] { self.devicePool = try Devicefarm.DevicePool(dictionary: devicePool) }
        }
    }

    public struct DevicePool: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool's description.
        public var description: String? = nil
        /// The device pool's name.
        public var name: String? = nil
        /// The device pool's type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public var type: String? = nil
        /// Information about the device pool's rules.
        public var rules: [Rule]? = nil
        /// The device pool's ARN.
        public var arn: String? = nil

        public init() {}

        public init(description: String? = nil, name: String? = nil, type: String? = nil, rules: [Rule]? = nil, arn: String? = nil) {
            self.description = description
            self.name = name
            self.type = type
            self.rules = rules
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            self.name = dictionary["name"] as? String
            self.type = dictionary["type"] as? String
            if let rules = dictionary["rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try Rule(dictionary: $0) })
            }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct CreateProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly created project.
        public var project: Project? = nil

        public init() {}

        public init(project: Project? = nil) {
            self.project = project
        }

        public init(dictionary: [String: Any]) throws {
            if let project = dictionary["project"] as? [String: Any] { self.project = try Devicefarm.Project(dictionary: project) }
        }
    }

    public struct PurchaseOfferingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the offering transaction for the purchase result.
        public var offeringTransaction: OfferingTransaction? = nil

        public init() {}

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        public init(dictionary: [String: Any]) throws {
            if let offeringTransaction = dictionary["offeringTransaction"] as? [String: Any] { self.offeringTransaction = try Devicefarm.OfferingTransaction(dictionary: offeringTransaction) }
        }
    }

    public struct ExecutionConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of minutes a test run will execute before it times out.
        public var jobTimeoutMinutes: Int32? = nil

        public init() {}

        public init(jobTimeoutMinutes: Int32? = nil) {
            self.jobTimeoutMinutes = jobTimeoutMinutes
        }

        public init(dictionary: [String: Any]) throws {
            self.jobTimeoutMinutes = dictionary["jobTimeoutMinutes"] as? Int32
        }
    }

    public struct MonetaryAmount: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The currency code of a monetary amount. For example, USD means "U.S. dollars."
        public var currencyCode: String? = nil
        /// The numerical amount of an offering or transaction.
        public var amount: Double? = nil

        public init() {}

        public init(currencyCode: String? = nil, amount: Double? = nil) {
            self.currencyCode = currencyCode
            self.amount = amount
        }

        public init(dictionary: [String: Any]) throws {
            self.currencyCode = dictionary["currencyCode"] as? String
            self.amount = dictionary["amount"] as? Double
        }
    }

    public struct CreateNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var uplinkJitterMs: Int64? = nil
        /// The name you wish to specify for the new network profile.
        public var name: String = ""
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var downlinkJitterMs: Int64? = nil
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var downlinkDelayMs: Int64? = nil
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public var uplinkLossPercent: Int32? = nil
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public var downlinkLossPercent: Int32? = nil
        /// The description of the network profile.
        public var description: String? = nil
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var uplinkDelayMs: Int64? = nil
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var uplinkBandwidthBits: Int64? = nil
        /// The type of network profile you wish to create. Valid values are listed below.
        public var type: String? = nil
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var downlinkBandwidthBits: Int64? = nil
        /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
        public var projectArn: String = ""

        public init() {}

        public init(uplinkJitterMs: Int64? = nil, name: String, downlinkJitterMs: Int64? = nil, downlinkDelayMs: Int64? = nil, uplinkLossPercent: Int32? = nil, downlinkLossPercent: Int32? = nil, description: String? = nil, uplinkDelayMs: Int64? = nil, uplinkBandwidthBits: Int64? = nil, type: String? = nil, downlinkBandwidthBits: Int64? = nil, projectArn: String) {
            self.uplinkJitterMs = uplinkJitterMs
            self.name = name
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkDelayMs = downlinkDelayMs
            self.uplinkLossPercent = uplinkLossPercent
            self.downlinkLossPercent = downlinkLossPercent
            self.description = description
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.type = type
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.projectArn = projectArn
        }

        public init(dictionary: [String: Any]) throws {
            self.uplinkJitterMs = dictionary["uplinkJitterMs"] as? Int64
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.downlinkJitterMs = dictionary["downlinkJitterMs"] as? Int64
            self.downlinkDelayMs = dictionary["downlinkDelayMs"] as? Int64
            self.uplinkLossPercent = dictionary["uplinkLossPercent"] as? Int32
            self.downlinkLossPercent = dictionary["downlinkLossPercent"] as? Int32
            self.description = dictionary["description"] as? String
            self.uplinkDelayMs = dictionary["uplinkDelayMs"] as? Int64
            self.uplinkBandwidthBits = dictionary["uplinkBandwidthBits"] as? Int64
            self.type = dictionary["type"] as? String
            self.downlinkBandwidthBits = dictionary["downlinkBandwidthBits"] as? Int64
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
        }
    }

    public struct GetDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct RemoteAccessSession: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see AWS Device Farm terminology."
        public var billingMethod: String? = nil
        /// The status of the remote access session. Can be any of the following:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public var status: String? = nil
        /// The name of the remote access session.
        public var name: String? = nil
        /// The endpoint for the remote access sesssion.
        public var endpoint: String? = nil
        /// The date and time the remote access session was created.
        public var created: Date? = nil
        /// The date and time the remote access session was started.
        public var started: Date? = nil
        /// The date and time the remote access session was stopped.
        public var stopped: Date? = nil
        /// The number of minutes a device is used in a remote access sesssion (including setup and teardown minutes).
        public var deviceMinutes: DeviceMinutes? = nil
        /// A message about the remote access session.
        public var message: String? = nil
        /// The device (phone or tablet) used in the remote access session.
        public var device: Device? = nil
        /// The result of the remote access session. Can be any of the following:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var result: String? = nil
        /// The Amazon Resource Name (ARN) of the remote access session.
        public var arn: String? = nil

        public init() {}

        public init(billingMethod: String? = nil, status: String? = nil, name: String? = nil, endpoint: String? = nil, created: Date? = nil, started: Date? = nil, stopped: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, device: Device? = nil, result: String? = nil, arn: String? = nil) {
            self.billingMethod = billingMethod
            self.status = status
            self.name = name
            self.endpoint = endpoint
            self.created = created
            self.started = started
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.device = device
            self.result = result
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.billingMethod = dictionary["billingMethod"] as? String
            self.status = dictionary["status"] as? String
            self.name = dictionary["name"] as? String
            self.endpoint = dictionary["endpoint"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            self.stopped = dictionary["stopped"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) }
            self.message = dictionary["message"] as? String
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) }
            self.result = dictionary["result"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct RecurringCharge: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The frequency in which charges will recur.
        public var frequency: String? = nil
        /// The cost of the recurring charge.
        public var cost: MonetaryAmount? = nil

        public init() {}

        public init(frequency: String? = nil, cost: MonetaryAmount? = nil) {
            self.frequency = frequency
            self.cost = cost
        }

        public init(dictionary: [String: Any]) throws {
            self.frequency = dictionary["frequency"] as? String
            if let cost = dictionary["cost"] as? [String: Any] { self.cost = try Devicefarm.MonetaryAmount(dictionary: cost) }
        }
    }

    public struct Suite: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The suite's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public var status: String? = nil
        /// The suite's name.
        public var name: String? = nil
        /// When the suite was created.
        public var created: Date? = nil
        /// The suite's start time.
        public var started: Date? = nil
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public var deviceMinutes: DeviceMinutes? = nil
        /// The suite's stop time.
        public var stopped: Date? = nil
        /// A message about the suite's result.
        public var message: String? = nil
        /// The suite's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public var type: String? = nil
        /// The suite's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var result: String? = nil
        /// The suite's result counters.
        public var counters: Counters? = nil
        /// The suite's ARN.
        public var arn: String? = nil

        public init() {}

        public init(status: String? = nil, name: String? = nil, created: Date? = nil, started: Date? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: Date? = nil, message: String? = nil, type: String? = nil, result: String? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.message = message
            self.type = type
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["status"] as? String
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) }
            self.stopped = dictionary["stopped"] as? Date
            self.message = dictionary["message"] as? String
            self.type = dictionary["type"] as? String
            self.result = dictionary["result"] as? String
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DeleteUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm upload you wish to delete.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListUniqueProblemsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The unique problems' ARNs.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetAccountSettingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ProblemDetail: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The problem detail's name.
        public var name: String? = nil
        /// The problem detail's ARN.
        public var arn: String? = nil

        public init() {}

        public init(name: String? = nil, arn: String? = nil) {
            self.name = name
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct ScheduleRunConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm will extract to external data for Android or the app's sandbox for iOS.
        public var extraDataPackageArn: String? = nil
        /// Information about the location that is used for the run.
        public var location: Location? = nil
        /// Reserved for internal use.
        public var networkProfileArn: String? = nil
        /// A list of auxiliary apps for the run.
        public var auxiliaryApps: [String]? = nil
        /// Information about the radio states for the run.
        public var radios: Radios? = nil
        /// Information about the locale that is used for the run.
        public var locale: String? = nil
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public var billingMethod: String? = nil

        public init() {}

        public init(extraDataPackageArn: String? = nil, location: Location? = nil, networkProfileArn: String? = nil, auxiliaryApps: [String]? = nil, radios: Radios? = nil, locale: String? = nil, billingMethod: String? = nil) {
            self.extraDataPackageArn = extraDataPackageArn
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.auxiliaryApps = auxiliaryApps
            self.radios = radios
            self.locale = locale
            self.billingMethod = billingMethod
        }

        public init(dictionary: [String: Any]) throws {
            self.extraDataPackageArn = dictionary["extraDataPackageArn"] as? String
            if let location = dictionary["location"] as? [String: Any] { self.location = try Devicefarm.Location(dictionary: location) }
            self.networkProfileArn = dictionary["networkProfileArn"] as? String
            if let auxiliaryApps = dictionary["auxiliaryApps"] as? [String] {
                self.auxiliaryApps = auxiliaryApps
            }
            if let radios = dictionary["radios"] as? [String: Any] { self.radios = try Devicefarm.Radios(dictionary: radios) }
            self.locale = dictionary["locale"] as? String
            self.billingMethod = dictionary["billingMethod"] as? String
        }
    }

    public struct GetJobResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An object containing information about the requested job.
        public var job: Job? = nil

        public init() {}

        public init(job: Job? = nil) {
            self.job = job
        }

        public init(dictionary: [String: Any]) throws {
            if let job = dictionary["job"] as? [String: Any] { self.job = try Devicefarm.Job(dictionary: job) }
        }
    }

    public struct ListOfferingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// A value representing the list offering results.
        public var offerings: [Offering]? = nil

        public init() {}

        public init(nextToken: String? = nil, offerings: [Offering]? = nil) {
            self.nextToken = nextToken
            self.offerings = offerings
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let offerings = dictionary["offerings"] as? [[String: Any]] {
                self.offerings = try offerings.map({ try Offering(dictionary: $0) })
            }
        }
    }

    public struct StopRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run that was stopped.
        public var run: Run? = nil

        public init() {}

        public init(run: Run? = nil) {
            self.run = run
        }

        public init(dictionary: [String: Any]) throws {
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.Run(dictionary: run) }
        }
    }

    public struct ScheduleRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the project for the run to be scheduled.
        public var projectArn: String = ""
        /// The name for the run to be scheduled.
        public var name: String? = nil
        /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
        public var executionConfiguration: ExecutionConfiguration? = nil
        /// Information about the test for the run to be scheduled.
        public var test: ScheduleRunTest = ScheduleRunTest()
        /// The ARN of the app to schedule a run.
        public var appArn: String? = nil
        /// The ARN of the device pool for the run to be scheduled.
        public var devicePoolArn: String = ""
        /// Information about the settings for the run to be scheduled.
        public var configuration: ScheduleRunConfiguration? = nil

        public init() {}

        public init(projectArn: String, name: String? = nil, executionConfiguration: ExecutionConfiguration? = nil, test: ScheduleRunTest, appArn: String? = nil, devicePoolArn: String, configuration: ScheduleRunConfiguration? = nil) {
            self.projectArn = projectArn
            self.name = name
            self.executionConfiguration = executionConfiguration
            self.test = test
            self.appArn = appArn
            self.devicePoolArn = devicePoolArn
            self.configuration = configuration
        }

        public init(dictionary: [String: Any]) throws {
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
            self.name = dictionary["name"] as? String
            if let executionConfiguration = dictionary["executionConfiguration"] as? [String: Any] { self.executionConfiguration = try Devicefarm.ExecutionConfiguration(dictionary: executionConfiguration) }
            guard let test = dictionary["test"] as? [String: Any] else { throw InitializableError.missingRequiredParam("test") }
            self.test = try Devicefarm.ScheduleRunTest(dictionary: test)
            self.appArn = dictionary["appArn"] as? String
            guard let devicePoolArn = dictionary["devicePoolArn"] as? String else { throw InitializableError.missingRequiredParam("devicePoolArn") }
            self.devicePoolArn = devicePoolArn
            if let configuration = dictionary["configuration"] as? [String: Any] { self.configuration = try Devicefarm.ScheduleRunConfiguration(dictionary: configuration) }
        }
    }

    public struct Artifact: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The artifact's name.
        public var name: String? = nil
        /// The artifact's type. Allowed values include the following:   UNKNOWN: An unknown type.   SCREENSHOT: The screenshot type.   DEVICE_LOG: The device log type.   MESSAGE_LOG: The message log type.   RESULT_LOG: The result log type.   SERVICE_LOG: The service log type.   WEBKIT_LOG: The web kit log type.   INSTRUMENTATION_OUTPUT: The instrumentation type.   EXERCISER_MONKEY_OUTPUT: For Android, the artifact (log) generated by an Android fuzz test.   CALABASH_JSON_OUTPUT: The Calabash JSON output type.   CALABASH_PRETTY_OUTPUT: The Calabash pretty output type.   CALABASH_STANDARD_OUTPUT: The Calabash standard output type.   CALABASH_JAVA_XML_OUTPUT: The Calabash Java XML output type.   AUTOMATION_OUTPUT: The automation output type.   APPIUM_SERVER_OUTPUT: The Appium server output type.   APPIUM_JAVA_OUTPUT: The Appium Java output type.   APPIUM_JAVA_XML_OUTPUT: The Appium Java XML output type.   APPIUM_PYTHON_OUTPUT: The Appium Python output type.   APPIUM_PYTHON_XML_OUTPUT: The Appium Python XML output type.   EXPLORER_EVENT_LOG: The Explorer event log output type.   EXPLORER_SUMMARY_LOG: The Explorer summary log output type.   APPLICATION_CRASH_REPORT: The application crash report output type.   XCTEST_LOG: The XCode test output type.  
        public var type: String? = nil
        /// The artifact's file extension.
        public var `extension`: String? = nil
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the artifact's file.
        public var url: String? = nil
        /// The artifact's ARN.
        public var arn: String? = nil

        public init() {}

        public init(name: String? = nil, type: String? = nil, extension: String? = nil, url: String? = nil, arn: String? = nil) {
            self.name = name
            self.type = type
            self.`extension` = `extension`
            self.url = url
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.type = dictionary["type"] as? String
            self.`extension` = dictionary["extension"] as? String
            self.url = dictionary["url"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct CreateNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The network profile that is returned by the create network profile request.
        public var networkProfile: NetworkProfile? = nil

        public init() {}

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) }
        }
    }

    public struct DeleteNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the network profile you want to delete.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Project: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project's name.
        public var name: String? = nil
        /// When the project was created.
        public var created: Date? = nil
        /// The default number of minutes (at the project level) a test run will execute before it times out. Default value is 60 minutes.
        public var defaultJobTimeoutMinutes: Int32? = nil
        /// The project's ARN.
        public var arn: String? = nil

        public init() {}

        public init(name: String? = nil, created: Date? = nil, defaultJobTimeoutMinutes: Int32? = nil, arn: String? = nil) {
            self.name = name
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct ScheduleRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the scheduled run.
        public var run: Run? = nil

        public init() {}

        public init(run: Run? = nil) {
            self.run = run
        }

        public init(dictionary: [String: Any]) throws {
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.Run(dictionary: run) }
        }
    }

    public struct GetRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListNetworkProfilesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of the available network profiles.
        public var networkProfiles: [NetworkProfile]? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(networkProfiles: [NetworkProfile]? = nil, nextToken: String? = nil) {
            self.networkProfiles = networkProfiles
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfiles = dictionary["networkProfiles"] as? [[String: Any]] {
                self.networkProfiles = try networkProfiles.map({ try NetworkProfile(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListSamplesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Amazon Resource Name (ARN) of the project for which you want to list samples.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project's name.
        public var name: String = ""
        /// Sets the execution timeout value (in minutes) for a project. All test runs in this project will use the specified execution timeout value unless overridden when scheduling a run.
        public var defaultJobTimeoutMinutes: Int32? = nil

        public init() {}

        public init(name: String, defaultJobTimeoutMinutes: Int32? = nil) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
        }
    }

    public struct GetRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A container that lists detailed information about the remote access session.
        public var remoteAccessSession: RemoteAccessSession? = nil

        public init() {}

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        public init(dictionary: [String: Any]) throws {
            if let remoteAccessSession = dictionary["remoteAccessSession"] as? [String: Any] { self.remoteAccessSession = try Devicefarm.RemoteAccessSession(dictionary: remoteAccessSession) }
        }
    }

    public struct UpdateDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool you just updated.
        public var devicePool: DevicePool? = nil

        public init() {}

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePool = dictionary["devicePool"] as? [String: Any] { self.devicePool = try Devicefarm.DevicePool(dictionary: devicePool) }
        }
    }

    public struct PurchaseOfferingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of the offering.
        public var offeringId: String? = nil
        /// The number of device slots you wish to purchase in an offering request.
        public var quantity: Int32? = nil

        public init() {}

        public init(offeringId: String? = nil, quantity: Int32? = nil) {
            self.offeringId = offeringId
            self.quantity = quantity
        }

        public init(dictionary: [String: Any]) throws {
            self.offeringId = dictionary["offeringId"] as? String
            self.quantity = dictionary["quantity"] as? Int32
        }
    }

    public struct StopRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the remote access session you wish to stop.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateUploadResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly created upload.
        public var upload: Upload? = nil

        public init() {}

        public init(upload: Upload? = nil) {
            self.upload = upload
        }

        public init(dictionary: [String: Any]) throws {
            if let upload = dictionary["upload"] as? [String: Any] { self.upload = try Devicefarm.Upload(dictionary: upload) }
        }
    }

    public struct UniqueProblem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the problems.
        public var problems: [Problem]? = nil
        /// A message about the unique problems' result.
        public var message: String? = nil

        public init() {}

        public init(problems: [Problem]? = nil, message: String? = nil) {
            self.problems = problems
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            if let problems = dictionary["problems"] as? [[String: Any]] {
                self.problems = try problems.map({ try Problem(dictionary: $0) })
            }
            self.message = dictionary["message"] as? String
        }
    }

    public struct UpdateNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of the available network profiles.
        public var networkProfile: NetworkProfile? = nil

        public init() {}

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) }
        }
    }

    public struct ListNetworkProfilesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of network profile you wish to return information about. Valid values are listed below.
        public var type: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
        public var arn: String = ""

        public init() {}

        public init(type: String? = nil, nextToken: String? = nil, arn: String) {
            self.type = type
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["type"] as? String
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetJobRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The job's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListRunsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil
        /// Information about the runs.
        public var runs: [Run]? = nil

        public init() {}

        public init(nextToken: String? = nil, runs: [Run]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let runs = dictionary["runs"] as? [[String: Any]] {
                self.runs = try runs.map({ try Run(dictionary: $0) })
            }
        }
    }

    public struct ListTestsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the tests.
        public var tests: [Test]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(tests: [Test]? = nil, nextToken: String? = nil) {
            self.tests = tests
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let tests = dictionary["tests"] as? [[String: Any]] {
                self.tests = try tests.map({ try Test(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DeleteNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct OfferingTransaction: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The transaction ID of the offering transaction.
        public var transactionId: String? = nil
        /// The cost of an offering transaction.
        public var cost: MonetaryAmount? = nil
        /// The date on which an offering transaction was created.
        public var createdOn: Date? = nil
        /// The status of an offering transaction.
        public var offeringStatus: OfferingStatus? = nil

        public init() {}

        public init(transactionId: String? = nil, cost: MonetaryAmount? = nil, createdOn: Date? = nil, offeringStatus: OfferingStatus? = nil) {
            self.transactionId = transactionId
            self.cost = cost
            self.createdOn = createdOn
            self.offeringStatus = offeringStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.transactionId = dictionary["transactionId"] as? String
            if let cost = dictionary["cost"] as? [String: Any] { self.cost = try Devicefarm.MonetaryAmount(dictionary: cost) }
            self.createdOn = dictionary["createdOn"] as? Date
            if let offeringStatus = dictionary["offeringStatus"] as? [String: Any] { self.offeringStatus = try Devicefarm.OfferingStatus(dictionary: offeringStatus) }
        }
    }

    public struct ListDevicesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the devices.
        public var devices: [Device]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let devices = dictionary["devices"] as? [[String: Any]] {
                self.devices = try devices.map({ try Device(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListUploadsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the uploads.
        public var uploads: [Upload]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(uploads: [Upload]? = nil, nextToken: String? = nil) {
            self.uploads = uploads
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let uploads = dictionary["uploads"] as? [[String: Any]] {
                self.uploads = try uploads.map({ try Upload(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct Offering: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A string describing the offering.
        public var description: String? = nil
        /// Specifies whether there are recurring charges for the offering.
        public var recurringCharges: [RecurringCharge]? = nil
        /// The ID that corresponds to a device offering.
        public var id: String? = nil
        /// The type of offering (e.g., "RECURRING") for a device.
        public var type: String? = nil
        /// The platform of the device (e.g., ANDROID or IOS).
        public var platform: String? = nil

        public init() {}

        public init(description: String? = nil, recurringCharges: [RecurringCharge]? = nil, id: String? = nil, type: String? = nil, platform: String? = nil) {
            self.description = description
            self.recurringCharges = recurringCharges
            self.id = id
            self.type = type
            self.platform = platform
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            if let recurringCharges = dictionary["recurringCharges"] as? [[String: Any]] {
                self.recurringCharges = try recurringCharges.map({ try RecurringCharge(dictionary: $0) })
            }
            self.id = dictionary["id"] as? String
            self.type = dictionary["type"] as? String
            self.platform = dictionary["platform"] as? String
        }
    }

    public struct GetSuiteResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A collection of one or more tests.
        public var suite: Suite? = nil

        public init() {}

        public init(suite: Suite? = nil) {
            self.suite = suite
        }

        public init(dictionary: [String: Any]) throws {
            if let suite = dictionary["suite"] as? [String: Any] { self.suite = try Devicefarm.Suite(dictionary: suite) }
        }
    }

    public struct GetSuiteRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The suite's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upload's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Test: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The test's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public var status: String? = nil
        /// The test's name.
        public var name: String? = nil
        /// When the test was created.
        public var created: Date? = nil
        /// The test's start time.
        public var started: Date? = nil
        /// Represents the total (metered or unmetered) minutes used by the test.
        public var deviceMinutes: DeviceMinutes? = nil
        /// The test's stop time.
        public var stopped: Date? = nil
        /// A message about the test's result.
        public var message: String? = nil
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public var type: String? = nil
        /// The test's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var result: String? = nil
        /// The test's result counters.
        public var counters: Counters? = nil
        /// The test's ARN.
        public var arn: String? = nil

        public init() {}

        public init(status: String? = nil, name: String? = nil, created: Date? = nil, started: Date? = nil, deviceMinutes: DeviceMinutes? = nil, stopped: Date? = nil, message: String? = nil, type: String? = nil, result: String? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.deviceMinutes = deviceMinutes
            self.stopped = stopped
            self.message = message
            self.type = type
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["status"] as? String
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) }
            self.stopped = dictionary["stopped"] as? Date
            self.message = dictionary["message"] as? String
            self.type = dictionary["type"] as? String
            self.result = dictionary["result"] as? String
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DeleteRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the sesssion for which you want to delete remote access.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetOfferingStatusResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// When specified, gets the offering status for the next period.
        public var nextPeriod: [String: OfferingStatus]? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// When specified, gets the offering status for the current period.
        public var current: [String: OfferingStatus]? = nil

        public init() {}

        public init(nextPeriod: [String: OfferingStatus]? = nil, nextToken: String? = nil, current: [String: OfferingStatus]? = nil) {
            self.nextPeriod = nextPeriod
            self.nextToken = nextToken
            self.current = current
        }

        public init(dictionary: [String: Any]) throws {
            if let nextPeriod = dictionary["nextPeriod"] as? [String: Any] {
                var nextPeriodDict: [String: OfferingStatus] = [:]
                for (key, value) in nextPeriod {
                    guard let offeringStatusDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    nextPeriodDict[key] = try OfferingStatus(dictionary: offeringStatusDict)
                }
                self.nextPeriod = nextPeriodDict
            }
            self.nextToken = dictionary["nextToken"] as? String
            if let current = dictionary["current"] as? [String: Any] {
                var currentDict: [String: OfferingStatus] = [:]
                for (key, value) in current {
                    guard let offeringStatusDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    currentDict[key] = try OfferingStatus(dictionary: offeringStatusDict)
                }
                self.current = currentDict
            }
        }
    }

    public struct GetOfferingStatusRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct IncompatibilityMessage: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The type of incompatibility. Allowed values include:   ARN: The ARN.   FORM_FACTOR: The form factor (for example, phone or tablet).   MANUFACTURER: The manufacturer.   PLATFORM: The platform (for example, Android or iOS).  
        public var type: String? = nil
        /// A message about the incompatibility.
        public var message: String? = nil

        public init() {}

        public init(type: String? = nil, message: String? = nil) {
            self.type = type
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["type"] as? String
            self.message = dictionary["message"] as? String
        }
    }

    public struct CreateUploadRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upload's file name. The name should not contain the '/' character. If uploading an iOS app, the file name needs to end with the .ipa extension. If uploading an Android app, the file name needs to end with the .apk extension. For all others, the file name must end with the .zip file extension.
        public var name: String = ""
        /// The upload's content type (for example, "application/octet-stream").
        public var contentType: String? = nil
        /// The upload's upload type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.    Note If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
        public var type: String = ""
        /// The ARN of the project for the upload.
        public var projectArn: String = ""

        public init() {}

        public init(name: String, contentType: String? = nil, type: String, projectArn: String) {
            self.name = name
            self.contentType = contentType
            self.type = type
            self.projectArn = projectArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.contentType = dictionary["contentType"] as? String
            guard let type = dictionary["type"] as? String else { throw InitializableError.missingRequiredParam("type") }
            self.type = type
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
        }
    }

    public struct UpdateProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project you wish to update.
        public var project: Project? = nil

        public init() {}

        public init(project: Project? = nil) {
            self.project = project
        }

        public init(dictionary: [String: Any]) throws {
            if let project = dictionary["project"] as? [String: Any] { self.project = try Devicefarm.Project(dictionary: project) }
        }
    }

    public struct ScheduleRunTest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The test's filter.
        public var filter: String? = nil
        /// The test's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public var type: String = ""
        /// The ARN of the uploaded test that will be run.
        public var testPackageArn: String? = nil
        /// The test's parameters, such as test framework parameters and fixture settings.
        public var parameters: [String: String]? = nil

        public init() {}

        public init(filter: String? = nil, type: String, testPackageArn: String? = nil, parameters: [String: String]? = nil) {
            self.filter = filter
            self.type = type
            self.testPackageArn = testPackageArn
            self.parameters = parameters
        }

        public init(dictionary: [String: Any]) throws {
            self.filter = dictionary["filter"] as? String
            guard let type = dictionary["type"] as? String else { throw InitializableError.missingRequiredParam("type") }
            self.type = type
            self.testPackageArn = dictionary["testPackageArn"] as? String
            if let parameters = dictionary["parameters"] as? [String: String] {
                self.parameters = parameters
            }
        }
    }

    public struct DeleteDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListUploadsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A container that describes the remote access session when the request to create a remote access session is sent.
        public var remoteAccessSession: RemoteAccessSession? = nil

        public init() {}

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        public init(dictionary: [String: Any]) throws {
            if let remoteAccessSession = dictionary["remoteAccessSession"] as? [String: Any] { self.remoteAccessSession = try Devicefarm.RemoteAccessSession(dictionary: remoteAccessSession) }
        }
    }

    public struct GetDeviceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device type's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Radios: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// True if Wi-Fi is enabled at the beginning of the test; otherwise, false.
        public var wifi: Bool? = nil
        /// True if Bluetooth is enabled at the beginning of the test; otherwise, false.
        public var bluetooth: Bool? = nil
        /// True if NFC is enabled at the beginning of the test; otherwise, false.
        public var nfc: Bool? = nil
        /// True if GPS is enabled at the beginning of the test; otherwise, false.
        public var gps: Bool? = nil

        public init() {}

        public init(wifi: Bool? = nil, bluetooth: Bool? = nil, nfc: Bool? = nil, gps: Bool? = nil) {
            self.wifi = wifi
            self.bluetooth = bluetooth
            self.nfc = nfc
            self.gps = gps
        }

        public init(dictionary: [String: Any]) throws {
            self.wifi = dictionary["wifi"] as? Bool
            self.bluetooth = dictionary["bluetooth"] as? Bool
            self.nfc = dictionary["nfc"] as? Bool
            self.gps = dictionary["gps"] as? Bool
        }
    }

    public struct GetRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run you wish to get results from.
        public var run: Run? = nil

        public init() {}

        public init(run: Run? = nil) {
            self.run = run
        }

        public init(dictionary: [String: Any]) throws {
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.Run(dictionary: run) }
        }
    }

    public struct RenewOfferingResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the status of the offering transaction for the renewal.
        public var offeringTransaction: OfferingTransaction? = nil

        public init() {}

        public init(offeringTransaction: OfferingTransaction? = nil) {
            self.offeringTransaction = offeringTransaction
        }

        public init(dictionary: [String: Any]) throws {
            if let offeringTransaction = dictionary["offeringTransaction"] as? [String: Any] { self.offeringTransaction = try Devicefarm.OfferingTransaction(dictionary: offeringTransaction) }
        }
    }

    public struct DeleteDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool you wish to delete.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The name of the remote access session that you wish to create.
        public var name: String? = nil
        /// The Amazon Resource Name (ARN) of the device for which you want to create a remote access session.
        public var deviceArn: String = ""
        /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
        public var projectArn: String = ""
        /// The configuration information for the remote access session request.
        public var configuration: CreateRemoteAccessSessionConfiguration? = nil

        public init() {}

        public init(name: String? = nil, deviceArn: String, projectArn: String, configuration: CreateRemoteAccessSessionConfiguration? = nil) {
            self.name = name
            self.deviceArn = deviceArn
            self.projectArn = projectArn
            self.configuration = configuration
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            guard let deviceArn = dictionary["deviceArn"] as? String else { throw InitializableError.missingRequiredParam("deviceArn") }
            self.deviceArn = deviceArn
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
            if let configuration = dictionary["configuration"] as? [String: Any] { self.configuration = try Devicefarm.CreateRemoteAccessSessionConfiguration(dictionary: configuration) }
        }
    }

    public struct ListJobsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil
        /// Information about the jobs.
        public var jobs: [Job]? = nil

        public init() {}

        public init(nextToken: String? = nil, jobs: [Job]? = nil) {
            self.nextToken = nextToken
            self.jobs = jobs
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let jobs = dictionary["jobs"] as? [[String: Any]] {
                self.jobs = try jobs.map({ try Job(dictionary: $0) })
            }
        }
    }

    public struct ListSamplesResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the samples.
        public var samples: [Sample]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(samples: [Sample]? = nil, nextToken: String? = nil) {
            self.samples = samples
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let samples = dictionary["samples"] as? [[String: Any]] {
                self.samples = try samples.map({ try Sample(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct CreateDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pool's description.
        public var description: String? = nil
        /// The device pool's name.
        public var name: String = ""
        /// The device pool's rules.
        public var rules: [Rule] = []
        /// The ARN of the project for the device pool.
        public var projectArn: String = ""

        public init() {}

        public init(description: String? = nil, name: String, rules: [Rule], projectArn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.projectArn = projectArn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let rules = dictionary["rules"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("rules") }
            self.rules = try rules.map({ try Rule(dictionary: $0) })
            guard let projectArn = dictionary["projectArn"] as? String else { throw InitializableError.missingRequiredParam("projectArn") }
            self.projectArn = projectArn
        }
    }

    public struct ListProjectsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil
        /// Information about the projects.
        public var projects: [Project]? = nil

        public init() {}

        public init(nextToken: String? = nil, projects: [Project]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let projects = dictionary["projects"] as? [[String: Any]] {
                self.projects = try projects.map({ try Project(dictionary: $0) })
            }
        }
    }

    public struct OfferingStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of available devices in the offering.
        public var quantity: Int32? = nil
        /// The type specified for the offering status.
        public var type: String? = nil
        /// The date on which the offering is effective.
        public var effectiveOn: Date? = nil
        /// Represents the metadata of an offering status.
        public var offering: Offering? = nil

        public init() {}

        public init(quantity: Int32? = nil, type: String? = nil, effectiveOn: Date? = nil, offering: Offering? = nil) {
            self.quantity = quantity
            self.type = type
            self.effectiveOn = effectiveOn
            self.offering = offering
        }

        public init(dictionary: [String: Any]) throws {
            self.quantity = dictionary["quantity"] as? Int32
            self.type = dictionary["type"] as? String
            self.effectiveOn = dictionary["effectiveOn"] as? Date
            if let offering = dictionary["offering"] as? [String: Any] { self.offering = try Devicefarm.Offering(dictionary: offering) }
        }
    }

    public struct ListDevicePoolsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device pools' type. Allowed values include:   CURATED: A device pool that is created and managed by AWS Device Farm.   PRIVATE: A device pool that is created and managed by the device pool developer.  
        public var type: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The project ARN.
        public var arn: String = ""

        public init() {}

        public init(type: String? = nil, nextToken: String? = nil, arn: String) {
            self.type = type
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["type"] as? String
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListJobsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The jobs' ARNs.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Run: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The run's name.
        public var name: String? = nil
        /// The run's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public var platform: String? = nil
        /// The run's type. Must be one of the following values:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public var type: String? = nil
        /// The run's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var result: String? = nil
        /// The run's ARN.
        public var arn: String? = nil
        /// The run's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public var status: String? = nil
        /// The total number of completed jobs.
        public var completedJobs: Int32? = nil
        /// When the run was created.
        public var created: Date? = nil
        /// The run's start time.
        public var started: Date? = nil
        /// The total number of jobs for the run.
        public var totalJobs: Int32? = nil
        /// The run's stop time.
        public var stopped: Date? = nil
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public var deviceMinutes: DeviceMinutes? = nil
        /// A message about the run's result.
        public var message: String? = nil
        /// The network profile being used for a test run.
        public var networkProfile: NetworkProfile? = nil
        /// The run's result counters.
        public var counters: Counters? = nil
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered.
        public var billingMethod: String? = nil

        public init() {}

        public init(name: String? = nil, platform: String? = nil, type: String? = nil, result: String? = nil, arn: String? = nil, status: String? = nil, completedJobs: Int32? = nil, created: Date? = nil, started: Date? = nil, totalJobs: Int32? = nil, stopped: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, networkProfile: NetworkProfile? = nil, counters: Counters? = nil, billingMethod: String? = nil) {
            self.name = name
            self.platform = platform
            self.type = type
            self.result = result
            self.arn = arn
            self.status = status
            self.completedJobs = completedJobs
            self.created = created
            self.started = started
            self.totalJobs = totalJobs
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.networkProfile = networkProfile
            self.counters = counters
            self.billingMethod = billingMethod
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.platform = dictionary["platform"] as? String
            self.type = dictionary["type"] as? String
            self.result = dictionary["result"] as? String
            self.arn = dictionary["arn"] as? String
            self.status = dictionary["status"] as? String
            self.completedJobs = dictionary["completedJobs"] as? Int32
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            self.totalJobs = dictionary["totalJobs"] as? Int32
            self.stopped = dictionary["stopped"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) }
            self.message = dictionary["message"] as? String
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) }
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) }
            self.billingMethod = dictionary["billingMethod"] as? String
        }
    }

    public struct DevicePoolCompatibilityResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device (phone or tablet) that you wish to return information about.
        public var device: Device? = nil
        /// Whether the result was compatible with the device pool.
        public var compatible: Bool? = nil
        /// Information about the compatibility.
        public var incompatibilityMessages: [IncompatibilityMessage]? = nil

        public init() {}

        public init(device: Device? = nil, compatible: Bool? = nil, incompatibilityMessages: [IncompatibilityMessage]? = nil) {
            self.device = device
            self.compatible = compatible
            self.incompatibilityMessages = incompatibilityMessages
        }

        public init(dictionary: [String: Any]) throws {
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) }
            self.compatible = dictionary["compatible"] as? Bool
            if let incompatibilityMessages = dictionary["incompatibilityMessages"] as? [[String: Any]] {
                self.incompatibilityMessages = try incompatibilityMessages.map({ try IncompatibilityMessage(dictionary: $0) })
            }
        }
    }

    public struct Upload: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public var metadata: String? = nil
        /// The upload's status. Must be one of the following values:   FAILED: A failed status.   INITIALIZED: An initialized status.   PROCESSING: A processing status.   SUCCEEDED: A succeeded status.  
        public var status: String? = nil
        /// The upload's content type (for example, "application/octet-stream").
        public var contentType: String? = nil
        /// The upload's file name.
        public var name: String? = nil
        /// When the upload was created.
        public var created: Date? = nil
        /// A message about the upload's result.
        public var message: String? = nil
        /// The upload's type. Must be one of the following values:   ANDROID_APP: An Android upload.   IOS_APP: An iOS upload.   WEB_APP: A web appliction upload.   EXTERNAL_DATA: An external data upload.   APPIUM_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE: An Appium Java JUnit test package upload.   APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE: An Appium Java TestNG test package upload.   APPIUM_WEB_PYTHON_TEST_PACKAGE: An Appium Python test package upload.   CALABASH_TEST_PACKAGE: A Calabash test package upload.   INSTRUMENTATION_TEST_PACKAGE: An instrumentation upload.   UIAUTOMATION_TEST_PACKAGE: A uiautomation test package upload.   UIAUTOMATOR_TEST_PACKAGE: A uiautomator test package upload.   XCTEST_TEST_PACKAGE: An XCode test package upload.   XCTEST_UI_TEST_PACKAGE: An XCode UI test package upload.  
        public var type: String? = nil
        /// The pre-signed Amazon S3 URL that was used to store a file through a corresponding PUT request.
        public var url: String? = nil
        /// The upload's ARN.
        public var arn: String? = nil

        public init() {}

        public init(metadata: String? = nil, status: String? = nil, contentType: String? = nil, name: String? = nil, created: Date? = nil, message: String? = nil, type: String? = nil, url: String? = nil, arn: String? = nil) {
            self.metadata = metadata
            self.status = status
            self.contentType = contentType
            self.name = name
            self.created = created
            self.message = message
            self.type = type
            self.url = url
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.metadata = dictionary["metadata"] as? String
            self.status = dictionary["status"] as? String
            self.contentType = dictionary["contentType"] as? String
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.message = dictionary["message"] as? String
            self.type = dictionary["type"] as? String
            self.url = dictionary["url"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct ListOfferingsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DeleteRunResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeleteProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListDevicePoolsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the device pools.
        public var devicePools: [DevicePool]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(devicePools: [DevicePool]? = nil, nextToken: String? = nil) {
            self.devicePools = devicePools
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePools = dictionary["devicePools"] as? [[String: Any]] {
                self.devicePools = try devicePools.map({ try DevicePool(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListOfferingTransactionsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
        public var offeringTransactions: [OfferingTransaction]? = nil

        public init() {}

        public init(nextToken: String? = nil, offeringTransactions: [OfferingTransaction]? = nil) {
            self.nextToken = nextToken
            self.offeringTransactions = offeringTransactions
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let offeringTransactions = dictionary["offeringTransactions"] as? [[String: Any]] {
                self.offeringTransactions = try offeringTransactions.map({ try OfferingTransaction(dictionary: $0) })
            }
        }
    }

    public struct ListSuitesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The suites' ARNs.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CPU: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The CPU's frequency.
        public var frequency: String? = nil
        /// The CPU's architecture, for example x86 or ARM.
        public var architecture: String? = nil
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public var clock: Double? = nil

        public init() {}

        public init(frequency: String? = nil, architecture: String? = nil, clock: Double? = nil) {
            self.frequency = frequency
            self.architecture = architecture
            self.clock = clock
        }

        public init(dictionary: [String: Any]) throws {
            self.frequency = dictionary["frequency"] as? String
            self.architecture = dictionary["architecture"] as? String
            self.clock = dictionary["clock"] as? Double
        }
    }

    public struct InstallToRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An app to upload or that has been uploaded.
        public var appUpload: Upload? = nil

        public init() {}

        public init(appUpload: Upload? = nil) {
            self.appUpload = appUpload
        }

        public init(dictionary: [String: Any]) throws {
            if let appUpload = dictionary["appUpload"] as? [String: Any] { self.appUpload = try Devicefarm.Upload(dictionary: appUpload) }
        }
    }

    public struct GetNetworkProfileRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the network profile you want to return information about.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Counters: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of warned entities.
        public var warned: Int32? = nil
        /// The number of errored entities.
        public var errored: Int32? = nil
        /// The number of failed entities.
        public var failed: Int32? = nil
        /// The number of skipped entities.
        public var skipped: Int32? = nil
        /// The number of passed entities.
        public var passed: Int32? = nil
        /// The number of stopped entities.
        public var stopped: Int32? = nil
        /// The total number of entities.
        public var total: Int32? = nil

        public init() {}

        public init(warned: Int32? = nil, errored: Int32? = nil, failed: Int32? = nil, skipped: Int32? = nil, passed: Int32? = nil, stopped: Int32? = nil, total: Int32? = nil) {
            self.warned = warned
            self.errored = errored
            self.failed = failed
            self.skipped = skipped
            self.passed = passed
            self.stopped = stopped
            self.total = total
        }

        public init(dictionary: [String: Any]) throws {
            self.warned = dictionary["warned"] as? Int32
            self.errored = dictionary["errored"] as? Int32
            self.failed = dictionary["failed"] as? Int32
            self.skipped = dictionary["skipped"] as? Int32
            self.passed = dictionary["passed"] as? Int32
            self.stopped = dictionary["stopped"] as? Int32
            self.total = dictionary["total"] as? Int32
        }
    }

    public struct DeleteRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DeviceMinutes: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// When specified, represents the total minutes used by the resource to run tests.
        public var total: Double? = nil
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public var metered: Double? = nil
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public var unmetered: Double? = nil

        public init() {}

        public init(total: Double? = nil, metered: Double? = nil, unmetered: Double? = nil) {
            self.total = total
            self.metered = metered
            self.unmetered = unmetered
        }

        public init(dictionary: [String: Any]) throws {
            self.total = dictionary["total"] as? Double
            self.metered = dictionary["metered"] as? Double
            self.unmetered = dictionary["unmetered"] as? Double
        }
    }

    public struct ListRemoteAccessSessionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListArtifactsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The artifacts' type. Allowed values include:   FILE: The artifacts are files.   LOG: The artifacts are logs.   SCREENSHOT: The artifacts are screenshots.  
        public var type: String = ""
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Run, Job, Suite, or Test ARN.
        public var arn: String = ""

        public init() {}

        public init(type: String, nextToken: String? = nil, arn: String) {
            self.type = type
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let type = dictionary["type"] as? String else { throw InitializableError.missingRequiredParam("type") }
            self.type = type
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetTestRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The test's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetDeviceResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An object containing information about the requested device.
        public var device: Device? = nil

        public init() {}

        public init(device: Device? = nil) {
            self.device = device
        }

        public init(dictionary: [String: Any]) throws {
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) }
        }
    }

    public struct DeleteProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm project you wish to delete.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct StopRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Represents the Amazon Resource Name (ARN) of the Device Farm run you wish to stop.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListUniqueProblemsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the unique problems. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var uniqueProblems: [String: [UniqueProblem]]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(uniqueProblems: [String: [UniqueProblem]]? = nil, nextToken: String? = nil) {
            self.uniqueProblems = uniqueProblems
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let uniqueProblems = dictionary["uniqueProblems"] as? [String: Any] {
                var uniqueProblemsDict: [String: [UniqueProblem]] = [:]
                for (key, value) in uniqueProblems {
                    guard let uniqueProblem = value as? [[String: Any]] else { throw InitializableError.convertingError }
                    let uniqueProblemList: [UniqueProblem] = try uniqueProblem.map { try UniqueProblem(dictionary: $0) }
                    uniqueProblemsDict[key] = uniqueProblemList
                }
                self.uniqueProblems = uniqueProblemsDict
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct Problem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the associated test.
        public var test: ProblemDetail? = nil
        /// Information about the associated suite.
        public var suite: ProblemDetail? = nil
        /// Information about the associated job.
        public var job: ProblemDetail? = nil
        /// A message about the problem's result.
        public var message: String? = nil
        /// Information about the associated device.
        public var device: Device? = nil
        /// Information about the associated run.
        public var run: ProblemDetail? = nil
        /// The problem's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var result: String? = nil

        public init() {}

        public init(test: ProblemDetail? = nil, suite: ProblemDetail? = nil, job: ProblemDetail? = nil, message: String? = nil, device: Device? = nil, run: ProblemDetail? = nil, result: String? = nil) {
            self.test = test
            self.suite = suite
            self.job = job
            self.message = message
            self.device = device
            self.run = run
            self.result = result
        }

        public init(dictionary: [String: Any]) throws {
            if let test = dictionary["test"] as? [String: Any] { self.test = try Devicefarm.ProblemDetail(dictionary: test) }
            if let suite = dictionary["suite"] as? [String: Any] { self.suite = try Devicefarm.ProblemDetail(dictionary: suite) }
            if let job = dictionary["job"] as? [String: Any] { self.job = try Devicefarm.ProblemDetail(dictionary: job) }
            self.message = dictionary["message"] as? String
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) }
            if let run = dictionary["run"] as? [String: Any] { self.run = try Devicefarm.ProblemDetail(dictionary: run) }
            self.result = dictionary["result"] as? String
        }
    }

    public struct Sample: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The sample's type. Must be one of the following values:   CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.   MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.   NATIVE_AVG_DRAWTIME   NATIVE_FPS   NATIVE_FRAMES   NATIVE_MAX_DRAWTIME   NATIVE_MIN_DRAWTIME   OPENGL_AVG_DRAWTIME   OPENGL_FPS   OPENGL_FRAMES   OPENGL_MAX_DRAWTIME   OPENGL_MIN_DRAWTIME   RX   RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.   THREADS: A threads sample type. This is expressed as the total number of threads per app process.   TX   TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.  
        public var type: String? = nil
        /// The pre-signed Amazon S3 URL that can be used with a corresponding GET request to download the sample's file.
        public var url: String? = nil
        /// The sample's ARN.
        public var arn: String? = nil

        public init() {}

        public init(type: String? = nil, url: String? = nil, arn: String? = nil) {
            self.type = type
            self.url = url
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["type"] as? String
            self.url = dictionary["url"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DeleteRunRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) for the run you wish to delete.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct CreateDevicePoolResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The newly created device pool.
        public var devicePool: DevicePool? = nil

        public init() {}

        public init(devicePool: DevicePool? = nil) {
            self.devicePool = devicePool
        }

        public init(dictionary: [String: Any]) throws {
            if let devicePool = dictionary["devicePool"] as? [String: Any] { self.devicePool = try Devicefarm.DevicePool(dictionary: devicePool) }
        }
    }

    public struct UpdateDevicePoolRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A description of the device pool you wish to update.
        public var description: String? = nil
        /// A string representing the name of the device pool you wish to update.
        public var name: String? = nil
        /// Represents the rules you wish to modify for the device pool. Updating rules is optional; however, if you choose to update rules for your request, the update will replace the existing rules.
        public var rules: [Rule]? = nil
        /// The Amazon Resourc Name (ARN) of the Device Farm device pool you wish to update.
        public var arn: String = ""

        public init() {}

        public init(description: String? = nil, name: String? = nil, rules: [Rule]? = nil, arn: String) {
            self.description = description
            self.name = name
            self.rules = rules
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["description"] as? String
            self.name = dictionary["name"] as? String
            if let rules = dictionary["rules"] as? [[String: Any]] {
                self.rules = try rules.map({ try Rule(dictionary: $0) })
            }
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListOfferingTransactionsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct AccountSettings: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS account number specified in the AccountSettings container.
        public var awsAccountNumber: String? = nil
        /// Returns the unmetered devices you have purchased or want to purchase.
        public var unmeteredDevices: [String: Int32]? = nil
        /// The default number of minutes (at the account level) a test run will execute before it times out. Default value is 60 minutes.
        public var defaultJobTimeoutMinutes: Int32? = nil
        /// The maximum number of minutes a test run will execute before it times out.
        public var maxJobTimeoutMinutes: Int32? = nil
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public var unmeteredRemoteAccessDevices: [String: Int32]? = nil

        public init() {}

        public init(awsAccountNumber: String? = nil, unmeteredDevices: [String: Int32]? = nil, defaultJobTimeoutMinutes: Int32? = nil, maxJobTimeoutMinutes: Int32? = nil, unmeteredRemoteAccessDevices: [String: Int32]? = nil) {
            self.awsAccountNumber = awsAccountNumber
            self.unmeteredDevices = unmeteredDevices
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
        }

        public init(dictionary: [String: Any]) throws {
            self.awsAccountNumber = dictionary["awsAccountNumber"] as? String
            if let unmeteredDevices = dictionary["unmeteredDevices"] as? [String: Int32] {
                self.unmeteredDevices = unmeteredDevices
            }
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
            self.maxJobTimeoutMinutes = dictionary["maxJobTimeoutMinutes"] as? Int32
            if let unmeteredRemoteAccessDevices = dictionary["unmeteredRemoteAccessDevices"] as? [String: Int32] {
                self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
            }
        }
    }

    public struct StopRemoteAccessSessionResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A container representing the metadata from the service about the remote access session you are stopping.
        public var remoteAccessSession: RemoteAccessSession? = nil

        public init() {}

        public init(remoteAccessSession: RemoteAccessSession? = nil) {
            self.remoteAccessSession = remoteAccessSession
        }

        public init(dictionary: [String: Any]) throws {
            if let remoteAccessSession = dictionary["remoteAccessSession"] as? [String: Any] { self.remoteAccessSession = try Devicefarm.RemoteAccessSession(dictionary: remoteAccessSession) }
        }
    }

    public struct ListArtifactsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about the artifacts.
        public var artifacts: [Artifact]? = nil
        /// If the number of items that are returned is significantly large, this is an identifier that is also returned, which can be used in a subsequent call to this operation to return the next set of items in the list.
        public var nextToken: String? = nil

        public init() {}

        public init(artifacts: [Artifact]? = nil, nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let artifacts = dictionary["artifacts"] as? [[String: Any]] {
                self.artifacts = try artifacts.map({ try Artifact(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct GetNetworkProfileResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The network profile.
        public var networkProfile: NetworkProfile? = nil

        public init() {}

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        public init(dictionary: [String: Any]) throws {
            if let networkProfile = dictionary["networkProfile"] as? [String: Any] { self.networkProfile = try Devicefarm.NetworkProfile(dictionary: networkProfile) }
        }
    }

    public struct Location: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The longitude.
        public var longitude: Double = 0
        /// The latitude.
        public var latitude: Double = 0

        public init() {}

        public init(longitude: Double, latitude: Double) {
            self.longitude = longitude
            self.latitude = latitude
        }

        public init(dictionary: [String: Any]) throws {
            guard let longitude = dictionary["longitude"] as? Double else { throw InitializableError.missingRequiredParam("longitude") }
            self.longitude = longitude
            guard let latitude = dictionary["latitude"] as? Double else { throw InitializableError.missingRequiredParam("latitude") }
            self.latitude = latitude
        }
    }

    public struct GetAccountSettingsResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The account settings.
        public var accountSettings: AccountSettings? = nil

        public init() {}

        public init(accountSettings: AccountSettings? = nil) {
            self.accountSettings = accountSettings
        }

        public init(dictionary: [String: Any]) throws {
            if let accountSettings = dictionary["accountSettings"] as? [String: Any] { self.accountSettings = try Devicefarm.AccountSettings(dictionary: accountSettings) }
        }
    }

    public struct GetDevicePoolCompatibilityRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ARN of the app that is associated with the specified device pool.
        public var appArn: String? = nil
        /// The device pool's ARN.
        public var devicePoolArn: String = ""
        /// The test type for the specified device pool. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public var testType: String? = nil

        public init() {}

        public init(appArn: String? = nil, devicePoolArn: String, testType: String? = nil) {
            self.appArn = appArn
            self.devicePoolArn = devicePoolArn
            self.testType = testType
        }

        public init(dictionary: [String: Any]) throws {
            self.appArn = dictionary["appArn"] as? String
            guard let devicePoolArn = dictionary["devicePoolArn"] as? String else { throw InitializableError.missingRequiredParam("devicePoolArn") }
            self.devicePoolArn = devicePoolArn
            self.testType = dictionary["testType"] as? String
        }
    }

    public struct Resolution: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The screen resolution's height, expressed in pixels.
        public var height: Int32? = nil
        /// The screen resolution's width, expressed in pixels.
        public var width: Int32? = nil

        public init() {}

        public init(height: Int32? = nil, width: Int32? = nil) {
            self.height = height
            self.width = width
        }

        public init(dictionary: [String: Any]) throws {
            self.height = dictionary["height"] as? Int32
            self.width = dictionary["width"] as? Int32
        }
    }

    public struct RenewOfferingRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ID of a request to renew an offering.
        public var offeringId: String? = nil
        /// The quantity requested in an offering renewal.
        public var quantity: Int32? = nil

        public init() {}

        public init(offeringId: String? = nil, quantity: Int32? = nil) {
            self.offeringId = offeringId
            self.quantity = quantity
        }

        public init(dictionary: [String: Any]) throws {
            self.offeringId = dictionary["offeringId"] as? String
            self.quantity = dictionary["quantity"] as? Int32
        }
    }

    public struct Device: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device's display name.
        public var name: String? = nil
        /// Information about the device's CPU.
        public var cpu: CPU? = nil
        /// The device's platform. Allowed values include:   ANDROID: The Android platform.   IOS: The iOS platform.  
        public var platform: String? = nil
        /// The device's heap size, expressed in bytes.
        public var heapSize: Int64? = nil
        /// The device's model name.
        public var model: String? = nil
        /// The device's radio.
        public var radio: String? = nil
        /// The device's ARN.
        public var arn: String? = nil
        /// The device's total memory size, expressed in bytes.
        public var memory: Int64? = nil
        /// The resolution of the device.
        public var resolution: Resolution? = nil
        /// The device's operating system type.
        public var os: String? = nil
        /// The device's image name.
        public var image: String? = nil
        /// Specifies whether remote access has been enabled for the specified device.
        public var remoteAccessEnabled: Bool? = nil
        /// The device's form factor. Allowed values include:   PHONE: The phone form factor.   TABLET: The tablet form factor.  
        public var formFactor: String? = nil
        /// The type of fleet to which this device belongs. Possible values for fleet type are PRIVATE and PUBLIC.
        public var fleetType: String? = nil
        /// The name of the fleet to which this device belongs.
        public var fleetName: String? = nil
        /// The device's manufacturer name.
        public var manufacturer: String? = nil
        /// The device's carrier.
        public var carrier: String? = nil

        public init() {}

        public init(name: String? = nil, cpu: CPU? = nil, platform: String? = nil, heapSize: Int64? = nil, model: String? = nil, radio: String? = nil, arn: String? = nil, memory: Int64? = nil, resolution: Resolution? = nil, os: String? = nil, image: String? = nil, remoteAccessEnabled: Bool? = nil, formFactor: String? = nil, fleetType: String? = nil, fleetName: String? = nil, manufacturer: String? = nil, carrier: String? = nil) {
            self.name = name
            self.cpu = cpu
            self.platform = platform
            self.heapSize = heapSize
            self.model = model
            self.radio = radio
            self.arn = arn
            self.memory = memory
            self.resolution = resolution
            self.os = os
            self.image = image
            self.remoteAccessEnabled = remoteAccessEnabled
            self.formFactor = formFactor
            self.fleetType = fleetType
            self.fleetName = fleetName
            self.manufacturer = manufacturer
            self.carrier = carrier
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            if let cpu = dictionary["cpu"] as? [String: Any] { self.cpu = try Devicefarm.CPU(dictionary: cpu) }
            self.platform = dictionary["platform"] as? String
            self.heapSize = dictionary["heapSize"] as? Int64
            self.model = dictionary["model"] as? String
            self.radio = dictionary["radio"] as? String
            self.arn = dictionary["arn"] as? String
            self.memory = dictionary["memory"] as? Int64
            if let resolution = dictionary["resolution"] as? [String: Any] { self.resolution = try Devicefarm.Resolution(dictionary: resolution) }
            self.os = dictionary["os"] as? String
            self.image = dictionary["image"] as? String
            self.remoteAccessEnabled = dictionary["remoteAccessEnabled"] as? Bool
            self.formFactor = dictionary["formFactor"] as? String
            self.fleetType = dictionary["fleetType"] as? String
            self.fleetName = dictionary["fleetName"] as? String
            self.manufacturer = dictionary["manufacturer"] as? String
            self.carrier = dictionary["carrier"] as? String
        }
    }

    public struct ListRunsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
        public var arn: String = ""

        public init() {}

        public init(nextToken: String? = nil, arn: String) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct Job: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The device (phone or tablet).
        public var device: Device? = nil
        /// The job's status. Allowed values include:   PENDING: A pending status.   PENDING_CONCURRENCY: A pending concurrency status.   PENDING_DEVICE: A pending device status.   PROCESSING: A processing status.   SCHEDULING: A scheduling status.   PREPARING: A preparing status.   RUNNING: A running status.   COMPLETED: A completed status.   STOPPING: A stopping status.  
        public var status: String? = nil
        /// The job's name.
        public var name: String? = nil
        /// When the job was created.
        public var created: Date? = nil
        /// The job's start time.
        public var started: Date? = nil
        /// The job's stop time.
        public var stopped: Date? = nil
        /// Represents the total (metered or unmetered) minutes used by the job.
        public var deviceMinutes: DeviceMinutes? = nil
        /// A message about the job's result.
        public var message: String? = nil
        /// The job's type. Allowed values include the following:   BUILTIN_FUZZ: The built-in fuzz type.   BUILTIN_EXPLORER: For Android, an app explorer that will traverse an Android app, interacting with it and capturing screenshots at the same time.   APPIUM_JAVA_JUNIT: The Appium Java JUnit type.   APPIUM_JAVA_TESTNG: The Appium Java TestNG type.   APPIUM_PYTHON: The Appium Python type.   APPIUM_WEB_JAVA_JUNIT: The Appium Java JUnit type for Web apps.   APPIUM_WEB_JAVA_TESTNG: The Appium Java TestNG type for Web apps.   APPIUM_WEB_PYTHON: The Appium Python type for Web apps.   CALABASH: The Calabash type.   INSTRUMENTATION: The Instrumentation type.   UIAUTOMATION: The uiautomation type.   UIAUTOMATOR: The uiautomator type.   XCTEST: The XCode test type.   XCTEST_UI: The XCode UI test type.  
        public var type: String? = nil
        /// The job's result. Allowed values include:   PENDING: A pending condition.   PASSED: A passing condition.   WARNED: A warning condition.   FAILED: A failed condition.   SKIPPED: A skipped condition.   ERRORED: An error condition.   STOPPED: A stopped condition.  
        public var result: String? = nil
        /// The job's result counters.
        public var counters: Counters? = nil
        /// The job's ARN.
        public var arn: String? = nil

        public init() {}

        public init(device: Device? = nil, status: String? = nil, name: String? = nil, created: Date? = nil, started: Date? = nil, stopped: Date? = nil, deviceMinutes: DeviceMinutes? = nil, message: String? = nil, type: String? = nil, result: String? = nil, counters: Counters? = nil, arn: String? = nil) {
            self.device = device
            self.status = status
            self.name = name
            self.created = created
            self.started = started
            self.stopped = stopped
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.type = type
            self.result = result
            self.counters = counters
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            if let device = dictionary["device"] as? [String: Any] { self.device = try Devicefarm.Device(dictionary: device) }
            self.status = dictionary["status"] as? String
            self.name = dictionary["name"] as? String
            self.created = dictionary["created"] as? Date
            self.started = dictionary["started"] as? Date
            self.stopped = dictionary["stopped"] as? Date
            if let deviceMinutes = dictionary["deviceMinutes"] as? [String: Any] { self.deviceMinutes = try Devicefarm.DeviceMinutes(dictionary: deviceMinutes) }
            self.message = dictionary["message"] as? String
            self.type = dictionary["type"] as? String
            self.result = dictionary["result"] as? String
            if let counters = dictionary["counters"] as? [String: Any] { self.counters = try Devicefarm.Counters(dictionary: counters) }
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct GetProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project's ARN.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct ListProjectsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public var nextToken: String? = nil
        /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
        public var arn: String? = nil

        public init() {}

        public init(nextToken: String? = nil, arn: String? = nil) {
            self.nextToken = nextToken
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct UpdateProjectRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A string representing the new name of the project that you are updating.
        public var name: String? = nil
        /// The number of minutes a test run in the project will execute before it times out.
        public var defaultJobTimeoutMinutes: Int32? = nil
        /// The Amazon Resource Name (ARN) of the project whose name you wish to update.
        public var arn: String = ""

        public init() {}

        public init(name: String? = nil, defaultJobTimeoutMinutes: Int32? = nil, arn: String) {
            self.name = name
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.defaultJobTimeoutMinutes = dictionary["defaultJobTimeoutMinutes"] as? Int32
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct InstallToRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the app about which you are requesting information.
        public var appArn: String = ""
        /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
        public var remoteAccessSessionArn: String = ""

        public init() {}

        public init(appArn: String, remoteAccessSessionArn: String) {
            self.appArn = appArn
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let appArn = dictionary["appArn"] as? String else { throw InitializableError.missingRequiredParam("appArn") }
            self.appArn = appArn
            guard let remoteAccessSessionArn = dictionary["remoteAccessSessionArn"] as? String else { throw InitializableError.missingRequiredParam("remoteAccessSessionArn") }
            self.remoteAccessSessionArn = remoteAccessSessionArn
        }
    }

    public struct GetDevicePoolCompatibilityResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Information about incompatible devices.
        public var incompatibleDevices: [DevicePoolCompatibilityResult]? = nil
        /// Information about compatible devices.
        public var compatibleDevices: [DevicePoolCompatibilityResult]? = nil

        public init() {}

        public init(incompatibleDevices: [DevicePoolCompatibilityResult]? = nil, compatibleDevices: [DevicePoolCompatibilityResult]? = nil) {
            self.incompatibleDevices = incompatibleDevices
            self.compatibleDevices = compatibleDevices
        }

        public init(dictionary: [String: Any]) throws {
            if let incompatibleDevices = dictionary["incompatibleDevices"] as? [[String: Any]] {
                self.incompatibleDevices = try incompatibleDevices.map({ try DevicePoolCompatibilityResult(dictionary: $0) })
            }
            if let compatibleDevices = dictionary["compatibleDevices"] as? [[String: Any]] {
                self.compatibleDevices = try compatibleDevices.map({ try DevicePoolCompatibilityResult(dictionary: $0) })
            }
        }
    }

    public struct GetRemoteAccessSessionRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
        public var arn: String = ""

        public init() {}

        public init(arn: String) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            guard let arn = dictionary["arn"] as? String else { throw InitializableError.missingRequiredParam("arn") }
            self.arn = arn
        }
    }

    public struct GetProjectResult: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The project you wish to get information about.
        public var project: Project? = nil

        public init() {}

        public init(project: Project? = nil) {
            self.project = project
        }

        public init(dictionary: [String: Any]) throws {
            if let project = dictionary["project"] as? [String: Any] { self.project = try Devicefarm.Project(dictionary: project) }
        }
    }

}