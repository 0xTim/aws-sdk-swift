// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension KinesisVideoArchivedMedia {

    public enum FragmentSelectorType: String, CustomStringConvertible, Codable {
        case producerTimestamp = "PRODUCER_TIMESTAMP"
        case serverTimestamp = "SERVER_TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public struct GetMediaForFragmentListInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fragments", required: true, type: .list), 
            AWSShapeMember(label: "StreamName", required: true, type: .string)
        ]
        /// A list of the numbers of fragments for which to retrieve media. You retrieve these values with ListFragments.
        public let fragments: [String]
        /// The name of the stream from which to retrieve fragment media.
        public let streamName: String

        public init(fragments: [String], streamName: String) {
            self.fragments = fragments
            self.streamName = streamName
        }

        private enum CodingKeys: String, CodingKey {
            case fragments = "Fragments"
            case streamName = "StreamName"
        }
    }

    public struct TimestampRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTimestamp", required: true, type: .timestamp), 
            AWSShapeMember(label: "EndTimestamp", required: true, type: .timestamp)
        ]
        /// The starting time stamp in the range of time stamps for which to return fragments.
        public let startTimestamp: TimeStamp
        /// The ending time stamp in the range of time stamps for which to return fragments.
        public let endTimestamp: TimeStamp

        public init(startTimestamp: TimeStamp, endTimestamp: TimeStamp) {
            self.startTimestamp = startTimestamp
            self.endTimestamp = endTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case startTimestamp = "StartTimestamp"
            case endTimestamp = "EndTimestamp"
        }
    }

    public struct ListFragmentsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamName", required: true, type: .string), 
            AWSShapeMember(label: "FragmentSelector", required: false, type: .structure), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .long)
        ]
        /// The name of the stream from which to retrieve a fragment list.
        public let streamName: String
        /// Describes the time stamp range and time stamp origin for the range of fragments to return.
        public let fragmentSelector: FragmentSelector?
        /// A token to specify where to start paginating. This is the ListFragmentsOutput$NextToken from a previously truncated response.
        public let nextToken: String?
        /// The total number of fragments to return. If the total number of fragments available is more than the value specified in max-results, then a ListFragmentsOutput$NextToken is provided in the output that you can use to resume pagination.
        public let maxResults: Int64?

        public init(streamName: String, fragmentSelector: FragmentSelector? = nil, nextToken: String? = nil, maxResults: Int64? = nil) {
            self.streamName = streamName
            self.fragmentSelector = fragmentSelector
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case streamName = "StreamName"
            case fragmentSelector = "FragmentSelector"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct FragmentSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FragmentSelectorType", required: true, type: .enum), 
            AWSShapeMember(label: "TimestampRange", required: true, type: .structure)
        ]
        /// The origin of the time stamps to use (Server or Producer).
        public let fragmentSelectorType: FragmentSelectorType
        /// The range of time stamps to return.
        public let timestampRange: TimestampRange

        public init(fragmentSelectorType: FragmentSelectorType, timestampRange: TimestampRange) {
            self.fragmentSelectorType = fragmentSelectorType
            self.timestampRange = timestampRange
        }

        private enum CodingKeys: String, CodingKey {
            case fragmentSelectorType = "FragmentSelectorType"
            case timestampRange = "TimestampRange"
        }
    }

    public struct ListFragmentsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Fragments", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// A list of fragment numbers that correspond to the time stamp range provided.
        public let fragments: [Fragment]?
        /// If the returned list is truncated, the operation returns this token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(fragments: [Fragment]? = nil, nextToken: String? = nil) {
            self.fragments = fragments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fragments = "Fragments"
            case nextToken = "NextToken"
        }
    }

    public struct Fragment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProducerTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "FragmentSizeInBytes", required: false, type: .long), 
            AWSShapeMember(label: "ServerTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "FragmentLengthInMilliseconds", required: false, type: .long), 
            AWSShapeMember(label: "FragmentNumber", required: false, type: .string)
        ]
        /// The time stamp from the producer corresponding to the fragment.
        public let producerTimestamp: TimeStamp?
        /// The total fragment size, including information about the fragment and contained media data.
        public let fragmentSizeInBytes: Int64?
        /// The time stamp from the AWS server corresponding to the fragment.
        public let serverTimestamp: TimeStamp?
        /// The playback duration or other time value associated with the fragment.
        public let fragmentLengthInMilliseconds: Int64?
        /// The index value of the fragment.
        public let fragmentNumber: String?

        public init(producerTimestamp: TimeStamp? = nil, fragmentSizeInBytes: Int64? = nil, serverTimestamp: TimeStamp? = nil, fragmentLengthInMilliseconds: Int64? = nil, fragmentNumber: String? = nil) {
            self.producerTimestamp = producerTimestamp
            self.fragmentSizeInBytes = fragmentSizeInBytes
            self.serverTimestamp = serverTimestamp
            self.fragmentLengthInMilliseconds = fragmentLengthInMilliseconds
            self.fragmentNumber = fragmentNumber
        }

        private enum CodingKeys: String, CodingKey {
            case producerTimestamp = "ProducerTimestamp"
            case fragmentSizeInBytes = "FragmentSizeInBytes"
            case serverTimestamp = "ServerTimestamp"
            case fragmentLengthInMilliseconds = "FragmentLengthInMilliseconds"
            case fragmentNumber = "FragmentNumber"
        }
    }

    public struct GetMediaForFragmentListOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "Payload"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContentType", location: .header(locationName: "Content-Type"), required: false, type: .string), 
            AWSShapeMember(label: "Payload", required: false, type: .blob)
        ]
        /// The content type of the requested media.
        public let contentType: String?
        /// The payload that Kinesis Video Streams returns is a sequence of chunks from the specified stream. For information about the chunks, see PutMedia. The chunks that Kinesis Video Streams returns in the GetMediaForFragmentList call also include the following additional Matroska (MKV) tags:    AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the chunk.   AWS_KINESISVIDEO_SERVER_SIDE_TIMESTAMP - Server-side time stamp of the fragment.   AWS_KINESISVIDEO_PRODUCER_SIDE_TIMESTAMP - Producer-side time stamp of the fragment.   The following tags will be included if an exception occurs:   AWS_KINESISVIDEO_FRAGMENT_NUMBER - The number of the fragment that threw the exception   AWS_KINESISVIDEO_EXCEPTION_ERROR_CODE - The integer code of the exception   AWS_KINESISVIDEO_EXCEPTION_MESSAGE - A text description of the exception  
        public let payload: Data?

        public init(contentType: String? = nil, payload: Data? = nil) {
            self.contentType = contentType
            self.payload = payload
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "Content-Type"
            case payload = "Payload"
        }
    }

}