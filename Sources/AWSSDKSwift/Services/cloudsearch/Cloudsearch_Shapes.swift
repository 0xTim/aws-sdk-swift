// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Cloudsearch {

    public struct DescribeScalingParametersRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct IntOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceField", required: false, type: .string), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SortEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .long)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// The name of the source field to map to the field. 
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public let defaultValue: Int64?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: Int64? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case facetEnabled = "FacetEnabled"
            case sourceField = "SourceField"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct ExpressionStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .structure), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        /// The expression that is evaluated for sorting while processing a search request.
        public let options: Expression
        public let status: OptionStatus

        public init(options: Expression, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct DescribeScalingParametersResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ScalingParameters", required: true, type: .structure)
        ]
        public let scalingParameters: ScalingParametersStatus

        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case scalingParameters = "ScalingParameters"
        }
    }

    public struct AnalysisScheme: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisSchemeLanguage", required: true, type: .enum), 
            AWSShapeMember(label: "AnalysisSchemeName", required: true, type: .string), 
            AWSShapeMember(label: "AnalysisOptions", required: false, type: .structure)
        ]
        public let analysisSchemeLanguage: AnalysisSchemeLanguage
        public let analysisSchemeName: String
        public let analysisOptions: AnalysisOptions?

        public init(analysisSchemeLanguage: AnalysisSchemeLanguage, analysisSchemeName: String, analysisOptions: AnalysisOptions? = nil) {
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
            self.analysisOptions = analysisOptions
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemeLanguage = "AnalysisSchemeLanguage"
            case analysisSchemeName = "AnalysisSchemeName"
            case analysisOptions = "AnalysisOptions"
        }
    }

    public struct DeleteIndexFieldRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndexFieldName", required: true, type: .string), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The name of the index field your want to remove from the domain's indexing options.
        public let indexFieldName: String
        public let domainName: String

        public init(indexFieldName: String, domainName: String) {
            self.indexFieldName = indexFieldName
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case indexFieldName = "IndexFieldName"
            case domainName = "DomainName"
        }
    }

    public struct DeleteExpressionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Expression", required: true, type: .structure)
        ]
        /// The status of the expression being deleted.
        public let expression: ExpressionStatus

        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct LiteralOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceField", required: false, type: .string), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SortEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case facetEnabled = "FacetEnabled"
            case sourceField = "SourceField"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct DescribeAnalysisSchemesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisSchemeNames", required: false, type: .list), 
            AWSShapeMember(label: "Deployed", required: false, type: .boolean), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The analysis schemes you want to describe.
        public let analysisSchemeNames: [String]?
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(analysisSchemeNames: [String]? = nil, deployed: Bool? = nil, domainName: String) {
            self.analysisSchemeNames = analysisSchemeNames
            self.deployed = deployed
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemeNames = "AnalysisSchemeNames"
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct OptionStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "UpdateVersion", required: false, type: .integer), 
            AWSShapeMember(label: "PendingDeletion", required: false, type: .boolean), 
            AWSShapeMember(label: "CreationDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "State", required: true, type: .enum), 
            AWSShapeMember(label: "UpdateDate", required: true, type: .timestamp)
        ]
        /// A unique integer that indicates when this option was last updated.
        public let updateVersion: Int32?
        /// Indicates that the option will be deleted once processing is complete.
        public let pendingDeletion: Bool?
        /// A timestamp for when this option was created.
        public let creationDate: Double
        /// The state of processing a change to an option. Possible values:   RequiresIndexDocuments: the option's latest value will not be deployed until IndexDocuments has been called and indexing is complete.  Processing: the option's latest value is in the process of being activated.   Active: the option's latest value is completely deployed.  FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents. 
        public let state: OptionState
        /// A timestamp for when this option was last updated.
        public let updateDate: Double

        public init(updateVersion: Int32? = nil, pendingDeletion: Bool? = nil, creationDate: Double, state: OptionState, updateDate: Double) {
            self.updateVersion = updateVersion
            self.pendingDeletion = pendingDeletion
            self.creationDate = creationDate
            self.state = state
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case updateVersion = "UpdateVersion"
            case pendingDeletion = "PendingDeletion"
            case creationDate = "CreationDate"
            case state = "State"
            case updateDate = "UpdateDate"
        }
    }

    public struct DescribeDomainsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainNames", required: false, type: .list)
        ]
        /// The names of the domains you want to include in the response.
        public let domainNames: [String]?

        public init(domainNames: [String]? = nil) {
            self.domainNames = domainNames
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct UpdateServiceAccessPoliciesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessPolicies", required: true, type: .structure)
        ]
        /// The access rules configured for the domain.
        public let accessPolicies: AccessPoliciesStatus

        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
        }
    }

    public struct DoubleArrayOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceFields", required: false, type: .string), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .double)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: Double?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: Double? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case sourceFields = "SourceFields"
            case facetEnabled = "FacetEnabled"
            case searchEnabled = "SearchEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct DomainStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limits", required: false, type: .structure), 
            AWSShapeMember(label: "Processing", required: false, type: .boolean), 
            AWSShapeMember(label: "Created", required: false, type: .boolean), 
            AWSShapeMember(label: "ARN", required: false, type: .string), 
            AWSShapeMember(label: "DocService", required: false, type: .structure), 
            AWSShapeMember(label: "RequiresIndexDocuments", required: true, type: .boolean), 
            AWSShapeMember(label: "SearchService", required: false, type: .structure), 
            AWSShapeMember(label: "SearchPartitionCount", required: false, type: .integer), 
            AWSShapeMember(label: "SearchInstanceType", required: false, type: .string), 
            AWSShapeMember(label: "DomainName", required: true, type: .string), 
            AWSShapeMember(label: "SearchInstanceCount", required: false, type: .integer), 
            AWSShapeMember(label: "Deleted", required: false, type: .boolean), 
            AWSShapeMember(label: "DomainId", required: true, type: .string)
        ]
        public let limits: Limits?
        /// True if processing is being done to activate the current domain configuration.
        public let processing: Bool?
        /// True if the search domain is created. It can take several minutes to initialize a domain when CreateDomain is called. Newly created search domains are returned from DescribeDomains with a false value for Created until domain creation is complete.
        public let created: Bool?
        public let aRN: String?
        /// The service endpoint for updating documents in a search domain.
        public let docService: ServiceEndpoint?
        /// True if IndexDocuments needs to be called to activate the current domain configuration.
        public let requiresIndexDocuments: Bool
        /// The service endpoint for requesting search results from a search domain.
        public let searchService: ServiceEndpoint?
        /// The number of partitions across which the search index is spread.
        public let searchPartitionCount: Int32?
        /// The instance type that is being used to process search requests.
        public let searchInstanceType: String?
        public let domainName: String
        /// The number of search instances that are available to process search requests.
        public let searchInstanceCount: Int32?
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when DeleteDomain is called. Newly deleted search domains are returned from DescribeDomains with a true value for IsDeleted for several minutes until resource cleanup is complete.
        public let deleted: Bool?
        public let domainId: String

        public init(limits: Limits? = nil, processing: Bool? = nil, created: Bool? = nil, aRN: String? = nil, docService: ServiceEndpoint? = nil, requiresIndexDocuments: Bool, searchService: ServiceEndpoint? = nil, searchPartitionCount: Int32? = nil, searchInstanceType: String? = nil, domainName: String, searchInstanceCount: Int32? = nil, deleted: Bool? = nil, domainId: String) {
            self.limits = limits
            self.processing = processing
            self.created = created
            self.aRN = aRN
            self.docService = docService
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchService = searchService
            self.searchPartitionCount = searchPartitionCount
            self.searchInstanceType = searchInstanceType
            self.domainName = domainName
            self.searchInstanceCount = searchInstanceCount
            self.deleted = deleted
            self.domainId = domainId
        }

        private enum CodingKeys: String, CodingKey {
            case limits = "Limits"
            case processing = "Processing"
            case created = "Created"
            case aRN = "ARN"
            case docService = "DocService"
            case requiresIndexDocuments = "RequiresIndexDocuments"
            case searchService = "SearchService"
            case searchPartitionCount = "SearchPartitionCount"
            case searchInstanceType = "SearchInstanceType"
            case domainName = "DomainName"
            case searchInstanceCount = "SearchInstanceCount"
            case deleted = "Deleted"
            case domainId = "DomainId"
        }
    }

    public enum AlgorithmicStemming: String, CustomStringConvertible, Codable {
        case none = "none"
        case minimal = "minimal"
        case light = "light"
        case full = "full"
        public var description: String { return self.rawValue }
    }

    public struct UpdateScalingParametersResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ScalingParameters", required: true, type: .structure)
        ]
        public let scalingParameters: ScalingParametersStatus

        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case scalingParameters = "ScalingParameters"
        }
    }

    public struct ListDomainNamesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainNames", required: false, type: .map)
        ]
        /// The names of the search domains owned by an account.
        public let domainNames: [String: String]?

        public init(domainNames: [String: String]? = nil) {
            self.domainNames = domainNames
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct DescribeAvailabilityOptionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deployed", required: false, type: .boolean), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct DeleteIndexFieldResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndexField", required: true, type: .structure)
        ]
        /// The status of the index field being deleted.
        public let indexField: IndexFieldStatus

        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

        private enum CodingKeys: String, CodingKey {
            case indexField = "IndexField"
        }
    }

    public struct DefineSuggesterRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Suggester", required: true, type: .structure), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        public let suggester: Suggester
        public let domainName: String

        public init(suggester: Suggester, domainName: String) {
            self.suggester = suggester
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case suggester = "Suggester"
            case domainName = "DomainName"
        }
    }

    public struct DescribeIndexFieldsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deployed", required: false, type: .boolean), 
            AWSShapeMember(label: "FieldNames", required: false, type: .list), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
        public let fieldNames: [String]?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, fieldNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.fieldNames = fieldNames
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case fieldNames = "FieldNames"
            case domainName = "DomainName"
        }
    }

    public enum PartitionInstanceType: String, CustomStringConvertible, Codable {
        case search_m1_small = "search.m1.small"
        case search_m1_large = "search.m1.large"
        case search_m2_xlarge = "search.m2.xlarge"
        case search_m2_2xlarge = "search.m2.2xlarge"
        case search_m3_medium = "search.m3.medium"
        case search_m3_large = "search.m3.large"
        case search_m3_xlarge = "search.m3.xlarge"
        case search_m3_2xlarge = "search.m3.2xlarge"
        public var description: String { return self.rawValue }
    }

    public struct DeleteDomainResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainStatus", required: false, type: .structure)
        ]
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public enum SuggesterFuzzyMatching: String, CustomStringConvertible, Codable {
        case none = "none"
        case low = "low"
        case high = "high"
        public var description: String { return self.rawValue }
    }

    public struct Suggester: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SuggesterName", required: true, type: .string), 
            AWSShapeMember(label: "DocumentSuggesterOptions", required: true, type: .structure)
        ]
        public let suggesterName: String
        public let documentSuggesterOptions: DocumentSuggesterOptions

        public init(suggesterName: String, documentSuggesterOptions: DocumentSuggesterOptions) {
            self.suggesterName = suggesterName
            self.documentSuggesterOptions = documentSuggesterOptions
        }

        private enum CodingKeys: String, CodingKey {
            case suggesterName = "SuggesterName"
            case documentSuggesterOptions = "DocumentSuggesterOptions"
        }
    }

    public struct ScalingParameters: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DesiredReplicationCount", required: false, type: .integer), 
            AWSShapeMember(label: "DesiredInstanceType", required: false, type: .enum), 
            AWSShapeMember(label: "DesiredPartitionCount", required: false, type: .integer)
        ]
        /// The number of replicas you want to preconfigure for each index partition.
        public let desiredReplicationCount: Int32?
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        public let desiredInstanceType: PartitionInstanceType?
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        public let desiredPartitionCount: Int32?

        public init(desiredReplicationCount: Int32? = nil, desiredInstanceType: PartitionInstanceType? = nil, desiredPartitionCount: Int32? = nil) {
            self.desiredReplicationCount = desiredReplicationCount
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
        }

        private enum CodingKeys: String, CodingKey {
            case desiredReplicationCount = "DesiredReplicationCount"
            case desiredInstanceType = "DesiredInstanceType"
            case desiredPartitionCount = "DesiredPartitionCount"
        }
    }

    public struct DescribeServiceAccessPoliciesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deployed", required: false, type: .boolean), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case domainName = "DomainName"
        }
    }

    public struct CreateDomainResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainStatus", required: false, type: .structure)
        ]
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DocumentSuggesterOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SortExpression", required: false, type: .string), 
            AWSShapeMember(label: "FuzzyMatching", required: false, type: .enum), 
            AWSShapeMember(label: "SourceField", required: true, type: .string)
        ]
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        public let sortExpression: String?
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none. 
        public let fuzzyMatching: SuggesterFuzzyMatching?
        /// The name of the index field you want to use for suggestions. 
        public let sourceField: String

        public init(sortExpression: String? = nil, fuzzyMatching: SuggesterFuzzyMatching? = nil, sourceField: String) {
            self.sortExpression = sortExpression
            self.fuzzyMatching = fuzzyMatching
            self.sourceField = sourceField
        }

        private enum CodingKeys: String, CodingKey {
            case sortExpression = "SortExpression"
            case fuzzyMatching = "FuzzyMatching"
            case sourceField = "SourceField"
        }
    }

    public struct DefineExpressionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: true, type: .string), 
            AWSShapeMember(label: "Expression", required: true, type: .structure)
        ]
        public let domainName: String
        public let expression: Expression

        public init(domainName: String, expression: Expression) {
            self.domainName = domainName
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case expression = "Expression"
        }
    }

    public struct TextArrayOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisScheme", required: false, type: .string), 
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceFields", required: false, type: .string), 
            AWSShapeMember(label: "HighlightEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// The name of an analysis scheme for a text-array field.
        public let analysisScheme: String?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether highlights can be returned for the field.
        public let highlightEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(analysisScheme: String? = nil, returnEnabled: Bool? = nil, sourceFields: String? = nil, highlightEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.analysisScheme = analysisScheme
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.highlightEnabled = highlightEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
            case returnEnabled = "ReturnEnabled"
            case sourceFields = "SourceFields"
            case highlightEnabled = "HighlightEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct DescribeDomainsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainStatusList", required: true, type: .list)
        ]
        public let domainStatusList: [DomainStatus]

        public init(domainStatusList: [DomainStatus]) {
            self.domainStatusList = domainStatusList
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatusList = "DomainStatusList"
        }
    }

    public struct DeleteSuggesterResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Suggester", required: true, type: .structure)
        ]
        /// The status of the suggester being deleted.
        public let suggester: SuggesterStatus

        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

        private enum CodingKeys: String, CodingKey {
            case suggester = "Suggester"
        }
    }

    public struct DefineIndexFieldRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndexField", required: true, type: .structure), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The index field and field options you want to configure. 
        public let indexField: IndexField
        public let domainName: String

        public init(indexField: IndexField, domainName: String) {
            self.indexField = indexField
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case indexField = "IndexField"
            case domainName = "DomainName"
        }
    }

    public enum IndexFieldType: String, CustomStringConvertible, Codable {
        case int = "int"
        case double = "double"
        case literal = "literal"
        case text = "text"
        case date = "date"
        case latlon = "latlon"
        case int_array = "int-array"
        case double_array = "double-array"
        case literal_array = "literal-array"
        case text_array = "text-array"
        case date_array = "date-array"
        public var description: String { return self.rawValue }
    }

    public struct DefineAnalysisSchemeRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisScheme", required: true, type: .structure), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        public let analysisScheme: AnalysisScheme
        public let domainName: String

        public init(analysisScheme: AnalysisScheme, domainName: String) {
            self.analysisScheme = analysisScheme
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
            case domainName = "DomainName"
        }
    }

    public struct DeleteDomainRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The name of the domain you want to permanently delete.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct IndexDocumentsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct DeleteExpressionRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExpressionName", required: true, type: .string), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The name of the Expression to delete.
        public let expressionName: String
        public let domainName: String

        public init(expressionName: String, domainName: String) {
            self.expressionName = expressionName
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case expressionName = "ExpressionName"
            case domainName = "DomainName"
        }
    }

    public struct IndexFieldStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .structure), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        public let options: IndexField
        public let status: OptionStatus

        public init(options: IndexField, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct DeleteAnalysisSchemeRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisSchemeName", required: true, type: .string), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The name of the analysis scheme you want to delete.
        public let analysisSchemeName: String
        public let domainName: String

        public init(analysisSchemeName: String, domainName: String) {
            self.analysisSchemeName = analysisSchemeName
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemeName = "AnalysisSchemeName"
            case domainName = "DomainName"
        }
    }

    public struct ScalingParametersStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .structure), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        public let options: ScalingParameters
        public let status: OptionStatus

        public init(options: ScalingParameters, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AnalysisOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "StemmingDictionary", required: false, type: .string), 
            AWSShapeMember(label: "JapaneseTokenizationDictionary", required: false, type: .string), 
            AWSShapeMember(label: "Stopwords", required: false, type: .string), 
            AWSShapeMember(label: "AlgorithmicStemming", required: false, type: .enum), 
            AWSShapeMember(label: "Synonyms", required: false, type: .string)
        ]
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        public let stemmingDictionary: String?
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        public let japaneseTokenizationDictionary: String?
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported. 
        public let stopwords: String?
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see Language Specific Text Processing Settings in the Amazon CloudSearch Developer Guide 
        public let algorithmicStemming: AlgorithmicStemming?
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see Synonyms in the Amazon CloudSearch Developer Guide.
        public let synonyms: String?

        public init(stemmingDictionary: String? = nil, japaneseTokenizationDictionary: String? = nil, stopwords: String? = nil, algorithmicStemming: AlgorithmicStemming? = nil, synonyms: String? = nil) {
            self.stemmingDictionary = stemmingDictionary
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stopwords = stopwords
            self.algorithmicStemming = algorithmicStemming
            self.synonyms = synonyms
        }

        private enum CodingKeys: String, CodingKey {
            case stemmingDictionary = "StemmingDictionary"
            case japaneseTokenizationDictionary = "JapaneseTokenizationDictionary"
            case stopwords = "Stopwords"
            case algorithmicStemming = "AlgorithmicStemming"
            case synonyms = "Synonyms"
        }
    }

    public struct UpdateServiceAccessPoliciesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessPolicies", required: true, type: .string), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// The access rules you want to configure. These rules replace any existing rules. 
        public let accessPolicies: String
        public let domainName: String

        public init(accessPolicies: String, domainName: String) {
            self.accessPolicies = accessPolicies
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case domainName = "DomainName"
        }
    }

    public struct DateArrayOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceFields", required: false, type: .string), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case sourceFields = "SourceFields"
            case facetEnabled = "FacetEnabled"
            case searchEnabled = "SearchEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct DeleteAnalysisSchemeResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisScheme", required: true, type: .structure)
        ]
        /// The status of the analysis scheme being deleted.
        public let analysisScheme: AnalysisSchemeStatus

        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
        }
    }

    public struct BuildSuggestersResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "FieldNames", required: false, type: .list)
        ]
        public let fieldNames: [String]?

        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

        private enum CodingKeys: String, CodingKey {
            case fieldNames = "FieldNames"
        }
    }

    public struct AnalysisSchemeStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .structure), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        public let options: AnalysisScheme
        public let status: OptionStatus

        public init(options: AnalysisScheme, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AccessPoliciesStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .string), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        public let options: String
        public let status: OptionStatus

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct TextOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisScheme", required: false, type: .string), 
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceField", required: false, type: .string), 
            AWSShapeMember(label: "HighlightEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SortEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// The name of an analysis scheme for a text field.
        public let analysisScheme: String?
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        public let sourceField: String?
        /// Whether highlights can be returned for the field.
        public let highlightEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(analysisScheme: String? = nil, returnEnabled: Bool? = nil, sourceField: String? = nil, highlightEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.analysisScheme = analysisScheme
            self.returnEnabled = returnEnabled
            self.sourceField = sourceField
            self.highlightEnabled = highlightEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
            case returnEnabled = "ReturnEnabled"
            case sourceField = "SourceField"
            case highlightEnabled = "HighlightEnabled"
            case sortEnabled = "SortEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct IndexDocumentsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "FieldNames", required: false, type: .list)
        ]
        /// The names of the fields that are currently being indexed.
        public let fieldNames: [String]?

        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

        private enum CodingKeys: String, CodingKey {
            case fieldNames = "FieldNames"
        }
    }

    public struct DefineExpressionResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Expression", required: true, type: .structure)
        ]
        public let expression: ExpressionStatus

        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
        }
    }

    public struct UpdateAvailabilityOptionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityOptions", required: false, type: .structure)
        ]
        /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain. 
        public let availabilityOptions: AvailabilityOptionsStatus?

        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityOptions = "AvailabilityOptions"
        }
    }

    public struct LiteralArrayOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceFields", required: false, type: .string), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case sourceFields = "SourceFields"
            case facetEnabled = "FacetEnabled"
            case searchEnabled = "SearchEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct IntArrayOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceFields", required: false, type: .string), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .long)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// A list of source fields to map to the field. 
        public let sourceFields: String?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: Int64?

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: Int64? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case sourceFields = "SourceFields"
            case facetEnabled = "FacetEnabled"
            case searchEnabled = "SearchEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct DescribeAnalysisSchemesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisSchemes", required: true, type: .list)
        ]
        /// The analysis scheme descriptions.
        public let analysisSchemes: [AnalysisSchemeStatus]

        public init(analysisSchemes: [AnalysisSchemeStatus]) {
            self.analysisSchemes = analysisSchemes
        }

        private enum CodingKeys: String, CodingKey {
            case analysisSchemes = "AnalysisSchemes"
        }
    }

    public struct DescribeExpressionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Expressions", required: true, type: .list)
        ]
        /// The expressions configured for the domain.
        public let expressions: [ExpressionStatus]

        public init(expressions: [ExpressionStatus]) {
            self.expressions = expressions
        }

        private enum CodingKeys: String, CodingKey {
            case expressions = "Expressions"
        }
    }

    public struct Expression: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ExpressionValue", required: true, type: .string), 
            AWSShapeMember(label: "ExpressionName", required: true, type: .string)
        ]
        public let expressionValue: String
        public let expressionName: String

        public init(expressionValue: String, expressionName: String) {
            self.expressionValue = expressionValue
            self.expressionName = expressionName
        }

        private enum CodingKeys: String, CodingKey {
            case expressionValue = "ExpressionValue"
            case expressionName = "ExpressionName"
        }
    }

    public struct SuggesterStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .structure), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        public let options: Suggester
        public let status: OptionStatus

        public init(options: Suggester, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct DescribeSuggestersRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deployed", required: false, type: .boolean), 
            AWSShapeMember(label: "SuggesterNames", required: false, type: .list), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// The suggesters you want to describe.
        public let suggesterNames: [String]?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, suggesterNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.suggesterNames = suggesterNames
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case suggesterNames = "SuggesterNames"
            case domainName = "DomainName"
        }
    }

    public struct IndexField: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IntOptions", required: false, type: .structure), 
            AWSShapeMember(label: "DateOptions", required: false, type: .structure), 
            AWSShapeMember(label: "TextArrayOptions", required: false, type: .structure), 
            AWSShapeMember(label: "DoubleOptions", required: false, type: .structure), 
            AWSShapeMember(label: "LiteralArrayOptions", required: false, type: .structure), 
            AWSShapeMember(label: "IntArrayOptions", required: false, type: .structure), 
            AWSShapeMember(label: "IndexFieldType", required: true, type: .enum), 
            AWSShapeMember(label: "IndexFieldName", required: true, type: .string), 
            AWSShapeMember(label: "DateArrayOptions", required: false, type: .structure), 
            AWSShapeMember(label: "LiteralOptions", required: false, type: .structure), 
            AWSShapeMember(label: "LatLonOptions", required: false, type: .structure), 
            AWSShapeMember(label: "TextOptions", required: false, type: .structure), 
            AWSShapeMember(label: "DoubleArrayOptions", required: false, type: .structure)
        ]
        public let intOptions: IntOptions?
        public let dateOptions: DateOptions?
        public let textArrayOptions: TextArrayOptions?
        public let doubleOptions: DoubleOptions?
        public let literalArrayOptions: LiteralArrayOptions?
        public let intArrayOptions: IntArrayOptions?
        public let indexFieldType: IndexFieldType
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options.  Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported.  The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id. 
        public let indexFieldName: String
        public let dateArrayOptions: DateArrayOptions?
        public let literalOptions: LiteralOptions?
        public let latLonOptions: LatLonOptions?
        public let textOptions: TextOptions?
        public let doubleArrayOptions: DoubleArrayOptions?

        public init(intOptions: IntOptions? = nil, dateOptions: DateOptions? = nil, textArrayOptions: TextArrayOptions? = nil, doubleOptions: DoubleOptions? = nil, literalArrayOptions: LiteralArrayOptions? = nil, intArrayOptions: IntArrayOptions? = nil, indexFieldType: IndexFieldType, indexFieldName: String, dateArrayOptions: DateArrayOptions? = nil, literalOptions: LiteralOptions? = nil, latLonOptions: LatLonOptions? = nil, textOptions: TextOptions? = nil, doubleArrayOptions: DoubleArrayOptions? = nil) {
            self.intOptions = intOptions
            self.dateOptions = dateOptions
            self.textArrayOptions = textArrayOptions
            self.doubleOptions = doubleOptions
            self.literalArrayOptions = literalArrayOptions
            self.intArrayOptions = intArrayOptions
            self.indexFieldType = indexFieldType
            self.indexFieldName = indexFieldName
            self.dateArrayOptions = dateArrayOptions
            self.literalOptions = literalOptions
            self.latLonOptions = latLonOptions
            self.textOptions = textOptions
            self.doubleArrayOptions = doubleArrayOptions
        }

        private enum CodingKeys: String, CodingKey {
            case intOptions = "IntOptions"
            case dateOptions = "DateOptions"
            case textArrayOptions = "TextArrayOptions"
            case doubleOptions = "DoubleOptions"
            case literalArrayOptions = "LiteralArrayOptions"
            case intArrayOptions = "IntArrayOptions"
            case indexFieldType = "IndexFieldType"
            case indexFieldName = "IndexFieldName"
            case dateArrayOptions = "DateArrayOptions"
            case literalOptions = "LiteralOptions"
            case latLonOptions = "LatLonOptions"
            case textOptions = "TextOptions"
            case doubleArrayOptions = "DoubleArrayOptions"
        }
    }

    public struct LatLonOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceField", required: false, type: .string), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SortEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case facetEnabled = "FacetEnabled"
            case sourceField = "SourceField"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public enum AnalysisSchemeLanguage: String, CustomStringConvertible, Codable {
        case ar = "ar"
        case bg = "bg"
        case ca = "ca"
        case cs = "cs"
        case da = "da"
        case de = "de"
        case el = "el"
        case en = "en"
        case es = "es"
        case eu = "eu"
        case fa = "fa"
        case fi = "fi"
        case fr = "fr"
        case ga = "ga"
        case gl = "gl"
        case he = "he"
        case hi = "hi"
        case hu = "hu"
        case hy = "hy"
        case id = "id"
        case it = "it"
        case ja = "ja"
        case ko = "ko"
        case lv = "lv"
        case mul = "mul"
        case nl = "nl"
        case no = "no"
        case pt = "pt"
        case ro = "ro"
        case ru = "ru"
        case sv = "sv"
        case th = "th"
        case tr = "tr"
        case zh_hans = "zh-Hans"
        case zh_hant = "zh-Hant"
        public var description: String { return self.rawValue }
    }

    public struct DescribeExpressionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deployed", required: false, type: .boolean), 
            AWSShapeMember(label: "ExpressionNames", required: false, type: .list), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        public let deployed: Bool?
        /// Limits the DescribeExpressions response to the specified expressions. If not specified, all expressions are shown.
        public let expressionNames: [String]?
        /// The name of the domain you want to describe.
        public let domainName: String

        public init(deployed: Bool? = nil, expressionNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.expressionNames = expressionNames
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case deployed = "Deployed"
            case expressionNames = "ExpressionNames"
            case domainName = "DomainName"
        }
    }

    public struct DoubleOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceField", required: false, type: .string), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SortEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .double)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        /// The name of the source field to map to the field. 
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        public let defaultValue: Double?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: Double? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case facetEnabled = "FacetEnabled"
            case sourceField = "SourceField"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct DateOptions: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FacetEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SourceField", required: false, type: .string), 
            AWSShapeMember(label: "SearchEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "SortEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DefaultValue", required: false, type: .string)
        ]
        /// Whether the contents of the field can be returned in the search results.
        public let returnEnabled: Bool?
        /// Whether facet information can be returned for the field.
        public let facetEnabled: Bool?
        public let sourceField: String?
        /// Whether the contents of the field are searchable.
        public let searchEnabled: Bool?
        /// Whether the field can be used to sort the search results.
        public let sortEnabled: Bool?
        /// A value to use for the field if the field isn't specified for a document.
        public let defaultValue: String?

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnEnabled = "ReturnEnabled"
            case facetEnabled = "FacetEnabled"
            case sourceField = "SourceField"
            case searchEnabled = "SearchEnabled"
            case sortEnabled = "SortEnabled"
            case defaultValue = "DefaultValue"
        }
    }

    public struct UpdateAvailabilityOptionsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MultiAZ", required: true, type: .boolean), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false. 
        public let multiAZ: Bool
        public let domainName: String

        public init(multiAZ: Bool, domainName: String) {
            self.multiAZ = multiAZ
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case multiAZ = "MultiAZ"
            case domainName = "DomainName"
        }
    }

    public struct DescribeServiceAccessPoliciesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccessPolicies", required: true, type: .structure)
        ]
        /// The access rules configured for the domain specified in the request.
        public let accessPolicies: AccessPoliciesStatus

        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
        }
    }

    public struct BuildSuggestersRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct AvailabilityOptionsStatus: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Options", required: true, type: .boolean), 
            AWSShapeMember(label: "Status", required: true, type: .structure)
        ]
        /// The availability options configured for the domain.
        public let options: Bool
        public let status: OptionStatus

        public init(options: Bool, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct ServiceEndpoint: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .string)
        ]
        public let endpoint: String?

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct DeleteSuggesterRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SuggesterName", required: true, type: .string), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// Specifies the name of the suggester you want to delete.
        public let suggesterName: String
        public let domainName: String

        public init(suggesterName: String, domainName: String) {
            self.suggesterName = suggesterName
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case suggesterName = "SuggesterName"
            case domainName = "DomainName"
        }
    }

    public struct Limits: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaximumReplicationCount", required: true, type: .integer), 
            AWSShapeMember(label: "MaximumPartitionCount", required: true, type: .integer)
        ]
        public let maximumReplicationCount: Int32
        public let maximumPartitionCount: Int32

        public init(maximumReplicationCount: Int32, maximumPartitionCount: Int32) {
            self.maximumReplicationCount = maximumReplicationCount
            self.maximumPartitionCount = maximumPartitionCount
        }

        private enum CodingKeys: String, CodingKey {
            case maximumReplicationCount = "MaximumReplicationCount"
            case maximumPartitionCount = "MaximumPartitionCount"
        }
    }

    public struct DescribeIndexFieldsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndexFields", required: true, type: .list)
        ]
        /// The index fields configured for the domain.
        public let indexFields: [IndexFieldStatus]

        public init(indexFields: [IndexFieldStatus]) {
            self.indexFields = indexFields
        }

        private enum CodingKeys: String, CodingKey {
            case indexFields = "IndexFields"
        }
    }

    public struct UpdateScalingParametersRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ScalingParameters", required: true, type: .structure), 
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        public let scalingParameters: ScalingParameters
        public let domainName: String

        public init(scalingParameters: ScalingParameters, domainName: String) {
            self.scalingParameters = scalingParameters
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case scalingParameters = "ScalingParameters"
            case domainName = "DomainName"
        }
    }

    public struct DefineAnalysisSchemeResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnalysisScheme", required: true, type: .structure)
        ]
        public let analysisScheme: AnalysisSchemeStatus

        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

        private enum CodingKeys: String, CodingKey {
            case analysisScheme = "AnalysisScheme"
        }
    }

    public struct DefineSuggesterResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Suggester", required: true, type: .structure)
        ]
        public let suggester: SuggesterStatus

        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

        private enum CodingKeys: String, CodingKey {
            case suggester = "Suggester"
        }
    }

    public struct DefineIndexFieldResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndexField", required: true, type: .structure)
        ]
        public let indexField: IndexFieldStatus

        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

        private enum CodingKeys: String, CodingKey {
            case indexField = "IndexField"
        }
    }

    public struct DescribeSuggestersResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Suggesters", required: true, type: .list)
        ]
        /// The suggesters configured for the domain specified in the request.
        public let suggesters: [SuggesterStatus]

        public init(suggesters: [SuggesterStatus]) {
            self.suggesters = suggesters
        }

        private enum CodingKeys: String, CodingKey {
            case suggesters = "Suggesters"
        }
    }

    public enum OptionState: String, CustomStringConvertible, Codable {
        case requiresindexdocuments = "RequiresIndexDocuments"
        case processing = "Processing"
        case active = "Active"
        case failedtovalidate = "FailedToValidate"
        public var description: String { return self.rawValue }
    }

    public struct DescribeAvailabilityOptionsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityOptions", required: false, type: .structure)
        ]
        /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain. 
        public let availabilityOptions: AvailabilityOptionsStatus?

        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityOptions = "AvailabilityOptions"
        }
    }

    public struct CreateDomainRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DomainName", required: true, type: .string)
        ]
        /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

}