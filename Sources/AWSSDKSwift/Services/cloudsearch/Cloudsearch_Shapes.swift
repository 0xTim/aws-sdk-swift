// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Cloudsearch {

    public struct DescribeScalingParametersRequest: Serializable, Initializable {
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

    public struct ExpressionStatus: Serializable, Initializable {
        /// The expression that is evaluated for sorting while processing a search request.
        var options: Expression = Expression()
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: Expression, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct IntOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        /// The name of the source field to map to the field. 
        var sourceField: String? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// Whether the field can be used to sort the search results.
        var sortEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        var defaultValue: Int64? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: Int64? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DescribeScalingParametersResponse: Serializable, Initializable {
        var scalingParameters: ScalingParametersStatus = ScalingParametersStatus()

        public init() {}

        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

    }

    public struct AnalysisScheme: Serializable, Initializable {
        var analysisSchemeLanguage: String = ""
        var analysisSchemeName: String = ""
        var analysisOptions: AnalysisOptions? = nil

        public init() {}

        public init(analysisSchemeLanguage: String, analysisSchemeName: String, analysisOptions: AnalysisOptions? = nil) {
            self.analysisSchemeLanguage = analysisSchemeLanguage
            self.analysisSchemeName = analysisSchemeName
            self.analysisOptions = analysisOptions
        }

    }

    public struct DeleteIndexFieldRequest: Serializable, Initializable {
        /// The name of the index field your want to remove from the domain's indexing options.
        var indexFieldName: String = ""
        var domainName: String = ""

        public init() {}

        public init(indexFieldName: String, domainName: String) {
            self.indexFieldName = indexFieldName
            self.domainName = domainName
        }

    }

    public struct LiteralOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        var sourceField: String? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// Whether the field can be used to sort the search results.
        var sortEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DeleteExpressionResponse: Serializable, Initializable {
        /// The status of the expression being deleted.
        var expression: ExpressionStatus = ExpressionStatus()

        public init() {}

        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

    }

    public struct DescribeAnalysisSchemesRequest: Serializable, Initializable {
        /// The analysis schemes you want to describe.
        var analysisSchemeNames: [String]? = nil
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        var deployed: Bool? = nil
        /// The name of the domain you want to describe.
        var domainName: String = ""

        public init() {}

        public init(analysisSchemeNames: [String]? = nil, deployed: Bool? = nil, domainName: String) {
            self.analysisSchemeNames = analysisSchemeNames
            self.deployed = deployed
            self.domainName = domainName
        }

    }

    public struct OptionStatus: Serializable, Initializable {
        /// A unique integer that indicates when this option was last updated.
        var updateVersion: Int32? = nil
        /// Indicates that the option will be deleted once processing is complete.
        var pendingDeletion: Bool? = nil
        /// A timestamp for when this option was created.
        var creationDate: Date = Date()
        /// The state of processing a change to an option. Possible values:   RequiresIndexDocuments: the option's latest value will not be deployed until IndexDocuments has been called and indexing is complete.  Processing: the option's latest value is in the process of being activated.   Active: the option's latest value is completely deployed.  FailedToValidate: the option value is not compatible with the domain's data and cannot be used to index the data. You must either modify the option value or update or remove the incompatible documents. 
        var state: String = ""
        /// A timestamp for when this option was last updated.
        var updateDate: Date = Date()

        public init() {}

        public init(updateVersion: Int32? = nil, pendingDeletion: Bool? = nil, creationDate: Date, state: String, updateDate: Date) {
            self.updateVersion = updateVersion
            self.pendingDeletion = pendingDeletion
            self.creationDate = creationDate
            self.state = state
            self.updateDate = updateDate
        }

    }

    public struct DescribeDomainsRequest: Serializable, Initializable {
        /// The names of the domains you want to include in the response.
        var domainNames: [String]? = nil

        public init() {}

        public init(domainNames: [String]? = nil) {
            self.domainNames = domainNames
        }

    }

    public struct DoubleArrayOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// A list of source fields to map to the field. 
        var sourceFields: String? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: Double? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: Double? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DomainStatus: Serializable, Initializable {
        var limits: Limits? = nil
        /// True if processing is being done to activate the current domain configuration.
        var processing: Bool? = nil
        /// True if the search domain is created. It can take several minutes to initialize a domain when CreateDomain is called. Newly created search domains are returned from DescribeDomains with a false value for Created until domain creation is complete.
        var created: Bool? = nil
        var aRN: String? = nil
        /// The service endpoint for updating documents in a search domain.
        var docService: ServiceEndpoint? = nil
        /// True if IndexDocuments needs to be called to activate the current domain configuration.
        var requiresIndexDocuments: Bool = false
        /// The service endpoint for requesting search results from a search domain.
        var searchService: ServiceEndpoint? = nil
        /// The number of partitions across which the search index is spread.
        var searchPartitionCount: Int32? = nil
        /// The instance type that is being used to process search requests.
        var searchInstanceType: String? = nil
        var domainName: String = ""
        /// The number of search instances that are available to process search requests.
        var searchInstanceCount: Int32? = nil
        /// True if the search domain has been deleted. The system must clean up resources dedicated to the search domain when DeleteDomain is called. Newly deleted search domains are returned from DescribeDomains with a true value for IsDeleted for several minutes until resource cleanup is complete.
        var deleted: Bool? = nil
        var domainId: String = ""

        public init() {}

        public init(limits: Limits? = nil, processing: Bool? = nil, created: Bool? = nil, aRN: String? = nil, docService: ServiceEndpoint? = nil, requiresIndexDocuments: Bool, searchService: ServiceEndpoint? = nil, searchPartitionCount: Int32? = nil, searchInstanceType: String? = nil, domainName: String, searchInstanceCount: Int32? = nil, deleted: Bool? = nil, domainId: String) {
            self.limits = limits
            self.processing = processing
            self.created = created
            self.aRN = aRN
            self.docService = docService
            self.requiresIndexDocuments = requiresIndexDocuments
            self.searchService = searchService
            self.searchPartitionCount = searchPartitionCount
            self.searchInstanceType = searchInstanceType
            self.domainName = domainName
            self.searchInstanceCount = searchInstanceCount
            self.deleted = deleted
            self.domainId = domainId
        }

    }

    public struct UpdateServiceAccessPoliciesResponse: Serializable, Initializable {
        /// The access rules configured for the domain.
        var accessPolicies: AccessPoliciesStatus = AccessPoliciesStatus()

        public init() {}

        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

    }

    public struct UpdateScalingParametersResponse: Serializable, Initializable {
        var scalingParameters: ScalingParametersStatus = ScalingParametersStatus()

        public init() {}

        public init(scalingParameters: ScalingParametersStatus) {
            self.scalingParameters = scalingParameters
        }

    }

    public struct ListDomainNamesResponse: Serializable, Initializable {
        /// The names of the search domains owned by an account.
        var domainNames: [String: String]? = nil

        public init() {}

        public init(domainNames: [String: String]? = nil) {
            self.domainNames = domainNames
        }

    }

    public struct DescribeAvailabilityOptionsRequest: Serializable, Initializable {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        var deployed: Bool? = nil
        /// The name of the domain you want to describe.
        var domainName: String = ""

        public init() {}

        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

    }

    public struct DeleteIndexFieldResponse: Serializable, Initializable {
        /// The status of the index field being deleted.
        var indexField: IndexFieldStatus = IndexFieldStatus()

        public init() {}

        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

    }

    public struct DefineSuggesterRequest: Serializable, Initializable {
        var suggester: Suggester = Suggester()
        var domainName: String = ""

        public init() {}

        public init(suggester: Suggester, domainName: String) {
            self.suggester = suggester
            self.domainName = domainName
        }

    }

    public struct DescribeIndexFieldsRequest: Serializable, Initializable {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        var deployed: Bool? = nil
        /// A list of the index fields you want to describe. If not specified, information is returned for all configured index fields.
        var fieldNames: [String]? = nil
        /// The name of the domain you want to describe.
        var domainName: String = ""

        public init() {}

        public init(deployed: Bool? = nil, fieldNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.fieldNames = fieldNames
            self.domainName = domainName
        }

    }

    public struct DeleteDomainResponse: Serializable, Initializable {
        var domainStatus: DomainStatus? = nil

        public init() {}

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

    }

    public struct Suggester: Serializable, Initializable {
        var suggesterName: String = ""
        var documentSuggesterOptions: DocumentSuggesterOptions = DocumentSuggesterOptions()

        public init() {}

        public init(suggesterName: String, documentSuggesterOptions: DocumentSuggesterOptions) {
            self.suggesterName = suggesterName
            self.documentSuggesterOptions = documentSuggesterOptions
        }

    }

    public struct ScalingParameters: Serializable, Initializable {
        /// The number of replicas you want to preconfigure for each index partition.
        var desiredReplicationCount: Int32? = nil
        /// The instance type that you want to preconfigure for your domain. For example, search.m1.small.
        var desiredInstanceType: String? = nil
        /// The number of partitions you want to preconfigure for your domain. Only valid when you select m2.2xlarge as the desired instance type.
        var desiredPartitionCount: Int32? = nil

        public init() {}

        public init(desiredReplicationCount: Int32? = nil, desiredInstanceType: String? = nil, desiredPartitionCount: Int32? = nil) {
            self.desiredReplicationCount = desiredReplicationCount
            self.desiredInstanceType = desiredInstanceType
            self.desiredPartitionCount = desiredPartitionCount
        }

    }

    public struct DescribeServiceAccessPoliciesRequest: Serializable, Initializable {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        var deployed: Bool? = nil
        /// The name of the domain you want to describe.
        var domainName: String = ""

        public init() {}

        public init(deployed: Bool? = nil, domainName: String) {
            self.deployed = deployed
            self.domainName = domainName
        }

    }

    public struct CreateDomainResponse: Serializable, Initializable {
        var domainStatus: DomainStatus? = nil

        public init() {}

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

    }

    public struct DocumentSuggesterOptions: Serializable, Initializable {
        /// An expression that computes a score for each suggestion to control how they are sorted. The scores are rounded to the nearest integer, with a floor of 0 and a ceiling of 2^31-1. A document's relevance score is not computed for suggestions, so sort expressions cannot reference the _score value. To sort suggestions using a numeric field or existing expression, simply specify the name of the field or expression. If no expression is configured for the suggester, the suggestions are sorted with the closest matches listed first.
        var sortExpression: String? = nil
        /// The level of fuzziness allowed when suggesting matches for a string: none, low, or high. With none, the specified string is treated as an exact prefix. With low, suggestions must differ from the specified string by no more than one character. With high, suggestions can differ by up to two characters. The default is none. 
        var fuzzyMatching: String? = nil
        /// The name of the index field you want to use for suggestions. 
        var sourceField: String = ""

        public init() {}

        public init(sortExpression: String? = nil, fuzzyMatching: String? = nil, sourceField: String) {
            self.sortExpression = sortExpression
            self.fuzzyMatching = fuzzyMatching
            self.sourceField = sourceField
        }

    }

    public struct DefineExpressionRequest: Serializable, Initializable {
        var domainName: String = ""
        var expression: Expression = Expression()

        public init() {}

        public init(domainName: String, expression: Expression) {
            self.domainName = domainName
            self.expression = expression
        }

    }

    public struct TextArrayOptions: Serializable, Initializable {
        /// The name of an analysis scheme for a text-array field.
        var analysisScheme: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// A list of source fields to map to the field. 
        var sourceFields: String? = nil
        /// Whether highlights can be returned for the field.
        var highlightEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(analysisScheme: String? = nil, returnEnabled: Bool? = nil, sourceFields: String? = nil, highlightEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.analysisScheme = analysisScheme
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.highlightEnabled = highlightEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DescribeDomainsResponse: Serializable, Initializable {
        var domainStatusList: [DomainStatus] = []

        public init() {}

        public init(domainStatusList: [DomainStatus]) {
            self.domainStatusList = domainStatusList
        }

    }

    public struct DeleteSuggesterResponse: Serializable, Initializable {
        /// The status of the suggester being deleted.
        var suggester: SuggesterStatus = SuggesterStatus()

        public init() {}

        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

    }

    public struct DefineIndexFieldRequest: Serializable, Initializable {
        /// The index field and field options you want to configure. 
        var indexField: IndexField = IndexField()
        var domainName: String = ""

        public init() {}

        public init(indexField: IndexField, domainName: String) {
            self.indexField = indexField
            self.domainName = domainName
        }

    }

    public struct DefineAnalysisSchemeRequest: Serializable, Initializable {
        var analysisScheme: AnalysisScheme = AnalysisScheme()
        var domainName: String = ""

        public init() {}

        public init(analysisScheme: AnalysisScheme, domainName: String) {
            self.analysisScheme = analysisScheme
            self.domainName = domainName
        }

    }

    public struct DeleteDomainRequest: Serializable, Initializable {
        /// The name of the domain you want to permanently delete.
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

    public struct IndexDocumentsRequest: Serializable, Initializable {
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

    public struct DeleteExpressionRequest: Serializable, Initializable {
        /// The name of the Expression to delete.
        var expressionName: String = ""
        var domainName: String = ""

        public init() {}

        public init(expressionName: String, domainName: String) {
            self.expressionName = expressionName
            self.domainName = domainName
        }

    }

    public struct IndexFieldStatus: Serializable, Initializable {
        var options: IndexField = IndexField()
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: IndexField, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct DeleteAnalysisSchemeRequest: Serializable, Initializable {
        /// The name of the analysis scheme you want to delete.
        var analysisSchemeName: String = ""
        var domainName: String = ""

        public init() {}

        public init(analysisSchemeName: String, domainName: String) {
            self.analysisSchemeName = analysisSchemeName
            self.domainName = domainName
        }

    }

    public struct ScalingParametersStatus: Serializable, Initializable {
        var options: ScalingParameters = ScalingParameters()
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: ScalingParameters, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct AnalysisOptions: Serializable, Initializable {
        /// A JSON object that contains a collection of string:value pairs that each map a term to its stem. For example, {"term1": "stem1", "term2": "stem2", "term3": "stem3"}. The stemming dictionary is applied in addition to any algorithmic stemming. This enables you to override the results of the algorithmic stemming to correct specific cases of overstemming or understemming. The maximum size of a stemming dictionary is 500 KB.
        var stemmingDictionary: String? = nil
        /// A JSON array that contains a collection of terms, tokens, readings and part of speech for Japanese Tokenizaiton. The Japanese tokenization dictionary enables you to override the default tokenization for selected terms. This is only valid for Japanese language fields.
        var japaneseTokenizationDictionary: String? = nil
        /// A JSON array of terms to ignore during indexing and searching. For example, ["a", "an", "the", "of"]. The stopwords dictionary must explicitly list each word you want to ignore. Wildcards and regular expressions are not supported. 
        var stopwords: String? = nil
        /// The level of algorithmic stemming to perform: none, minimal, light, or full. The available levels vary depending on the language. For more information, see Language Specific Text Processing Settings in the Amazon CloudSearch Developer Guide 
        var algorithmicStemming: String? = nil
        /// A JSON object that defines synonym groups and aliases. A synonym group is an array of arrays, where each sub-array is a group of terms where each term in the group is considered a synonym of every other term in the group. The aliases value is an object that contains a collection of string:value pairs where the string specifies a term and the array of values specifies each of the aliases for that term. An alias is considered a synonym of the specified term, but the term is not considered a synonym of the alias. For more information about specifying synonyms, see Synonyms in the Amazon CloudSearch Developer Guide.
        var synonyms: String? = nil

        public init() {}

        public init(stemmingDictionary: String? = nil, japaneseTokenizationDictionary: String? = nil, stopwords: String? = nil, algorithmicStemming: String? = nil, synonyms: String? = nil) {
            self.stemmingDictionary = stemmingDictionary
            self.japaneseTokenizationDictionary = japaneseTokenizationDictionary
            self.stopwords = stopwords
            self.algorithmicStemming = algorithmicStemming
            self.synonyms = synonyms
        }

    }

    public struct UpdateServiceAccessPoliciesRequest: Serializable, Initializable {
        /// The access rules you want to configure. These rules replace any existing rules. 
        var accessPolicies: String = ""
        var domainName: String = ""

        public init() {}

        public init(accessPolicies: String, domainName: String) {
            self.accessPolicies = accessPolicies
            self.domainName = domainName
        }

    }

    public struct DateArrayOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// A list of source fields to map to the field. 
        var sourceFields: String? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DeleteAnalysisSchemeResponse: Serializable, Initializable {
        /// The status of the analysis scheme being deleted.
        var analysisScheme: AnalysisSchemeStatus = AnalysisSchemeStatus()

        public init() {}

        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

    }

    public struct BuildSuggestersResponse: Serializable, Initializable {
        var fieldNames: [String]? = nil

        public init() {}

        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

    }

    public struct AnalysisSchemeStatus: Serializable, Initializable {
        var options: AnalysisScheme = AnalysisScheme()
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: AnalysisScheme, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct AccessPoliciesStatus: Serializable, Initializable {
        var options: String = ""
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct TextOptions: Serializable, Initializable {
        /// The name of an analysis scheme for a text field.
        var analysisScheme: String? = nil
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        var sourceField: String? = nil
        /// Whether highlights can be returned for the field.
        var highlightEnabled: Bool? = nil
        /// Whether the field can be used to sort the search results.
        var sortEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(analysisScheme: String? = nil, returnEnabled: Bool? = nil, sourceField: String? = nil, highlightEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.analysisScheme = analysisScheme
            self.returnEnabled = returnEnabled
            self.sourceField = sourceField
            self.highlightEnabled = highlightEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct IndexDocumentsResponse: Serializable, Initializable {
        /// The names of the fields that are currently being indexed.
        var fieldNames: [String]? = nil

        public init() {}

        public init(fieldNames: [String]? = nil) {
            self.fieldNames = fieldNames
        }

    }

    public struct DefineExpressionResponse: Serializable, Initializable {
        var expression: ExpressionStatus = ExpressionStatus()

        public init() {}

        public init(expression: ExpressionStatus) {
            self.expression = expression
        }

    }

    public struct UpdateAvailabilityOptionsResponse: Serializable, Initializable {
        /// The newly-configured availability options. Indicates whether Multi-AZ is enabled for the domain. 
        var availabilityOptions: AvailabilityOptionsStatus? = nil

        public init() {}

        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

    }

    public struct LiteralArrayOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// A list of source fields to map to the field. 
        var sourceFields: String? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct IntArrayOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// A list of source fields to map to the field. 
        var sourceFields: String? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: Int64? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, sourceFields: String? = nil, facetEnabled: Bool? = nil, searchEnabled: Bool? = nil, defaultValue: Int64? = nil) {
            self.returnEnabled = returnEnabled
            self.sourceFields = sourceFields
            self.facetEnabled = facetEnabled
            self.searchEnabled = searchEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DescribeAnalysisSchemesResponse: Serializable, Initializable {
        /// The analysis scheme descriptions.
        var analysisSchemes: [AnalysisSchemeStatus] = []

        public init() {}

        public init(analysisSchemes: [AnalysisSchemeStatus]) {
            self.analysisSchemes = analysisSchemes
        }

    }

    public struct DescribeExpressionsResponse: Serializable, Initializable {
        /// The expressions configured for the domain.
        var expressions: [ExpressionStatus] = []

        public init() {}

        public init(expressions: [ExpressionStatus]) {
            self.expressions = expressions
        }

    }

    public struct Expression: Serializable, Initializable {
        var expressionValue: String = ""
        var expressionName: String = ""

        public init() {}

        public init(expressionValue: String, expressionName: String) {
            self.expressionValue = expressionValue
            self.expressionName = expressionName
        }

    }

    public struct SuggesterStatus: Serializable, Initializable {
        var options: Suggester = Suggester()
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: Suggester, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct DescribeSuggestersRequest: Serializable, Initializable {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        var deployed: Bool? = nil
        /// The suggesters you want to describe.
        var suggesterNames: [String]? = nil
        /// The name of the domain you want to describe.
        var domainName: String = ""

        public init() {}

        public init(deployed: Bool? = nil, suggesterNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.suggesterNames = suggesterNames
            self.domainName = domainName
        }

    }

    public struct IndexField: Serializable, Initializable {
        var intOptions: IntOptions? = nil
        var dateOptions: DateOptions? = nil
        var textArrayOptions: TextArrayOptions? = nil
        var doubleOptions: DoubleOptions? = nil
        var literalArrayOptions: LiteralArrayOptions? = nil
        var intArrayOptions: IntArrayOptions? = nil
        var indexFieldType: String = ""
        /// A string that represents the name of an index field. CloudSearch supports regular index fields as well as dynamic fields. A dynamic field's name defines a pattern that begins or ends with a wildcard. Any document fields that don't map to a regular index field but do match a dynamic field's pattern are configured with the dynamic field's indexing options.  Regular field names begin with a letter and can contain the following characters: a-z (lowercase), 0-9, and _ (underscore). Dynamic field names must begin or end with a wildcard (*). The wildcard can also be the only character in a dynamic field name. Multiple wildcards, and wildcards embedded within a string are not supported.  The name score is reserved and cannot be used as a field name. To reference a document's ID, you can use the name _id. 
        var indexFieldName: String = ""
        var dateArrayOptions: DateArrayOptions? = nil
        var literalOptions: LiteralOptions? = nil
        var latLonOptions: LatLonOptions? = nil
        var textOptions: TextOptions? = nil
        var doubleArrayOptions: DoubleArrayOptions? = nil

        public init() {}

        public init(intOptions: IntOptions? = nil, dateOptions: DateOptions? = nil, textArrayOptions: TextArrayOptions? = nil, doubleOptions: DoubleOptions? = nil, literalArrayOptions: LiteralArrayOptions? = nil, intArrayOptions: IntArrayOptions? = nil, indexFieldType: String, indexFieldName: String, dateArrayOptions: DateArrayOptions? = nil, literalOptions: LiteralOptions? = nil, latLonOptions: LatLonOptions? = nil, textOptions: TextOptions? = nil, doubleArrayOptions: DoubleArrayOptions? = nil) {
            self.intOptions = intOptions
            self.dateOptions = dateOptions
            self.textArrayOptions = textArrayOptions
            self.doubleOptions = doubleOptions
            self.literalArrayOptions = literalArrayOptions
            self.intArrayOptions = intArrayOptions
            self.indexFieldType = indexFieldType
            self.indexFieldName = indexFieldName
            self.dateArrayOptions = dateArrayOptions
            self.literalOptions = literalOptions
            self.latLonOptions = latLonOptions
            self.textOptions = textOptions
            self.doubleArrayOptions = doubleArrayOptions
        }

    }

    public struct LatLonOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        var sourceField: String? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// Whether the field can be used to sort the search results.
        var sortEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DescribeExpressionsRequest: Serializable, Initializable {
        /// Whether to display the deployed configuration (true) or include any pending changes (false). Defaults to false.
        var deployed: Bool? = nil
        /// Limits the DescribeExpressions response to the specified expressions. If not specified, all expressions are shown.
        var expressionNames: [String]? = nil
        /// The name of the domain you want to describe.
        var domainName: String = ""

        public init() {}

        public init(deployed: Bool? = nil, expressionNames: [String]? = nil, domainName: String) {
            self.deployed = deployed
            self.expressionNames = expressionNames
            self.domainName = domainName
        }

    }

    public struct DoubleOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        /// The name of the source field to map to the field. 
        var sourceField: String? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// Whether the field can be used to sort the search results.
        var sortEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document. This can be important if you are using the field in an expression and that field is not present in every document.
        var defaultValue: Double? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: Double? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct DateOptions: Serializable, Initializable {
        /// Whether the contents of the field can be returned in the search results.
        var returnEnabled: Bool? = nil
        /// Whether facet information can be returned for the field.
        var facetEnabled: Bool? = nil
        var sourceField: String? = nil
        /// Whether the contents of the field are searchable.
        var searchEnabled: Bool? = nil
        /// Whether the field can be used to sort the search results.
        var sortEnabled: Bool? = nil
        /// A value to use for the field if the field isn't specified for a document.
        var defaultValue: String? = nil

        public init() {}

        public init(returnEnabled: Bool? = nil, facetEnabled: Bool? = nil, sourceField: String? = nil, searchEnabled: Bool? = nil, sortEnabled: Bool? = nil, defaultValue: String? = nil) {
            self.returnEnabled = returnEnabled
            self.facetEnabled = facetEnabled
            self.sourceField = sourceField
            self.searchEnabled = searchEnabled
            self.sortEnabled = sortEnabled
            self.defaultValue = defaultValue
        }

    }

    public struct UpdateAvailabilityOptionsRequest: Serializable, Initializable {
        /// You expand an existing search domain to a second Availability Zone by setting the Multi-AZ option to true. Similarly, you can turn off the Multi-AZ option to downgrade the domain to a single Availability Zone by setting the Multi-AZ option to false. 
        var multiAZ: Bool = false
        var domainName: String = ""

        public init() {}

        public init(multiAZ: Bool, domainName: String) {
            self.multiAZ = multiAZ
            self.domainName = domainName
        }

    }

    public struct DescribeServiceAccessPoliciesResponse: Serializable, Initializable {
        /// The access rules configured for the domain specified in the request.
        var accessPolicies: AccessPoliciesStatus = AccessPoliciesStatus()

        public init() {}

        public init(accessPolicies: AccessPoliciesStatus) {
            self.accessPolicies = accessPolicies
        }

    }

    public struct BuildSuggestersRequest: Serializable, Initializable {
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

    public struct AvailabilityOptionsStatus: Serializable, Initializable {
        /// The availability options configured for the domain.
        var options: Bool = false
        var status: OptionStatus = OptionStatus()

        public init() {}

        public init(options: Bool, status: OptionStatus) {
            self.options = options
            self.status = status
        }

    }

    public struct ServiceEndpoint: Serializable, Initializable {
        var endpoint: String? = nil

        public init() {}

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

    }

    public struct DeleteSuggesterRequest: Serializable, Initializable {
        /// Specifies the name of the suggester you want to delete.
        var suggesterName: String = ""
        var domainName: String = ""

        public init() {}

        public init(suggesterName: String, domainName: String) {
            self.suggesterName = suggesterName
            self.domainName = domainName
        }

    }

    public struct Limits: Serializable, Initializable {
        var maximumReplicationCount: Int32 = 0
        var maximumPartitionCount: Int32 = 0

        public init() {}

        public init(maximumReplicationCount: Int32, maximumPartitionCount: Int32) {
            self.maximumReplicationCount = maximumReplicationCount
            self.maximumPartitionCount = maximumPartitionCount
        }

    }

    public struct DescribeIndexFieldsResponse: Serializable, Initializable {
        /// The index fields configured for the domain.
        var indexFields: [IndexFieldStatus] = []

        public init() {}

        public init(indexFields: [IndexFieldStatus]) {
            self.indexFields = indexFields
        }

    }

    public struct UpdateScalingParametersRequest: Serializable, Initializable {
        var scalingParameters: ScalingParameters = ScalingParameters()
        var domainName: String = ""

        public init() {}

        public init(scalingParameters: ScalingParameters, domainName: String) {
            self.scalingParameters = scalingParameters
            self.domainName = domainName
        }

    }

    public struct DefineAnalysisSchemeResponse: Serializable, Initializable {
        var analysisScheme: AnalysisSchemeStatus = AnalysisSchemeStatus()

        public init() {}

        public init(analysisScheme: AnalysisSchemeStatus) {
            self.analysisScheme = analysisScheme
        }

    }

    public struct DefineSuggesterResponse: Serializable, Initializable {
        var suggester: SuggesterStatus = SuggesterStatus()

        public init() {}

        public init(suggester: SuggesterStatus) {
            self.suggester = suggester
        }

    }

    public struct DefineIndexFieldResponse: Serializable, Initializable {
        var indexField: IndexFieldStatus = IndexFieldStatus()

        public init() {}

        public init(indexField: IndexFieldStatus) {
            self.indexField = indexField
        }

    }

    public struct DescribeSuggestersResponse: Serializable, Initializable {
        /// The suggesters configured for the domain specified in the request.
        var suggesters: [SuggesterStatus] = []

        public init() {}

        public init(suggesters: [SuggesterStatus]) {
            self.suggesters = suggesters
        }

    }

    public struct DescribeAvailabilityOptionsResponse: Serializable, Initializable {
        /// The availability options configured for the domain. Indicates whether Multi-AZ is enabled for the domain. 
        var availabilityOptions: AvailabilityOptionsStatus? = nil

        public init() {}

        public init(availabilityOptions: AvailabilityOptionsStatus? = nil) {
            self.availabilityOptions = availabilityOptions
        }

    }

    public struct CreateDomainRequest: Serializable, Initializable {
        /// A name for the domain you are creating. Allowed characters are a-z (lower-case letters), 0-9, and hyphen (-). Domain names must start with a letter or number and be at least 3 and no more than 28 characters long.
        var domainName: String = ""

        public init() {}

        public init(domainName: String) {
            self.domainName = domainName
        }

    }

}