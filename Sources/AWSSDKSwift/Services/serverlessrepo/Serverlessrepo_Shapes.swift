// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Serverlessrepo {

    public struct ListApplicationsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Applications", location: .body(locationName: "applications"), required: false, type: .list)
        ]
        public let nextToken: String?
        public let applications: [ApplicationSummary]?

        public init(nextToken: String? = nil, applications: [ApplicationSummary]? = nil) {
            self.nextToken = nextToken
            self.applications = applications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case applications = "applications"
        }
    }

    public struct GetApplicationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Version", location: .body(locationName: "version"), required: false, type: .structure), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseUrl", location: .body(locationName: "licenseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        public let labels: [String]?
        public let author: String?
        public let name: String?
        public let readmeUrl: String?
        public let version: Version?
        public let spdxLicenseId: String?
        public let creationTime: String?
        public let licenseUrl: String?
        public let applicationId: String?
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, name: String? = nil, readmeUrl: String? = nil, version: Version? = nil, spdxLicenseId: String? = nil, creationTime: String? = nil, licenseUrl: String? = nil, applicationId: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.name = name
            self.readmeUrl = readmeUrl
            self.version = version
            self.spdxLicenseId = spdxLicenseId
            self.creationTime = creationTime
            self.licenseUrl = licenseUrl
            self.applicationId = applicationId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case version = "version"
            case spdxLicenseId = "spdxLicenseId"
            case creationTime = "creationTime"
            case licenseUrl = "licenseUrl"
            case applicationId = "applicationId"
            case description = "description"
        }
    }

    public struct ChangeSetDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "StackId", location: .body(locationName: "stackId"), required: false, type: .string), 
            AWSShapeMember(label: "ChangeSetId", location: .body(locationName: "changeSetId"), required: false, type: .string)
        ]
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The semantic version of the application:\n\n https://semver.org/
        public let semanticVersion: String?
        /// The unique ID of the stack.
        public let stackId: String?
        /// The ARN of the change set.\nLength Constraints: Minimum length of 1.\nPattern: arn:[-a-zA-Z0-9:/]*
        public let changeSetId: String?

        public init(applicationId: String? = nil, semanticVersion: String? = nil, stackId: String? = nil, changeSetId: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.stackId = stackId
            self.changeSetId = changeSetId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
            case stackId = "stackId"
            case changeSetId = "changeSetId"
        }
    }

    public struct UpdateApplicationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Version", location: .body(locationName: "version"), required: false, type: .structure), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseUrl", location: .body(locationName: "licenseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        public let labels: [String]?
        public let author: String?
        public let name: String?
        public let readmeUrl: String?
        public let version: Version?
        public let spdxLicenseId: String?
        public let creationTime: String?
        public let licenseUrl: String?
        public let applicationId: String?
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, name: String? = nil, readmeUrl: String? = nil, version: Version? = nil, spdxLicenseId: String? = nil, creationTime: String? = nil, licenseUrl: String? = nil, applicationId: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.name = name
            self.readmeUrl = readmeUrl
            self.version = version
            self.spdxLicenseId = spdxLicenseId
            self.creationTime = creationTime
            self.licenseUrl = licenseUrl
            self.applicationId = applicationId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case version = "version"
            case spdxLicenseId = "spdxLicenseId"
            case creationTime = "creationTime"
            case licenseUrl = "licenseUrl"
            case applicationId = "applicationId"
            case description = "description"
        }
    }

    public struct GetApplicationPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string)
        ]
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
        }
    }

    public struct ParameterDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllowedValues", location: .body(locationName: "allowedValues"), required: false, type: .list), 
            AWSShapeMember(label: "MinValue", location: .body(locationName: "minValue"), required: false, type: .integer), 
            AWSShapeMember(label: "MinLength", location: .body(locationName: "minLength"), required: false, type: .integer), 
            AWSShapeMember(label: "AllowedPattern", location: .body(locationName: "allowedPattern"), required: false, type: .string), 
            AWSShapeMember(label: "DefaultValue", location: .body(locationName: "defaultValue"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "MaxValue", location: .body(locationName: "maxValue"), required: false, type: .integer), 
            AWSShapeMember(label: "NoEcho", location: .body(locationName: "noEcho"), required: false, type: .boolean), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "MaxLength", location: .body(locationName: "maxLength"), required: false, type: .integer), 
            AWSShapeMember(label: "ReferencedByResources", location: .body(locationName: "referencedByResources"), required: false, type: .list), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .string), 
            AWSShapeMember(label: "ConstraintDescription", location: .body(locationName: "constraintDescription"), required: false, type: .string)
        ]
        /// Array containing the list of values allowed for the parameter.
        public let allowedValues: [String]?
        /// A numeric value that determines the smallest numeric value you want to allow for Number types.
        public let minValue: Int32?
        /// An integer value that determines the smallest number of characters you want to allow for String types.
        public let minLength: Int32?
        /// A regular expression that represents the patterns to allow for String types.
        public let allowedPattern: String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created.\n If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public let defaultValue: String?
        /// A string of up to 4,000 characters that describes the parameter.
        public let description: String?
        /// A numeric value that determines the largest numeric value you want to allow for Number types.
        public let maxValue: Int32?
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the\n value to true, the parameter value is masked with asterisks (*****).
        public let noEcho: Bool?
        /// The name of the parameter.
        public let name: String?
        /// An integer value that determines the largest number of characters you want to allow for String types.
        public let maxLength: Int32?
        /// A list of SAM resources that use this parameter.
        public let referencedByResources: [String]?
        /// The type of the parameter.\nValid values: String | Number | List | CommaDelimitedList \n \n\n String : A literal string.\nFor example, users could specify "MyUserName" .\n\n Number : An integer or float. AWS CloudFormation validates the parameter value as a number; however, when you use the\n parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.\nFor example, users could specify "8888" .\n\n List : An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers; however, when\n you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.\nFor example, users could specify "80,20", and a Ref results in ["80","20"] .\n\n CommaDelimitedList : An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas.\n Also, each member string is space-trimmed.\nFor example, users could specify "test,dev,prod", and a Ref results in ["test","dev","prod"] .
        public let `type`: String?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description,\n a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user\n specifies an invalid value:\n\n Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ \n \nBy adding a constraint description, such as "must contain only uppercase and lowercase letters, and numbers," you can display\n the following customized error message:\n\n Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        public let constraintDescription: String?

        public init(allowedValues: [String]? = nil, minValue: Int32? = nil, minLength: Int32? = nil, allowedPattern: String? = nil, defaultValue: String? = nil, description: String? = nil, maxValue: Int32? = nil, noEcho: Bool? = nil, name: String? = nil, maxLength: Int32? = nil, referencedByResources: [String]? = nil, type: String? = nil, constraintDescription: String? = nil) {
            self.allowedValues = allowedValues
            self.minValue = minValue
            self.minLength = minLength
            self.allowedPattern = allowedPattern
            self.defaultValue = defaultValue
            self.description = description
            self.maxValue = maxValue
            self.noEcho = noEcho
            self.name = name
            self.maxLength = maxLength
            self.referencedByResources = referencedByResources
            self.`type` = `type`
            self.constraintDescription = constraintDescription
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case minValue = "minValue"
            case minLength = "minLength"
            case allowedPattern = "allowedPattern"
            case defaultValue = "defaultValue"
            case description = "description"
            case maxValue = "maxValue"
            case noEcho = "noEcho"
            case name = "name"
            case maxLength = "maxLength"
            case referencedByResources = "referencedByResources"
            case `type` = "type"
            case constraintDescription = "constraintDescription"
        }
    }

    public struct Version: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "ParameterDefinitions", location: .body(locationName: "parameterDefinitions"), required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateUrl", location: .body(locationName: "templateUrl"), required: false, type: .string)
        ]
        /// A link to a public repository for the source code of your application.
        public let sourceCodeUrl: String?
        /// The date/time this resource was created.
        public let creationTime: String?
        /// Array of parameter types supported by the application.
        public let parameterDefinitions: [ParameterDefinition]?
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The semantic version of the application:\n\n https://semver.org/
        public let semanticVersion: String?
        /// A link to the packaged SAM template of your application.
        public let templateUrl: String?

        public init(sourceCodeUrl: String? = nil, creationTime: String? = nil, parameterDefinitions: [ParameterDefinition]? = nil, applicationId: String? = nil, semanticVersion: String? = nil, templateUrl: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case creationTime = "creationTime"
            case parameterDefinitions = "parameterDefinitions"
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
            case templateUrl = "templateUrl"
        }
    }

    public struct VersionSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string)
        ]
        /// A link to a public repository for the source code of your application.
        public let sourceCodeUrl: String?
        /// The date/time this resource was created.
        public let creationTime: String?
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The semantic version of the application:\n\n https://semver.org/
        public let semanticVersion: String?

        public init(sourceCodeUrl: String? = nil, creationTime: String? = nil, applicationId: String? = nil, semanticVersion: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.creationTime = creationTime
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case creationTime = "creationTime"
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
        }
    }

    public struct CreateApplicationVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .uri(locationName: "semanticVersion"), required: true, type: .string), 
            AWSShapeMember(label: "TemplateBody", location: .body(locationName: "templateBody"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateUrl", location: .body(locationName: "templateUrl"), required: false, type: .string)
        ]
        public let sourceCodeUrl: String?
        public let applicationId: String
        public let semanticVersion: String
        public let templateBody: String?
        public let templateUrl: String?

        public init(sourceCodeUrl: String? = nil, applicationId: String, semanticVersion: String, templateBody: String? = nil, templateUrl: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
            case templateBody = "templateBody"
            case templateUrl = "templateUrl"
        }
    }

    public struct CreateCloudFormationChangeSetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "StackId", location: .body(locationName: "stackId"), required: false, type: .string), 
            AWSShapeMember(label: "ChangeSetId", location: .body(locationName: "changeSetId"), required: false, type: .string)
        ]
        public let applicationId: String?
        public let semanticVersion: String?
        public let stackId: String?
        public let changeSetId: String?

        public init(applicationId: String? = nil, semanticVersion: String? = nil, stackId: String? = nil, changeSetId: String? = nil) {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.stackId = stackId
            self.changeSetId = changeSetId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
            case stackId = "stackId"
            case changeSetId = "changeSetId"
        }
    }

    public struct ApplicationPolicyStatement: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StatementId", location: .body(locationName: "statementId"), required: false, type: .string), 
            AWSShapeMember(label: "Principals", location: .body(locationName: "principals"), required: false, type: .list), 
            AWSShapeMember(label: "Actions", location: .body(locationName: "actions"), required: false, type: .list)
        ]
        /// A unique ID for the statement.
        public let statementId: String?
        /// An AWS account ID, or * to make the application public.
        public let principals: [String]?
        /// A list of supported actions:\n\n GetApplication \n \n\n CreateCloudFormationChangeSet \n \n\n ListApplicationVersions \n \n\n SearchApplications \n \n\n Deploy (Note: This action enables all other actions above.)
        public let actions: [String]?

        public init(statementId: String? = nil, principals: [String]? = nil, actions: [String]? = nil) {
            self.statementId = statementId
            self.principals = principals
            self.actions = actions
        }

        private enum CodingKeys: String, CodingKey {
            case statementId = "statementId"
            case principals = "principals"
            case actions = "actions"
        }
    }

    public struct CreateCloudFormationChangeSetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ParameterOverrides", location: .body(locationName: "parameterOverrides"), required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "StackName", location: .body(locationName: "stackName"), required: false, type: .string)
        ]
        public let parameterOverrides: [ParameterValue]?
        public let applicationId: String
        public let semanticVersion: String?
        public let stackName: String?

        public init(parameterOverrides: [ParameterValue]? = nil, applicationId: String, semanticVersion: String? = nil, stackName: String? = nil) {
            self.parameterOverrides = parameterOverrides
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case parameterOverrides = "parameterOverrides"
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
            case stackName = "stackName"
        }
    }

    public struct ApplicationVersionPage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Versions", location: .body(locationName: "versions"), required: false, type: .list)
        ]
        /// The token to request the next page of results.
        public let nextToken: String?
        /// Array of version summaries for the application.
        public let versions: [VersionSummary]?

        public init(nextToken: String? = nil, versions: [VersionSummary]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case versions = "versions"
        }
    }

    public struct Application: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Version", location: .body(locationName: "version"), required: false, type: .structure), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseUrl", location: .body(locationName: "licenseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Labels to improve discovery of apps in search results.\nMin Length=1. Max Length=127. Maximum number of labels: 10\nPattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the author publishing the app.\nMin Length=1. Max Length=127.\nPattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The name of the application.\nMin Length=1. Max Length=140\nPattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the Readme file that contains a more detailed description of the application and how it works in markdown language.\nMax size 5 MB
        public let readmeUrl: String?
        /// Version information about the application.
        public let version: Version?
        /// A valid identifier from https://spdx.org/licenses/.
        public let spdxLicenseId: String?
        /// The date/time this resource was created.
        public let creationTime: String?
        /// A link to a license file of the app that matches the spdxLicenseID of your application.\nMax size 5 MB
        public let licenseUrl: String?
        /// The application Amazon Resource Name (ARN).
        public let applicationId: String?
        /// The description of the application.\nMin Length=1. Max Length=256
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, name: String? = nil, readmeUrl: String? = nil, version: Version? = nil, spdxLicenseId: String? = nil, creationTime: String? = nil, licenseUrl: String? = nil, applicationId: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.name = name
            self.readmeUrl = readmeUrl
            self.version = version
            self.spdxLicenseId = spdxLicenseId
            self.creationTime = creationTime
            self.licenseUrl = licenseUrl
            self.applicationId = applicationId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case version = "version"
            case spdxLicenseId = "spdxLicenseId"
            case creationTime = "creationTime"
            case licenseUrl = "licenseUrl"
            case applicationId = "applicationId"
            case description = "description"
        }
    }

    public struct PutApplicationPolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Statements", location: .body(locationName: "statements"), required: false, type: .list)
        ]
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
        }
    }

    public struct CreateApplicationVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "ParameterDefinitions", location: .body(locationName: "parameterDefinitions"), required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateUrl", location: .body(locationName: "templateUrl"), required: false, type: .string)
        ]
        public let sourceCodeUrl: String?
        public let creationTime: String?
        public let parameterDefinitions: [ParameterDefinition]?
        public let applicationId: String?
        public let semanticVersion: String?
        public let templateUrl: String?

        public init(sourceCodeUrl: String? = nil, creationTime: String? = nil, parameterDefinitions: [ParameterDefinition]? = nil, applicationId: String? = nil, semanticVersion: String? = nil, templateUrl: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case creationTime = "creationTime"
            case parameterDefinitions = "parameterDefinitions"
            case applicationId = "applicationId"
            case semanticVersion = "semanticVersion"
            case templateUrl = "templateUrl"
        }
    }

    public struct CreateApplicationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Version", location: .body(locationName: "version"), required: false, type: .structure), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseUrl", location: .body(locationName: "licenseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        public let labels: [String]?
        public let author: String?
        public let name: String?
        public let readmeUrl: String?
        public let version: Version?
        public let spdxLicenseId: String?
        public let creationTime: String?
        public let licenseUrl: String?
        public let applicationId: String?
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, name: String? = nil, readmeUrl: String? = nil, version: Version? = nil, spdxLicenseId: String? = nil, creationTime: String? = nil, licenseUrl: String? = nil, applicationId: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.name = name
            self.readmeUrl = readmeUrl
            self.version = version
            self.spdxLicenseId = spdxLicenseId
            self.creationTime = creationTime
            self.licenseUrl = licenseUrl
            self.applicationId = applicationId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case version = "version"
            case spdxLicenseId = "spdxLicenseId"
            case creationTime = "creationTime"
            case licenseUrl = "licenseUrl"
            case applicationId = "applicationId"
            case description = "description"
        }
    }

    public struct UpdateApplicationInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeBody", location: .body(locationName: "readmeBody"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Labels to improve discovery of apps in search results.\nMin Length=1. Max Length=127. Maximum number of labels: 10\nPattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the author publishing the app.\nMin Length=1. Max Length=127.\nPattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// A raw text Readme file that contains a more detailed description of the application and how it works in markdown language.\nMax size 5 MB
        public let readmeBody: String?
        /// A link to the Readme file that contains a more detailed description of the application and how it works in markdown language.\nMax size 5 MB
        public let readmeUrl: String?
        /// The description of the application.\nMin Length=1. Max Length=256
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, readmeBody: String? = nil, readmeUrl: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case readmeBody = "readmeBody"
            case readmeUrl = "readmeUrl"
            case description = "description"
        }
    }

    public struct GetApplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SemanticVersion", location: .querystring(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string)
        ]
        public let semanticVersion: String?
        public let applicationId: String

        public init(semanticVersion: String? = nil, applicationId: String) {
            self.semanticVersion = semanticVersion
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case semanticVersion = "semanticVersion"
            case applicationId = "applicationId"
        }
    }

    public struct PutApplicationPolicyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Statements", location: .body(locationName: "statements"), required: false, type: .list), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string)
        ]
        public let statements: [ApplicationPolicyStatement]?
        public let applicationId: String

        public init(statements: [ApplicationPolicyStatement]? = nil, applicationId: String) {
            self.statements = statements
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
            case applicationId = "applicationId"
        }
    }

    public struct CreateCloudFormationChangeSetInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "StackName", location: .body(locationName: "stackName"), required: false, type: .string), 
            AWSShapeMember(label: "ParameterOverrides", location: .body(locationName: "parameterOverrides"), required: false, type: .list)
        ]
        /// The semantic version of the application:\n\n https://semver.org/
        public let semanticVersion: String?
        /// The name or the unique ID of the stack for which you are creating a change set. AWS CloudFormation generates\n the change set by comparing this stack's information with the information that you submit, such as a modified\n template or different parameter input values. \nConstraints: Minimum length of 1.\nPattern: ([a-zA-Z][-a-zA-Z0-9]*)|(arn:\b(aws|aws-us-gov|aws-cn)\b:[-a-zA-Z0-9:/._+]*)
        public let stackName: String?
        /// A list of parameter values for the parameters of the application.
        public let parameterOverrides: [ParameterValue]?

        public init(semanticVersion: String? = nil, stackName: String? = nil, parameterOverrides: [ParameterValue]? = nil) {
            self.semanticVersion = semanticVersion
            self.stackName = stackName
            self.parameterOverrides = parameterOverrides
        }

        private enum CodingKeys: String, CodingKey {
            case semanticVersion = "semanticVersion"
            case stackName = "stackName"
            case parameterOverrides = "parameterOverrides"
        }
    }

    public struct ListApplicationVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "MaxItems", location: .querystring(locationName: "maxItems"), required: false, type: .integer), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string)
        ]
        public let nextToken: String?
        public let maxItems: Int32?
        public let applicationId: String

        public init(nextToken: String? = nil, maxItems: Int32? = nil, applicationId: String) {
            self.nextToken = nextToken
            self.maxItems = maxItems
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxItems = "maxItems"
            case applicationId = "applicationId"
        }
    }

    public struct ApplicationPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Statements", location: .body(locationName: "statements"), required: false, type: .list)
        ]
        /// Array of policy statements applied to the application.
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
        }
    }

    public struct CreateApplicationInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeBody", location: .body(locationName: "readmeBody"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseUrl", location: .body(locationName: "licenseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseBody", location: .body(locationName: "licenseBody"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateBody", location: .body(locationName: "templateBody"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateUrl", location: .body(locationName: "templateUrl"), required: false, type: .string)
        ]
        /// A link to a public repository for the source code of your application.
        public let sourceCodeUrl: String?
        /// Labels to improve discovery of apps in search results.\nMin Length=1. Max Length=127. Maximum number of labels: 10\nPattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the author publishing the app.\nMin Length=1. Max Length=127.\nPattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// A raw text Readme file that contains a more detailed description of the application and how it works in markdown language.\nMax size 5 MB
        public let readmeBody: String?
        /// A link to a license file of the app that matches the spdxLicenseID of your application.\nMax size 5 MB
        public let licenseUrl: String?
        /// The semantic version of the application:\n\n https://semver.org/
        public let semanticVersion: String?
        /// The description of the application.\nMin Length=1. Max Length=256
        public let description: String?
        /// A raw text file that contains the license of the app that matches the spdxLicenseID of your application.\nMax size 5 MB
        public let licenseBody: String?
        /// The name of the application you want to publish.\nMin Length=1. Max Length=140\nPattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A link to the Readme file that contains a more detailed description of the application and how it works in markdown language.\nMax size 5 MB
        public let readmeUrl: String?
        /// A valid identifier from https://spdx.org/licenses/ .
        public let spdxLicenseId: String?
        /// The raw packaged SAM template of your application.
        public let templateBody: String?
        /// A link to the packaged SAM template of your application.
        public let templateUrl: String?

        public init(sourceCodeUrl: String? = nil, labels: [String]? = nil, author: String? = nil, readmeBody: String? = nil, licenseUrl: String? = nil, semanticVersion: String? = nil, description: String? = nil, licenseBody: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.labels = labels
            self.author = author
            self.readmeBody = readmeBody
            self.licenseUrl = licenseUrl
            self.semanticVersion = semanticVersion
            self.description = description
            self.licenseBody = licenseBody
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case labels = "labels"
            case author = "author"
            case readmeBody = "readmeBody"
            case licenseUrl = "licenseUrl"
            case semanticVersion = "semanticVersion"
            case description = "description"
            case licenseBody = "licenseBody"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case spdxLicenseId = "spdxLicenseId"
            case templateBody = "templateBody"
            case templateUrl = "templateUrl"
        }
    }

    public struct ListApplicationsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "MaxItems", location: .querystring(locationName: "maxItems"), required: false, type: .integer)
        ]
        public let nextToken: String?
        public let maxItems: Int32?

        public init(nextToken: String? = nil, maxItems: Int32? = nil) {
            self.nextToken = nextToken
            self.maxItems = maxItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxItems = "maxItems"
        }
    }

    public struct CreateApplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeBody", location: .body(locationName: "readmeBody"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseUrl", location: .body(locationName: "licenseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "SemanticVersion", location: .body(locationName: "semanticVersion"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "LicenseBody", location: .body(locationName: "licenseBody"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateBody", location: .body(locationName: "templateBody"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateUrl", location: .body(locationName: "templateUrl"), required: false, type: .string)
        ]
        public let sourceCodeUrl: String?
        public let labels: [String]?
        public let author: String?
        public let readmeBody: String?
        public let licenseUrl: String?
        public let semanticVersion: String?
        public let description: String?
        public let licenseBody: String?
        public let name: String?
        public let readmeUrl: String?
        public let spdxLicenseId: String?
        public let templateBody: String?
        public let templateUrl: String?

        public init(sourceCodeUrl: String? = nil, labels: [String]? = nil, author: String? = nil, readmeBody: String? = nil, licenseUrl: String? = nil, semanticVersion: String? = nil, description: String? = nil, licenseBody: String? = nil, name: String? = nil, readmeUrl: String? = nil, spdxLicenseId: String? = nil, templateBody: String? = nil, templateUrl: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.labels = labels
            self.author = author
            self.readmeBody = readmeBody
            self.licenseUrl = licenseUrl
            self.semanticVersion = semanticVersion
            self.description = description
            self.licenseBody = licenseBody
            self.name = name
            self.readmeUrl = readmeUrl
            self.spdxLicenseId = spdxLicenseId
            self.templateBody = templateBody
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case labels = "labels"
            case author = "author"
            case readmeBody = "readmeBody"
            case licenseUrl = "licenseUrl"
            case semanticVersion = "semanticVersion"
            case description = "description"
            case licenseBody = "licenseBody"
            case name = "name"
            case readmeUrl = "readmeUrl"
            case spdxLicenseId = "spdxLicenseId"
            case templateBody = "templateBody"
            case templateUrl = "templateUrl"
        }
    }

    public struct ApplicationPage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Applications", location: .body(locationName: "applications"), required: false, type: .list)
        ]
        /// The token to request the next page of results.
        public let nextToken: String?
        /// Array of application summaries.
        public let applications: [ApplicationSummary]?

        public init(nextToken: String? = nil, applications: [ApplicationSummary]? = nil) {
            self.nextToken = nextToken
            self.applications = applications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case applications = "applications"
        }
    }

    public struct GetApplicationPolicyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Statements", location: .body(locationName: "statements"), required: false, type: .list)
        ]
        public let statements: [ApplicationPolicyStatement]?

        public init(statements: [ApplicationPolicyStatement]? = nil) {
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case statements = "statements"
        }
    }

    public struct CreateApplicationVersionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceCodeUrl", location: .body(locationName: "sourceCodeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateUrl", location: .body(locationName: "templateUrl"), required: false, type: .string), 
            AWSShapeMember(label: "TemplateBody", location: .body(locationName: "templateBody"), required: false, type: .string)
        ]
        /// A link to a public repository for the source code of your application.
        public let sourceCodeUrl: String?
        /// A link to the packaged SAM template of your application.
        public let templateUrl: String?
        /// The raw packaged SAM template of your application.
        public let templateBody: String?

        public init(sourceCodeUrl: String? = nil, templateUrl: String? = nil, templateBody: String? = nil) {
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
            self.templateBody = templateBody
        }

        private enum CodingKeys: String, CodingKey {
            case sourceCodeUrl = "sourceCodeUrl"
            case templateUrl = "templateUrl"
            case templateBody = "templateBody"
        }
    }

    public struct ApplicationSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "SpdxLicenseId", location: .body(locationName: "spdxLicenseId"), required: false, type: .string), 
            AWSShapeMember(label: "CreationTime", location: .body(locationName: "creationTime"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .body(locationName: "applicationId"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Labels to improve discovery of apps in search results.\nMin Length=1. Max Length=127. Maximum number of labels: 10\nPattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public let labels: [String]?
        /// The name of the author publishing the app\nMin Length=1. Max Length=127.\nPattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        public let author: String?
        /// The name of the application.\nMin Length=1. Max Length=140\nPattern: "[a-zA-Z0-9\\-]+";
        public let name: String?
        /// A valid identifier from https://spdx.org/licenses/ .
        public let spdxLicenseId: String?
        /// The date/time this resource was created.
        public let creationTime: String?
        /// The application ARN.
        public let applicationId: String?
        /// The description of the application.\nMin Length=1. Max Length=256
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, name: String? = nil, spdxLicenseId: String? = nil, creationTime: String? = nil, applicationId: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.name = name
            self.spdxLicenseId = spdxLicenseId
            self.creationTime = creationTime
            self.applicationId = applicationId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case name = "name"
            case spdxLicenseId = "spdxLicenseId"
            case creationTime = "creationTime"
            case applicationId = "applicationId"
            case description = "description"
        }
    }

    public struct ListApplicationVersionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Versions", location: .body(locationName: "versions"), required: false, type: .list)
        ]
        public let nextToken: String?
        public let versions: [VersionSummary]?

        public init(nextToken: String? = nil, versions: [VersionSummary]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case versions = "versions"
        }
    }

    public struct UpdateApplicationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Labels", location: .body(locationName: "labels"), required: false, type: .list), 
            AWSShapeMember(label: "Author", location: .body(locationName: "author"), required: false, type: .string), 
            AWSShapeMember(label: "ApplicationId", location: .uri(locationName: "applicationId"), required: true, type: .string), 
            AWSShapeMember(label: "ReadmeBody", location: .body(locationName: "readmeBody"), required: false, type: .string), 
            AWSShapeMember(label: "ReadmeUrl", location: .body(locationName: "readmeUrl"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        public let labels: [String]?
        public let author: String?
        public let applicationId: String
        public let readmeBody: String?
        public let readmeUrl: String?
        public let description: String?

        public init(labels: [String]? = nil, author: String? = nil, applicationId: String, readmeBody: String? = nil, readmeUrl: String? = nil, description: String? = nil) {
            self.labels = labels
            self.author = author
            self.applicationId = applicationId
            self.readmeBody = readmeBody
            self.readmeUrl = readmeUrl
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case labels = "labels"
            case author = "author"
            case applicationId = "applicationId"
            case readmeBody = "readmeBody"
            case readmeUrl = "readmeUrl"
            case description = "description"
        }
    }

    public struct ParameterValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", location: .body(locationName: "value"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string)
        ]
        /// The input value associated with the parameter.
        public let value: String?
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation\n uses the default value that is specified in your template.
        public let name: String?

        public init(value: String? = nil, name: String? = nil) {
            self.value = value
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
            case name = "name"
        }
    }

}