// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension S3 {

    public struct DeleteBucketWebsiteRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct MetricsAndOperator: Serializable, Initializable {
        /// The list of tags used when evaluating an AND predicate.
        var tags: [Tag]? = nil
        /// The prefix used when evaluating an AND predicate.
        var prefix: String? = nil

        public init() {}

        public init(tags: [Tag]? = nil, prefix: String? = nil) {
            self.tags = tags
            self.prefix = prefix
        }

    }

    public struct LifecycleExpiration: Serializable, Initializable {
        /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        var expiredObjectDeleteMarker: Bool? = nil
        /// Indicates at what date the object is to be moved or deleted. Should be in GMT ISO 8601 Format.
        var date: Date? = nil
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        var days: Int32? = nil

        public init() {}

        public init(expiredObjectDeleteMarker: Bool? = nil, date: Date? = nil, days: Int32? = nil) {
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
            self.date = date
            self.days = days
        }

    }

    public struct PutBucketCorsRequest: Serializable, Initializable {
        var bucket: String = ""
        var cORSConfiguration: CORSConfiguration = CORSConfiguration()
        var contentMD5: String? = nil

        public init() {}

        public init(bucket: String, cORSConfiguration: CORSConfiguration, contentMD5: String? = nil) {
            self.bucket = bucket
            self.cORSConfiguration = cORSConfiguration
            self.contentMD5 = contentMD5
        }

    }

    public struct DeleteBucketCorsRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct Rule: Serializable, Initializable {
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        var iD: String? = nil
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        var status: String = ""
        var abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil
        var noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil
        var transition: Transition? = nil
        var noncurrentVersionTransition: NoncurrentVersionTransition? = nil
        var expiration: LifecycleExpiration? = nil
        /// Prefix identifying one or more objects to which the rule applies.
        var prefix: String = ""

        public init() {}

        public init(iD: String? = nil, status: String, abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil, noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil, transition: Transition? = nil, noncurrentVersionTransition: NoncurrentVersionTransition? = nil, expiration: LifecycleExpiration? = nil, prefix: String) {
            self.iD = iD
            self.status = status
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.transition = transition
            self.noncurrentVersionTransition = noncurrentVersionTransition
            self.expiration = expiration
            self.prefix = prefix
        }

    }

    public struct GetBucketReplicationRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct GetBucketLifecycleConfigurationRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct LifecycleRuleAndOperator: Serializable, Initializable {
        /// All of these tags must exist in the object's tag set in order for the rule to apply.
        var tags: [Tag]? = nil
        var prefix: String? = nil

        public init() {}

        public init(tags: [Tag]? = nil, prefix: String? = nil) {
            self.tags = tags
            self.prefix = prefix
        }

    }

    public struct GetBucketPolicyRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct CopyObjectResult: Serializable, Initializable {
        var eTag: String? = nil
        var lastModified: Date? = nil

        public init() {}

        public init(eTag: String? = nil, lastModified: Date? = nil) {
            self.eTag = eTag
            self.lastModified = lastModified
        }

    }

    public struct PutBucketAccelerateConfigurationRequest: Serializable, Initializable {
        /// Name of the bucket for which the accelerate configuration is set.
        var bucket: String = ""
        /// Specifies the Accelerate Configuration you want to set for the bucket.
        var accelerateConfiguration: AccelerateConfiguration = AccelerateConfiguration()

        public init() {}

        public init(bucket: String, accelerateConfiguration: AccelerateConfiguration) {
            self.bucket = bucket
            self.accelerateConfiguration = accelerateConfiguration
        }

    }

    public struct GetBucketLocationOutput: Serializable, Initializable {
        var locationConstraint: String? = nil

        public init() {}

        public init(locationConstraint: String? = nil) {
            self.locationConstraint = locationConstraint
        }

    }

    public struct RedirectAllRequestsTo: Serializable, Initializable {
        /// Name of the host where requests will be redirected.
        var hostName: String = ""
        /// Protocol to use (http, https) when redirecting requests. The default is the protocol that is used in the original request.
        var `protocol`: String? = nil

        public init() {}

        public init(hostName: String, protocol: String? = nil) {
            self.hostName = hostName
            self.`protocol` = `protocol`
        }

    }

    public struct UploadPartCopyOutput: Serializable, Initializable {
        var copyPartResult: CopyPartResult? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        /// The version of the source object that was copied, if you have enabled versioning on the source bucket.
        var copySourceVersionId: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil
        var requestCharged: String? = nil

        public init() {}

        public init(copyPartResult: CopyPartResult? = nil, sSECustomerKeyMD5: String? = nil, copySourceVersionId: String? = nil, sSEKMSKeyId: String? = nil, sSECustomerAlgorithm: String? = nil, serverSideEncryption: String? = nil, requestCharged: String? = nil) {
            self.copyPartResult = copyPartResult
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.copySourceVersionId = copySourceVersionId
            self.sSEKMSKeyId = sSEKMSKeyId
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.serverSideEncryption = serverSideEncryption
            self.requestCharged = requestCharged
        }

    }

    public struct Tagging: Serializable, Initializable {
        var tagSet: [Tag] = []

        public init() {}

        public init(tagSet: [Tag]) {
            self.tagSet = tagSet
        }

    }

    public struct GetBucketAnalyticsConfigurationOutput: Serializable, Initializable {
        /// The configuration and any analyses for the analytics filter.
        var analyticsConfiguration: AnalyticsConfiguration? = nil

        public init() {}

        public init(analyticsConfiguration: AnalyticsConfiguration? = nil) {
            self.analyticsConfiguration = analyticsConfiguration
        }

    }

    public struct Owner: Serializable, Initializable {
        var iD: String? = nil
        var displayName: String? = nil

        public init() {}

        public init(iD: String? = nil, displayName: String? = nil) {
            self.iD = iD
            self.displayName = displayName
        }

    }

    public struct CreateMultipartUploadOutput: Serializable, Initializable {
        /// Name of the bucket to which the multipart upload was initiated.
        var bucket: String? = nil
        /// Date when multipart upload will become eligible for abort operation by lifecycle.
        var abortDate: Date? = nil
        /// Id of the lifecycle rule that makes a multipart upload eligible for abort operation.
        var abortRuleId: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        /// Object key for which the multipart upload was initiated.
        var key: String? = nil
        /// ID for the initiated multipart upload.
        var uploadId: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        var requestCharged: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil

        public init() {}

        public init(bucket: String? = nil, abortDate: Date? = nil, abortRuleId: String? = nil, sSECustomerKeyMD5: String? = nil, key: String? = nil, uploadId: String? = nil, sSEKMSKeyId: String? = nil, sSECustomerAlgorithm: String? = nil, requestCharged: String? = nil, serverSideEncryption: String? = nil) {
            self.bucket = bucket
            self.abortDate = abortDate
            self.abortRuleId = abortRuleId
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.key = key
            self.uploadId = uploadId
            self.sSEKMSKeyId = sSEKMSKeyId
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.requestCharged = requestCharged
            self.serverSideEncryption = serverSideEncryption
        }

    }

    public struct Object: Serializable, Initializable {
        var lastModified: Date? = nil
        /// The class of storage used to store the object.
        var storageClass: String? = nil
        var key: String? = nil
        var eTag: String? = nil
        var owner: Owner? = nil
        var size: Int32? = nil

        public init() {}

        public init(lastModified: Date? = nil, storageClass: String? = nil, key: String? = nil, eTag: String? = nil, owner: Owner? = nil, size: Int32? = nil) {
            self.lastModified = lastModified
            self.storageClass = storageClass
            self.key = key
            self.eTag = eTag
            self.owner = owner
            self.size = size
        }

    }

    public struct CopyObjectRequest: Serializable, Initializable {
        var bucket: String = ""
        /// The tag-set for the object destination object this value must be used in conjunction with the TaggingDirective. The tag-set must be encoded as URL Query parameters
        var tagging: String? = nil
        /// Specifies presentational information for the object.
        var contentDisposition: String? = nil
        /// Copies the object if it has been modified since the specified time.
        var copySourceIfModifiedSince: Date? = nil
        /// Copies the object if its entity tag (ETag) is different than the specified ETag.
        var copySourceIfNoneMatch: String? = nil
        /// Copies the object if its entity tag (ETag) matches the specified tag.
        var copySourceIfMatch: String? = nil
        /// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
        var copySourceSSECustomerKey: String? = nil
        /// The language the content is in.
        var contentLanguage: String? = nil
        /// Allows grantee to read the object ACL.
        var grantReadACP: String? = nil
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil
        /// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not made via SSL or using SigV4. Documentation on configuring any of the officially supported AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
        var sSEKMSKeyId: String? = nil
        /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
        var contentEncoding: String? = nil
        /// Allows grantee to write the ACL for the applicable object.
        var grantWriteACP: String? = nil
        var key: String = ""
        /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
        var websiteRedirectLocation: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var copySourceSSECustomerKeyMD5: String? = nil
        /// Copies the object if it hasn't been modified since the specified time.
        var copySourceIfUnmodifiedSince: Date? = nil
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header.
        var sSECustomerKey: String? = nil
        /// Specifies caching behavior along the request/reply chain.
        var cacheControl: String? = nil
        /// Specifies whether the object tag-set are copied from the source object or replaced with tag-set provided in the request.
        var taggingDirective: String? = nil
        var requestPayer: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
        var grantFullControl: String? = nil
        /// Specifies whether the metadata is copied from the source object or replaced with metadata provided in the request.
        var metadataDirective: String? = nil
        /// The name of the source bucket and key name of the source object, separated by a slash (/). Must be URL-encoded.
        var copySource: String = ""
        /// The canned ACL to apply to the object.
        var aCL: String? = nil
        /// A map of metadata to store with the object in S3.
        var metadata: [String: String]? = nil
        /// The date and time at which the object is no longer cacheable.
        var expires: Date? = nil
        /// A standard MIME type describing the format of the object data.
        var contentType: String? = nil
        /// The type of storage to use for the object. Defaults to 'STANDARD'.
        var storageClass: String? = nil
        /// Specifies the algorithm to use when decrypting the source object (e.g., AES256).
        var copySourceSSECustomerAlgorithm: String? = nil
        /// Allows grantee to read the object data and its metadata.
        var grantRead: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil

        public init() {}

        public init(bucket: String, tagging: String? = nil, contentDisposition: String? = nil, copySourceIfModifiedSince: Date? = nil, copySourceIfNoneMatch: String? = nil, copySourceIfMatch: String? = nil, copySourceSSECustomerKey: String? = nil, contentLanguage: String? = nil, grantReadACP: String? = nil, sSECustomerAlgorithm: String? = nil, sSEKMSKeyId: String? = nil, contentEncoding: String? = nil, grantWriteACP: String? = nil, key: String, websiteRedirectLocation: String? = nil, copySourceSSECustomerKeyMD5: String? = nil, copySourceIfUnmodifiedSince: Date? = nil, sSECustomerKey: String? = nil, cacheControl: String? = nil, taggingDirective: String? = nil, requestPayer: String? = nil, sSECustomerKeyMD5: String? = nil, grantFullControl: String? = nil, metadataDirective: String? = nil, copySource: String, aCL: String? = nil, metadata: [String: String]? = nil, expires: Date? = nil, contentType: String? = nil, storageClass: String? = nil, copySourceSSECustomerAlgorithm: String? = nil, grantRead: String? = nil, serverSideEncryption: String? = nil) {
            self.bucket = bucket
            self.tagging = tagging
            self.contentDisposition = contentDisposition
            self.copySourceIfModifiedSince = copySourceIfModifiedSince
            self.copySourceIfNoneMatch = copySourceIfNoneMatch
            self.copySourceIfMatch = copySourceIfMatch
            self.copySourceSSECustomerKey = copySourceSSECustomerKey
            self.contentLanguage = contentLanguage
            self.grantReadACP = grantReadACP
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.sSEKMSKeyId = sSEKMSKeyId
            self.contentEncoding = contentEncoding
            self.grantWriteACP = grantWriteACP
            self.key = key
            self.websiteRedirectLocation = websiteRedirectLocation
            self.copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5
            self.copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince
            self.sSECustomerKey = sSECustomerKey
            self.cacheControl = cacheControl
            self.taggingDirective = taggingDirective
            self.requestPayer = requestPayer
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.grantFullControl = grantFullControl
            self.metadataDirective = metadataDirective
            self.copySource = copySource
            self.aCL = aCL
            self.metadata = metadata
            self.expires = expires
            self.contentType = contentType
            self.storageClass = storageClass
            self.copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm
            self.grantRead = grantRead
            self.serverSideEncryption = serverSideEncryption
        }

    }

    public struct GetBucketLocationRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct Grant: Serializable, Initializable {
        /// Specifies the permission given to the grantee.
        var permission: String? = nil
        var grantee: Grantee? = nil

        public init() {}

        public init(permission: String? = nil, grantee: Grantee? = nil) {
            self.permission = permission
            self.grantee = grantee
        }

    }

    public struct InventoryDestination: Serializable, Initializable {
        /// Contains the bucket name, file format, bucket owner (optional), and prefix (optional) where inventory results are published.
        var s3BucketDestination: InventoryS3BucketDestination = InventoryS3BucketDestination()

        public init() {}

        public init(s3BucketDestination: InventoryS3BucketDestination) {
            self.s3BucketDestination = s3BucketDestination
        }

    }

    public struct ListObjectsRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Sets the maximum number of keys returned in the response. The response might contain fewer keys but will never contain more.
        var maxKeys: Int32? = nil
        /// Specifies the key to start with when listing objects in a bucket.
        var marker: String? = nil
        /// Confirms that the requester knows that she or he will be charged for the list objects request. Bucket owners need not specify this parameter in their requests.
        var requestPayer: String? = nil
        /// Limits the response to keys that begin with the specified prefix.
        var prefix: String? = nil
        /// A delimiter is a character you use to group keys.
        var delimiter: String? = nil
        var encodingType: String? = nil

        public init() {}

        public init(bucket: String, maxKeys: Int32? = nil, marker: String? = nil, requestPayer: String? = nil, prefix: String? = nil, delimiter: String? = nil, encodingType: String? = nil) {
            self.bucket = bucket
            self.maxKeys = maxKeys
            self.marker = marker
            self.requestPayer = requestPayer
            self.prefix = prefix
            self.delimiter = delimiter
            self.encodingType = encodingType
        }

    }

    public struct PutBucketAnalyticsConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket to which an analytics configuration is stored.
        var bucket: String = ""
        /// The configuration and any analyses for the analytics filter.
        var analyticsConfiguration: AnalyticsConfiguration = AnalyticsConfiguration()
        /// The identifier used to represent an analytics configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, analyticsConfiguration: AnalyticsConfiguration, id: String) {
            self.bucket = bucket
            self.analyticsConfiguration = analyticsConfiguration
            self.id = id
        }

    }

    public struct CloudFunctionConfiguration: Serializable, Initializable {
        var cloudFunction: String? = nil
        var events: [String]? = nil
        var invocationRole: String? = nil
        var event: String? = nil
        var id: String? = nil

        public init() {}

        public init(cloudFunction: String? = nil, events: [String]? = nil, invocationRole: String? = nil, event: String? = nil, id: String? = nil) {
            self.cloudFunction = cloudFunction
            self.events = events
            self.invocationRole = invocationRole
            self.event = event
            self.id = id
        }

    }

    public struct HeadObjectRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header.
        var sSECustomerKey: String? = nil
        /// Return the object only if it has not been modified since the specified time, otherwise return a 412 (precondition failed).
        var ifUnmodifiedSince: Date? = nil
        /// Part number of the object being read. This is a positive integer between 1 and 10,000. Effectively performs a 'ranged' HEAD request for the part specified. Useful querying about the size of the part and the number of parts in this object.
        var partNumber: Int32? = nil
        /// Downloads the specified range bytes of an object. For more information about the HTTP Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
        var range: String? = nil
        var requestPayer: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// VersionId used to reference a specific version of the object.
        var versionId: String? = nil
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil
        /// Return the object only if its entity tag (ETag) is different from the one specified, otherwise return a 304 (not modified).
        var ifNoneMatch: String? = nil
        var key: String = ""
        /// Return the object only if it has been modified since the specified time, otherwise return a 304 (not modified).
        var ifModifiedSince: Date? = nil
        /// Return the object only if its entity tag (ETag) is the same as the one specified, otherwise return a 412 (precondition failed).
        var ifMatch: String? = nil

        public init() {}

        public init(bucket: String, sSECustomerKey: String? = nil, ifUnmodifiedSince: Date? = nil, partNumber: Int32? = nil, range: String? = nil, requestPayer: String? = nil, sSECustomerKeyMD5: String? = nil, versionId: String? = nil, sSECustomerAlgorithm: String? = nil, ifNoneMatch: String? = nil, key: String, ifModifiedSince: Date? = nil, ifMatch: String? = nil) {
            self.bucket = bucket
            self.sSECustomerKey = sSECustomerKey
            self.ifUnmodifiedSince = ifUnmodifiedSince
            self.partNumber = partNumber
            self.range = range
            self.requestPayer = requestPayer
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.versionId = versionId
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.ifNoneMatch = ifNoneMatch
            self.key = key
            self.ifModifiedSince = ifModifiedSince
            self.ifMatch = ifMatch
        }

    }

    public struct GetBucketRequestPaymentOutput: Serializable, Initializable {
        /// Specifies who pays for the download and request fees.
        var payer: String? = nil

        public init() {}

        public init(payer: String? = nil) {
            self.payer = payer
        }

    }

    public struct AbortMultipartUploadOutput: Serializable, Initializable {
        var requestCharged: String? = nil

        public init() {}

        public init(requestCharged: String? = nil) {
            self.requestCharged = requestCharged
        }

    }

    public struct PutObjectTaggingRequest: Serializable, Initializable {
        var bucket: String = ""
        var contentMD5: String? = nil
        var tagging: Tagging = Tagging()
        var key: String = ""
        var versionId: String? = nil

        public init() {}

        public init(bucket: String, contentMD5: String? = nil, tagging: Tagging, key: String, versionId: String? = nil) {
            self.bucket = bucket
            self.contentMD5 = contentMD5
            self.tagging = tagging
            self.key = key
            self.versionId = versionId
        }

    }

    public struct CompletedMultipartUpload: Serializable, Initializable {
        var parts: [CompletedPart]? = nil

        public init() {}

        public init(parts: [CompletedPart]? = nil) {
            self.parts = parts
        }

    }

    public struct GetObjectOutput: Serializable, Initializable {
        /// The count of parts this object has.
        var partsCount: Int32? = nil
        /// Specifies presentational information for the object.
        var contentDisposition: String? = nil
        /// Version of the object.
        var versionId: String? = nil
        var replicationStatus: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// The language the content is in.
        var contentLanguage: String? = nil
        /// The number of tags, if any, on the object.
        var tagCount: Int32? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        /// Provides information about object restoration operation and expiration time of the restored object copy.
        var restore: String? = nil
        /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
        var contentEncoding: String? = nil
        /// Size of the body in bytes.
        var contentLength: Int64? = nil
        /// If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the expiry-date and rule-id key value pairs providing object expiration information. The value of the rule-id is URL encoded.
        var expiration: String? = nil
        /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
        var websiteRedirectLocation: String? = nil
        /// An ETag is an opaque identifier assigned by a web server to a specific version of a resource found at a URL
        var eTag: String? = nil
        /// Object data.
        var body: Data? = nil
        /// This is set to the number of metadata entries not returned in x-amz-meta headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.
        var missingMeta: Int32? = nil
        /// Specifies caching behavior along the request/reply chain.
        var cacheControl: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        var acceptRanges: String? = nil
        /// Last modified date of the object
        var lastModified: Date? = nil
        /// A map of metadata to store with the object in S3.
        var metadata: [String: String]? = nil
        /// The date and time at which the object is no longer cacheable.
        var expires: Date? = nil
        /// The portion of the object returned in the response.
        var contentRange: String? = nil
        /// A standard MIME type describing the format of the object data.
        var contentType: String? = nil
        var storageClass: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil
        var requestCharged: String? = nil
        /// Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.
        var deleteMarker: Bool? = nil

        public init() {}

        public init(partsCount: Int32? = nil, contentDisposition: String? = nil, versionId: String? = nil, replicationStatus: String? = nil, sSEKMSKeyId: String? = nil, contentLanguage: String? = nil, tagCount: Int32? = nil, sSECustomerAlgorithm: String? = nil, restore: String? = nil, contentEncoding: String? = nil, contentLength: Int64? = nil, expiration: String? = nil, websiteRedirectLocation: String? = nil, eTag: String? = nil, body: Data? = nil, missingMeta: Int32? = nil, cacheControl: String? = nil, sSECustomerKeyMD5: String? = nil, acceptRanges: String? = nil, lastModified: Date? = nil, metadata: [String: String]? = nil, expires: Date? = nil, contentRange: String? = nil, contentType: String? = nil, storageClass: String? = nil, serverSideEncryption: String? = nil, requestCharged: String? = nil, deleteMarker: Bool? = nil) {
            self.partsCount = partsCount
            self.contentDisposition = contentDisposition
            self.versionId = versionId
            self.replicationStatus = replicationStatus
            self.sSEKMSKeyId = sSEKMSKeyId
            self.contentLanguage = contentLanguage
            self.tagCount = tagCount
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.restore = restore
            self.contentEncoding = contentEncoding
            self.contentLength = contentLength
            self.expiration = expiration
            self.websiteRedirectLocation = websiteRedirectLocation
            self.eTag = eTag
            self.body = body
            self.missingMeta = missingMeta
            self.cacheControl = cacheControl
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.acceptRanges = acceptRanges
            self.lastModified = lastModified
            self.metadata = metadata
            self.expires = expires
            self.contentRange = contentRange
            self.contentType = contentType
            self.storageClass = storageClass
            self.serverSideEncryption = serverSideEncryption
            self.requestCharged = requestCharged
            self.deleteMarker = deleteMarker
        }

    }

    public struct NotificationConfigurationDeprecated: Serializable, Initializable {
        var queueConfiguration: QueueConfigurationDeprecated? = nil
        var topicConfiguration: TopicConfigurationDeprecated? = nil
        var cloudFunctionConfiguration: CloudFunctionConfiguration? = nil

        public init() {}

        public init(queueConfiguration: QueueConfigurationDeprecated? = nil, topicConfiguration: TopicConfigurationDeprecated? = nil, cloudFunctionConfiguration: CloudFunctionConfiguration? = nil) {
            self.queueConfiguration = queueConfiguration
            self.topicConfiguration = topicConfiguration
            self.cloudFunctionConfiguration = cloudFunctionConfiguration
        }

    }

    public struct Transition: Serializable, Initializable {
        /// The class of storage used to store the object.
        var storageClass: String? = nil
        /// Indicates at what date the object is to be moved or deleted. Should be in GMT ISO 8601 Format.
        var date: Date? = nil
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        var days: Int32? = nil

        public init() {}

        public init(storageClass: String? = nil, date: Date? = nil, days: Int32? = nil) {
            self.storageClass = storageClass
            self.date = date
            self.days = days
        }

    }

    public struct MetricsConfiguration: Serializable, Initializable {
        /// The ID used to identify the metrics configuration.
        var id: String = ""
        /// Specifies a metrics configuration filter. The metrics configuration will only include objects that meet the filter's criteria. A filter must be a prefix, a tag, or a conjunction (MetricsAndOperator).
        var filter: MetricsFilter? = nil

        public init() {}

        public init(id: String, filter: MetricsFilter? = nil) {
            self.id = id
            self.filter = filter
        }

    }

    public struct Condition: Serializable, Initializable {
        /// The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element Condition is specified and sibling KeyPrefixEquals is not specified. If both are specified, then both must be true for the redirect to be applied.
        var httpErrorCodeReturnedEquals: String? = nil
        /// The object key name prefix when the redirect is applied. For example, to redirect requests for ExamplePage.html, the key prefix will be ExamplePage.html. To redirect request for all pages with the prefix docs/, the key prefix will be /docs, which identifies all objects in the docs/ folder. Required when the parent element Condition is specified and sibling HttpErrorCodeReturnedEquals is not specified. If both conditions are specified, both must be true for the redirect to be applied.
        var keyPrefixEquals: String? = nil

        public init() {}

        public init(httpErrorCodeReturnedEquals: String? = nil, keyPrefixEquals: String? = nil) {
            self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
            self.keyPrefixEquals = keyPrefixEquals
        }

    }

    public struct VersioningConfiguration: Serializable, Initializable {
        /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is only returned if the bucket has been configured with MFA delete. If the bucket has never been so configured, this element is not returned.
        var mFADelete: String? = nil
        /// The versioning state of the bucket.
        var status: String? = nil

        public init() {}

        public init(mFADelete: String? = nil, status: String? = nil) {
            self.mFADelete = mFADelete
            self.status = status
        }

    }

    public struct AccelerateConfiguration: Serializable, Initializable {
        /// The accelerate configuration of the bucket.
        var status: String? = nil

        public init() {}

        public init(status: String? = nil) {
            self.status = status
        }

    }

    public struct PutBucketLoggingRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var bucketLoggingStatus: BucketLoggingStatus = BucketLoggingStatus()

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, bucketLoggingStatus: BucketLoggingStatus) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.bucketLoggingStatus = bucketLoggingStatus
        }

    }

    public struct GetBucketPolicyOutput: Serializable, Initializable {
        /// The bucket policy as a JSON document.
        var policy: String? = nil

        public init() {}

        public init(policy: String? = nil) {
            self.policy = policy
        }

    }

    public struct ReplicationConfiguration: Serializable, Initializable {
        /// Amazon Resource Name (ARN) of an IAM role for Amazon S3 to assume when replicating the objects.
        var role: String = ""
        /// Container for information about a particular replication rule. Replication configuration must have at least one rule and can contain up to 1,000 rules.
        var rules: [ReplicationRule] = []

        public init() {}

        public init(role: String, rules: [ReplicationRule]) {
            self.role = role
            self.rules = rules
        }

    }

    public struct ObjectVersion: Serializable, Initializable {
        /// Date and time the object was last modified.
        var lastModified: Date? = nil
        /// Size in bytes of the object.
        var size: Int32? = nil
        /// Version ID of an object.
        var versionId: String? = nil
        /// The class of storage used to store the object.
        var storageClass: String? = nil
        /// The object key.
        var key: String? = nil
        /// Specifies whether the object is (true) or is not (false) the latest version of an object.
        var isLatest: Bool? = nil
        var eTag: String? = nil
        var owner: Owner? = nil

        public init() {}

        public init(lastModified: Date? = nil, size: Int32? = nil, versionId: String? = nil, storageClass: String? = nil, key: String? = nil, isLatest: Bool? = nil, eTag: String? = nil, owner: Owner? = nil) {
            self.lastModified = lastModified
            self.size = size
            self.versionId = versionId
            self.storageClass = storageClass
            self.key = key
            self.isLatest = isLatest
            self.eTag = eTag
            self.owner = owner
        }

    }

    public struct GetBucketReplicationOutput: Serializable, Initializable {
        var replicationConfiguration: ReplicationConfiguration? = nil

        public init() {}

        public init(replicationConfiguration: ReplicationConfiguration? = nil) {
            self.replicationConfiguration = replicationConfiguration
        }

    }

    public struct PutBucketInventoryConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket where the inventory configuration will be stored.
        var bucket: String = ""
        /// Specifies the inventory configuration.
        var inventoryConfiguration: InventoryConfiguration = InventoryConfiguration()
        /// The ID used to identify the inventory configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, inventoryConfiguration: InventoryConfiguration, id: String) {
            self.bucket = bucket
            self.inventoryConfiguration = inventoryConfiguration
            self.id = id
        }

    }

    public struct ListObjectsOutput: Serializable, Initializable {
        var maxKeys: Int32? = nil
        /// A flag that indicates whether or not Amazon S3 returned all of the results that satisfied the search criteria.
        var isTruncated: Bool? = nil
        var marker: String? = nil
        var name: String? = nil
        var prefix: String? = nil
        var commonPrefixes: [CommonPrefix]? = nil
        var contents: [Object]? = nil
        var delimiter: String? = nil
        /// Encoding type used by Amazon S3 to encode object keys in the response.
        var encodingType: String? = nil
        /// When response is truncated (the IsTruncated element value in the response is true), you can use the key name in this field as marker in the subsequent request to get next set of objects. Amazon S3 lists objects in alphabetical order Note: This element is returned only if you have delimiter request parameter specified. If response does not include the NextMaker and it is truncated, you can use the value of the last Key in the response as the marker in the subsequent request to get the next set of object keys.
        var nextMarker: String? = nil

        public init() {}

        public init(maxKeys: Int32? = nil, isTruncated: Bool? = nil, marker: String? = nil, name: String? = nil, prefix: String? = nil, commonPrefixes: [CommonPrefix]? = nil, contents: [Object]? = nil, delimiter: String? = nil, encodingType: String? = nil, nextMarker: String? = nil) {
            self.maxKeys = maxKeys
            self.isTruncated = isTruncated
            self.marker = marker
            self.name = name
            self.prefix = prefix
            self.commonPrefixes = commonPrefixes
            self.contents = contents
            self.delimiter = delimiter
            self.encodingType = encodingType
            self.nextMarker = nextMarker
        }

    }

    public struct CompleteMultipartUploadOutput: Serializable, Initializable {
        var bucket: String? = nil
        var location: String? = nil
        /// If the object expiration is configured, this will contain the expiration date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
        var expiration: String? = nil
        /// Version of the object.
        var versionId: String? = nil
        var key: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// Entity tag of the object.
        var eTag: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil
        var requestCharged: String? = nil

        public init() {}

        public init(bucket: String? = nil, location: String? = nil, expiration: String? = nil, versionId: String? = nil, key: String? = nil, sSEKMSKeyId: String? = nil, eTag: String? = nil, serverSideEncryption: String? = nil, requestCharged: String? = nil) {
            self.bucket = bucket
            self.location = location
            self.expiration = expiration
            self.versionId = versionId
            self.key = key
            self.sSEKMSKeyId = sSEKMSKeyId
            self.eTag = eTag
            self.serverSideEncryption = serverSideEncryption
            self.requestCharged = requestCharged
        }

    }

    public struct NotificationConfigurationFilter: Serializable, Initializable {
        var key: S3KeyFilter? = nil

        public init() {}

        public init(key: S3KeyFilter? = nil) {
            self.key = key
        }

    }

    public struct PutObjectAclRequest: Serializable, Initializable {
        var bucket: String = ""
        var contentMD5: String? = nil
        var accessControlPolicy: AccessControlPolicy? = nil
        /// Allows grantee to write the ACL for the applicable bucket.
        var grantWriteACP: String? = nil
        var requestPayer: String? = nil
        /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
        var grantFullControl: String? = nil
        /// VersionId used to reference a specific version of the object.
        var versionId: String? = nil
        /// Allows grantee to create, overwrite, and delete any object in the bucket.
        var grantWrite: String? = nil
        var key: String = ""
        /// Allows grantee to read the bucket ACL.
        var grantReadACP: String? = nil
        /// Allows grantee to list the objects in the bucket.
        var grantRead: String? = nil
        /// The canned ACL to apply to the object.
        var aCL: String? = nil

        public init() {}

        public init(bucket: String, contentMD5: String? = nil, accessControlPolicy: AccessControlPolicy? = nil, grantWriteACP: String? = nil, requestPayer: String? = nil, grantFullControl: String? = nil, versionId: String? = nil, grantWrite: String? = nil, key: String, grantReadACP: String? = nil, grantRead: String? = nil, aCL: String? = nil) {
            self.bucket = bucket
            self.contentMD5 = contentMD5
            self.accessControlPolicy = accessControlPolicy
            self.grantWriteACP = grantWriteACP
            self.requestPayer = requestPayer
            self.grantFullControl = grantFullControl
            self.versionId = versionId
            self.grantWrite = grantWrite
            self.key = key
            self.grantReadACP = grantReadACP
            self.grantRead = grantRead
            self.aCL = aCL
        }

    }

    public struct TopicConfiguration: Serializable, Initializable {
        /// Amazon SNS topic ARN to which Amazon S3 will publish a message when it detects events of specified type.
        var topicArn: String = ""
        var filter: NotificationConfigurationFilter? = nil
        var events: [String] = []
        var id: String? = nil

        public init() {}

        public init(topicArn: String, filter: NotificationConfigurationFilter? = nil, events: [String], id: String? = nil) {
            self.topicArn = topicArn
            self.filter = filter
            self.events = events
            self.id = id
        }

    }

    public struct RoutingRule: Serializable, Initializable {
        /// Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can can specify a different error code to return.
        var redirect: Redirect = Redirect()
        /// A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
        var condition: Condition? = nil

        public init() {}

        public init(redirect: Redirect, condition: Condition? = nil) {
            self.redirect = redirect
            self.condition = condition
        }

    }

    public struct LifecycleRuleFilter: Serializable, Initializable {
        /// This tag must exist in the object's tag set in order for the rule to apply.
        var tag: Tag? = nil
        var and: LifecycleRuleAndOperator? = nil
        /// Prefix identifying one or more objects to which the rule applies.
        var prefix: String? = nil

        public init() {}

        public init(tag: Tag? = nil, and: LifecycleRuleAndOperator? = nil, prefix: String? = nil) {
            self.tag = tag
            self.and = and
            self.prefix = prefix
        }

    }

    public struct IndexDocument: Serializable, Initializable {
        /// A suffix that is appended to a request that is for a directory on the website endpoint (e.g. if the suffix is index.html and you make a request to samplebucket/images/ the data that is returned will be for the object with the key name images/index.html) The suffix must not be empty and must not include a slash character.
        var suffix: String = ""

        public init() {}

        public init(suffix: String) {
            self.suffix = suffix
        }

    }

    public struct HeadObjectOutput: Serializable, Initializable {
        /// The count of parts this object has.
        var partsCount: Int32? = nil
        /// Specifies presentational information for the object.
        var contentDisposition: String? = nil
        /// Version of the object.
        var versionId: String? = nil
        var replicationStatus: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// The language the content is in.
        var contentLanguage: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        /// Provides information about object restoration operation and expiration time of the restored object copy.
        var restore: String? = nil
        /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
        var contentEncoding: String? = nil
        /// Size of the body in bytes.
        var contentLength: Int64? = nil
        /// If the object expiration is configured (see PUT Bucket lifecycle), the response includes this header. It includes the expiry-date and rule-id key value pairs providing object expiration information. The value of the rule-id is URL encoded.
        var expiration: String? = nil
        /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
        var websiteRedirectLocation: String? = nil
        /// An ETag is an opaque identifier assigned by a web server to a specific version of a resource found at a URL
        var eTag: String? = nil
        /// This is set to the number of metadata entries not returned in x-amz-meta headers. This can happen if you create metadata using an API like SOAP that supports more flexible metadata than the REST API. For example, using SOAP, you can create metadata whose values are not legal HTTP headers.
        var missingMeta: Int32? = nil
        /// Specifies caching behavior along the request/reply chain.
        var cacheControl: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        var acceptRanges: String? = nil
        /// Last modified date of the object
        var lastModified: Date? = nil
        /// A map of metadata to store with the object in S3.
        var metadata: [String: String]? = nil
        /// The date and time at which the object is no longer cacheable.
        var expires: Date? = nil
        /// A standard MIME type describing the format of the object data.
        var contentType: String? = nil
        var storageClass: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil
        var requestCharged: String? = nil
        /// Specifies whether the object retrieved was (true) or was not (false) a Delete Marker. If false, this response header does not appear in the response.
        var deleteMarker: Bool? = nil

        public init() {}

        public init(partsCount: Int32? = nil, contentDisposition: String? = nil, versionId: String? = nil, replicationStatus: String? = nil, sSEKMSKeyId: String? = nil, contentLanguage: String? = nil, sSECustomerAlgorithm: String? = nil, restore: String? = nil, contentEncoding: String? = nil, contentLength: Int64? = nil, expiration: String? = nil, websiteRedirectLocation: String? = nil, eTag: String? = nil, missingMeta: Int32? = nil, cacheControl: String? = nil, sSECustomerKeyMD5: String? = nil, acceptRanges: String? = nil, lastModified: Date? = nil, metadata: [String: String]? = nil, expires: Date? = nil, contentType: String? = nil, storageClass: String? = nil, serverSideEncryption: String? = nil, requestCharged: String? = nil, deleteMarker: Bool? = nil) {
            self.partsCount = partsCount
            self.contentDisposition = contentDisposition
            self.versionId = versionId
            self.replicationStatus = replicationStatus
            self.sSEKMSKeyId = sSEKMSKeyId
            self.contentLanguage = contentLanguage
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.restore = restore
            self.contentEncoding = contentEncoding
            self.contentLength = contentLength
            self.expiration = expiration
            self.websiteRedirectLocation = websiteRedirectLocation
            self.eTag = eTag
            self.missingMeta = missingMeta
            self.cacheControl = cacheControl
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.acceptRanges = acceptRanges
            self.lastModified = lastModified
            self.metadata = metadata
            self.expires = expires
            self.contentType = contentType
            self.storageClass = storageClass
            self.serverSideEncryption = serverSideEncryption
            self.requestCharged = requestCharged
            self.deleteMarker = deleteMarker
        }

    }

    public struct CompletedPart: Serializable, Initializable {
        /// Entity tag returned when the part was uploaded.
        var eTag: String? = nil
        /// Part number that identifies the part. This is a positive integer between 1 and 10,000.
        var partNumber: Int32? = nil

        public init() {}

        public init(eTag: String? = nil, partNumber: Int32? = nil) {
            self.eTag = eTag
            self.partNumber = partNumber
        }

    }

    public struct GetBucketTaggingRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct ListObjectsV2Output: Serializable, Initializable {
        /// Sets the maximum number of keys returned in the response. The response might contain fewer keys but will never contain more.
        var maxKeys: Int32? = nil
        /// StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this specified key. StartAfter can be any key in the bucket
        var startAfter: String? = nil
        /// A flag that indicates whether or not Amazon S3 returned all of the results that satisfied the search criteria.
        var isTruncated: Bool? = nil
        /// ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key
        var continuationToken: String? = nil
        /// Name of the bucket to list.
        var name: String? = nil
        /// Limits the response to keys that begin with the specified prefix.
        var prefix: String? = nil
        /// NextContinuationToken is sent when isTruncated is true which means there are more keys in the bucket that can be listed. The next list requests to Amazon S3 can be continued with this NextContinuationToken. NextContinuationToken is obfuscated and is not a real key
        var nextContinuationToken: String? = nil
        /// CommonPrefixes contains all (if there are any) keys between Prefix and the next occurrence of the string specified by delimiter
        var commonPrefixes: [CommonPrefix]? = nil
        /// Metadata about each object returned.
        var contents: [Object]? = nil
        /// A delimiter is a character you use to group keys.
        var delimiter: String? = nil
        /// Encoding type used by Amazon S3 to encode object keys in the response.
        var encodingType: String? = nil
        /// KeyCount is the number of keys returned with this request. KeyCount will always be less than equals to MaxKeys field. Say you ask for 50 keys, your result will include less than equals 50 keys
        var keyCount: Int32? = nil

        public init() {}

        public init(maxKeys: Int32? = nil, startAfter: String? = nil, isTruncated: Bool? = nil, continuationToken: String? = nil, name: String? = nil, prefix: String? = nil, nextContinuationToken: String? = nil, commonPrefixes: [CommonPrefix]? = nil, contents: [Object]? = nil, delimiter: String? = nil, encodingType: String? = nil, keyCount: Int32? = nil) {
            self.maxKeys = maxKeys
            self.startAfter = startAfter
            self.isTruncated = isTruncated
            self.continuationToken = continuationToken
            self.name = name
            self.prefix = prefix
            self.nextContinuationToken = nextContinuationToken
            self.commonPrefixes = commonPrefixes
            self.contents = contents
            self.delimiter = delimiter
            self.encodingType = encodingType
            self.keyCount = keyCount
        }

    }

    public struct TargetGrant: Serializable, Initializable {
        /// Logging permissions assigned to the Grantee for the bucket.
        var permission: String? = nil
        var grantee: Grantee? = nil

        public init() {}

        public init(permission: String? = nil, grantee: Grantee? = nil) {
            self.permission = permission
            self.grantee = grantee
        }

    }

    public struct BucketLoggingStatus: Serializable, Initializable {
        var loggingEnabled: LoggingEnabled? = nil

        public init() {}

        public init(loggingEnabled: LoggingEnabled? = nil) {
            self.loggingEnabled = loggingEnabled
        }

    }

    public struct AnalyticsS3BucketDestination: Serializable, Initializable {
        /// The Amazon resource name (ARN) of the bucket to which data is exported.
        var bucket: String = ""
        /// The file format used when exporting data to Amazon S3.
        var format: String = ""
        /// The account ID that owns the destination bucket. If no account ID is provided, the owner will not be validated prior to exporting data.
        var bucketAccountId: String? = nil
        /// The prefix to use when exporting data. The exported data begins with this prefix.
        var prefix: String? = nil

        public init() {}

        public init(bucket: String, format: String, bucketAccountId: String? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.format = format
            self.bucketAccountId = bucketAccountId
            self.prefix = prefix
        }

    }

    public struct PutBucketLifecycleRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var lifecycleConfiguration: LifecycleConfiguration? = nil

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, lifecycleConfiguration: LifecycleConfiguration? = nil) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.lifecycleConfiguration = lifecycleConfiguration
        }

    }

    public struct WebsiteConfiguration: Serializable, Initializable {
        var routingRules: [RoutingRule]? = nil
        var indexDocument: IndexDocument? = nil
        var errorDocument: ErrorDocument? = nil
        var redirectAllRequestsTo: RedirectAllRequestsTo? = nil

        public init() {}

        public init(routingRules: [RoutingRule]? = nil, indexDocument: IndexDocument? = nil, errorDocument: ErrorDocument? = nil, redirectAllRequestsTo: RedirectAllRequestsTo? = nil) {
            self.routingRules = routingRules
            self.indexDocument = indexDocument
            self.errorDocument = errorDocument
            self.redirectAllRequestsTo = redirectAllRequestsTo
        }

    }

    public struct NotificationConfiguration: Serializable, Initializable {
        var topicConfigurations: [TopicConfiguration]? = nil
        var queueConfigurations: [QueueConfiguration]? = nil
        var lambdaFunctionConfigurations: [LambdaFunctionConfiguration]? = nil

        public init() {}

        public init(topicConfigurations: [TopicConfiguration]? = nil, queueConfigurations: [QueueConfiguration]? = nil, lambdaFunctionConfigurations: [LambdaFunctionConfiguration]? = nil) {
            self.topicConfigurations = topicConfigurations
            self.queueConfigurations = queueConfigurations
            self.lambdaFunctionConfigurations = lambdaFunctionConfigurations
        }

    }

    public struct AnalyticsFilter: Serializable, Initializable {
        /// The tag to use when evaluating an analytics filter.
        var tag: Tag? = nil
        /// A conjunction (logical AND) of predicates, which is used in evaluating an analytics filter. The operator must have at least two predicates.
        var and: AnalyticsAndOperator? = nil
        /// The prefix to use when evaluating an analytics filter.
        var prefix: String? = nil

        public init() {}

        public init(tag: Tag? = nil, and: AnalyticsAndOperator? = nil, prefix: String? = nil) {
            self.tag = tag
            self.and = and
            self.prefix = prefix
        }

    }

    public struct GetBucketAclRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct GetObjectTaggingRequest: Serializable, Initializable {
        var bucket: String = ""
        var versionId: String? = nil
        var key: String = ""

        public init() {}

        public init(bucket: String, versionId: String? = nil, key: String) {
            self.bucket = bucket
            self.versionId = versionId
            self.key = key
        }

    }

    public struct PutBucketLifecycleConfigurationRequest: Serializable, Initializable {
        var bucket: String = ""
        var lifecycleConfiguration: BucketLifecycleConfiguration? = nil

        public init() {}

        public init(bucket: String, lifecycleConfiguration: BucketLifecycleConfiguration? = nil) {
            self.bucket = bucket
            self.lifecycleConfiguration = lifecycleConfiguration
        }

    }

    public struct ListObjectVersionsOutput: Serializable, Initializable {
        var maxKeys: Int32? = nil
        /// A flag that indicates whether or not Amazon S3 returned all of the results that satisfied the search criteria. If your results were truncated, you can make a follow-up paginated request using the NextKeyMarker and NextVersionIdMarker response parameters as a starting place in another request to return the rest of the results.
        var isTruncated: Bool? = nil
        var versionIdMarker: String? = nil
        /// Use this value for the next version id marker parameter in a subsequent request.
        var nextVersionIdMarker: String? = nil
        var commonPrefixes: [CommonPrefix]? = nil
        var delimiter: String? = nil
        /// Marks the last Key returned in a truncated response.
        var keyMarker: String? = nil
        /// Encoding type used by Amazon S3 to encode object keys in the response.
        var encodingType: String? = nil
        var name: String? = nil
        var prefix: String? = nil
        var deleteMarkers: [DeleteMarkerEntry]? = nil
        /// Use this value for the key marker request parameter in a subsequent request.
        var nextKeyMarker: String? = nil
        var versions: [ObjectVersion]? = nil

        public init() {}

        public init(maxKeys: Int32? = nil, isTruncated: Bool? = nil, versionIdMarker: String? = nil, nextVersionIdMarker: String? = nil, commonPrefixes: [CommonPrefix]? = nil, delimiter: String? = nil, keyMarker: String? = nil, encodingType: String? = nil, name: String? = nil, prefix: String? = nil, deleteMarkers: [DeleteMarkerEntry]? = nil, nextKeyMarker: String? = nil, versions: [ObjectVersion]? = nil) {
            self.maxKeys = maxKeys
            self.isTruncated = isTruncated
            self.versionIdMarker = versionIdMarker
            self.nextVersionIdMarker = nextVersionIdMarker
            self.commonPrefixes = commonPrefixes
            self.delimiter = delimiter
            self.keyMarker = keyMarker
            self.encodingType = encodingType
            self.name = name
            self.prefix = prefix
            self.deleteMarkers = deleteMarkers
            self.nextKeyMarker = nextKeyMarker
            self.versions = versions
        }

    }

    public struct AnalyticsConfiguration: Serializable, Initializable {
        /// The identifier used to represent an analytics configuration.
        var id: String = ""
        /// If present, it indicates that data related to access patterns will be collected and made available to analyze the tradeoffs between different storage classes.
        var storageClassAnalysis: StorageClassAnalysis = StorageClassAnalysis()
        /// The filter used to describe a set of objects for analyses. A filter must have exactly one prefix, one tag, or one conjunction (AnalyticsAndOperator). If no filter is provided, all objects will be considered in any analysis.
        var filter: AnalyticsFilter? = nil

        public init() {}

        public init(id: String, storageClassAnalysis: StorageClassAnalysis, filter: AnalyticsFilter? = nil) {
            self.id = id
            self.storageClassAnalysis = storageClassAnalysis
            self.filter = filter
        }

    }

    public struct GetBucketVersioningOutput: Serializable, Initializable {
        /// Specifies whether MFA delete is enabled in the bucket versioning configuration. This element is only returned if the bucket has been configured with MFA delete. If the bucket has never been so configured, this element is not returned.
        var mFADelete: String? = nil
        /// The versioning state of the bucket.
        var status: String? = nil

        public init() {}

        public init(mFADelete: String? = nil, status: String? = nil) {
            self.mFADelete = mFADelete
            self.status = status
        }

    }

    public struct InventoryFilter: Serializable, Initializable {
        /// The prefix that an object must have to be included in the inventory results.
        var prefix: String = ""

        public init() {}

        public init(prefix: String) {
            self.prefix = prefix
        }

    }

    public struct DeleteObjectsRequest: Serializable, Initializable {
        var bucket: String = ""
        /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
        var mFA: String? = nil
        var requestPayer: String? = nil
        var delete: Delete = Delete()

        public init() {}

        public init(bucket: String, mFA: String? = nil, requestPayer: String? = nil, delete: Delete) {
            self.bucket = bucket
            self.mFA = mFA
            self.requestPayer = requestPayer
            self.delete = delete
        }

    }

    public struct PutBucketVersioningRequest: Serializable, Initializable {
        var bucket: String = ""
        var contentMD5: String? = nil
        /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
        var mFA: String? = nil
        var versioningConfiguration: VersioningConfiguration = VersioningConfiguration()

        public init() {}

        public init(bucket: String, contentMD5: String? = nil, mFA: String? = nil, versioningConfiguration: VersioningConfiguration) {
            self.bucket = bucket
            self.contentMD5 = contentMD5
            self.mFA = mFA
            self.versioningConfiguration = versioningConfiguration
        }

    }

    public struct GetObjectAclOutput: Serializable, Initializable {
        var owner: Owner? = nil
        /// A list of grants.
        var grants: [Grant]? = nil
        var requestCharged: String? = nil

        public init() {}

        public init(owner: Owner? = nil, grants: [Grant]? = nil, requestCharged: String? = nil) {
            self.owner = owner
            self.grants = grants
            self.requestCharged = requestCharged
        }

    }

    public struct Delete: Serializable, Initializable {
        var objects: [ObjectIdentifier] = []
        /// Element to enable quiet mode for the request. When you add this element, you must set its value to true.
        var quiet: Bool? = nil

        public init() {}

        public init(objects: [ObjectIdentifier], quiet: Bool? = nil) {
            self.objects = objects
            self.quiet = quiet
        }

    }

    public struct ListMultipartUploadsRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Lists in-progress uploads only for those keys that begin with the specified prefix.
        var prefix: String? = nil
        /// Together with key-marker, specifies the multipart upload after which listing should begin. If key-marker is not specified, the upload-id-marker parameter is ignored.
        var uploadIdMarker: String? = nil
        /// Sets the maximum number of multipart uploads, from 1 to 1,000, to return in the response body. 1,000 is the maximum number of uploads that can be returned in a response.
        var maxUploads: Int32? = nil
        /// Character you use to group keys.
        var delimiter: String? = nil
        var encodingType: String? = nil
        /// Together with upload-id-marker, this parameter specifies the multipart upload after which listing should begin.
        var keyMarker: String? = nil

        public init() {}

        public init(bucket: String, prefix: String? = nil, uploadIdMarker: String? = nil, maxUploads: Int32? = nil, delimiter: String? = nil, encodingType: String? = nil, keyMarker: String? = nil) {
            self.bucket = bucket
            self.prefix = prefix
            self.uploadIdMarker = uploadIdMarker
            self.maxUploads = maxUploads
            self.delimiter = delimiter
            self.encodingType = encodingType
            self.keyMarker = keyMarker
        }

    }

    public struct DeleteObjectsOutput: Serializable, Initializable {
        var requestCharged: String? = nil
        var errors: [Error]? = nil
        var deleted: [DeletedObject]? = nil

        public init() {}

        public init(requestCharged: String? = nil, errors: [Error]? = nil, deleted: [DeletedObject]? = nil) {
            self.requestCharged = requestCharged
            self.errors = errors
            self.deleted = deleted
        }

    }

    public struct DeleteBucketAnalyticsConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket from which an analytics configuration is deleted.
        var bucket: String = ""
        /// The identifier used to represent an analytics configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, id: String) {
            self.bucket = bucket
            self.id = id
        }

    }

    public struct DeleteBucketReplicationRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct ListBucketAnalyticsConfigurationsOutput: Serializable, Initializable {
        /// The ContinuationToken that represents where this request began.
        var continuationToken: String? = nil
        /// Indicates whether the returned list of analytics configurations is complete. A value of true indicates that the list is not complete and the NextContinuationToken will be provided for a subsequent request.
        var isTruncated: Bool? = nil
        /// NextContinuationToken is sent when isTruncated is true, which indicates that there are more analytics configurations to list. The next request must include this NextContinuationToken. The token is obfuscated and is not a usable value.
        var nextContinuationToken: String? = nil
        /// The list of analytics configurations for a bucket.
        var analyticsConfigurationList: [AnalyticsConfiguration]? = nil

        public init() {}

        public init(continuationToken: String? = nil, isTruncated: Bool? = nil, nextContinuationToken: String? = nil, analyticsConfigurationList: [AnalyticsConfiguration]? = nil) {
            self.continuationToken = continuationToken
            self.isTruncated = isTruncated
            self.nextContinuationToken = nextContinuationToken
            self.analyticsConfigurationList = analyticsConfigurationList
        }

    }

    public struct InventorySchedule: Serializable, Initializable {
        /// Specifies how frequently inventory results are produced.
        var frequency: String = ""

        public init() {}

        public init(frequency: String) {
            self.frequency = frequency
        }

    }

    public struct ListMultipartUploadsOutput: Serializable, Initializable {
        /// Name of the bucket to which the multipart upload was initiated.
        var bucket: String? = nil
        /// Indicates whether the returned list of multipart uploads is truncated. A value of true indicates that the list was truncated. The list can be truncated if the number of multipart uploads exceeds the limit allowed or specified by max uploads.
        var isTruncated: Bool? = nil
        /// The key at or after which the listing began.
        var keyMarker: String? = nil
        /// Upload ID after which listing began.
        var uploadIdMarker: String? = nil
        /// When a prefix is provided in the request, this field contains the specified prefix. The result contains only keys starting with the specified prefix.
        var prefix: String? = nil
        var commonPrefixes: [CommonPrefix]? = nil
        /// Maximum number of multipart uploads that could have been included in the response.
        var maxUploads: Int32? = nil
        var uploads: [MultipartUpload]? = nil
        var delimiter: String? = nil
        /// Encoding type used by Amazon S3 to encode object keys in the response.
        var encodingType: String? = nil
        /// When a list is truncated, this element specifies the value that should be used for the key-marker request parameter in a subsequent request.
        var nextKeyMarker: String? = nil
        /// When a list is truncated, this element specifies the value that should be used for the upload-id-marker request parameter in a subsequent request.
        var nextUploadIdMarker: String? = nil

        public init() {}

        public init(bucket: String? = nil, isTruncated: Bool? = nil, keyMarker: String? = nil, uploadIdMarker: String? = nil, prefix: String? = nil, commonPrefixes: [CommonPrefix]? = nil, maxUploads: Int32? = nil, uploads: [MultipartUpload]? = nil, delimiter: String? = nil, encodingType: String? = nil, nextKeyMarker: String? = nil, nextUploadIdMarker: String? = nil) {
            self.bucket = bucket
            self.isTruncated = isTruncated
            self.keyMarker = keyMarker
            self.uploadIdMarker = uploadIdMarker
            self.prefix = prefix
            self.commonPrefixes = commonPrefixes
            self.maxUploads = maxUploads
            self.uploads = uploads
            self.delimiter = delimiter
            self.encodingType = encodingType
            self.nextKeyMarker = nextKeyMarker
            self.nextUploadIdMarker = nextUploadIdMarker
        }

    }

    public struct GetBucketMetricsConfigurationOutput: Serializable, Initializable {
        /// Specifies the metrics configuration.
        var metricsConfiguration: MetricsConfiguration? = nil

        public init() {}

        public init(metricsConfiguration: MetricsConfiguration? = nil) {
            self.metricsConfiguration = metricsConfiguration
        }

    }

    public struct ListBucketMetricsConfigurationsOutput: Serializable, Initializable {
        /// The marker that is used as a starting point for this metrics configuration list response. This value is present if it was sent in the request.
        var continuationToken: String? = nil
        /// Indicates whether the returned list of metrics configurations is complete. A value of true indicates that the list is not complete and the NextContinuationToken will be provided for a subsequent request.
        var isTruncated: Bool? = nil
        /// The list of metrics configurations for a bucket.
        var metricsConfigurationList: [MetricsConfiguration]? = nil
        /// The marker used to continue a metrics configuration listing that has been truncated. Use the NextContinuationToken from a previously truncated list response to continue the listing. The continuation token is an opaque value that Amazon S3 understands.
        var nextContinuationToken: String? = nil

        public init() {}

        public init(continuationToken: String? = nil, isTruncated: Bool? = nil, metricsConfigurationList: [MetricsConfiguration]? = nil, nextContinuationToken: String? = nil) {
            self.continuationToken = continuationToken
            self.isTruncated = isTruncated
            self.metricsConfigurationList = metricsConfigurationList
            self.nextContinuationToken = nextContinuationToken
        }

    }

    public struct GetBucketAclOutput: Serializable, Initializable {
        var owner: Owner? = nil
        /// A list of grants.
        var grants: [Grant]? = nil

        public init() {}

        public init(owner: Owner? = nil, grants: [Grant]? = nil) {
            self.owner = owner
            self.grants = grants
        }

    }

    public struct ListObjectsV2Request: Serializable, Initializable {
        /// Name of the bucket to list.
        var bucket: String = ""
        /// Sets the maximum number of keys returned in the response. The response might contain fewer keys but will never contain more.
        var maxKeys: Int32? = nil
        /// StartAfter is where you want Amazon S3 to start listing from. Amazon S3 starts listing after this specified key. StartAfter can be any key in the bucket
        var startAfter: String? = nil
        /// ContinuationToken indicates Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key
        var continuationToken: String? = nil
        /// Confirms that the requester knows that she or he will be charged for the list objects request in V2 style. Bucket owners need not specify this parameter in their requests.
        var requestPayer: String? = nil
        /// Limits the response to keys that begin with the specified prefix.
        var prefix: String? = nil
        /// The owner field is not present in listV2 by default, if you want to return owner field with each key in the result then set the fetch owner field to true
        var fetchOwner: Bool? = nil
        /// A delimiter is a character you use to group keys.
        var delimiter: String? = nil
        /// Encoding type used by Amazon S3 to encode object keys in the response.
        var encodingType: String? = nil

        public init() {}

        public init(bucket: String, maxKeys: Int32? = nil, startAfter: String? = nil, continuationToken: String? = nil, requestPayer: String? = nil, prefix: String? = nil, fetchOwner: Bool? = nil, delimiter: String? = nil, encodingType: String? = nil) {
            self.bucket = bucket
            self.maxKeys = maxKeys
            self.startAfter = startAfter
            self.continuationToken = continuationToken
            self.requestPayer = requestPayer
            self.prefix = prefix
            self.fetchOwner = fetchOwner
            self.delimiter = delimiter
            self.encodingType = encodingType
        }

    }

    public struct HeadBucketRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct CreateBucketRequest: Serializable, Initializable {
        var bucket: String = ""
        var createBucketConfiguration: CreateBucketConfiguration? = nil
        /// Allows grantee to write the ACL for the applicable bucket.
        var grantWriteACP: String? = nil
        /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
        var grantFullControl: String? = nil
        /// Allows grantee to create, overwrite, and delete any object in the bucket.
        var grantWrite: String? = nil
        /// Allows grantee to list the objects in the bucket.
        var grantRead: String? = nil
        /// The canned ACL to apply to the bucket.
        var aCL: String? = nil
        /// Allows grantee to read the bucket ACL.
        var grantReadACP: String? = nil

        public init() {}

        public init(bucket: String, createBucketConfiguration: CreateBucketConfiguration? = nil, grantWriteACP: String? = nil, grantFullControl: String? = nil, grantWrite: String? = nil, grantRead: String? = nil, aCL: String? = nil, grantReadACP: String? = nil) {
            self.bucket = bucket
            self.createBucketConfiguration = createBucketConfiguration
            self.grantWriteACP = grantWriteACP
            self.grantFullControl = grantFullControl
            self.grantWrite = grantWrite
            self.grantRead = grantRead
            self.aCL = aCL
            self.grantReadACP = grantReadACP
        }

    }

    public struct Initiator: Serializable, Initializable {
        /// If the principal is an AWS account, it provides the Canonical User ID. If the principal is an IAM User, it provides a user ARN value.
        var iD: String? = nil
        /// Name of the Principal.
        var displayName: String? = nil

        public init() {}

        public init(iD: String? = nil, displayName: String? = nil) {
            self.iD = iD
            self.displayName = displayName
        }

    }

    public struct DeleteObjectTaggingOutput: Serializable, Initializable {
        /// The versionId of the object the tag-set was removed from.
        var versionId: String? = nil

        public init() {}

        public init(versionId: String? = nil) {
            self.versionId = versionId
        }

    }

    public struct PutBucketReplicationRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var replicationConfiguration: ReplicationConfiguration = ReplicationConfiguration()

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, replicationConfiguration: ReplicationConfiguration) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.replicationConfiguration = replicationConfiguration
        }

    }

    public struct CORSRule: Serializable, Initializable {
        /// One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        var exposeHeaders: [String]? = nil
        /// One or more origins you want customers to be able to access the bucket from.
        var allowedOrigins: [String] = []
        /// The time in seconds that your browser is to cache the preflight response for the specified resource.
        var maxAgeSeconds: Int32? = nil
        /// Specifies which headers are allowed in a pre-flight OPTIONS request.
        var allowedHeaders: [String]? = nil
        /// Identifies HTTP methods that the domain/origin specified in the rule is allowed to execute.
        var allowedMethods: [String] = []

        public init() {}

        public init(exposeHeaders: [String]? = nil, allowedOrigins: [String], maxAgeSeconds: Int32? = nil, allowedHeaders: [String]? = nil, allowedMethods: [String]) {
            self.exposeHeaders = exposeHeaders
            self.allowedOrigins = allowedOrigins
            self.maxAgeSeconds = maxAgeSeconds
            self.allowedHeaders = allowedHeaders
            self.allowedMethods = allowedMethods
        }

    }

    public struct CreateMultipartUploadRequest: Serializable, Initializable {
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header.
        var sSECustomerKey: String? = nil
        /// Specifies caching behavior along the request/reply chain.
        var cacheControl: String? = nil
        var bucket: String = ""
        /// Specifies presentational information for the object.
        var contentDisposition: String? = nil
        var requestPayer: String? = nil
        /// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
        var grantFullControl: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not made via SSL or using SigV4. Documentation on configuring any of the officially supported AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
        var sSEKMSKeyId: String? = nil
        /// Allows grantee to read the object ACL.
        var grantReadACP: String? = nil
        /// The canned ACL to apply to the object.
        var aCL: String? = nil
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil
        /// The language the content is in.
        var contentLanguage: String? = nil
        /// A map of metadata to store with the object in S3.
        var metadata: [String: String]? = nil
        /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
        var contentEncoding: String? = nil
        /// The date and time at which the object is no longer cacheable.
        var expires: Date? = nil
        /// Allows grantee to write the ACL for the applicable object.
        var grantWriteACP: String? = nil
        /// A standard MIME type describing the format of the object data.
        var contentType: String? = nil
        /// The type of storage to use for the object. Defaults to 'STANDARD'.
        var storageClass: String? = nil
        var key: String = ""
        /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
        var websiteRedirectLocation: String? = nil
        /// Allows grantee to read the object data and its metadata.
        var grantRead: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil

        public init() {}

        public init(sSECustomerKey: String? = nil, cacheControl: String? = nil, bucket: String, contentDisposition: String? = nil, requestPayer: String? = nil, grantFullControl: String? = nil, sSECustomerKeyMD5: String? = nil, sSEKMSKeyId: String? = nil, grantReadACP: String? = nil, aCL: String? = nil, sSECustomerAlgorithm: String? = nil, contentLanguage: String? = nil, metadata: [String: String]? = nil, contentEncoding: String? = nil, expires: Date? = nil, grantWriteACP: String? = nil, contentType: String? = nil, storageClass: String? = nil, key: String, websiteRedirectLocation: String? = nil, grantRead: String? = nil, serverSideEncryption: String? = nil) {
            self.sSECustomerKey = sSECustomerKey
            self.cacheControl = cacheControl
            self.bucket = bucket
            self.contentDisposition = contentDisposition
            self.requestPayer = requestPayer
            self.grantFullControl = grantFullControl
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.sSEKMSKeyId = sSEKMSKeyId
            self.grantReadACP = grantReadACP
            self.aCL = aCL
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.contentLanguage = contentLanguage
            self.metadata = metadata
            self.contentEncoding = contentEncoding
            self.expires = expires
            self.grantWriteACP = grantWriteACP
            self.contentType = contentType
            self.storageClass = storageClass
            self.key = key
            self.websiteRedirectLocation = websiteRedirectLocation
            self.grantRead = grantRead
            self.serverSideEncryption = serverSideEncryption
        }

    }

    public struct DeleteObjectRequest: Serializable, Initializable {
        /// VersionId used to reference a specific version of the object.
        var versionId: String? = nil
        var bucket: String = ""
        var key: String = ""
        /// The concatenation of the authentication device's serial number, a space, and the value that is displayed on your authentication device.
        var mFA: String? = nil
        var requestPayer: String? = nil

        public init() {}

        public init(versionId: String? = nil, bucket: String, key: String, mFA: String? = nil, requestPayer: String? = nil) {
            self.versionId = versionId
            self.bucket = bucket
            self.key = key
            self.mFA = mFA
            self.requestPayer = requestPayer
        }

    }

    public struct PutObjectAclOutput: Serializable, Initializable {
        var requestCharged: String? = nil

        public init() {}

        public init(requestCharged: String? = nil) {
            self.requestCharged = requestCharged
        }

    }

    public struct ListPartsOutput: Serializable, Initializable {
        /// Part number after which listing begins.
        var partNumberMarker: Int32? = nil
        /// Name of the bucket to which the multipart upload was initiated.
        var bucket: String? = nil
        /// Indicates whether the returned list of parts is truncated.
        var isTruncated: Bool? = nil
        /// Date when multipart upload will become eligible for abort operation by lifecycle.
        var abortDate: Date? = nil
        /// Upload ID identifying the multipart upload whose parts are being listed.
        var uploadId: String? = nil
        var owner: Owner? = nil
        var parts: [Part]? = nil
        /// Identifies who initiated the multipart upload.
        var initiator: Initiator? = nil
        /// Id of the lifecycle rule that makes a multipart upload eligible for abort operation.
        var abortRuleId: String? = nil
        /// The class of storage used to store the object.
        var storageClass: String? = nil
        /// Object key for which the multipart upload was initiated.
        var key: String? = nil
        /// Maximum number of parts that were allowed in the response.
        var maxParts: Int32? = nil
        /// When a list is truncated, this element specifies the last part in the list, as well as the value to use for the part-number-marker request parameter in a subsequent request.
        var nextPartNumberMarker: Int32? = nil
        var requestCharged: String? = nil

        public init() {}

        public init(partNumberMarker: Int32? = nil, bucket: String? = nil, isTruncated: Bool? = nil, abortDate: Date? = nil, uploadId: String? = nil, owner: Owner? = nil, parts: [Part]? = nil, initiator: Initiator? = nil, abortRuleId: String? = nil, storageClass: String? = nil, key: String? = nil, maxParts: Int32? = nil, nextPartNumberMarker: Int32? = nil, requestCharged: String? = nil) {
            self.partNumberMarker = partNumberMarker
            self.bucket = bucket
            self.isTruncated = isTruncated
            self.abortDate = abortDate
            self.uploadId = uploadId
            self.owner = owner
            self.parts = parts
            self.initiator = initiator
            self.abortRuleId = abortRuleId
            self.storageClass = storageClass
            self.key = key
            self.maxParts = maxParts
            self.nextPartNumberMarker = nextPartNumberMarker
            self.requestCharged = requestCharged
        }

    }

    public struct ListBucketInventoryConfigurationsOutput: Serializable, Initializable {
        /// If sent in the request, the marker that is used as a starting point for this inventory configuration list response.
        var continuationToken: String? = nil
        /// Indicates whether the returned list of inventory configurations is truncated in this response. A value of true indicates that the list is truncated.
        var isTruncated: Bool? = nil
        /// The marker used to continue this inventory configuration listing. Use the NextContinuationToken from this response to continue the listing in a subsequent request. The continuation token is an opaque value that Amazon S3 understands.
        var nextContinuationToken: String? = nil
        /// The list of inventory configurations for a bucket.
        var inventoryConfigurationList: [InventoryConfiguration]? = nil

        public init() {}

        public init(continuationToken: String? = nil, isTruncated: Bool? = nil, nextContinuationToken: String? = nil, inventoryConfigurationList: [InventoryConfiguration]? = nil) {
            self.continuationToken = continuationToken
            self.isTruncated = isTruncated
            self.nextContinuationToken = nextContinuationToken
            self.inventoryConfigurationList = inventoryConfigurationList
        }

    }

    public struct ListBucketMetricsConfigurationsRequest: Serializable, Initializable {
        /// The name of the bucket containing the metrics configurations to retrieve.
        var bucket: String = ""
        /// The marker that is used to continue a metrics configuration listing that has been truncated. Use the NextContinuationToken from a previously truncated list response to continue the listing. The continuation token is an opaque value that Amazon S3 understands.
        var continuationToken: String? = nil

        public init() {}

        public init(bucket: String, continuationToken: String? = nil) {
            self.bucket = bucket
            self.continuationToken = continuationToken
        }

    }

    public struct TopicConfigurationDeprecated: Serializable, Initializable {
        /// Amazon SNS topic to which Amazon S3 will publish a message to report the specified events for the bucket.
        var topic: String? = nil
        var events: [String]? = nil
        /// Bucket event for which to send notifications.
        var event: String? = nil
        var id: String? = nil

        public init() {}

        public init(topic: String? = nil, events: [String]? = nil, event: String? = nil, id: String? = nil) {
            self.topic = topic
            self.events = events
            self.event = event
            self.id = id
        }

    }

    public struct DeleteBucketRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct StorageClassAnalysis: Serializable, Initializable {
        /// A container used to describe how data related to the storage class analysis should be exported.
        var dataExport: StorageClassAnalysisDataExport? = nil

        public init() {}

        public init(dataExport: StorageClassAnalysisDataExport? = nil) {
            self.dataExport = dataExport
        }

    }

    public struct GetBucketNotificationConfigurationRequest: Serializable, Initializable {
        /// Name of the bucket to get the notification configuration for.
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct CommonPrefix: Serializable, Initializable {
        var prefix: String? = nil

        public init() {}

        public init(prefix: String? = nil) {
            self.prefix = prefix
        }

    }

    public struct GetObjectTorrentRequest: Serializable, Initializable {
        var bucket: String = ""
        var key: String = ""
        var requestPayer: String? = nil

        public init() {}

        public init(bucket: String, key: String, requestPayer: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.requestPayer = requestPayer
        }

    }

    public struct InventoryS3BucketDestination: Serializable, Initializable {
        /// The Amazon resource name (ARN) of the bucket where inventory results will be published.
        var bucket: String = ""
        /// Specifies the output format of the inventory results.
        var format: String = ""
        /// The ID of the account that owns the destination bucket.
        var accountId: String? = nil
        /// The prefix that is prepended to all inventory results.
        var prefix: String? = nil

        public init() {}

        public init(bucket: String, format: String, accountId: String? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.format = format
            self.accountId = accountId
            self.prefix = prefix
        }

    }

    public struct GetObjectAclRequest: Serializable, Initializable {
        var bucket: String = ""
        /// VersionId used to reference a specific version of the object.
        var versionId: String? = nil
        var key: String = ""
        var requestPayer: String? = nil

        public init() {}

        public init(bucket: String, versionId: String? = nil, key: String, requestPayer: String? = nil) {
            self.bucket = bucket
            self.versionId = versionId
            self.key = key
            self.requestPayer = requestPayer
        }

    }

    public struct AccessControlPolicy: Serializable, Initializable {
        var owner: Owner? = nil
        /// A list of grants.
        var grants: [Grant]? = nil

        public init() {}

        public init(owner: Owner? = nil, grants: [Grant]? = nil) {
            self.owner = owner
            self.grants = grants
        }

    }

    public struct DeleteBucketLifecycleRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct CreateBucketOutput: Serializable, Initializable {
        var location: String? = nil

        public init() {}

        public init(location: String? = nil) {
            self.location = location
        }

    }

    public struct DeleteBucketInventoryConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket containing the inventory configuration to delete.
        var bucket: String = ""
        /// The ID used to identify the inventory configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, id: String) {
            self.bucket = bucket
            self.id = id
        }

    }

    public struct GetBucketWebsiteOutput: Serializable, Initializable {
        var routingRules: [RoutingRule]? = nil
        var indexDocument: IndexDocument? = nil
        var errorDocument: ErrorDocument? = nil
        var redirectAllRequestsTo: RedirectAllRequestsTo? = nil

        public init() {}

        public init(routingRules: [RoutingRule]? = nil, indexDocument: IndexDocument? = nil, errorDocument: ErrorDocument? = nil, redirectAllRequestsTo: RedirectAllRequestsTo? = nil) {
            self.routingRules = routingRules
            self.indexDocument = indexDocument
            self.errorDocument = errorDocument
            self.redirectAllRequestsTo = redirectAllRequestsTo
        }

    }

    public struct LoggingEnabled: Serializable, Initializable {
        var targetGrants: [TargetGrant]? = nil
        /// This element lets you specify a prefix for the keys that the log files will be stored under.
        var targetPrefix: String? = nil
        /// Specifies the bucket where you want Amazon S3 to store server access logs. You can have your logs delivered to any bucket that you own, including the same bucket that is being logged. You can also configure multiple buckets to deliver their logs to the same target bucket. In this case you should choose a different TargetPrefix for each source bucket so that the delivered log files can be distinguished by key.
        var targetBucket: String? = nil

        public init() {}

        public init(targetGrants: [TargetGrant]? = nil, targetPrefix: String? = nil, targetBucket: String? = nil) {
            self.targetGrants = targetGrants
            self.targetPrefix = targetPrefix
            self.targetBucket = targetBucket
        }

    }

    public struct CORSConfiguration: Serializable, Initializable {
        var cORSRules: [CORSRule] = []

        public init() {}

        public init(cORSRules: [CORSRule]) {
            self.cORSRules = cORSRules
        }

    }

    public struct ObjectIdentifier: Serializable, Initializable {
        /// VersionId for the specific version of the object to delete.
        var versionId: String? = nil
        /// Key name of the object to delete.
        var key: String = ""

        public init() {}

        public init(versionId: String? = nil, key: String) {
            self.versionId = versionId
            self.key = key
        }

    }

    public struct StorageClassAnalysisDataExport: Serializable, Initializable {
        /// The place to store the data for an analysis.
        var destination: AnalyticsExportDestination = AnalyticsExportDestination()
        /// The version of the output schema to use when exporting data. Must be V_1.
        var outputSchemaVersion: String = ""

        public init() {}

        public init(destination: AnalyticsExportDestination, outputSchemaVersion: String) {
            self.destination = destination
            self.outputSchemaVersion = outputSchemaVersion
        }

    }

    public struct Tag: Serializable, Initializable {
        /// Value of the tag.
        var value: String = ""
        /// Name of the tag.
        var key: String = ""

        public init() {}

        public init(value: String, key: String) {
            self.value = value
            self.key = key
        }

    }

    public struct RestoreObjectOutput: Serializable, Initializable {
        var requestCharged: String? = nil

        public init() {}

        public init(requestCharged: String? = nil) {
            self.requestCharged = requestCharged
        }

    }

    public struct BucketLifecycleConfiguration: Serializable, Initializable {
        var rules: [LifecycleRule] = []

        public init() {}

        public init(rules: [LifecycleRule]) {
            self.rules = rules
        }

    }

    public struct GetBucketMetricsConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket containing the metrics configuration to retrieve.
        var bucket: String = ""
        /// The ID used to identify the metrics configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, id: String) {
            self.bucket = bucket
            self.id = id
        }

    }

    public struct LifecycleRule: Serializable, Initializable {
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        var iD: String? = nil
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        var status: String = ""
        var noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil
        var abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil
        /// Prefix identifying one or more objects to which the rule applies. This is deprecated; use Filter instead.
        var prefix: String? = nil
        var expiration: LifecycleExpiration? = nil
        var transitions: [Transition]? = nil
        var filter: LifecycleRuleFilter? = nil
        var noncurrentVersionTransitions: [NoncurrentVersionTransition]? = nil

        public init() {}

        public init(iD: String? = nil, status: String, noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil, abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil, prefix: String? = nil, expiration: LifecycleExpiration? = nil, transitions: [Transition]? = nil, filter: LifecycleRuleFilter? = nil, noncurrentVersionTransitions: [NoncurrentVersionTransition]? = nil) {
            self.iD = iD
            self.status = status
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.prefix = prefix
            self.expiration = expiration
            self.transitions = transitions
            self.filter = filter
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
        }

    }

    public struct GetBucketCorsRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct Bucket: Serializable, Initializable {
        /// The name of the bucket.
        var name: String? = nil
        /// Date the bucket was created.
        var creationDate: Date? = nil

        public init() {}

        public init(name: String? = nil, creationDate: Date? = nil) {
            self.name = name
            self.creationDate = creationDate
        }

    }

    public struct Destination: Serializable, Initializable {
        /// Amazon resource name (ARN) of the bucket where you want Amazon S3 to store replicas of the object identified by the rule.
        var bucket: String = ""
        /// The class of storage used to store the object.
        var storageClass: String? = nil

        public init() {}

        public init(bucket: String, storageClass: String? = nil) {
            self.bucket = bucket
            self.storageClass = storageClass
        }

    }

    public struct GlacierJobParameters: Serializable, Initializable {
        /// Glacier retrieval tier at which the restore will be processed.
        var tier: String = ""

        public init() {}

        public init(tier: String) {
            self.tier = tier
        }

    }

    public struct PutBucketNotificationRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var notificationConfiguration: NotificationConfigurationDeprecated = NotificationConfigurationDeprecated()

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, notificationConfiguration: NotificationConfigurationDeprecated) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.notificationConfiguration = notificationConfiguration
        }

    }

    public struct CompleteMultipartUploadRequest: Serializable, Initializable {
        var bucket: String = ""
        var multipartUpload: CompletedMultipartUpload? = nil
        var key: String = ""
        var uploadId: String = ""
        var requestPayer: String? = nil

        public init() {}

        public init(bucket: String, multipartUpload: CompletedMultipartUpload? = nil, key: String, uploadId: String, requestPayer: String? = nil) {
            self.bucket = bucket
            self.multipartUpload = multipartUpload
            self.key = key
            self.uploadId = uploadId
            self.requestPayer = requestPayer
        }

    }

    public struct PutBucketMetricsConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket for which the metrics configuration is set.
        var bucket: String = ""
        /// Specifies the metrics configuration.
        var metricsConfiguration: MetricsConfiguration = MetricsConfiguration()
        /// The ID used to identify the metrics configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, metricsConfiguration: MetricsConfiguration, id: String) {
            self.bucket = bucket
            self.metricsConfiguration = metricsConfiguration
            self.id = id
        }

    }

    public struct Part: Serializable, Initializable {
        /// Date and time at which the part was uploaded.
        var lastModified: Date? = nil
        /// Part number identifying the part. This is a positive integer between 1 and 10,000.
        var partNumber: Int32? = nil
        /// Entity tag returned when the part was uploaded.
        var eTag: String? = nil
        /// Size of the uploaded part data.
        var size: Int32? = nil

        public init() {}

        public init(lastModified: Date? = nil, partNumber: Int32? = nil, eTag: String? = nil, size: Int32? = nil) {
            self.lastModified = lastModified
            self.partNumber = partNumber
            self.eTag = eTag
            self.size = size
        }

    }

    public struct ListBucketsOutput: Serializable, Initializable {
        var buckets: [Bucket]? = nil
        var owner: Owner? = nil

        public init() {}

        public init(buckets: [Bucket]? = nil, owner: Owner? = nil) {
            self.buckets = buckets
            self.owner = owner
        }

    }

    public struct GetBucketAccelerateConfigurationOutput: Serializable, Initializable {
        /// The accelerate configuration of the bucket.
        var status: String? = nil

        public init() {}

        public init(status: String? = nil) {
            self.status = status
        }

    }

    public struct CopyPartResult: Serializable, Initializable {
        /// Entity tag of the object.
        var eTag: String? = nil
        /// Date and time at which the object was uploaded.
        var lastModified: Date? = nil

        public init() {}

        public init(eTag: String? = nil, lastModified: Date? = nil) {
            self.eTag = eTag
            self.lastModified = lastModified
        }

    }

    public struct NoncurrentVersionExpiration: Serializable, Initializable {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see How Amazon S3 Calculates When an Object Became Noncurrent in the Amazon Simple Storage Service Developer Guide.
        var noncurrentDays: Int32? = nil

        public init() {}

        public init(noncurrentDays: Int32? = nil) {
            self.noncurrentDays = noncurrentDays
        }

    }

    public struct AnalyticsExportDestination: Serializable, Initializable {
        /// A destination signifying output to an S3 bucket.
        var s3BucketDestination: AnalyticsS3BucketDestination = AnalyticsS3BucketDestination()

        public init() {}

        public init(s3BucketDestination: AnalyticsS3BucketDestination) {
            self.s3BucketDestination = s3BucketDestination
        }

    }

    public struct FilterRule: Serializable, Initializable {
        var value: String? = nil
        /// Object key name prefix or suffix identifying one or more objects to which the filtering rule applies. Maximum prefix length can be up to 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, go to Configuring Event Notifications in the Amazon Simple Storage Service Developer Guide.
        var name: String? = nil

        public init() {}

        public init(value: String? = nil, name: String? = nil) {
            self.value = value
            self.name = name
        }

    }

    public struct ListBucketInventoryConfigurationsRequest: Serializable, Initializable {
        /// The name of the bucket containing the inventory configurations to retrieve.
        var bucket: String = ""
        /// The marker used to continue an inventory configuration listing that has been truncated. Use the NextContinuationToken from a previously truncated list response to continue the listing. The continuation token is an opaque value that Amazon S3 understands.
        var continuationToken: String? = nil

        public init() {}

        public init(bucket: String, continuationToken: String? = nil) {
            self.bucket = bucket
            self.continuationToken = continuationToken
        }

    }

    public struct PutBucketPolicyRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        /// The bucket policy as a JSON document.
        var policy: String = ""

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, policy: String) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.policy = policy
        }

    }

    public struct GetObjectRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header.
        var sSECustomerKey: String? = nil
        /// Return the object only if it has not been modified since the specified time, otherwise return a 412 (precondition failed).
        var ifUnmodifiedSince: Date? = nil
        /// Part number of the object being read. This is a positive integer between 1 and 10,000. Effectively performs a 'ranged' GET request for the part specified. Useful for downloading just a part of an object.
        var partNumber: Int32? = nil
        /// Downloads the specified range bytes of an object. For more information about the HTTP Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
        var range: String? = nil
        /// Sets the Content-Encoding header of the response.
        var responseContentEncoding: String? = nil
        var requestPayer: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// Sets the Content-Language header of the response.
        var responseContentLanguage: String? = nil
        /// Sets the Expires header of the response.
        var responseExpires: Date? = nil
        /// VersionId used to reference a specific version of the object.
        var versionId: String? = nil
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil
        /// Return the object only if its entity tag (ETag) is different from the one specified, otherwise return a 304 (not modified).
        var ifNoneMatch: String? = nil
        /// Sets the Content-Disposition header of the response
        var responseContentDisposition: String? = nil
        var key: String = ""
        /// Sets the Cache-Control header of the response.
        var responseCacheControl: String? = nil
        /// Sets the Content-Type header of the response.
        var responseContentType: String? = nil
        /// Return the object only if it has been modified since the specified time, otherwise return a 304 (not modified).
        var ifModifiedSince: Date? = nil
        /// Return the object only if its entity tag (ETag) is the same as the one specified, otherwise return a 412 (precondition failed).
        var ifMatch: String? = nil

        public init() {}

        public init(bucket: String, sSECustomerKey: String? = nil, ifUnmodifiedSince: Date? = nil, partNumber: Int32? = nil, range: String? = nil, responseContentEncoding: String? = nil, requestPayer: String? = nil, sSECustomerKeyMD5: String? = nil, responseContentLanguage: String? = nil, responseExpires: Date? = nil, versionId: String? = nil, sSECustomerAlgorithm: String? = nil, ifNoneMatch: String? = nil, responseContentDisposition: String? = nil, key: String, responseCacheControl: String? = nil, responseContentType: String? = nil, ifModifiedSince: Date? = nil, ifMatch: String? = nil) {
            self.bucket = bucket
            self.sSECustomerKey = sSECustomerKey
            self.ifUnmodifiedSince = ifUnmodifiedSince
            self.partNumber = partNumber
            self.range = range
            self.responseContentEncoding = responseContentEncoding
            self.requestPayer = requestPayer
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.responseContentLanguage = responseContentLanguage
            self.responseExpires = responseExpires
            self.versionId = versionId
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.ifNoneMatch = ifNoneMatch
            self.responseContentDisposition = responseContentDisposition
            self.key = key
            self.responseCacheControl = responseCacheControl
            self.responseContentType = responseContentType
            self.ifModifiedSince = ifModifiedSince
            self.ifMatch = ifMatch
        }

    }

    public struct AbortMultipartUploadRequest: Serializable, Initializable {
        var bucket: String = ""
        var key: String = ""
        var uploadId: String = ""
        var requestPayer: String? = nil

        public init() {}

        public init(bucket: String, key: String, uploadId: String, requestPayer: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.uploadId = uploadId
            self.requestPayer = requestPayer
        }

    }

    public struct GetObjectTorrentOutput: Serializable, Initializable {
        var body: Data? = nil
        var requestCharged: String? = nil

        public init() {}

        public init(body: Data? = nil, requestCharged: String? = nil) {
            self.body = body
            self.requestCharged = requestCharged
        }

    }

    public struct NoncurrentVersionTransition: Serializable, Initializable {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see How Amazon S3 Calculates When an Object Became Noncurrent in the Amazon Simple Storage Service Developer Guide.
        var noncurrentDays: Int32? = nil
        /// The class of storage used to store the object.
        var storageClass: String? = nil

        public init() {}

        public init(noncurrentDays: Int32? = nil, storageClass: String? = nil) {
            self.noncurrentDays = noncurrentDays
            self.storageClass = storageClass
        }

    }

    public struct UploadPartCopyRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header. This must be the same encryption key specified in the initiate multipart upload request.
        var sSECustomerKey: String? = nil
        /// Part number of part being copied. This is a positive integer between 1 and 10,000.
        var partNumber: Int32 = 0
        /// Copies the object if it has been modified since the specified time.
        var copySourceIfModifiedSince: Date? = nil
        var requestPayer: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
        var copySourceSSECustomerKey: String? = nil
        /// The name of the source bucket and key name of the source object, separated by a slash (/). Must be URL-encoded.
        var copySource: String = ""
        /// Copies the object if its entity tag (ETag) is different than the specified ETag.
        var copySourceIfNoneMatch: String? = nil
        /// Upload ID identifying the multipart upload whose part is being copied.
        var uploadId: String = ""
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil
        /// Copies the object if its entity tag (ETag) matches the specified tag.
        var copySourceIfMatch: String? = nil
        /// The range of bytes to copy from the source object. The range value must use the form bytes=first-last, where the first and last are the zero-based byte offsets to copy. For example, bytes=0-9 indicates that you want to copy the first ten bytes of the source. You can copy a range only if the source object is greater than 5 GB.
        var copySourceRange: String? = nil
        var key: String = ""
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var copySourceSSECustomerKeyMD5: String? = nil
        /// Specifies the algorithm to use when decrypting the source object (e.g., AES256).
        var copySourceSSECustomerAlgorithm: String? = nil
        /// Copies the object if it hasn't been modified since the specified time.
        var copySourceIfUnmodifiedSince: Date? = nil

        public init() {}

        public init(bucket: String, sSECustomerKey: String? = nil, partNumber: Int32, copySourceIfModifiedSince: Date? = nil, requestPayer: String? = nil, sSECustomerKeyMD5: String? = nil, copySourceSSECustomerKey: String? = nil, copySource: String, copySourceIfNoneMatch: String? = nil, uploadId: String, sSECustomerAlgorithm: String? = nil, copySourceIfMatch: String? = nil, copySourceRange: String? = nil, key: String, copySourceSSECustomerKeyMD5: String? = nil, copySourceSSECustomerAlgorithm: String? = nil, copySourceIfUnmodifiedSince: Date? = nil) {
            self.bucket = bucket
            self.sSECustomerKey = sSECustomerKey
            self.partNumber = partNumber
            self.copySourceIfModifiedSince = copySourceIfModifiedSince
            self.requestPayer = requestPayer
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.copySourceSSECustomerKey = copySourceSSECustomerKey
            self.copySource = copySource
            self.copySourceIfNoneMatch = copySourceIfNoneMatch
            self.uploadId = uploadId
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.copySourceIfMatch = copySourceIfMatch
            self.copySourceRange = copySourceRange
            self.key = key
            self.copySourceSSECustomerKeyMD5 = copySourceSSECustomerKeyMD5
            self.copySourceSSECustomerAlgorithm = copySourceSSECustomerAlgorithm
            self.copySourceIfUnmodifiedSince = copySourceIfUnmodifiedSince
        }

    }

    public struct PutBucketAclRequest: Serializable, Initializable {
        var bucket: String = ""
        var contentMD5: String? = nil
        var accessControlPolicy: AccessControlPolicy? = nil
        /// Allows grantee to write the ACL for the applicable bucket.
        var grantWriteACP: String? = nil
        /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.
        var grantFullControl: String? = nil
        /// Allows grantee to create, overwrite, and delete any object in the bucket.
        var grantWrite: String? = nil
        /// Allows grantee to list the objects in the bucket.
        var grantRead: String? = nil
        /// The canned ACL to apply to the bucket.
        var aCL: String? = nil
        /// Allows grantee to read the bucket ACL.
        var grantReadACP: String? = nil

        public init() {}

        public init(bucket: String, contentMD5: String? = nil, accessControlPolicy: AccessControlPolicy? = nil, grantWriteACP: String? = nil, grantFullControl: String? = nil, grantWrite: String? = nil, grantRead: String? = nil, aCL: String? = nil, grantReadACP: String? = nil) {
            self.bucket = bucket
            self.contentMD5 = contentMD5
            self.accessControlPolicy = accessControlPolicy
            self.grantWriteACP = grantWriteACP
            self.grantFullControl = grantFullControl
            self.grantWrite = grantWrite
            self.grantRead = grantRead
            self.aCL = aCL
            self.grantReadACP = grantReadACP
        }

    }

    public struct Redirect: Serializable, Initializable {
        /// The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix docs/ (objects in the docs/ folder) to documents/, you can set a condition block with KeyPrefixEquals set to docs/ and in the Redirect set ReplaceKeyPrefixWith to /documents. Not required if one of the siblings is present. Can be present only if ReplaceKeyWith is not provided.
        var replaceKeyPrefixWith: String? = nil
        /// The HTTP redirect code to use on the response. Not required if one of the siblings is present.
        var httpRedirectCode: String? = nil
        /// The host name to use in the redirect request.
        var hostName: String? = nil
        /// Protocol to use (http, https) when redirecting requests. The default is the protocol that is used in the original request.
        var `protocol`: String? = nil
        /// The specific object key to use in the redirect request. For example, redirect request to error.html. Not required if one of the sibling is present. Can be present only if ReplaceKeyPrefixWith is not provided.
        var replaceKeyWith: String? = nil

        public init() {}

        public init(replaceKeyPrefixWith: String? = nil, httpRedirectCode: String? = nil, hostName: String? = nil, protocol: String? = nil, replaceKeyWith: String? = nil) {
            self.replaceKeyPrefixWith = replaceKeyPrefixWith
            self.httpRedirectCode = httpRedirectCode
            self.hostName = hostName
            self.`protocol` = `protocol`
            self.replaceKeyWith = replaceKeyWith
        }

    }

    public struct MultipartUpload: Serializable, Initializable {
        /// The class of storage used to store the object.
        var storageClass: String? = nil
        /// Key of the object for which the multipart upload was initiated.
        var key: String? = nil
        /// Upload ID that identifies the multipart upload.
        var uploadId: String? = nil
        var owner: Owner? = nil
        /// Date and time at which the multipart upload was initiated.
        var initiated: Date? = nil
        /// Identifies who initiated the multipart upload.
        var initiator: Initiator? = nil

        public init() {}

        public init(storageClass: String? = nil, key: String? = nil, uploadId: String? = nil, owner: Owner? = nil, initiated: Date? = nil, initiator: Initiator? = nil) {
            self.storageClass = storageClass
            self.key = key
            self.uploadId = uploadId
            self.owner = owner
            self.initiated = initiated
            self.initiator = initiator
        }

    }

    public struct ListBucketAnalyticsConfigurationsRequest: Serializable, Initializable {
        /// The name of the bucket from which analytics configurations are retrieved.
        var bucket: String = ""
        /// The ContinuationToken that represents a placeholder from where this request should begin.
        var continuationToken: String? = nil

        public init() {}

        public init(bucket: String, continuationToken: String? = nil) {
            self.bucket = bucket
            self.continuationToken = continuationToken
        }

    }

    public struct GetBucketLifecycleConfigurationOutput: Serializable, Initializable {
        var rules: [LifecycleRule]? = nil

        public init() {}

        public init(rules: [LifecycleRule]? = nil) {
            self.rules = rules
        }

    }

    public struct GetBucketLifecycleRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct RequestPaymentConfiguration: Serializable, Initializable {
        /// Specifies who pays for the download and request fees.
        var payer: String = ""

        public init() {}

        public init(payer: String) {
            self.payer = payer
        }

    }

    public struct DeleteObjectOutput: Serializable, Initializable {
        /// Returns the version ID of the delete marker created as a result of the DELETE operation.
        var versionId: String? = nil
        var requestCharged: String? = nil
        /// Specifies whether the versioned object that was permanently deleted was (true) or was not (false) a delete marker.
        var deleteMarker: Bool? = nil

        public init() {}

        public init(versionId: String? = nil, requestCharged: String? = nil, deleteMarker: Bool? = nil) {
            self.versionId = versionId
            self.requestCharged = requestCharged
            self.deleteMarker = deleteMarker
        }

    }

    public struct QueueConfiguration: Serializable, Initializable {
        var filter: NotificationConfigurationFilter? = nil
        /// Amazon SQS queue ARN to which Amazon S3 will publish a message when it detects events of specified type.
        var queueArn: String = ""
        var events: [String] = []
        var id: String? = nil

        public init() {}

        public init(filter: NotificationConfigurationFilter? = nil, queueArn: String, events: [String], id: String? = nil) {
            self.filter = filter
            self.queueArn = queueArn
            self.events = events
            self.id = id
        }

    }

    public struct GetBucketTaggingOutput: Serializable, Initializable {
        var tagSet: [Tag] = []

        public init() {}

        public init(tagSet: [Tag]) {
            self.tagSet = tagSet
        }

    }

    public struct ErrorDocument: Serializable, Initializable {
        /// The object key name to use when a 4XX class error occurs.
        var key: String = ""

        public init() {}

        public init(key: String) {
            self.key = key
        }

    }

    public struct InventoryConfiguration: Serializable, Initializable {
        /// Contains the optional fields that are included in the inventory results.
        var optionalFields: [String]? = nil
        /// Contains information about where to publish the inventory results.
        var destination: InventoryDestination = InventoryDestination()
        /// Specifies whether the inventory is enabled or disabled.
        var isEnabled: Bool = false
        /// Specifies the schedule for generating inventory results.
        var schedule: InventorySchedule = InventorySchedule()
        /// Specifies an inventory filter. The inventory only includes objects that meet the filter's criteria.
        var filter: InventoryFilter? = nil
        /// Specifies which object version(s) to included in the inventory results.
        var includedObjectVersions: String = ""
        /// The ID used to identify the inventory configuration.
        var id: String = ""

        public init() {}

        public init(optionalFields: [String]? = nil, destination: InventoryDestination, isEnabled: Bool, schedule: InventorySchedule, filter: InventoryFilter? = nil, includedObjectVersions: String, id: String) {
            self.optionalFields = optionalFields
            self.destination = destination
            self.isEnabled = isEnabled
            self.schedule = schedule
            self.filter = filter
            self.includedObjectVersions = includedObjectVersions
            self.id = id
        }

    }

    public struct MetricsFilter: Serializable, Initializable {
        /// The tag used when evaluating a metrics filter.
        var tag: Tag? = nil
        /// A conjunction (logical AND) of predicates, which is used in evaluating a metrics filter. The operator must have at least two predicates, and an object must match all of the predicates in order for the filter to apply.
        var and: MetricsAndOperator? = nil
        /// The prefix used when evaluating a metrics filter.
        var prefix: String? = nil

        public init() {}

        public init(tag: Tag? = nil, and: MetricsAndOperator? = nil, prefix: String? = nil) {
            self.tag = tag
            self.and = and
            self.prefix = prefix
        }

    }

    public struct PutBucketTaggingRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var tagging: Tagging = Tagging()

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, tagging: Tagging) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.tagging = tagging
        }

    }

    public struct AnalyticsAndOperator: Serializable, Initializable {
        /// The list of tags to use when evaluating an AND predicate.
        var tags: [Tag]? = nil
        /// The prefix to use when evaluating an AND predicate.
        var prefix: String? = nil

        public init() {}

        public init(tags: [Tag]? = nil, prefix: String? = nil) {
            self.tags = tags
            self.prefix = prefix
        }

    }

    public struct ListObjectVersionsRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Sets the maximum number of keys returned in the response. The response might contain fewer keys but will never contain more.
        var maxKeys: Int32? = nil
        /// Limits the response to keys that begin with the specified prefix.
        var prefix: String? = nil
        /// A delimiter is a character you use to group keys.
        var delimiter: String? = nil
        var encodingType: String? = nil
        /// Specifies the key to start with when listing objects in a bucket.
        var keyMarker: String? = nil
        /// Specifies the object version you want to start listing from.
        var versionIdMarker: String? = nil

        public init() {}

        public init(bucket: String, maxKeys: Int32? = nil, prefix: String? = nil, delimiter: String? = nil, encodingType: String? = nil, keyMarker: String? = nil, versionIdMarker: String? = nil) {
            self.bucket = bucket
            self.maxKeys = maxKeys
            self.prefix = prefix
            self.delimiter = delimiter
            self.encodingType = encodingType
            self.keyMarker = keyMarker
            self.versionIdMarker = versionIdMarker
        }

    }

    public struct GetBucketLifecycleOutput: Serializable, Initializable {
        var rules: [Rule]? = nil

        public init() {}

        public init(rules: [Rule]? = nil) {
            self.rules = rules
        }

    }

    public struct DeleteMarkerEntry: Serializable, Initializable {
        /// Specifies whether the object is (true) or is not (false) the latest version of an object.
        var isLatest: Bool? = nil
        /// Date and time the object was last modified.
        var lastModified: Date? = nil
        /// The object key.
        var key: String? = nil
        /// Version ID of an object.
        var versionId: String? = nil
        var owner: Owner? = nil

        public init() {}

        public init(isLatest: Bool? = nil, lastModified: Date? = nil, key: String? = nil, versionId: String? = nil, owner: Owner? = nil) {
            self.isLatest = isLatest
            self.lastModified = lastModified
            self.key = key
            self.versionId = versionId
            self.owner = owner
        }

    }

    public struct DeleteBucketTaggingRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct ReplicationRule: Serializable, Initializable {
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        var iD: String? = nil
        /// The rule is ignored if status is not Enabled.
        var status: String = ""
        var destination: Destination = Destination()
        /// Object keyname prefix identifying one or more objects to which the rule applies. Maximum prefix length can be up to 1,024 characters. Overlapping prefixes are not supported.
        var prefix: String = ""

        public init() {}

        public init(iD: String? = nil, status: String, destination: Destination, prefix: String) {
            self.iD = iD
            self.status = status
            self.destination = destination
            self.prefix = prefix
        }

    }

    public struct DeleteObjectTaggingRequest: Serializable, Initializable {
        var bucket: String = ""
        /// The versionId of the object that the tag-set will be removed from.
        var versionId: String? = nil
        var key: String = ""

        public init() {}

        public init(bucket: String, versionId: String? = nil, key: String) {
            self.bucket = bucket
            self.versionId = versionId
            self.key = key
        }

    }

    public struct LambdaFunctionConfiguration: Serializable, Initializable {
        /// Lambda cloud function ARN that Amazon S3 can invoke when it detects events of the specified type.
        var lambdaFunctionArn: String = ""
        var events: [String] = []
        var filter: NotificationConfigurationFilter? = nil
        var id: String? = nil

        public init() {}

        public init(lambdaFunctionArn: String, events: [String], filter: NotificationConfigurationFilter? = nil, id: String? = nil) {
            self.lambdaFunctionArn = lambdaFunctionArn
            self.events = events
            self.filter = filter
            self.id = id
        }

    }

    public struct GetBucketLoggingOutput: Serializable, Initializable {
        var loggingEnabled: LoggingEnabled? = nil

        public init() {}

        public init(loggingEnabled: LoggingEnabled? = nil) {
            self.loggingEnabled = loggingEnabled
        }

    }

    public struct UploadPartOutput: Serializable, Initializable {
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// Entity tag for the uploaded object.
        var eTag: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        var requestCharged: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil

        public init() {}

        public init(sSECustomerKeyMD5: String? = nil, sSEKMSKeyId: String? = nil, eTag: String? = nil, sSECustomerAlgorithm: String? = nil, requestCharged: String? = nil, serverSideEncryption: String? = nil) {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.sSEKMSKeyId = sSEKMSKeyId
            self.eTag = eTag
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.requestCharged = requestCharged
            self.serverSideEncryption = serverSideEncryption
        }

    }

    public struct GetObjectTaggingOutput: Serializable, Initializable {
        var versionId: String? = nil
        var tagSet: [Tag] = []

        public init() {}

        public init(versionId: String? = nil, tagSet: [Tag]) {
            self.versionId = versionId
            self.tagSet = tagSet
        }

    }

    public struct GetBucketCorsOutput: Serializable, Initializable {
        var cORSRules: [CORSRule]? = nil

        public init() {}

        public init(cORSRules: [CORSRule]? = nil) {
            self.cORSRules = cORSRules
        }

    }

    public struct Error: Serializable, Initializable {
        var versionId: String? = nil
        var key: String? = nil
        var code: String? = nil
        var message: String? = nil

        public init() {}

        public init(versionId: String? = nil, key: String? = nil, code: String? = nil, message: String? = nil) {
            self.versionId = versionId
            self.key = key
            self.code = code
            self.message = message
        }

    }

    public struct PutObjectRequest: Serializable, Initializable {
        /// Name of the bucket to which the PUT operation was initiated.
        var bucket: String = ""
        /// The tag-set for the object. The tag-set must be encoded as URL Query parameters
        var tagging: String? = nil
        /// Specifies presentational information for the object.
        var contentDisposition: String? = nil
        /// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS will fail if not made via SSL or using SigV4. Documentation on configuring any of the officially supported AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
        var sSEKMSKeyId: String? = nil
        /// Allows grantee to read the object ACL.
        var grantReadACP: String? = nil
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil
        /// The language the content is in.
        var contentLanguage: String? = nil
        /// Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field.
        var contentEncoding: String? = nil
        /// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically.
        var contentLength: Int64? = nil
        /// Allows grantee to write the ACL for the applicable object.
        var grantWriteACP: String? = nil
        /// Object key for which the PUT operation was initiated.
        var key: String = ""
        /// If the bucket is configured as a website, redirects requests for this object to another object in the same bucket or to an external URL. Amazon S3 stores the value of this header in the object metadata.
        var websiteRedirectLocation: String? = nil
        /// Object data.
        var body: Data? = nil
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header.
        var sSECustomerKey: String? = nil
        /// The base64-encoded 128-bit MD5 digest of the part data.
        var contentMD5: String? = nil
        /// Specifies caching behavior along the request/reply chain.
        var cacheControl: String? = nil
        var requestPayer: String? = nil
        /// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
        var grantFullControl: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// The canned ACL to apply to the object.
        var aCL: String? = nil
        /// A map of metadata to store with the object in S3.
        var metadata: [String: String]? = nil
        /// The date and time at which the object is no longer cacheable.
        var expires: Date? = nil
        /// A standard MIME type describing the format of the object data.
        var contentType: String? = nil
        /// The type of storage to use for the object. Defaults to 'STANDARD'.
        var storageClass: String? = nil
        /// Allows grantee to read the object data and its metadata.
        var grantRead: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil

        public init() {}

        public init(bucket: String, tagging: String? = nil, contentDisposition: String? = nil, sSEKMSKeyId: String? = nil, grantReadACP: String? = nil, sSECustomerAlgorithm: String? = nil, contentLanguage: String? = nil, contentEncoding: String? = nil, contentLength: Int64? = nil, grantWriteACP: String? = nil, key: String, websiteRedirectLocation: String? = nil, body: Data? = nil, sSECustomerKey: String? = nil, contentMD5: String? = nil, cacheControl: String? = nil, requestPayer: String? = nil, grantFullControl: String? = nil, sSECustomerKeyMD5: String? = nil, aCL: String? = nil, metadata: [String: String]? = nil, expires: Date? = nil, contentType: String? = nil, storageClass: String? = nil, grantRead: String? = nil, serverSideEncryption: String? = nil) {
            self.bucket = bucket
            self.tagging = tagging
            self.contentDisposition = contentDisposition
            self.sSEKMSKeyId = sSEKMSKeyId
            self.grantReadACP = grantReadACP
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.contentLanguage = contentLanguage
            self.contentEncoding = contentEncoding
            self.contentLength = contentLength
            self.grantWriteACP = grantWriteACP
            self.key = key
            self.websiteRedirectLocation = websiteRedirectLocation
            self.body = body
            self.sSECustomerKey = sSECustomerKey
            self.contentMD5 = contentMD5
            self.cacheControl = cacheControl
            self.requestPayer = requestPayer
            self.grantFullControl = grantFullControl
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.aCL = aCL
            self.metadata = metadata
            self.expires = expires
            self.contentType = contentType
            self.storageClass = storageClass
            self.grantRead = grantRead
            self.serverSideEncryption = serverSideEncryption
        }

    }

    public struct CreateBucketConfiguration: Serializable, Initializable {
        /// Specifies the region where the bucket will be created. If you don't specify a region, the bucket will be created in US Standard.
        var locationConstraint: String? = nil

        public init() {}

        public init(locationConstraint: String? = nil) {
            self.locationConstraint = locationConstraint
        }

    }

    public struct GetBucketWebsiteRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct UploadPartRequest: Serializable, Initializable {
        /// Name of the bucket to which the multipart upload was initiated.
        var bucket: String = ""
        /// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm header. This must be the same encryption key specified in the initiate multipart upload request.
        var sSECustomerKey: String? = nil
        /// The base64-encoded 128-bit MD5 digest of the part data.
        var contentMD5: String? = nil
        /// Part number of part being uploaded. This is a positive integer between 1 and 10,000.
        var partNumber: Int32 = 0
        /// Size of the body in bytes. This parameter is useful when the size of the body cannot be determined automatically.
        var contentLength: Int64? = nil
        var requestPayer: String? = nil
        /// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure the encryption key was transmitted without error.
        var sSECustomerKeyMD5: String? = nil
        /// Object key for which the multipart upload was initiated.
        var key: String = ""
        /// Upload ID identifying the multipart upload whose part is being uploaded.
        var uploadId: String = ""
        /// Object data.
        var body: Data? = nil
        /// Specifies the algorithm to use to when encrypting the object (e.g., AES256).
        var sSECustomerAlgorithm: String? = nil

        public init() {}

        public init(bucket: String, sSECustomerKey: String? = nil, contentMD5: String? = nil, partNumber: Int32, contentLength: Int64? = nil, requestPayer: String? = nil, sSECustomerKeyMD5: String? = nil, key: String, uploadId: String, body: Data? = nil, sSECustomerAlgorithm: String? = nil) {
            self.bucket = bucket
            self.sSECustomerKey = sSECustomerKey
            self.contentMD5 = contentMD5
            self.partNumber = partNumber
            self.contentLength = contentLength
            self.requestPayer = requestPayer
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.key = key
            self.uploadId = uploadId
            self.body = body
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
        }

    }

    public struct DeletedObject: Serializable, Initializable {
        var deleteMarkerVersionId: String? = nil
        var versionId: String? = nil
        var key: String? = nil
        var deleteMarker: Bool? = nil

        public init() {}

        public init(deleteMarkerVersionId: String? = nil, versionId: String? = nil, key: String? = nil, deleteMarker: Bool? = nil) {
            self.deleteMarkerVersionId = deleteMarkerVersionId
            self.versionId = versionId
            self.key = key
            self.deleteMarker = deleteMarker
        }

    }

    public struct PutObjectTaggingOutput: Serializable, Initializable {
        var versionId: String? = nil

        public init() {}

        public init(versionId: String? = nil) {
            self.versionId = versionId
        }

    }

    public struct GetBucketRequestPaymentRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct DeleteBucketPolicyRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct S3KeyFilter: Serializable, Initializable {
        var filterRules: [FilterRule]? = nil

        public init() {}

        public init(filterRules: [FilterRule]? = nil) {
            self.filterRules = filterRules
        }

    }

    public struct PutBucketWebsiteRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var websiteConfiguration: WebsiteConfiguration = WebsiteConfiguration()

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, websiteConfiguration: WebsiteConfiguration) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.websiteConfiguration = websiteConfiguration
        }

    }

    public struct PutBucketNotificationConfigurationRequest: Serializable, Initializable {
        var bucket: String = ""
        var notificationConfiguration: NotificationConfiguration = NotificationConfiguration()

        public init() {}

        public init(bucket: String, notificationConfiguration: NotificationConfiguration) {
            self.bucket = bucket
            self.notificationConfiguration = notificationConfiguration
        }

    }

    public struct DeleteBucketMetricsConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket containing the metrics configuration to delete.
        var bucket: String = ""
        /// The ID used to identify the metrics configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, id: String) {
            self.bucket = bucket
            self.id = id
        }

    }

    public struct AbortIncompleteMultipartUpload: Serializable, Initializable {
        /// Indicates the number of days that must pass since initiation for Lifecycle to abort an Incomplete Multipart Upload.
        var daysAfterInitiation: Int32? = nil

        public init() {}

        public init(daysAfterInitiation: Int32? = nil) {
            self.daysAfterInitiation = daysAfterInitiation
        }

    }

    public struct RestoreRequest: Serializable, Initializable {
        /// Glacier related prameters pertaining to this job.
        var glacierJobParameters: GlacierJobParameters? = nil
        /// Lifetime of the active copy in days
        var days: Int32 = 0

        public init() {}

        public init(glacierJobParameters: GlacierJobParameters? = nil, days: Int32) {
            self.glacierJobParameters = glacierJobParameters
            self.days = days
        }

    }

    public struct GetBucketInventoryConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket containing the inventory configuration to retrieve.
        var bucket: String = ""
        /// The ID used to identify the inventory configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, id: String) {
            self.bucket = bucket
            self.id = id
        }

    }

    public struct LifecycleConfiguration: Serializable, Initializable {
        var rules: [Rule] = []

        public init() {}

        public init(rules: [Rule]) {
            self.rules = rules
        }

    }

    public struct GetBucketAnalyticsConfigurationRequest: Serializable, Initializable {
        /// The name of the bucket from which an analytics configuration is retrieved.
        var bucket: String = ""
        /// The identifier used to represent an analytics configuration.
        var id: String = ""

        public init() {}

        public init(bucket: String, id: String) {
            self.bucket = bucket
            self.id = id
        }

    }

    public struct GetBucketAccelerateConfigurationRequest: Serializable, Initializable {
        /// Name of the bucket for which the accelerate configuration is retrieved.
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct GetBucketInventoryConfigurationOutput: Serializable, Initializable {
        /// Specifies the inventory configuration.
        var inventoryConfiguration: InventoryConfiguration? = nil

        public init() {}

        public init(inventoryConfiguration: InventoryConfiguration? = nil) {
            self.inventoryConfiguration = inventoryConfiguration
        }

    }

    public struct ListPartsRequest: Serializable, Initializable {
        var bucket: String = ""
        /// Specifies the part after which listing should begin. Only parts with higher part numbers will be listed.
        var partNumberMarker: Int32? = nil
        var key: String = ""
        /// Upload ID identifying the multipart upload whose parts are being listed.
        var uploadId: String = ""
        /// Sets the maximum number of parts to return.
        var maxParts: Int32? = nil
        var requestPayer: String? = nil

        public init() {}

        public init(bucket: String, partNumberMarker: Int32? = nil, key: String, uploadId: String, maxParts: Int32? = nil, requestPayer: String? = nil) {
            self.bucket = bucket
            self.partNumberMarker = partNumberMarker
            self.key = key
            self.uploadId = uploadId
            self.maxParts = maxParts
            self.requestPayer = requestPayer
        }

    }

    public struct RestoreObjectRequest: Serializable, Initializable {
        var bucket: String = ""
        var restoreRequest: RestoreRequest? = nil
        var key: String = ""
        var versionId: String? = nil
        var requestPayer: String? = nil

        public init() {}

        public init(bucket: String, restoreRequest: RestoreRequest? = nil, key: String, versionId: String? = nil, requestPayer: String? = nil) {
            self.bucket = bucket
            self.restoreRequest = restoreRequest
            self.key = key
            self.versionId = versionId
            self.requestPayer = requestPayer
        }

    }

    public struct Grantee: Serializable, Initializable {
        /// The canonical user ID of the grantee.
        var iD: String? = nil
        /// Email address of the grantee.
        var emailAddress: String? = nil
        /// Type of grantee
        var type: String = ""
        /// Screen name of the grantee.
        var displayName: String? = nil
        /// URI of the grantee group.
        var uRI: String? = nil

        public init() {}

        public init(iD: String? = nil, emailAddress: String? = nil, type: String, displayName: String? = nil, uRI: String? = nil) {
            self.iD = iD
            self.emailAddress = emailAddress
            self.type = type
            self.displayName = displayName
            self.uRI = uRI
        }

    }

    public struct QueueConfigurationDeprecated: Serializable, Initializable {
        var queue: String? = nil
        var events: [String]? = nil
        var event: String? = nil
        var id: String? = nil

        public init() {}

        public init(queue: String? = nil, events: [String]? = nil, event: String? = nil, id: String? = nil) {
            self.queue = queue
            self.events = events
            self.event = event
            self.id = id
        }

    }

    public struct GetBucketVersioningRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct GetBucketLoggingRequest: Serializable, Initializable {
        var bucket: String = ""

        public init() {}

        public init(bucket: String) {
            self.bucket = bucket
        }

    }

    public struct PutBucketRequestPaymentRequest: Serializable, Initializable {
        var contentMD5: String? = nil
        var bucket: String = ""
        var requestPaymentConfiguration: RequestPaymentConfiguration = RequestPaymentConfiguration()

        public init() {}

        public init(contentMD5: String? = nil, bucket: String, requestPaymentConfiguration: RequestPaymentConfiguration) {
            self.contentMD5 = contentMD5
            self.bucket = bucket
            self.requestPaymentConfiguration = requestPaymentConfiguration
        }

    }

    public struct PutObjectOutput: Serializable, Initializable {
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        /// Version of the object.
        var versionId: String? = nil
        /// If the object expiration is configured, this will contain the expiration date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
        var expiration: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// Entity tag for the uploaded object.
        var eTag: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        var requestCharged: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil

        public init() {}

        public init(sSECustomerKeyMD5: String? = nil, versionId: String? = nil, expiration: String? = nil, sSEKMSKeyId: String? = nil, eTag: String? = nil, sSECustomerAlgorithm: String? = nil, requestCharged: String? = nil, serverSideEncryption: String? = nil) {
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.versionId = versionId
            self.expiration = expiration
            self.sSEKMSKeyId = sSEKMSKeyId
            self.eTag = eTag
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.requestCharged = requestCharged
            self.serverSideEncryption = serverSideEncryption
        }

    }

    public struct CopyObjectOutput: Serializable, Initializable {
        var copyObjectResult: CopyObjectResult? = nil
        /// If the object expiration is configured, the response includes this header.
        var expiration: String? = nil
        /// Version ID of the newly created copy.
        var versionId: String? = nil
        var copySourceVersionId: String? = nil
        /// If present, specifies the ID of the AWS Key Management Service (KMS) master encryption key that was used for the object.
        var sSEKMSKeyId: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header to provide round trip message integrity verification of the customer-provided encryption key.
        var sSECustomerKeyMD5: String? = nil
        /// If server-side encryption with a customer-provided encryption key was requested, the response will include this header confirming the encryption algorithm used.
        var sSECustomerAlgorithm: String? = nil
        /// The Server-side encryption algorithm used when storing this object in S3 (e.g., AES256, aws:kms).
        var serverSideEncryption: String? = nil
        var requestCharged: String? = nil

        public init() {}

        public init(copyObjectResult: CopyObjectResult? = nil, expiration: String? = nil, versionId: String? = nil, copySourceVersionId: String? = nil, sSEKMSKeyId: String? = nil, sSECustomerKeyMD5: String? = nil, sSECustomerAlgorithm: String? = nil, serverSideEncryption: String? = nil, requestCharged: String? = nil) {
            self.copyObjectResult = copyObjectResult
            self.expiration = expiration
            self.versionId = versionId
            self.copySourceVersionId = copySourceVersionId
            self.sSEKMSKeyId = sSEKMSKeyId
            self.sSECustomerKeyMD5 = sSECustomerKeyMD5
            self.sSECustomerAlgorithm = sSECustomerAlgorithm
            self.serverSideEncryption = serverSideEncryption
            self.requestCharged = requestCharged
        }

    }

}