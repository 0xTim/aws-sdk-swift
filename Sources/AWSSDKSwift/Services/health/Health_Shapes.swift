// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Health {

    public struct DescribeEntityAggregatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of entities that are affected by each of the specified events.
        public var entityAggregates: [EntityAggregate]? = nil

        public init() {}

        public init(entityAggregates: [EntityAggregate]? = nil) {
            self.entityAggregates = entityAggregates
        }

        public init(dictionary: [String: Any]) throws {
            if let entityAggregates = dictionary["entityAggregates"] as? [[String: Any]] {
                self.entityAggregates = try entityAggregates.map({ try EntityAggregate(dictionary: $0) })
            }
        }
    }

    public struct AffectedEntity: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The most recent time that the entity was updated.
        public var lastUpdatedTime: Date? = nil
        /// The most recent status of the entity affected by the event. The possible values are IMPAIRED, UNIMPAIRED, and UNKNOWN.
        public var statusCode: String? = nil
        /// The unique identifier for the entity. Format: arn:aws:health:entity-region:aws-account:entity/entity-id . Example: arn:aws:health:us-east-1:111222333444:entity/AVh5GGT7ul1arKr1sE1K 
        public var entityArn: String? = nil
        /// A map of entity tags attached to the affected entity.
        public var tags: [String: String]? = nil
        /// The 12-digit AWS account number that contains the affected entity.
        public var awsAccountId: String? = nil
        /// The unique identifier for the event. Format: arn:aws:health:event-region::event/EVENT_TYPE_PLUS_ID . Example: arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331 
        public var eventArn: String? = nil
        /// The ID of the affected entity.
        public var entityValue: String? = nil

        public init() {}

        public init(lastUpdatedTime: Date? = nil, statusCode: String? = nil, entityArn: String? = nil, tags: [String: String]? = nil, awsAccountId: String? = nil, eventArn: String? = nil, entityValue: String? = nil) {
            self.lastUpdatedTime = lastUpdatedTime
            self.statusCode = statusCode
            self.entityArn = entityArn
            self.tags = tags
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
            self.entityValue = entityValue
        }

        public init(dictionary: [String: Any]) throws {
            self.lastUpdatedTime = dictionary["lastUpdatedTime"] as? Date
            self.statusCode = dictionary["statusCode"] as? String
            self.entityArn = dictionary["entityArn"] as? String
            if let tags = dictionary["tags"] as? [String: String] {
                self.tags = tags
            }
            self.awsAccountId = dictionary["awsAccountId"] as? String
            self.eventArn = dictionary["eventArn"] as? String
            self.entityValue = dictionary["entityValue"] as? String
        }
    }

    public struct EventDetailsErrorItem: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique identifier for the event. Format: arn:aws:health:event-region::event/EVENT_TYPE_PLUS_ID . Example: arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331 
        public var eventArn: String? = nil
        /// A message that describes the error.
        public var errorMessage: String? = nil
        /// The name of the error.
        public var errorName: String? = nil

        public init() {}

        public init(eventArn: String? = nil, errorMessage: String? = nil, errorName: String? = nil) {
            self.eventArn = eventArn
            self.errorMessage = errorMessage
            self.errorName = errorName
        }

        public init(dictionary: [String: Any]) throws {
            self.eventArn = dictionary["eventArn"] as? String
            self.errorMessage = dictionary["errorMessage"] as? String
            self.errorName = dictionary["errorName"] as? String
        }
    }

    public struct EventTypeFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of event type category codes (issue, scheduledChange, or accountNotification).
        public var eventTypeCategories: [String]? = nil
        /// The AWS services associated with the event. For example, EC2, RDS.
        public var services: [String]? = nil
        /// A list of event type codes.
        public var eventTypeCodes: [String]? = nil

        public init() {}

        public init(eventTypeCategories: [String]? = nil, services: [String]? = nil, eventTypeCodes: [String]? = nil) {
            self.eventTypeCategories = eventTypeCategories
            self.services = services
            self.eventTypeCodes = eventTypeCodes
        }

        public init(dictionary: [String: Any]) throws {
            if let eventTypeCategories = dictionary["eventTypeCategories"] as? [String] {
                self.eventTypeCategories = eventTypeCategories
            }
            if let services = dictionary["services"] as? [String] {
                self.services = services
            }
            if let eventTypeCodes = dictionary["eventTypeCodes"] as? [String] {
                self.eventTypeCodes = eventTypeCodes
            }
        }
    }

    public struct DescribeAffectedEntitiesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The entities that match the filter criteria.
        public var entities: [AffectedEntity]? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil

        public init() {}

        public init(entities: [AffectedEntity]? = nil, nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let entities = dictionary["entities"] as? [[String: Any]] {
                self.entities = try entities.map({ try AffectedEntity(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct Event: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS service that is affected by the event. For example, EC2, RDS.
        public var service: String? = nil
        /// The AWS Availability Zone of the event. For example, us-east-1a.
        public var availabilityZone: String? = nil
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: Date? = nil
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: String? = nil
        /// The 
        public var eventTypeCategory: String? = nil
        /// The AWS region name of the event.
        public var region: String? = nil
        /// The date and time that the event ended.
        public var endTime: Date? = nil
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: String? = nil
        /// The date and time that the event began.
        public var startTime: Date? = nil
        /// The unique identifier for the event. Format: arn:aws:health:event-region::event/EVENT_TYPE_PLUS_ID . Example: arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331 
        public var arn: String? = nil

        public init() {}

        public init(service: String? = nil, availabilityZone: String? = nil, lastUpdatedTime: Date? = nil, statusCode: String? = nil, eventTypeCategory: String? = nil, region: String? = nil, endTime: Date? = nil, eventTypeCode: String? = nil, startTime: Date? = nil, arn: String? = nil) {
            self.service = service
            self.availabilityZone = availabilityZone
            self.lastUpdatedTime = lastUpdatedTime
            self.statusCode = statusCode
            self.eventTypeCategory = eventTypeCategory
            self.region = region
            self.endTime = endTime
            self.eventTypeCode = eventTypeCode
            self.startTime = startTime
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.service = dictionary["service"] as? String
            self.availabilityZone = dictionary["availabilityZone"] as? String
            self.lastUpdatedTime = dictionary["lastUpdatedTime"] as? Date
            self.statusCode = dictionary["statusCode"] as? String
            self.eventTypeCategory = dictionary["eventTypeCategory"] as? String
            self.region = dictionary["region"] as? String
            self.endTime = dictionary["endTime"] as? Date
            self.eventTypeCode = dictionary["eventTypeCode"] as? String
            self.startTime = dictionary["startTime"] as? Date
            self.arn = dictionary["arn"] as? String
        }
    }

    public struct DescribeEventDetailsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Error messages for any events that could not be retrieved.
        public var failedSet: [EventDetailsErrorItem]? = nil
        /// Information about the events that could be retrieved.
        public var successfulSet: [EventDetails]? = nil

        public init() {}

        public init(failedSet: [EventDetailsErrorItem]? = nil, successfulSet: [EventDetails]? = nil) {
            self.failedSet = failedSet
            self.successfulSet = successfulSet
        }

        public init(dictionary: [String: Any]) throws {
            if let failedSet = dictionary["failedSet"] as? [[String: Any]] {
                self.failedSet = try failedSet.map({ try EventDetailsErrorItem(dictionary: $0) })
            }
            if let successfulSet = dictionary["successfulSet"] as? [[String: Any]] {
                self.successfulSet = try successfulSet.map({ try EventDetails(dictionary: $0) })
            }
        }
    }

    public struct DescribeEventDetailsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331", "arn:aws:health:us-west-1::event/AWS_EBS_LOST_VOLUME_xyz" 
        public var eventArns: [String] = []
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public var locale: String? = nil

        public init() {}

        public init(eventArns: [String], locale: String? = nil) {
            self.eventArns = eventArns
            self.locale = locale
        }

        public init(dictionary: [String: Any]) throws {
            guard let eventArns = dictionary["eventArns"] as? [String] else { throw InitializableError.missingRequiredParam("eventArns") }
            self.eventArns = eventArns
            self.locale = dictionary["locale"] as? String
        }
    }

    public struct EventDescription: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The most recent description of the event.
        public var latestDescription: String? = nil

        public init() {}

        public init(latestDescription: String? = nil) {
            self.latestDescription = latestDescription
        }

        public init(dictionary: [String: Any]) throws {
            self.latestDescription = dictionary["latestDescription"] as? String
        }
    }

    public struct DescribeEventAggregatesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of events in each category that meet the optional filter criteria.
        public var eventAggregates: [EventAggregate]? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil

        public init() {}

        public init(eventAggregates: [EventAggregate]? = nil, nextToken: String? = nil) {
            self.eventAggregates = eventAggregates
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let eventAggregates = dictionary["eventAggregates"] as? [[String: Any]] {
                self.eventAggregates = try eventAggregates.map({ try EventAggregate(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct DescribeEventAggregatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil
        /// Values to narrow the results returned.
        public var filter: EventFilter? = nil
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public var maxResults: Int32? = nil
        /// The only currently supported value is eventTypeCategory.
        public var aggregateField: String = ""

        public init() {}

        public init(nextToken: String? = nil, filter: EventFilter? = nil, maxResults: Int32? = nil, aggregateField: String) {
            self.nextToken = nextToken
            self.filter = filter
            self.maxResults = maxResults
            self.aggregateField = aggregateField
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Health.EventFilter(dictionary: filter) }
            self.maxResults = dictionary["maxResults"] as? Int32
            guard let aggregateField = dictionary["aggregateField"] as? String else { throw InitializableError.missingRequiredParam("aggregateField") }
            self.aggregateField = aggregateField
        }
    }

    public struct EventFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of event type category codes (issue, scheduledChange, or accountNotification).
        public var eventTypeCategories: [String]? = nil
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331", "arn:aws:health:us-west-1::event/AWS_EBS_LOST_VOLUME_xyz" 
        public var eventArns: [String]? = nil
        /// A list of event status codes.
        public var eventStatusCodes: [String]? = nil
        /// A list of dates and times that the event was last updated.
        public var lastUpdatedTimes: [DateTimeRange]? = nil
        /// A map of entity tags attached to the affected entity.
        public var tags: [[String: String]]? = nil
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED" 
        public var eventTypeCodes: [String]? = nil
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [String]? = nil
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [String]? = nil
        /// A list of AWS availability zones.
        public var availabilityZones: [String]? = nil
        /// The AWS services associated with the event. For example, EC2, RDS.
        public var services: [String]? = nil
        /// A list of dates and times that the event ended.
        public var endTimes: [DateTimeRange]? = nil
        /// A list of AWS regions.
        public var regions: [String]? = nil
        /// A list of dates and times that the event began.
        public var startTimes: [DateTimeRange]? = nil

        public init() {}

        public init(eventTypeCategories: [String]? = nil, eventArns: [String]? = nil, eventStatusCodes: [String]? = nil, lastUpdatedTimes: [DateTimeRange]? = nil, tags: [[String: String]]? = nil, eventTypeCodes: [String]? = nil, entityArns: [String]? = nil, entityValues: [String]? = nil, availabilityZones: [String]? = nil, services: [String]? = nil, endTimes: [DateTimeRange]? = nil, regions: [String]? = nil, startTimes: [DateTimeRange]? = nil) {
            self.eventTypeCategories = eventTypeCategories
            self.eventArns = eventArns
            self.eventStatusCodes = eventStatusCodes
            self.lastUpdatedTimes = lastUpdatedTimes
            self.tags = tags
            self.eventTypeCodes = eventTypeCodes
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.availabilityZones = availabilityZones
            self.services = services
            self.endTimes = endTimes
            self.regions = regions
            self.startTimes = startTimes
        }

        public init(dictionary: [String: Any]) throws {
            if let eventTypeCategories = dictionary["eventTypeCategories"] as? [String] {
                self.eventTypeCategories = eventTypeCategories
            }
            if let eventArns = dictionary["eventArns"] as? [String] {
                self.eventArns = eventArns
            }
            if let eventStatusCodes = dictionary["eventStatusCodes"] as? [String] {
                self.eventStatusCodes = eventStatusCodes
            }
            if let lastUpdatedTimes = dictionary["lastUpdatedTimes"] as? [[String: Any]] {
                self.lastUpdatedTimes = try lastUpdatedTimes.map({ try DateTimeRange(dictionary: $0) })
            }
            if let tags = dictionary["tags"] as? [[String: String]] {
                self.tags = tags
            }
            if let eventTypeCodes = dictionary["eventTypeCodes"] as? [String] {
                self.eventTypeCodes = eventTypeCodes
            }
            if let entityArns = dictionary["entityArns"] as? [String] {
                self.entityArns = entityArns
            }
            if let entityValues = dictionary["entityValues"] as? [String] {
                self.entityValues = entityValues
            }
            if let availabilityZones = dictionary["availabilityZones"] as? [String] {
                self.availabilityZones = availabilityZones
            }
            if let services = dictionary["services"] as? [String] {
                self.services = services
            }
            if let endTimes = dictionary["endTimes"] as? [[String: Any]] {
                self.endTimes = try endTimes.map({ try DateTimeRange(dictionary: $0) })
            }
            if let regions = dictionary["regions"] as? [String] {
                self.regions = regions
            }
            if let startTimes = dictionary["startTimes"] as? [[String: Any]] {
                self.startTimes = try startTimes.map({ try DateTimeRange(dictionary: $0) })
            }
        }
    }

    public struct EventAggregate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The number of events of the associated issue type.
        public var count: Int32? = nil
        /// The issue type for the associated count.
        public var aggregateValue: String? = nil

        public init() {}

        public init(count: Int32? = nil, aggregateValue: String? = nil) {
            self.count = count
            self.aggregateValue = aggregateValue
        }

        public init(dictionary: [String: Any]) throws {
            self.count = dictionary["count"] as? Int32
            self.aggregateValue = dictionary["aggregateValue"] as? String
        }
    }

    public struct EntityAggregate: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The unique identifier for the event. Format: arn:aws:health:event-region::event/EVENT_TYPE_PLUS_ID . Example: arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331 
        public var eventArn: String? = nil
        /// The number entities that match the criteria for the specified events.
        public var count: Int32? = nil

        public init() {}

        public init(eventArn: String? = nil, count: Int32? = nil) {
            self.eventArn = eventArn
            self.count = count
        }

        public init(dictionary: [String: Any]) throws {
            self.eventArn = dictionary["eventArn"] as? String
            self.count = dictionary["count"] as? Int32
        }
    }

    public struct EventType: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The AWS service that is affected by the event. For example, EC2, RDS.
        public var service: String? = nil
        /// A list of event type category codes (issue, scheduledChange, or accountNotification).
        public var category: String? = nil
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var code: String? = nil

        public init() {}

        public init(service: String? = nil, category: String? = nil, code: String? = nil) {
            self.service = service
            self.category = category
            self.code = code
        }

        public init(dictionary: [String: Any]) throws {
            self.service = dictionary["service"] as? String
            self.category = dictionary["category"] as? String
            self.code = dictionary["code"] as? String
        }
    }

    public struct DescribeEntityAggregatesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331", "arn:aws:health:us-west-1::event/AWS_EBS_LOST_VOLUME_xyz" 
        public var eventArns: [String]? = nil

        public init() {}

        public init(eventArns: [String]? = nil) {
            self.eventArns = eventArns
        }

        public init(dictionary: [String: Any]) throws {
            if let eventArns = dictionary["eventArns"] as? [String] {
                self.eventArns = eventArns
            }
        }
    }

    public struct DescribeEventTypesResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of event types that match the filter criteria. Event types have a category (issue, accountNotification, or scheduledChange), a service (for example, EC2, RDS, DATAPIPELINE, BILLING), and a code (in the format AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT).
        public var eventTypes: [EventType]? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil

        public init() {}

        public init(eventTypes: [EventType]? = nil, nextToken: String? = nil) {
            self.eventTypes = eventTypes
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let eventTypes = dictionary["eventTypes"] as? [[String: Any]] {
                self.eventTypes = try eventTypes.map({ try EventType(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct EventDetails: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// Additional metadata about the event.
        public var eventMetadata: [String: String]? = nil
        /// Summary information about the event.
        public var event: Event? = nil
        /// The most recent description of the event.
        public var eventDescription: EventDescription? = nil

        public init() {}

        public init(eventMetadata: [String: String]? = nil, event: Event? = nil, eventDescription: EventDescription? = nil) {
            self.eventMetadata = eventMetadata
            self.event = event
            self.eventDescription = eventDescription
        }

        public init(dictionary: [String: Any]) throws {
            if let eventMetadata = dictionary["eventMetadata"] as? [String: String] {
                self.eventMetadata = eventMetadata
            }
            if let event = dictionary["event"] as? [String: Any] { self.event = try Health.Event(dictionary: event) }
            if let eventDescription = dictionary["eventDescription"] as? [String: Any] { self.eventDescription = try Health.EventDescription(dictionary: eventDescription) }
        }
    }

    public struct DescribeAffectedEntitiesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public var maxResults: Int32? = nil
        /// Values to narrow the results returned. At least one event ARN is required. 
        public var filter: EntityFilter = EntityFilter()
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public var locale: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, filter: EntityFilter, nextToken: String? = nil, locale: String? = nil) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.locale = locale
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            guard let filter = dictionary["filter"] as? [String: Any] else { throw InitializableError.missingRequiredParam("filter") }
            self.filter = try Health.EntityFilter(dictionary: filter)
            self.nextToken = dictionary["nextToken"] as? String
            self.locale = dictionary["locale"] as? String
        }
    }

    public struct DescribeEventsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public var maxResults: Int32? = nil
        /// Values to narrow the results returned.
        public var filter: EventFilter? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public var locale: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, filter: EventFilter? = nil, nextToken: String? = nil, locale: String? = nil) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.locale = locale
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Health.EventFilter(dictionary: filter) }
            self.nextToken = dictionary["nextToken"] as? String
            self.locale = dictionary["locale"] as? String
        }
    }

    public struct DateTimeRange: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The ending date and time of a time range.
        public var to: Date? = nil
        /// The starting date and time of a time range.
        public var from: Date? = nil

        public init() {}

        public init(to: Date? = nil, from: Date? = nil) {
            self.to = to
            self.from = from
        }

        public init(dictionary: [String: Any]) throws {
            self.to = dictionary["to"] as? Date
            self.from = dictionary["from"] as? Date
        }
    }

    public struct EntityFilter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/AWS_EC2_MAINTENANCE_5331", "arn:aws:health:us-west-1::event/AWS_EBS_LOST_VOLUME_xyz" 
        public var eventArns: [String] = []
        /// A list of the most recent dates and times that the entity was updated.
        public var lastUpdatedTimes: [DateTimeRange]? = nil
        /// A list of entity status codes (IMPAIRED, UNIMPAIRED, or UNKNOWN).
        public var statusCodes: [String]? = nil
        /// A map of entity tags attached to the affected entity.
        public var tags: [[String: String]]? = nil
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [String]? = nil
        /// A list of IDs for affected entities.
        public var entityValues: [String]? = nil

        public init() {}

        public init(eventArns: [String], lastUpdatedTimes: [DateTimeRange]? = nil, statusCodes: [String]? = nil, tags: [[String: String]]? = nil, entityArns: [String]? = nil, entityValues: [String]? = nil) {
            self.eventArns = eventArns
            self.lastUpdatedTimes = lastUpdatedTimes
            self.statusCodes = statusCodes
            self.tags = tags
            self.entityArns = entityArns
            self.entityValues = entityValues
        }

        public init(dictionary: [String: Any]) throws {
            guard let eventArns = dictionary["eventArns"] as? [String] else { throw InitializableError.missingRequiredParam("eventArns") }
            self.eventArns = eventArns
            if let lastUpdatedTimes = dictionary["lastUpdatedTimes"] as? [[String: Any]] {
                self.lastUpdatedTimes = try lastUpdatedTimes.map({ try DateTimeRange(dictionary: $0) })
            }
            if let statusCodes = dictionary["statusCodes"] as? [String] {
                self.statusCodes = statusCodes
            }
            if let tags = dictionary["tags"] as? [[String: String]] {
                self.tags = tags
            }
            if let entityArns = dictionary["entityArns"] as? [String] {
                self.entityArns = entityArns
            }
            if let entityValues = dictionary["entityValues"] as? [String] {
                self.entityValues = entityValues
            }
        }
    }

    public struct DescribeEventTypesRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public var maxResults: Int32? = nil
        /// Values to narrow the results returned.
        public var filter: EventTypeFilter? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public var locale: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, filter: EventTypeFilter? = nil, nextToken: String? = nil, locale: String? = nil) {
            self.maxResults = maxResults
            self.filter = filter
            self.nextToken = nextToken
            self.locale = locale
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            if let filter = dictionary["filter"] as? [String: Any] { self.filter = try Health.EventTypeFilter(dictionary: filter) }
            self.nextToken = dictionary["nextToken"] as? String
            self.locale = dictionary["locale"] as? String
        }
    }

    public struct DescribeEventsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        /// The events that match the specified filter criteria.
        public var events: [Event]? = nil
        /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public var nextToken: String? = nil

        public init() {}

        public init(events: [Event]? = nil, nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let events = dictionary["events"] as? [[String: Any]] {
                self.events = try events.map({ try Event(dictionary: $0) })
            }
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

}