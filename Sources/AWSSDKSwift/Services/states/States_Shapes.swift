// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension States {

    public struct StateEnteredEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the state.
        public var name: String = ""
        /// The JSON input data to the state.
        public var input: String? = nil

        public init() {}

        public init(name: String, input: String? = nil) {
            self.name = name
            self.input = input
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            self.input = dictionary["input"] as? String
        }
    }

    public struct SendTaskHeartbeatOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct StopExecutionOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date the execution was stopped.
        public var stopDate: Date = Date()

        public init() {}

        public init(stopDate: Date) {
            self.stopDate = stopDate
        }

        public init(dictionary: [String: Any]) throws {
            guard let stopDate = dictionary["stopDate"] as? Date else { throw InitializableError.missingRequiredParam("stopDate") }
            self.stopDate = stopDate
        }
    }

    public struct CreateActivityOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the created activity.
        public var activityArn: String = ""
        /// The date the activity was created.
        public var creationDate: Date = Date()

        public init() {}

        public init(activityArn: String, creationDate: Date) {
            self.activityArn = activityArn
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            guard let activityArn = dictionary["activityArn"] as? String else { throw InitializableError.missingRequiredParam("activityArn") }
            self.activityArn = activityArn
            guard let creationDate = dictionary["creationDate"] as? Date else { throw InitializableError.missingRequiredParam("creationDate") }
            self.creationDate = creationDate
        }
    }

    public struct ListActivitiesInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        public var maxResults: Int32? = nil
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct GetExecutionHistoryOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The list of events that occurred in the execution.
        public var events: [HistoryEvent] = []
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil

        public init() {}

        public init(events: [HistoryEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let events = dictionary["events"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("events") }
            self.events = try events.map({ try HistoryEvent(dictionary: $0) })
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ActivityFailedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ActivityListItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the activity.
        public var activityArn: String = ""
        /// The name of the activity.
        public var name: String = ""
        /// The date the activity was created.
        public var creationDate: Date = Date()

        public init() {}

        public init(activityArn: String, name: String, creationDate: Date) {
            self.activityArn = activityArn
            self.name = name
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            guard let activityArn = dictionary["activityArn"] as? String else { throw InitializableError.missingRequiredParam("activityArn") }
            self.activityArn = activityArn
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let creationDate = dictionary["creationDate"] as? Date else { throw InitializableError.missingRequiredParam("creationDate") }
            self.creationDate = creationDate
        }
    }

    public struct DescribeActivityOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the activity.
        public var activityArn: String = ""
        /// The name of the activity.
        public var name: String = ""
        /// The date the activity was created.
        public var creationDate: Date = Date()

        public init() {}

        public init(activityArn: String, name: String, creationDate: Date) {
            self.activityArn = activityArn
            self.name = name
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            guard let activityArn = dictionary["activityArn"] as? String else { throw InitializableError.missingRequiredParam("activityArn") }
            self.activityArn = activityArn
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let creationDate = dictionary["creationDate"] as? Date else { throw InitializableError.missingRequiredParam("creationDate") }
            self.creationDate = creationDate
        }
    }

    public struct ExecutionListItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current status of the execution.
        public var status: String = ""
        /// The name of the execution.
        public var name: String = ""
        /// The Amazon Resource Name (ARN) of the executed state machine.
        public var stateMachineArn: String = ""
        /// The date the execution started.
        public var startDate: Date = Date()
        /// If the execution already ended, the date the execution stopped.
        public var stopDate: Date? = nil
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public var executionArn: String = ""

        public init() {}

        public init(status: String, name: String, stateMachineArn: String, startDate: Date, stopDate: Date? = nil, executionArn: String) {
            self.status = status
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.startDate = startDate
            self.stopDate = stopDate
            self.executionArn = executionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let status = dictionary["status"] as? String else { throw InitializableError.missingRequiredParam("status") }
            self.status = status
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
            guard let startDate = dictionary["startDate"] as? Date else { throw InitializableError.missingRequiredParam("startDate") }
            self.startDate = startDate
            self.stopDate = dictionary["stopDate"] as? Date
            guard let executionArn = dictionary["executionArn"] as? String else { throw InitializableError.missingRequiredParam("executionArn") }
            self.executionArn = executionArn
        }
    }

    public struct StartExecutionInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the execution. This name must be unique for your AWS account and region.
        public var name: String? = nil
        /// The JSON input data for the execution.
        public var input: String? = nil
        /// The Amazon Resource Name (ARN) of the state machine to execute.
        public var stateMachineArn: String = ""

        public init() {}

        public init(name: String? = nil, input: String? = nil, stateMachineArn: String) {
            self.name = name
            self.input = input
            self.stateMachineArn = stateMachineArn
        }

        public init(dictionary: [String: Any]) throws {
            self.name = dictionary["name"] as? String
            self.input = dictionary["input"] as? String
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
        }
    }

    public struct DeleteActivityOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct DescribeStateMachineOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current status of the state machine.
        public var status: String? = nil
        /// The name of the state machine.
        public var name: String = ""
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        public var stateMachineArn: String = ""
        /// The date the state machine was created.
        public var creationDate: Date = Date()
        /// The Amazon States Language definition of the state machine.
        public var definition: String = ""
        /// The Amazon Resource Name (ARN) of the IAM role used for executing this state machine.
        public var roleArn: String = ""

        public init() {}

        public init(status: String? = nil, name: String, stateMachineArn: String, creationDate: Date, definition: String, roleArn: String) {
            self.status = status
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.creationDate = creationDate
            self.definition = definition
            self.roleArn = roleArn
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["status"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
            guard let creationDate = dictionary["creationDate"] as? Date else { throw InitializableError.missingRequiredParam("creationDate") }
            self.creationDate = creationDate
            guard let definition = dictionary["definition"] as? String else { throw InitializableError.missingRequiredParam("definition") }
            self.definition = definition
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
        }
    }

    public struct LambdaFunctionStartFailedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ActivityTimedOutEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the timeout.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct StartExecutionOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date the execution was started.
        public var startDate: Date = Date()
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public var executionArn: String = ""

        public init() {}

        public init(startDate: Date, executionArn: String) {
            self.startDate = startDate
            self.executionArn = executionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let startDate = dictionary["startDate"] as? Date else { throw InitializableError.missingRequiredParam("startDate") }
            self.startDate = startDate
            guard let executionArn = dictionary["executionArn"] as? String else { throw InitializableError.missingRequiredParam("executionArn") }
            self.executionArn = executionArn
        }
    }

    public struct HistoryEvent: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil
        public var lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil
        public var executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil
        public var activityFailedEventDetails: ActivityFailedEventDetails? = nil
        public var executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil
        public var lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil
        public var executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil
        public var executionFailedEventDetails: ExecutionFailedEventDetails? = nil
        public var activityScheduledEventDetails: ActivityScheduledEventDetails? = nil
        public var activityStartedEventDetails: ActivityStartedEventDetails? = nil
        /// The type of the event.
        public var type: String = ""
        public var stateEnteredEventDetails: StateEnteredEventDetails? = nil
        public var executionStartedEventDetails: ExecutionStartedEventDetails? = nil
        public var activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil
        /// The date the event occured.
        public var timestamp: Date = Date()
        /// The id of the previous event.
        public var previousEventId: Int64? = nil
        /// The id of the event. Events are numbered sequentially, starting at one.
        public var id: Int64 = 0
        public var activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil
        public var lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil
        public var activitySucceededEventDetails: ActivitySucceededEventDetails? = nil
        public var stateExitedEventDetails: StateExitedEventDetails? = nil
        public var lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil
        public var lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil

        public init() {}

        public init(lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil, lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil, executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil, activityFailedEventDetails: ActivityFailedEventDetails? = nil, executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil, lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil, executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil, executionFailedEventDetails: ExecutionFailedEventDetails? = nil, activityScheduledEventDetails: ActivityScheduledEventDetails? = nil, activityStartedEventDetails: ActivityStartedEventDetails? = nil, type: String, stateEnteredEventDetails: StateEnteredEventDetails? = nil, executionStartedEventDetails: ExecutionStartedEventDetails? = nil, activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil, timestamp: Date, previousEventId: Int64? = nil, id: Int64, activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil, lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil, activitySucceededEventDetails: ActivitySucceededEventDetails? = nil, stateExitedEventDetails: StateExitedEventDetails? = nil, lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil, lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil) {
            self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
            self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
            self.executionSucceededEventDetails = executionSucceededEventDetails
            self.activityFailedEventDetails = activityFailedEventDetails
            self.executionTimedOutEventDetails = executionTimedOutEventDetails
            self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
            self.executionAbortedEventDetails = executionAbortedEventDetails
            self.executionFailedEventDetails = executionFailedEventDetails
            self.activityScheduledEventDetails = activityScheduledEventDetails
            self.activityStartedEventDetails = activityStartedEventDetails
            self.type = type
            self.stateEnteredEventDetails = stateEnteredEventDetails
            self.executionStartedEventDetails = executionStartedEventDetails
            self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
            self.timestamp = timestamp
            self.previousEventId = previousEventId
            self.id = id
            self.activityTimedOutEventDetails = activityTimedOutEventDetails
            self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
            self.activitySucceededEventDetails = activitySucceededEventDetails
            self.stateExitedEventDetails = stateExitedEventDetails
            self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
            self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
        }

        public init(dictionary: [String: Any]) throws {
            if let lambdaFunctionSucceededEventDetails = dictionary["lambdaFunctionSucceededEventDetails"] as? [String: Any] { self.lambdaFunctionSucceededEventDetails = try States.LambdaFunctionSucceededEventDetails(dictionary: lambdaFunctionSucceededEventDetails) }
            if let lambdaFunctionFailedEventDetails = dictionary["lambdaFunctionFailedEventDetails"] as? [String: Any] { self.lambdaFunctionFailedEventDetails = try States.LambdaFunctionFailedEventDetails(dictionary: lambdaFunctionFailedEventDetails) }
            if let executionSucceededEventDetails = dictionary["executionSucceededEventDetails"] as? [String: Any] { self.executionSucceededEventDetails = try States.ExecutionSucceededEventDetails(dictionary: executionSucceededEventDetails) }
            if let activityFailedEventDetails = dictionary["activityFailedEventDetails"] as? [String: Any] { self.activityFailedEventDetails = try States.ActivityFailedEventDetails(dictionary: activityFailedEventDetails) }
            if let executionTimedOutEventDetails = dictionary["executionTimedOutEventDetails"] as? [String: Any] { self.executionTimedOutEventDetails = try States.ExecutionTimedOutEventDetails(dictionary: executionTimedOutEventDetails) }
            if let lambdaFunctionTimedOutEventDetails = dictionary["lambdaFunctionTimedOutEventDetails"] as? [String: Any] { self.lambdaFunctionTimedOutEventDetails = try States.LambdaFunctionTimedOutEventDetails(dictionary: lambdaFunctionTimedOutEventDetails) }
            if let executionAbortedEventDetails = dictionary["executionAbortedEventDetails"] as? [String: Any] { self.executionAbortedEventDetails = try States.ExecutionAbortedEventDetails(dictionary: executionAbortedEventDetails) }
            if let executionFailedEventDetails = dictionary["executionFailedEventDetails"] as? [String: Any] { self.executionFailedEventDetails = try States.ExecutionFailedEventDetails(dictionary: executionFailedEventDetails) }
            if let activityScheduledEventDetails = dictionary["activityScheduledEventDetails"] as? [String: Any] { self.activityScheduledEventDetails = try States.ActivityScheduledEventDetails(dictionary: activityScheduledEventDetails) }
            if let activityStartedEventDetails = dictionary["activityStartedEventDetails"] as? [String: Any] { self.activityStartedEventDetails = try States.ActivityStartedEventDetails(dictionary: activityStartedEventDetails) }
            guard let type = dictionary["type"] as? String else { throw InitializableError.missingRequiredParam("type") }
            self.type = type
            if let stateEnteredEventDetails = dictionary["stateEnteredEventDetails"] as? [String: Any] { self.stateEnteredEventDetails = try States.StateEnteredEventDetails(dictionary: stateEnteredEventDetails) }
            if let executionStartedEventDetails = dictionary["executionStartedEventDetails"] as? [String: Any] { self.executionStartedEventDetails = try States.ExecutionStartedEventDetails(dictionary: executionStartedEventDetails) }
            if let activityScheduleFailedEventDetails = dictionary["activityScheduleFailedEventDetails"] as? [String: Any] { self.activityScheduleFailedEventDetails = try States.ActivityScheduleFailedEventDetails(dictionary: activityScheduleFailedEventDetails) }
            guard let timestamp = dictionary["timestamp"] as? Date else { throw InitializableError.missingRequiredParam("timestamp") }
            self.timestamp = timestamp
            self.previousEventId = dictionary["previousEventId"] as? Int64
            guard let id = dictionary["id"] as? Int64 else { throw InitializableError.missingRequiredParam("id") }
            self.id = id
            if let activityTimedOutEventDetails = dictionary["activityTimedOutEventDetails"] as? [String: Any] { self.activityTimedOutEventDetails = try States.ActivityTimedOutEventDetails(dictionary: activityTimedOutEventDetails) }
            if let lambdaFunctionScheduledEventDetails = dictionary["lambdaFunctionScheduledEventDetails"] as? [String: Any] { self.lambdaFunctionScheduledEventDetails = try States.LambdaFunctionScheduledEventDetails(dictionary: lambdaFunctionScheduledEventDetails) }
            if let activitySucceededEventDetails = dictionary["activitySucceededEventDetails"] as? [String: Any] { self.activitySucceededEventDetails = try States.ActivitySucceededEventDetails(dictionary: activitySucceededEventDetails) }
            if let stateExitedEventDetails = dictionary["stateExitedEventDetails"] as? [String: Any] { self.stateExitedEventDetails = try States.StateExitedEventDetails(dictionary: stateExitedEventDetails) }
            if let lambdaFunctionScheduleFailedEventDetails = dictionary["lambdaFunctionScheduleFailedEventDetails"] as? [String: Any] { self.lambdaFunctionScheduleFailedEventDetails = try States.LambdaFunctionScheduleFailedEventDetails(dictionary: lambdaFunctionScheduleFailedEventDetails) }
            if let lambdaFunctionStartFailedEventDetails = dictionary["lambdaFunctionStartFailedEventDetails"] as? [String: Any] { self.lambdaFunctionStartFailedEventDetails = try States.LambdaFunctionStartFailedEventDetails(dictionary: lambdaFunctionStartFailedEventDetails) }
        }
    }

    public struct ListActivitiesOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The list of activities.
        public var activities: [ActivityListItem] = []
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil

        public init() {}

        public init(activities: [ActivityListItem], nextToken: String? = nil) {
            self.activities = activities
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let activities = dictionary["activities"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("activities") }
            self.activities = try activities.map({ try ActivityListItem(dictionary: $0) })
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct SendTaskFailureOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListStateMachinesInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        public var maxResults: Int32? = nil
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["maxResults"] as? Int32
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct ListExecutionsOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The list of matching executions.
        public var executions: [ExecutionListItem] = []
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil

        public init() {}

        public init(executions: [ExecutionListItem], nextToken: String? = nil) {
            self.executions = executions
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let executions = dictionary["executions"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("executions") }
            self.executions = try executions.map({ try ExecutionListItem(dictionary: $0) })
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct CreateStateMachineInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the state machine. This name must be unique for your AWS account and region.
        public var name: String = ""
        /// The Amazon States Language definition of the state machine.
        public var definition: String = ""
        /// The Amazon Resource Name (ARN) of the IAM role to use for this state machine.
        public var roleArn: String = ""

        public init() {}

        public init(name: String, definition: String, roleArn: String) {
            self.name = name
            self.definition = definition
            self.roleArn = roleArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let definition = dictionary["definition"] as? String else { throw InitializableError.missingRequiredParam("definition") }
            self.definition = definition
            guard let roleArn = dictionary["roleArn"] as? String else { throw InitializableError.missingRequiredParam("roleArn") }
            self.roleArn = roleArn
        }
    }

    public struct SendTaskHeartbeatInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token that represents this task. Task tokens are generated by the service when the tasks are assigned to a worker (see GetActivityTask::taskToken).
        public var taskToken: String = ""

        public init() {}

        public init(taskToken: String) {
            self.taskToken = taskToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let taskToken = dictionary["taskToken"] as? String else { throw InitializableError.missingRequiredParam("taskToken") }
            self.taskToken = taskToken
        }
    }

    public struct ActivityScheduleFailedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ActivitySucceededEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON data output by the activity task.
        public var output: String? = nil

        public init() {}

        public init(output: String? = nil) {
            self.output = output
        }

        public init(dictionary: [String: Any]) throws {
            self.output = dictionary["output"] as? String
        }
    }

    public struct SendTaskFailureInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token that represents this task. Task tokens are generated by the service when the tasks are assigned to a worker (see GetActivityTask::taskToken).
        public var taskToken: String = ""
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// An arbitrary error code that identifies the cause of the failure.
        public var error: String? = nil

        public init() {}

        public init(taskToken: String, cause: String? = nil, error: String? = nil) {
            self.taskToken = taskToken
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            guard let taskToken = dictionary["taskToken"] as? String else { throw InitializableError.missingRequiredParam("taskToken") }
            self.taskToken = taskToken
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct GetActivityTaskInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An arbitrary name may be provided in order to identify the worker that the task is assigned to. This name will be used when it is logged in the execution history.
        public var workerName: String? = nil
        /// The Amazon Resource Name (ARN) of the activity to retrieve tasks from.
        public var activityArn: String = ""

        public init() {}

        public init(workerName: String? = nil, activityArn: String) {
            self.workerName = workerName
            self.activityArn = activityArn
        }

        public init(dictionary: [String: Any]) throws {
            self.workerName = dictionary["workerName"] as? String
            guard let activityArn = dictionary["activityArn"] as? String else { throw InitializableError.missingRequiredParam("activityArn") }
            self.activityArn = activityArn
        }
    }

    public struct DescribeActivityInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the activity to describe.
        public var activityArn: String = ""

        public init() {}

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let activityArn = dictionary["activityArn"] as? String else { throw InitializableError.missingRequiredParam("activityArn") }
            self.activityArn = activityArn
        }
    }

    public struct LambdaFunctionScheduledEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum allowed duration of the lambda function.
        public var timeoutInSeconds: Int64? = nil
        /// The JSON data input to the lambda function.
        public var input: String? = nil
        /// The Amazon Resource Name (ARN) of the scheduled lambda function.
        public var resource: String = ""

        public init() {}

        public init(timeoutInSeconds: Int64? = nil, input: String? = nil, resource: String) {
            self.timeoutInSeconds = timeoutInSeconds
            self.input = input
            self.resource = resource
        }

        public init(dictionary: [String: Any]) throws {
            self.timeoutInSeconds = dictionary["timeoutInSeconds"] as? Int64
            self.input = dictionary["input"] as? String
            guard let resource = dictionary["resource"] as? String else { throw InitializableError.missingRequiredParam("resource") }
            self.resource = resource
        }
    }

    public struct DeleteStateMachineOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct GetActivityTaskOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A token that identifies the scheduled task. This token must be copied and included in subsequent calls to SendTaskHeartbeat, SendTaskSuccess or SendTaskFailure in order to report the progress or completion of the task.
        public var taskToken: String? = nil
        /// The JSON input data for the task.
        public var input: String? = nil

        public init() {}

        public init(taskToken: String? = nil, input: String? = nil) {
            self.taskToken = taskToken
            self.input = input
        }

        public init(dictionary: [String: Any]) throws {
            self.taskToken = dictionary["taskToken"] as? String
            self.input = dictionary["input"] as? String
        }
    }

    public struct StateExitedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON output data of the state.
        public var output: String? = nil
        /// The name of the state.
        public var name: String = ""

        public init() {}

        public init(output: String? = nil, name: String) {
            self.output = output
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.output = dictionary["output"] as? String
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct LambdaFunctionSucceededEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON data output by the lambda function.
        public var output: String? = nil

        public init() {}

        public init(output: String? = nil) {
            self.output = output
        }

        public init(dictionary: [String: Any]) throws {
            self.output = dictionary["output"] as? String
        }
    }

    public struct ActivityScheduledEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum allowed duration of the activity task.
        public var timeoutInSeconds: Int64? = nil
        /// The JSON data input to the activity task.
        public var input: String? = nil
        /// The maximum allowed duration between two heartbeats for the activity task.
        public var heartbeatInSeconds: Int64? = nil
        /// The Amazon Resource Name (ARN) of the scheduled activity.
        public var resource: String = ""

        public init() {}

        public init(timeoutInSeconds: Int64? = nil, input: String? = nil, heartbeatInSeconds: Int64? = nil, resource: String) {
            self.timeoutInSeconds = timeoutInSeconds
            self.input = input
            self.heartbeatInSeconds = heartbeatInSeconds
            self.resource = resource
        }

        public init(dictionary: [String: Any]) throws {
            self.timeoutInSeconds = dictionary["timeoutInSeconds"] as? Int64
            self.input = dictionary["input"] as? String
            self.heartbeatInSeconds = dictionary["heartbeatInSeconds"] as? Int64
            guard let resource = dictionary["resource"] as? String else { throw InitializableError.missingRequiredParam("resource") }
            self.resource = resource
        }
    }

    public struct CreateStateMachineOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the created state machine.
        public var stateMachineArn: String = ""
        /// The date the state machine was created.
        public var creationDate: Date = Date()

        public init() {}

        public init(stateMachineArn: String, creationDate: Date) {
            self.stateMachineArn = stateMachineArn
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
            guard let creationDate = dictionary["creationDate"] as? Date else { throw InitializableError.missingRequiredParam("creationDate") }
            self.creationDate = creationDate
        }
    }

    public struct DescribeExecutionInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the execution to describe.
        public var executionArn: String = ""

        public init() {}

        public init(executionArn: String) {
            self.executionArn = executionArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let executionArn = dictionary["executionArn"] as? String else { throw InitializableError.missingRequiredParam("executionArn") }
            self.executionArn = executionArn
        }
    }

    public struct DeleteActivityInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the activity to delete.
        public var activityArn: String = ""

        public init() {}

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let activityArn = dictionary["activityArn"] as? String else { throw InitializableError.missingRequiredParam("activityArn") }
            self.activityArn = activityArn
        }
    }

    public struct DeleteStateMachineInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the state machine to delete.
        public var stateMachineArn: String = ""

        public init() {}

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
        }
    }

    public struct DescribeStateMachineInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the state machine to describe.
        public var stateMachineArn: String = ""

        public init() {}

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
        }
    }

    public struct SendTaskSuccessInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON output of the task.
        public var output: String = ""
        /// The token that represents this task. Task tokens are generated by the service when the tasks are assigned to a worker (see GetActivityTask::taskToken).
        public var taskToken: String = ""

        public init() {}

        public init(output: String, taskToken: String) {
            self.output = output
            self.taskToken = taskToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let output = dictionary["output"] as? String else { throw InitializableError.missingRequiredParam("output") }
            self.output = output
            guard let taskToken = dictionary["taskToken"] as? String else { throw InitializableError.missingRequiredParam("taskToken") }
            self.taskToken = taskToken
        }
    }

    public struct LambdaFunctionScheduleFailedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ExecutionFailedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ListStateMachinesOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil
        public var stateMachines: [StateMachineListItem] = []

        public init() {}

        public init(nextToken: String? = nil, stateMachines: [StateMachineListItem]) {
            self.nextToken = nextToken
            self.stateMachines = stateMachines
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            guard let stateMachines = dictionary["stateMachines"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("stateMachines") }
            self.stateMachines = try stateMachines.map({ try StateMachineListItem(dictionary: $0) })
        }
    }

    public struct CreateActivityInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the activity to create. This name must be unique for your AWS account and region.
        public var name: String = ""

        public init() {}

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
        }
    }

    public struct ListExecutionsInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If specified, only list the executions whose current execution status matches the given filter.
        public var statusFilter: String? = nil
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        public var maxResults: Int32? = nil
        /// The Amazon Resource Name (ARN) of the state machine whose executions will be listed.
        public var stateMachineArn: String = ""
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil

        public init() {}

        public init(statusFilter: String? = nil, maxResults: Int32? = nil, stateMachineArn: String, nextToken: String? = nil) {
            self.statusFilter = statusFilter
            self.maxResults = maxResults
            self.stateMachineArn = stateMachineArn
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            self.statusFilter = dictionary["statusFilter"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
            self.nextToken = dictionary["nextToken"] as? String
        }
    }

    public struct LambdaFunctionTimedOutEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the timeout.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct GetExecutionHistoryInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        public var nextToken: String? = nil
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        public var maxResults: Int32? = nil
        /// Lists events in descending order of their timeStamp.
        public var reverseOrder: Bool? = nil
        /// The Amazon Resource Name (ARN) of the execution.
        public var executionArn: String = ""

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil, reverseOrder: Bool? = nil, executionArn: String) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.reverseOrder = reverseOrder
            self.executionArn = executionArn
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["nextToken"] as? String
            self.maxResults = dictionary["maxResults"] as? Int32
            self.reverseOrder = dictionary["reverseOrder"] as? Bool
            guard let executionArn = dictionary["executionArn"] as? String else { throw InitializableError.missingRequiredParam("executionArn") }
            self.executionArn = executionArn
        }
    }

    public struct ExecutionStartedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) of the IAM role used for executing AWS Lambda tasks.
        public var roleArn: String? = nil
        /// The JSON data input to the execution.
        public var input: String? = nil

        public init() {}

        public init(roleArn: String? = nil, input: String? = nil) {
            self.roleArn = roleArn
            self.input = input
        }

        public init(dictionary: [String: Any]) throws {
            self.roleArn = dictionary["roleArn"] as? String
            self.input = dictionary["input"] as? String
        }
    }

    public struct LambdaFunctionFailedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ActivityStartedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the worker that the task was assigned to. These names are provided by the workers when calling GetActivityTask.
        public var workerName: String? = nil

        public init() {}

        public init(workerName: String? = nil) {
            self.workerName = workerName
        }

        public init(dictionary: [String: Any]) throws {
            self.workerName = dictionary["workerName"] as? String
        }
    }

    public struct StateMachineListItem: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        public var stateMachineArn: String = ""
        /// The name of the state machine.
        public var name: String = ""
        /// The date the state machine was created.
        public var creationDate: Date = Date()

        public init() {}

        public init(stateMachineArn: String, name: String, creationDate: Date) {
            self.stateMachineArn = stateMachineArn
            self.name = name
            self.creationDate = creationDate
        }

        public init(dictionary: [String: Any]) throws {
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
            guard let name = dictionary["name"] as? String else { throw InitializableError.missingRequiredParam("name") }
            self.name = name
            guard let creationDate = dictionary["creationDate"] as? Date else { throw InitializableError.missingRequiredParam("creationDate") }
            self.creationDate = creationDate
        }
    }

    public struct SendTaskSuccessOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ExecutionTimedOutEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the timeout.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ExecutionAbortedEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A more detailed explanation of the cause of the failure.
        public var cause: String? = nil
        /// The error code of the failure.
        public var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        public init(dictionary: [String: Any]) throws {
            self.cause = dictionary["cause"] as? String
            self.error = dictionary["error"] as? String
        }
    }

    public struct ExecutionSucceededEventDetails: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON data output by the execution.
        public var output: String? = nil

        public init() {}

        public init(output: String? = nil) {
            self.output = output
        }

        public init(dictionary: [String: Any]) throws {
            self.output = dictionary["output"] as? String
        }
    }

    public struct DescribeExecutionOutput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The current status of the execution.
        public var status: String = ""
        /// The name of the execution.
        public var name: String? = nil
        /// If the execution has already ended, the date the execution stopped.
        public var stopDate: Date? = nil
        /// The date the execution was started.
        public var startDate: Date = Date()
        /// The JSON output data of the execution.
        public var output: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public var executionArn: String = ""
        /// The JSON input data of the execution.
        public var input: String = ""
        /// The Amazon Resource Name (ARN) of the executed stated machine.
        public var stateMachineArn: String = ""

        public init() {}

        public init(status: String, name: String? = nil, stopDate: Date? = nil, startDate: Date, output: String? = nil, executionArn: String, input: String, stateMachineArn: String) {
            self.status = status
            self.name = name
            self.stopDate = stopDate
            self.startDate = startDate
            self.output = output
            self.executionArn = executionArn
            self.input = input
            self.stateMachineArn = stateMachineArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let status = dictionary["status"] as? String else { throw InitializableError.missingRequiredParam("status") }
            self.status = status
            self.name = dictionary["name"] as? String
            self.stopDate = dictionary["stopDate"] as? Date
            guard let startDate = dictionary["startDate"] as? Date else { throw InitializableError.missingRequiredParam("startDate") }
            self.startDate = startDate
            self.output = dictionary["output"] as? String
            guard let executionArn = dictionary["executionArn"] as? String else { throw InitializableError.missingRequiredParam("executionArn") }
            self.executionArn = executionArn
            guard let input = dictionary["input"] as? String else { throw InitializableError.missingRequiredParam("input") }
            self.input = input
            guard let stateMachineArn = dictionary["stateMachineArn"] as? String else { throw InitializableError.missingRequiredParam("stateMachineArn") }
            self.stateMachineArn = stateMachineArn
        }
    }

    public struct StopExecutionInput: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// An arbitrary error code that identifies the cause of the termination.
        public var error: String? = nil
        /// The Amazon Resource Name (ARN) of the execution to stop.
        public var executionArn: String = ""
        /// A more detailed explanation of the cause of the termination.
        public var cause: String? = nil

        public init() {}

        public init(error: String? = nil, executionArn: String, cause: String? = nil) {
            self.error = error
            self.executionArn = executionArn
            self.cause = cause
        }

        public init(dictionary: [String: Any]) throws {
            self.error = dictionary["error"] as? String
            guard let executionArn = dictionary["executionArn"] as? String else { throw InitializableError.missingRequiredParam("executionArn") }
            self.executionArn = executionArn
            self.cause = dictionary["cause"] as? String
        }
    }

}