// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension States {

    public struct StateEnteredEventDetails: Serializable, Initializable {
        /// The name of the state.
        var name: String = ""
        /// The JSON input data to the state.
        var input: String? = nil

        public init() {}

        public init(name: String, input: String? = nil) {
            self.name = name
            self.input = input
        }

    }

    public struct SendTaskHeartbeatOutput: Serializable, Initializable {

        public init() {}

    }

    public struct StopExecutionOutput: Serializable, Initializable {
        /// The date the execution was stopped.
        var stopDate: Date = Date()

        public init() {}

        public init(stopDate: Date) {
            self.stopDate = stopDate
        }

    }

    public struct CreateActivityOutput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) that identifies the created activity.
        var activityArn: String = ""
        /// The date the activity was created.
        var creationDate: Date = Date()

        public init() {}

        public init(activityArn: String, creationDate: Date) {
            self.activityArn = activityArn
            self.creationDate = creationDate
        }

    }

    public struct ListActivitiesInput: Serializable, Initializable {
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        var maxResults: Int32? = nil
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

    }

    public struct GetExecutionHistoryOutput: Serializable, Initializable {
        /// The list of events that occurred in the execution.
        var events: [HistoryEvent] = []
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil

        public init() {}

        public init(events: [HistoryEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

    }

    public struct ActivityFailedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ActivityListItem: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) that identifies the activity.
        var activityArn: String = ""
        /// The name of the activity.
        var name: String = ""
        /// The date the activity was created.
        var creationDate: Date = Date()

        public init() {}

        public init(activityArn: String, name: String, creationDate: Date) {
            self.activityArn = activityArn
            self.name = name
            self.creationDate = creationDate
        }

    }

    public struct DescribeActivityOutput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) that identifies the activity.
        var activityArn: String = ""
        /// The name of the activity.
        var name: String = ""
        /// The date the activity was created.
        var creationDate: Date = Date()

        public init() {}

        public init(activityArn: String, name: String, creationDate: Date) {
            self.activityArn = activityArn
            self.name = name
            self.creationDate = creationDate
        }

    }

    public struct ExecutionListItem: Serializable, Initializable {
        /// The current status of the execution.
        var status: String = ""
        /// The name of the execution.
        var name: String = ""
        /// The Amazon Resource Name (ARN) of the executed state machine.
        var stateMachineArn: String = ""
        /// The date the execution started.
        var startDate: Date = Date()
        /// If the execution already ended, the date the execution stopped.
        var stopDate: Date? = nil
        /// The Amazon Resource Name (ARN) that identifies the execution.
        var executionArn: String = ""

        public init() {}

        public init(status: String, name: String, stateMachineArn: String, startDate: Date, stopDate: Date? = nil, executionArn: String) {
            self.status = status
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.startDate = startDate
            self.stopDate = stopDate
            self.executionArn = executionArn
        }

    }

    public struct StartExecutionInput: Serializable, Initializable {
        /// The name of the execution. This name must be unique for your AWS account and region.
        var name: String? = nil
        /// The JSON input data for the execution.
        var input: String? = nil
        /// The Amazon Resource Name (ARN) of the state machine to execute.
        var stateMachineArn: String = ""

        public init() {}

        public init(name: String? = nil, input: String? = nil, stateMachineArn: String) {
            self.name = name
            self.input = input
            self.stateMachineArn = stateMachineArn
        }

    }

    public struct DeleteActivityOutput: Serializable, Initializable {

        public init() {}

    }

    public struct DescribeStateMachineOutput: Serializable, Initializable {
        /// The current status of the state machine.
        var status: String? = nil
        /// The name of the state machine.
        var name: String = ""
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        var stateMachineArn: String = ""
        /// The date the state machine was created.
        var creationDate: Date = Date()
        /// The Amazon States Language definition of the state machine.
        var definition: String = ""
        /// The Amazon Resource Name (ARN) of the IAM role used for executing this state machine.
        var roleArn: String = ""

        public init() {}

        public init(status: String? = nil, name: String, stateMachineArn: String, creationDate: Date, definition: String, roleArn: String) {
            self.status = status
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.creationDate = creationDate
            self.definition = definition
            self.roleArn = roleArn
        }

    }

    public struct LambdaFunctionStartFailedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ActivityTimedOutEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the timeout.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct StartExecutionOutput: Serializable, Initializable {
        /// The date the execution was started.
        var startDate: Date = Date()
        /// The Amazon Resource Name (ARN) that identifies the execution.
        var executionArn: String = ""

        public init() {}

        public init(startDate: Date, executionArn: String) {
            self.startDate = startDate
            self.executionArn = executionArn
        }

    }

    public struct HistoryEvent: Serializable, Initializable {
        var lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil
        var lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil
        var executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil
        var activityFailedEventDetails: ActivityFailedEventDetails? = nil
        var executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil
        var lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil
        var executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil
        var executionFailedEventDetails: ExecutionFailedEventDetails? = nil
        var activityScheduledEventDetails: ActivityScheduledEventDetails? = nil
        var activityStartedEventDetails: ActivityStartedEventDetails? = nil
        /// The type of the event.
        var type: String = ""
        var stateEnteredEventDetails: StateEnteredEventDetails? = nil
        var executionStartedEventDetails: ExecutionStartedEventDetails? = nil
        var activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil
        /// The date the event occured.
        var timestamp: Date = Date()
        /// The id of the previous event.
        var previousEventId: Int64? = nil
        /// The id of the event. Events are numbered sequentially, starting at one.
        var id: Int64 = 0
        var activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil
        var lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil
        var activitySucceededEventDetails: ActivitySucceededEventDetails? = nil
        var stateExitedEventDetails: StateExitedEventDetails? = nil
        var lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil
        var lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil

        public init() {}

        public init(lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil, lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil, executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil, activityFailedEventDetails: ActivityFailedEventDetails? = nil, executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil, lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil, executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil, executionFailedEventDetails: ExecutionFailedEventDetails? = nil, activityScheduledEventDetails: ActivityScheduledEventDetails? = nil, activityStartedEventDetails: ActivityStartedEventDetails? = nil, type: String, stateEnteredEventDetails: StateEnteredEventDetails? = nil, executionStartedEventDetails: ExecutionStartedEventDetails? = nil, activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil, timestamp: Date, previousEventId: Int64? = nil, id: Int64, activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil, lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil, activitySucceededEventDetails: ActivitySucceededEventDetails? = nil, stateExitedEventDetails: StateExitedEventDetails? = nil, lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil, lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil) {
            self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
            self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
            self.executionSucceededEventDetails = executionSucceededEventDetails
            self.activityFailedEventDetails = activityFailedEventDetails
            self.executionTimedOutEventDetails = executionTimedOutEventDetails
            self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
            self.executionAbortedEventDetails = executionAbortedEventDetails
            self.executionFailedEventDetails = executionFailedEventDetails
            self.activityScheduledEventDetails = activityScheduledEventDetails
            self.activityStartedEventDetails = activityStartedEventDetails
            self.type = type
            self.stateEnteredEventDetails = stateEnteredEventDetails
            self.executionStartedEventDetails = executionStartedEventDetails
            self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
            self.timestamp = timestamp
            self.previousEventId = previousEventId
            self.id = id
            self.activityTimedOutEventDetails = activityTimedOutEventDetails
            self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
            self.activitySucceededEventDetails = activitySucceededEventDetails
            self.stateExitedEventDetails = stateExitedEventDetails
            self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
            self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
        }

    }

    public struct ListActivitiesOutput: Serializable, Initializable {
        /// The list of activities.
        var activities: [ActivityListItem] = []
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil

        public init() {}

        public init(activities: [ActivityListItem], nextToken: String? = nil) {
            self.activities = activities
            self.nextToken = nextToken
        }

    }

    public struct SendTaskFailureOutput: Serializable, Initializable {

        public init() {}

    }

    public struct ListStateMachinesInput: Serializable, Initializable {
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        var maxResults: Int32? = nil
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

    }

    public struct ListExecutionsOutput: Serializable, Initializable {
        /// The list of matching executions.
        var executions: [ExecutionListItem] = []
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil

        public init() {}

        public init(executions: [ExecutionListItem], nextToken: String? = nil) {
            self.executions = executions
            self.nextToken = nextToken
        }

    }

    public struct CreateStateMachineInput: Serializable, Initializable {
        /// The name of the state machine. This name must be unique for your AWS account and region.
        var name: String = ""
        /// The Amazon States Language definition of the state machine.
        var definition: String = ""
        /// The Amazon Resource Name (ARN) of the IAM role to use for this state machine.
        var roleArn: String = ""

        public init() {}

        public init(name: String, definition: String, roleArn: String) {
            self.name = name
            self.definition = definition
            self.roleArn = roleArn
        }

    }

    public struct SendTaskHeartbeatInput: Serializable, Initializable {
        /// The token that represents this task. Task tokens are generated by the service when the tasks are assigned to a worker (see GetActivityTask::taskToken).
        var taskToken: String = ""

        public init() {}

        public init(taskToken: String) {
            self.taskToken = taskToken
        }

    }

    public struct ActivityScheduleFailedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ActivitySucceededEventDetails: Serializable, Initializable {
        /// The JSON data output by the activity task.
        var output: String? = nil

        public init() {}

        public init(output: String? = nil) {
            self.output = output
        }

    }

    public struct SendTaskFailureInput: Serializable, Initializable {
        /// The token that represents this task. Task tokens are generated by the service when the tasks are assigned to a worker (see GetActivityTask::taskToken).
        var taskToken: String = ""
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// An arbitrary error code that identifies the cause of the failure.
        var error: String? = nil

        public init() {}

        public init(taskToken: String, cause: String? = nil, error: String? = nil) {
            self.taskToken = taskToken
            self.cause = cause
            self.error = error
        }

    }

    public struct GetActivityTaskInput: Serializable, Initializable {
        /// An arbitrary name may be provided in order to identify the worker that the task is assigned to. This name will be used when it is logged in the execution history.
        var workerName: String? = nil
        /// The Amazon Resource Name (ARN) of the activity to retrieve tasks from.
        var activityArn: String = ""

        public init() {}

        public init(workerName: String? = nil, activityArn: String) {
            self.workerName = workerName
            self.activityArn = activityArn
        }

    }

    public struct DescribeActivityInput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the activity to describe.
        var activityArn: String = ""

        public init() {}

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

    }

    public struct LambdaFunctionScheduledEventDetails: Serializable, Initializable {
        /// The maximum allowed duration of the lambda function.
        var timeoutInSeconds: Int64? = nil
        /// The JSON data input to the lambda function.
        var input: String? = nil
        /// The Amazon Resource Name (ARN) of the scheduled lambda function.
        var resource: String = ""

        public init() {}

        public init(timeoutInSeconds: Int64? = nil, input: String? = nil, resource: String) {
            self.timeoutInSeconds = timeoutInSeconds
            self.input = input
            self.resource = resource
        }

    }

    public struct DeleteStateMachineOutput: Serializable, Initializable {

        public init() {}

    }

    public struct GetActivityTaskOutput: Serializable, Initializable {
        /// A token that identifies the scheduled task. This token must be copied and included in subsequent calls to SendTaskHeartbeat, SendTaskSuccess or SendTaskFailure in order to report the progress or completion of the task.
        var taskToken: String? = nil
        /// The JSON input data for the task.
        var input: String? = nil

        public init() {}

        public init(taskToken: String? = nil, input: String? = nil) {
            self.taskToken = taskToken
            self.input = input
        }

    }

    public struct StateExitedEventDetails: Serializable, Initializable {
        /// The JSON output data of the state.
        var output: String? = nil
        /// The name of the state.
        var name: String = ""

        public init() {}

        public init(output: String? = nil, name: String) {
            self.output = output
            self.name = name
        }

    }

    public struct LambdaFunctionSucceededEventDetails: Serializable, Initializable {
        /// The JSON data output by the lambda function.
        var output: String? = nil

        public init() {}

        public init(output: String? = nil) {
            self.output = output
        }

    }

    public struct ActivityScheduledEventDetails: Serializable, Initializable {
        /// The maximum allowed duration of the activity task.
        var timeoutInSeconds: Int64? = nil
        /// The JSON data input to the activity task.
        var input: String? = nil
        /// The maximum allowed duration between two heartbeats for the activity task.
        var heartbeatInSeconds: Int64? = nil
        /// The Amazon Resource Name (ARN) of the scheduled activity.
        var resource: String = ""

        public init() {}

        public init(timeoutInSeconds: Int64? = nil, input: String? = nil, heartbeatInSeconds: Int64? = nil, resource: String) {
            self.timeoutInSeconds = timeoutInSeconds
            self.input = input
            self.heartbeatInSeconds = heartbeatInSeconds
            self.resource = resource
        }

    }

    public struct CreateStateMachineOutput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) that identifies the created state machine.
        var stateMachineArn: String = ""
        /// The date the state machine was created.
        var creationDate: Date = Date()

        public init() {}

        public init(stateMachineArn: String, creationDate: Date) {
            self.stateMachineArn = stateMachineArn
            self.creationDate = creationDate
        }

    }

    public struct DescribeExecutionInput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the execution to describe.
        var executionArn: String = ""

        public init() {}

        public init(executionArn: String) {
            self.executionArn = executionArn
        }

    }

    public struct DeleteActivityInput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the activity to delete.
        var activityArn: String = ""

        public init() {}

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

    }

    public struct DeleteStateMachineInput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the state machine to delete.
        var stateMachineArn: String = ""

        public init() {}

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

    }

    public struct DescribeStateMachineInput: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the state machine to describe.
        var stateMachineArn: String = ""

        public init() {}

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

    }

    public struct SendTaskSuccessInput: Serializable, Initializable {
        /// The JSON output of the task.
        var output: String = ""
        /// The token that represents this task. Task tokens are generated by the service when the tasks are assigned to a worker (see GetActivityTask::taskToken).
        var taskToken: String = ""

        public init() {}

        public init(output: String, taskToken: String) {
            self.output = output
            self.taskToken = taskToken
        }

    }

    public struct LambdaFunctionScheduleFailedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ExecutionFailedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ListStateMachinesOutput: Serializable, Initializable {
        /// If a nextToken is returned, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil
        var stateMachines: [StateMachineListItem] = []

        public init() {}

        public init(nextToken: String? = nil, stateMachines: [StateMachineListItem]) {
            self.nextToken = nextToken
            self.stateMachines = stateMachines
        }

    }

    public struct CreateActivityInput: Serializable, Initializable {
        /// The name of the activity to create. This name must be unique for your AWS account and region.
        var name: String = ""

        public init() {}

        public init(name: String) {
            self.name = name
        }

    }

    public struct ListExecutionsInput: Serializable, Initializable {
        /// If specified, only list the executions whose current execution status matches the given filter.
        var statusFilter: String? = nil
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        var maxResults: Int32? = nil
        /// The Amazon Resource Name (ARN) of the state machine whose executions will be listed.
        var stateMachineArn: String = ""
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil

        public init() {}

        public init(statusFilter: String? = nil, maxResults: Int32? = nil, stateMachineArn: String, nextToken: String? = nil) {
            self.statusFilter = statusFilter
            self.maxResults = maxResults
            self.stateMachineArn = stateMachineArn
            self.nextToken = nextToken
        }

    }

    public struct LambdaFunctionTimedOutEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the timeout.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct GetExecutionHistoryInput: Serializable, Initializable {
        /// If a nextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in nextToken. Keep all other arguments unchanged. The configured maxResults determines how many results can be returned in a single call.
        var nextToken: String? = nil
        /// The maximum number of results that will be returned per call. nextToken can be used to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. This is an upper limit only; the actual number of results returned per call may be fewer than the specified maximum.
        var maxResults: Int32? = nil
        /// Lists events in descending order of their timeStamp.
        var reverseOrder: Bool? = nil
        /// The Amazon Resource Name (ARN) of the execution.
        var executionArn: String = ""

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil, reverseOrder: Bool? = nil, executionArn: String) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.reverseOrder = reverseOrder
            self.executionArn = executionArn
        }

    }

    public struct ExecutionStartedEventDetails: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) of the IAM role used for executing AWS Lambda tasks.
        var roleArn: String? = nil
        /// The JSON data input to the execution.
        var input: String? = nil

        public init() {}

        public init(roleArn: String? = nil, input: String? = nil) {
            self.roleArn = roleArn
            self.input = input
        }

    }

    public struct LambdaFunctionFailedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ActivityStartedEventDetails: Serializable, Initializable {
        /// The name of the worker that the task was assigned to. These names are provided by the workers when calling GetActivityTask.
        var workerName: String? = nil

        public init() {}

        public init(workerName: String? = nil) {
            self.workerName = workerName
        }

    }

    public struct StateMachineListItem: Serializable, Initializable {
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        var stateMachineArn: String = ""
        /// The name of the state machine.
        var name: String = ""
        /// The date the state machine was created.
        var creationDate: Date = Date()

        public init() {}

        public init(stateMachineArn: String, name: String, creationDate: Date) {
            self.stateMachineArn = stateMachineArn
            self.name = name
            self.creationDate = creationDate
        }

    }

    public struct SendTaskSuccessOutput: Serializable, Initializable {

        public init() {}

    }

    public struct ExecutionTimedOutEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the timeout.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ExecutionAbortedEventDetails: Serializable, Initializable {
        /// A more detailed explanation of the cause of the failure.
        var cause: String? = nil
        /// The error code of the failure.
        var error: String? = nil

        public init() {}

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

    }

    public struct ExecutionSucceededEventDetails: Serializable, Initializable {
        /// The JSON data output by the execution.
        var output: String? = nil

        public init() {}

        public init(output: String? = nil) {
            self.output = output
        }

    }

    public struct DescribeExecutionOutput: Serializable, Initializable {
        /// The current status of the execution.
        var status: String = ""
        /// The name of the execution.
        var name: String? = nil
        /// If the execution has already ended, the date the execution stopped.
        var stopDate: Date? = nil
        /// The date the execution was started.
        var startDate: Date = Date()
        /// The JSON output data of the execution.
        var output: String? = nil
        /// The Amazon Resource Name (ARN) that identifies the execution.
        var executionArn: String = ""
        /// The JSON input data of the execution.
        var input: String = ""
        /// The Amazon Resource Name (ARN) of the executed stated machine.
        var stateMachineArn: String = ""

        public init() {}

        public init(status: String, name: String? = nil, stopDate: Date? = nil, startDate: Date, output: String? = nil, executionArn: String, input: String, stateMachineArn: String) {
            self.status = status
            self.name = name
            self.stopDate = stopDate
            self.startDate = startDate
            self.output = output
            self.executionArn = executionArn
            self.input = input
            self.stateMachineArn = stateMachineArn
        }

    }

    public struct StopExecutionInput: Serializable, Initializable {
        /// An arbitrary error code that identifies the cause of the termination.
        var error: String? = nil
        /// The Amazon Resource Name (ARN) of the execution to stop.
        var executionArn: String = ""
        /// A more detailed explanation of the cause of the termination.
        var cause: String? = nil

        public init() {}

        public init(error: String? = nil, executionArn: String, cause: String? = nil) {
            self.error = error
            self.executionArn = executionArn
            self.cause = cause
        }

    }

}