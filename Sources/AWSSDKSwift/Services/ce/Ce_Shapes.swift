// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Ce {

    public struct GetCostAndUsageResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupDefinitions", required: false, type: .list), 
            AWSShapeMember(label: "ResultsByTime", required: false, type: .list), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// The groups specified by the the Filter or GroupBy parameters in the request.
        public let groupDefinitions: [GroupDefinition]?
        /// The time period covered by the results in the response.
        public let resultsByTime: [ResultByTime]?
        /// The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(groupDefinitions: [GroupDefinition]? = nil, resultsByTime: [ResultByTime]? = nil, nextPageToken: String? = nil) {
            self.groupDefinitions = groupDefinitions
            self.resultsByTime = resultsByTime
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case groupDefinitions = "GroupDefinitions"
            case resultsByTime = "ResultsByTime"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct GetCostAndUsageRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Metrics", required: false, type: .list), 
            AWSShapeMember(label: "Filter", required: false, type: .structure), 
            AWSShapeMember(label: "GroupBy", required: false, type: .list), 
            AWSShapeMember(label: "TimePeriod", required: false, type: .structure), 
            AWSShapeMember(label: "Granularity", required: false, type: .enum), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// Which metrics are returned in the query. For more information about blended and unblended rates, see https://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/.  Valid values are BlendedCost, UnblendedCost, and UsageQuantity.  If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of EC2, the results aren't meaningful because EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups.  
        public let metrics: [String]?
        /// Filters AWS costs by different dimensions. For example, you can specify Service and Linked Account and get the costs associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see the Expression object or More Examples. 
        public let filter: Expression?
        /// You can group AWS costs using up to two different groups, either dimensions, tag keys, or both. When you group by tag key, you get all tag values, including empty strings. Valid values are: AZ, INSTANCE_TYPE, LINKED_ACCCOUNT, OPERATION, PURCHASE_TYPE, SERVICE, USAGE_TYPE, TAGS, and PLATFORM.
        public let groupBy: [GroupDefinition]?
        /// Sets the start and end dates for retrieving AWS costs. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval?
        /// Sets the AWS cost granularity to MONTHLY or DAILY.
        public let granularity: Granularity?
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(metrics: [String]? = nil, filter: Expression? = nil, groupBy: [GroupDefinition]? = nil, timePeriod: DateInterval? = nil, granularity: Granularity? = nil, nextPageToken: String? = nil) {
            self.metrics = metrics
            self.filter = filter
            self.groupBy = groupBy
            self.timePeriod = timePeriod
            self.granularity = granularity
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "Metrics"
            case filter = "Filter"
            case groupBy = "GroupBy"
            case timePeriod = "TimePeriod"
            case granularity = "Granularity"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct DimensionValues: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: false, type: .enum), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]
        /// The names of the metadata types that you can use to filter and group your results. For example, AZ returns a list of Availability Zones.
        public let key: Dimension?
        /// The metadata values that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
        public let values: [String]?

        public init(key: Dimension? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    public struct ResultByTime: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Estimated", required: false, type: .boolean), 
            AWSShapeMember(label: "TimePeriod", required: false, type: .structure), 
            AWSShapeMember(label: "Total", required: false, type: .map), 
            AWSShapeMember(label: "Groups", required: false, type: .list)
        ]
        /// Whether or not this result is estimated.
        public let estimated: Bool?
        /// The time period covered by a result.
        public let timePeriod: DateInterval?
        /// The total amount of cost or usage accrued during the time period.
        public let total: [String: MetricValue]?
        /// The groups that are included in this time period.
        public let groups: [Group]?

        public init(estimated: Bool? = nil, timePeriod: DateInterval? = nil, total: [String: MetricValue]? = nil, groups: [Group]? = nil) {
            self.estimated = estimated
            self.timePeriod = timePeriod
            self.total = total
            self.groups = groups
        }

        private enum CodingKeys: String, CodingKey {
            case estimated = "Estimated"
            case timePeriod = "TimePeriod"
            case total = "Total"
            case groups = "Groups"
        }
    }

    public struct DateInterval: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Start", required: true, type: .string), 
            AWSShapeMember(label: "End", required: true, type: .string)
        ]
        /// The beginning of the time period that you want the usage and costs for. The start date is inclusive. For example, if start is 2017-01-01, then the cost and usage data is retrieved starting at 2017-01-01 up to the end date.
        public let start: String
        /// The end of the time period that you want the usage and costs for. The end date is exclusive. For example, if the end is 2017-05-01, then the cost and usage data is retrieved from the start date but not including 2017-05-01.
        public let end: String

        public init(start: String, end: String) {
            self.start = start
            self.end = end
        }

        private enum CodingKeys: String, CodingKey {
            case start = "Start"
            case end = "End"
        }
    }

    public class Expression: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Or", required: false, type: .list), 
            AWSShapeMember(label: "Dimensions", required: false, type: .structure), 
            AWSShapeMember(label: "Not", required: false, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .structure), 
            AWSShapeMember(label: "And", required: false, type: .list)
        ]
        /// Return results that match either Dimension.
        public let or: [Expression]?
        /// The specific Dimension to use for Expression.
        public let dimensions: DimensionValues?
        /// Return results that don't match Dimension.
        public let not: Expression?
        /// The specific Tag to use for Expression.
        public let tags: TagValues?
        /// Return results that match both Dimension objects.
        public let and: [Expression]?

        public init(or: [Expression]? = nil, dimensions: DimensionValues? = nil, not: Expression? = nil, tags: TagValues? = nil, and: [Expression]? = nil) {
            self.or = or
            self.dimensions = dimensions
            self.not = not
            self.tags = tags
            self.and = and
        }

        private enum CodingKeys: String, CodingKey {
            case or = "Or"
            case dimensions = "Dimensions"
            case not = "Not"
            case tags = "Tags"
            case and = "And"
        }
    }

    public struct GroupDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "Key", required: false, type: .string)
        ]
        /// The string that represents the type of group.
        public let `type`: GroupDefinitionType?
        /// The string that represents a key for a specified group.
        public let key: String?

        public init(type: GroupDefinitionType? = nil, key: String? = nil) {
            self.`type` = `type`
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case key = "Key"
        }
    }

    public struct MetricValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Unit", required: false, type: .string), 
            AWSShapeMember(label: "Amount", required: false, type: .string)
        ]
        /// The unit that the metric is given in.
        public let unit: String?
        /// The actual number that represents the metric.
        public let amount: String?

        public init(unit: String? = nil, amount: String? = nil) {
            self.unit = unit
            self.amount = amount
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case amount = "Amount"
        }
    }

    public struct GetTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagKey", required: false, type: .string), 
            AWSShapeMember(label: "TimePeriod", required: true, type: .structure), 
            AWSShapeMember(label: "SearchString", required: false, type: .string), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// The key of the tag that you want to return values for.
        public let tagKey: String?
        /// The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval
        /// The value that you want to search for.
        public let searchString: String?
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(tagKey: String? = nil, timePeriod: DateInterval, searchString: String? = nil, nextPageToken: String? = nil) {
            self.tagKey = tagKey
            self.timePeriod = timePeriod
            self.searchString = searchString
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "TagKey"
            case timePeriod = "TimePeriod"
            case searchString = "SearchString"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct UtilizationByTime: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TimePeriod", required: false, type: .structure), 
            AWSShapeMember(label: "Groups", required: false, type: .list), 
            AWSShapeMember(label: "Total", required: false, type: .structure)
        ]
        /// The period of time over which this utilization was used.
        public let timePeriod: DateInterval?
        /// The groups that are included in this utilization result.
        public let groups: [ReservationUtilizationGroup]?
        /// The total number of RI hours that were used.
        public let total: ReservationAggregates?

        public init(timePeriod: DateInterval? = nil, groups: [ReservationUtilizationGroup]? = nil, total: ReservationAggregates? = nil) {
            self.timePeriod = timePeriod
            self.groups = groups
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case timePeriod = "TimePeriod"
            case groups = "Groups"
            case total = "Total"
        }
    }

    public struct ReservationAggregates: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UtilizationPercentage", required: false, type: .string), 
            AWSShapeMember(label: "TotalActualHours", required: false, type: .string), 
            AWSShapeMember(label: "PurchasedHours", required: false, type: .string), 
            AWSShapeMember(label: "UnusedHours", required: false, type: .string)
        ]
        /// The percentage of RI time that you used.
        public let utilizationPercentage: String?
        /// The total number of RI hours that you used.
        public let totalActualHours: String?
        /// How many RI hours you purchased.
        public let purchasedHours: String?
        /// The number of RI hours that you didn't use.
        public let unusedHours: String?

        public init(utilizationPercentage: String? = nil, totalActualHours: String? = nil, purchasedHours: String? = nil, unusedHours: String? = nil) {
            self.utilizationPercentage = utilizationPercentage
            self.totalActualHours = totalActualHours
            self.purchasedHours = purchasedHours
            self.unusedHours = unusedHours
        }

        private enum CodingKeys: String, CodingKey {
            case utilizationPercentage = "UtilizationPercentage"
            case totalActualHours = "TotalActualHours"
            case purchasedHours = "PurchasedHours"
            case unusedHours = "UnusedHours"
        }
    }

    public struct GetTagsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnSize", required: true, type: .integer), 
            AWSShapeMember(label: "TotalSize", required: true, type: .integer), 
            AWSShapeMember(label: "Tags", required: true, type: .list), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// The number of query results that AWS returns at a time.
        public let returnSize: Int32
        /// The total number of query results.
        public let totalSize: Int32
        /// The tags that match your request.
        public let tags: [String]
        /// The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(returnSize: Int32, totalSize: Int32, tags: [String], nextPageToken: String? = nil) {
            self.returnSize = returnSize
            self.totalSize = totalSize
            self.tags = tags
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case returnSize = "ReturnSize"
            case totalSize = "TotalSize"
            case tags = "Tags"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct DimensionValuesWithAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .string), 
            AWSShapeMember(label: "Attributes", required: false, type: .map)
        ]
        /// The value of a dimension with a specific attribute.
        public let value: String?
        /// The attribute that applies to a specific Dimension.
        public let attributes: [String: String]?

        public init(value: String? = nil, attributes: [String: String]? = nil) {
            self.value = value
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case attributes = "Attributes"
        }
    }

    public enum Dimension: String, CustomStringConvertible, Codable {
        case az = "AZ"
        case instanceType = "INSTANCE_TYPE"
        case linkedAccount = "LINKED_ACCOUNT"
        case operation = "OPERATION"
        case purchaseType = "PURCHASE_TYPE"
        case region = "REGION"
        case service = "SERVICE"
        case usageType = "USAGE_TYPE"
        case usageTypeGroup = "USAGE_TYPE_GROUP"
        case recordType = "RECORD_TYPE"
        case operatingSystem = "OPERATING_SYSTEM"
        case tenancy = "TENANCY"
        case scope = "SCOPE"
        case platform = "PLATFORM"
        case subscriptionId = "SUBSCRIPTION_ID"
        public var description: String { return self.rawValue }
    }

    public struct ReservationUtilizationGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "Key", required: false, type: .string), 
            AWSShapeMember(label: "Utilization", required: false, type: .structure), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]
        /// The attributes for this group of RIs.
        public let attributes: [String: String]?
        /// The key for a specific RI attribute.
        public let key: String?
        /// How much you used this group of RIs.
        public let utilization: ReservationAggregates?
        /// The value of a specific RI attribute.
        public let value: String?

        public init(attributes: [String: String]? = nil, key: String? = nil, utilization: ReservationAggregates? = nil, value: String? = nil) {
            self.attributes = attributes
            self.key = key
            self.utilization = utilization
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case key = "Key"
            case utilization = "Utilization"
            case value = "Value"
        }
    }

    public struct TagValues: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: false, type: .string), 
            AWSShapeMember(label: "Values", required: false, type: .list)
        ]
        /// The key for a tag.
        public let key: String?
        /// The specific value of a tag.
        public let values: [String]?

        public init(key: String? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    public struct GetDimensionValuesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Context", required: false, type: .enum), 
            AWSShapeMember(label: "Dimension", required: true, type: .enum), 
            AWSShapeMember(label: "TimePeriod", required: true, type: .structure), 
            AWSShapeMember(label: "SearchString", required: false, type: .string), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// The context for the call to GetDimensionValues. This can be RESERVED_INSTANCE or COST_AND_USAGE. The default value is COST_AND_USAGE. If the context is set to RESERVED_INSTANCE, the resulting dimension values can be used in the GetReservationUtilization action. If the context is set to COST_AND_USAGE, , the resulting dimension values can be used in the GetCostAndUsage operation. If you set the context to CostAndUsage, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   InstanceType - The type of EC2 instance. An example is m4.xlarge.   LinkedAccount - The description in the attribute map that includes the full name of the member account. The value field contains the AWS ID of the member account   Operation - The action performed. Examples include RunInstance and CreateBucket.   PurchaseType - The reservation type of the purchase to which this usage is related. Examples include: On Demand Instances and Standard Reserved Instances   Service - The AWS service such as DynamoDB.   UsageType -The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues action includes a unit attribute, examples of which include GB and Hrs.   UsageTypeGroup - The grouping of common usage types. An example is EC2: CloudWatch – Alarms. The response for this action includes a unit attribute.   RecordType - The different types of charges such as RI fees, usage costs, tax refunds, and credits   If you set the context to ReservedInstance, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   InstanceType - The type of EC2 instance. An example is m4.xlarge.   LinkedAccount - The description in the attribute map that includes the full name of the member account. The value field contains the AWS ID of the member account   Platform - The operating system. Examples are Windows or Linux.   Region - The AWS region.   Scope - The scope of a reserved instance (RI). Values are regional or a single availability zone.   Tenancy - The tenancy of a resource. Examples are shared or dedicated.  
        public let context: Context?
        /// The name of the dimension. Different Dimensionsare available for different Contexts. For more information, see Context.
        public let dimension: Dimension
        /// The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
        public let timePeriod: DateInterval
        /// The value that you want to search the filter values for.
        public let searchString: String?
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(context: Context? = nil, dimension: Dimension, timePeriod: DateInterval, searchString: String? = nil, nextPageToken: String? = nil) {
            self.context = context
            self.dimension = dimension
            self.timePeriod = timePeriod
            self.searchString = searchString
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case context = "Context"
            case dimension = "Dimension"
            case timePeriod = "TimePeriod"
            case searchString = "SearchString"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct GetDimensionValuesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReturnSize", required: true, type: .integer), 
            AWSShapeMember(label: "DimensionValues", required: true, type: .list), 
            AWSShapeMember(label: "TotalSize", required: true, type: .integer), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// The number of results that AWS returned at one time.
        public let returnSize: Int32
        /// The filters that you used to filter your request. Some dimensions are available only for a specific context: If you set the context to CostAndUsage, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   InstanceType - The type of EC2 instance. An example is m4.xlarge.   LinkedAccount - The description in the attribute map that includes the full name of the member account. The value field contains the AWS ID of the member account   Operation - The action performed. Examples include RunInstance and CreateBucket.   PurchaseType - The reservation type of the purchase to which this usage is related. Examples include: On Demand Instances and Standard Reserved Instances   Service - The AWS service such as DynamoDB.   UsageType -The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues action includes a unit attribute, examples of which include GB and Hrs.   UsageTypeGroup - The grouping of common usage types. An example is EC2: CloudWatch – Alarms. The response for this action includes a unit attribute.   RecordType - The different types of charges such as RI fees, usage costs, tax refunds, and credits   If you set the context to ReservedInstance, you can use the following dimensions for searching:   AZ - The Availability Zone. An example is us-east-1a.   InstanceType - The type of EC2 instance. An example is m4.xlarge.   LinkedAccount - The description in the attribute map that includes the full name of the member account. The value field contains the AWS ID of the member account   Platform - The operating system. Examples are Windows or Linux.   Region - The AWS region.   Scope - The scope of a reserved instance (RI). Values are regional or a single availability zone.   Tenancy - The tenancy of a resource. Examples are shared or dedicated.  
        public let dimensionValues: [DimensionValuesWithAttributes]
        /// The total number of search results.
        public let totalSize: Int32
        /// The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(returnSize: Int32, dimensionValues: [DimensionValuesWithAttributes], totalSize: Int32, nextPageToken: String? = nil) {
            self.returnSize = returnSize
            self.dimensionValues = dimensionValues
            self.totalSize = totalSize
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case returnSize = "ReturnSize"
            case dimensionValues = "DimensionValues"
            case totalSize = "TotalSize"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct Group: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Metrics", required: false, type: .map), 
            AWSShapeMember(label: "Keys", required: false, type: .list)
        ]
        /// The metrics included in this group.
        public let metrics: [String: MetricValue]?
        /// The keys included in this group.
        public let keys: [String]?

        public init(metrics: [String: MetricValue]? = nil, keys: [String]? = nil) {
            self.metrics = metrics
            self.keys = keys
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "Metrics"
            case keys = "Keys"
        }
    }

    public struct GetReservationUtilizationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filter", required: false, type: .structure), 
            AWSShapeMember(label: "GroupBy", required: false, type: .list), 
            AWSShapeMember(label: "TimePeriod", required: true, type: .structure), 
            AWSShapeMember(label: "Granularity", required: false, type: .enum), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// Filters utilization data by using different dimensions. GetReservationUtilization uses the same Expression object as the other operations, but only AND is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.
        public let filter: Expression?
        /// Groups only by SubscriptionId. Metadata is included.
        public let groupBy: [GroupDefinition]?
        /// Sets the start and end dates for retrieving reserve instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01. 
        public let timePeriod: DateInterval
        /// Sets the AWS cost granularity to MONTHLY or DAILY. If both GroupBy and granularity are not set, GetReservationUtilization defaults to DAILY. If GroupBy is set, Granularity can't be set, and the response object doesn't include MONTHLY or DAILY granularity.
        public let granularity: Granularity?
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(filter: Expression? = nil, groupBy: [GroupDefinition]? = nil, timePeriod: DateInterval, granularity: Granularity? = nil, nextPageToken: String? = nil) {
            self.filter = filter
            self.groupBy = groupBy
            self.timePeriod = timePeriod
            self.granularity = granularity
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case groupBy = "GroupBy"
            case timePeriod = "TimePeriod"
            case granularity = "Granularity"
            case nextPageToken = "NextPageToken"
        }
    }

    public enum Granularity: String, CustomStringConvertible, Codable {
        case daily = "DAILY"
        case monthly = "MONTHLY"
        public var description: String { return self.rawValue }
    }

    public struct GetReservationUtilizationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UtilizationsByTime", required: true, type: .list), 
            AWSShapeMember(label: "Total", required: false, type: .structure), 
            AWSShapeMember(label: "NextPageToken", required: false, type: .string)
        ]
        /// The amount of time that you utilized your RIs.
        public let utilizationsByTime: [UtilizationByTime]
        /// The total amount of time that you utilized your RIs.
        public let total: ReservationAggregates?
        /// The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        public let nextPageToken: String?

        public init(utilizationsByTime: [UtilizationByTime], total: ReservationAggregates? = nil, nextPageToken: String? = nil) {
            self.utilizationsByTime = utilizationsByTime
            self.total = total
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case utilizationsByTime = "UtilizationsByTime"
            case total = "Total"
            case nextPageToken = "NextPageToken"
        }
    }

    public enum GroupDefinitionType: String, CustomStringConvertible, Codable {
        case dimension = "DIMENSION"
        case tag = "TAG"
        public var description: String { return self.rawValue }
    }

    public enum Context: String, CustomStringConvertible, Codable {
        case costAndUsage = "COST_AND_USAGE"
        case reservations = "RESERVATIONS"
        public var description: String { return self.rawValue }
    }

}