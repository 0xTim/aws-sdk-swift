// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension XRay {

    public struct GetServiceGraphResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Services", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The end of the time frame for which the graph was generated.
        public let endTime: TimeStamp?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// The start of the time frame for which the graph was generated.
        public let startTime: TimeStamp?

        public init(nextToken: String? = nil, endTime: TimeStamp? = nil, services: [Service]? = nil, startTime: TimeStamp? = nil) {
            self.nextToken = nextToken
            self.endTime = endTime
            self.services = services
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case endTime = "EndTime"
            case services = "Services"
            case startTime = "StartTime"
        }
    }

    public struct ServiceStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "OkCount", required: false, type: .long), 
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalResponseTime = "TotalResponseTime"
            case okCount = "OkCount"
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case totalCount = "TotalCount"
        }
    }

    public struct AnnotationValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BooleanValue", required: false, type: .boolean), 
            AWSShapeMember(label: "NumberValue", required: false, type: .double), 
            AWSShapeMember(label: "StringValue", required: false, type: .string)
        ]
        /// Value for a Boolean annotation.
        public let booleanValue: Bool?
        /// Value for a Number annotation.
        public let numberValue: Double?
        /// Value for a String annotation.
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, numberValue: Double? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.numberValue = numberValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "BooleanValue"
            case numberValue = "NumberValue"
            case stringValue = "StringValue"
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "Sampling", required: false, type: .boolean), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The end of the time frame for which to retrieve traces.
        public let endTime: TimeStamp
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// The start of the time frame for which to retrieve traces.
        public let startTime: TimeStamp

        public init(nextToken: String? = nil, endTime: TimeStamp, sampling: Bool? = nil, filterExpression: String? = nil, startTime: TimeStamp) {
            self.nextToken = nextToken
            self.endTime = endTime
            self.sampling = sampling
            self.filterExpression = filterExpression
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case endTime = "EndTime"
            case sampling = "Sampling"
            case filterExpression = "FilterExpression"
            case startTime = "StartTime"
        }
    }

    public enum EncryptionStatus: String, CustomStringConvertible, Codable {
        case updating = "UPDATING"
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct GetTraceGraphResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The services that have processed one of the specified requests.
        public let services: [Service]?

        public init(nextToken: String? = nil, services: [Service]? = nil) {
            self.nextToken = nextToken
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case services = "Services"
        }
    }

    public struct Alias: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list)
        ]
        /// The type of the alias.
        public let `type`: String?
        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?

        public init(type: String? = nil, name: String? = nil, names: [String]? = nil) {
            self.`type` = `type`
            self.name = name
            self.names = names
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case name = "Name"
            case names = "Names"
        }
    }

    public struct GetEncryptionConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure)
        ]
        /// The encryption configuration document.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct Segment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Document", required: false, type: .string)
        ]
        /// The segment's ID.
        public let id: String?
        /// The segment document.
        public let document: String?

        public init(id: String? = nil, document: String? = nil) {
            self.id = id
            self.document = document
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case document = "Document"
        }
    }

    public struct EdgeStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "OkCount", required: false, type: .long), 
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The total number of completed requests.
        public let totalCount: Int64?

        public init(totalResponseTime: Double? = nil, okCount: Int64? = nil, errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, totalCount: Int64? = nil) {
            self.totalResponseTime = totalResponseTime
            self.okCount = okCount
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalResponseTime = "TotalResponseTime"
            case okCount = "OkCount"
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case totalCount = "TotalCount"
        }
    }

    public struct EncryptionConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "KeyId", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]
        /// The encryption status. After modifying encryption configuration with PutEncryptionConfig, the status can be UPDATING for up to one hour before X-Ray starts encrypting data with the new key.
        public let status: EncryptionStatus?
        /// The ID of the customer master key (CMK) used for encryption, if applicable.
        public let keyId: String?
        /// The type of encryption. Set to KMS for encryption with CMKs. Set to NONE for default encryption.
        public let `type`: EncryptionType?

        public init(status: EncryptionStatus? = nil, keyId: String? = nil, type: EncryptionType? = nil) {
            self.status = status
            self.keyId = keyId
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case keyId = "KeyId"
            case `type` = "Type"
        }
    }

    public struct ErrorStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OtherCount", required: false, type: .long), 
            AWSShapeMember(label: "ThrottleCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, throttleCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case throttleCount = "ThrottleCount"
            case totalCount = "TotalCount"
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedTraceSegments", required: false, type: .list)
        ]
        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceSegments = "UnprocessedTraceSegments"
        }
    }

    public struct GetEncryptionConfigRequest: AWSShape {

    }

    public struct TraceSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: false, type: .double), 
            AWSShapeMember(label: "HasFault", required: false, type: .boolean), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "Users", required: false, type: .list), 
            AWSShapeMember(label: "HasError", required: false, type: .boolean), 
            AWSShapeMember(label: "IsPartial", required: false, type: .boolean), 
            AWSShapeMember(label: "Annotations", required: false, type: .map), 
            AWSShapeMember(label: "ResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "HasThrottle", required: false, type: .boolean), 
            AWSShapeMember(label: "Http", required: false, type: .structure)
        ]
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// One or more of the segment documents has a 500 series error.
        public let hasFault: Bool?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?
        /// One or more of the segment documents has a 400 series error.
        public let hasError: Bool?
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Information about the HTTP request served by the trace.
        public let http: Http?

        public init(duration: Double? = nil, hasFault: Bool? = nil, serviceIds: [ServiceId]? = nil, users: [TraceUser]? = nil, hasError: Bool? = nil, isPartial: Bool? = nil, annotations: [String: [ValueWithServiceIds]]? = nil, responseTime: Double? = nil, id: String? = nil, hasThrottle: Bool? = nil, http: Http? = nil) {
            self.duration = duration
            self.hasFault = hasFault
            self.serviceIds = serviceIds
            self.users = users
            self.hasError = hasError
            self.isPartial = isPartial
            self.annotations = annotations
            self.responseTime = responseTime
            self.id = id
            self.hasThrottle = hasThrottle
            self.http = http
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case hasFault = "HasFault"
            case serviceIds = "ServiceIds"
            case users = "Users"
            case hasError = "HasError"
            case isPartial = "IsPartial"
            case annotations = "Annotations"
            case responseTime = "ResponseTime"
            case id = "Id"
            case hasThrottle = "HasThrottle"
            case http = "Http"
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// The end of the time frame for which to generate a graph.
        public let endTime: TimeStamp
        /// The start of the time frame for which to generate a graph.
        public let startTime: TimeStamp

        public init(nextToken: String? = nil, endTime: TimeStamp, startTime: TimeStamp) {
            self.nextToken = nextToken
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct FaultStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OtherCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]
        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case totalCount = "TotalCount"
        }
    }

    public struct TelemetryRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentsRejectedCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsSpilloverCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsSentCount", required: false, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: true, type: .timestamp), 
            AWSShapeMember(label: "SegmentsReceivedCount", required: false, type: .integer), 
            AWSShapeMember(label: "BackendConnectionErrors", required: false, type: .structure)
        ]
        public let segmentsRejectedCount: Int32?
        public let segmentsSpilloverCount: Int32?
        public let segmentsSentCount: Int32?
        public let timestamp: TimeStamp
        public let segmentsReceivedCount: Int32?
        public let backendConnectionErrors: BackendConnectionErrors?

        public init(segmentsRejectedCount: Int32? = nil, segmentsSpilloverCount: Int32? = nil, segmentsSentCount: Int32? = nil, timestamp: TimeStamp, segmentsReceivedCount: Int32? = nil, backendConnectionErrors: BackendConnectionErrors? = nil) {
            self.segmentsRejectedCount = segmentsRejectedCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.segmentsSentCount = segmentsSentCount
            self.timestamp = timestamp
            self.segmentsReceivedCount = segmentsReceivedCount
            self.backendConnectionErrors = backendConnectionErrors
        }

        private enum CodingKeys: String, CodingKey {
            case segmentsRejectedCount = "SegmentsRejectedCount"
            case segmentsSpilloverCount = "SegmentsSpilloverCount"
            case segmentsSentCount = "SegmentsSentCount"
            case timestamp = "Timestamp"
            case segmentsReceivedCount = "SegmentsReceivedCount"
            case backendConnectionErrors = "BackendConnectionErrors"
        }
    }

    public struct Trace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Segments", required: false, type: .list), 
            AWSShapeMember(label: "Duration", required: false, type: .double)
        ]
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?

        public init(id: String? = nil, segments: [Segment]? = nil, duration: Double? = nil) {
            self.id = id
            self.segments = segments
            self.duration = duration
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case segments = "Segments"
            case duration = "Duration"
        }
    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TelemetryRecords", required: true, type: .list), 
            AWSShapeMember(label: "Hostname", required: false, type: .string), 
            AWSShapeMember(label: "EC2InstanceId", required: false, type: .string), 
            AWSShapeMember(label: "ResourceARN", required: false, type: .string)
        ]
        public let telemetryRecords: [TelemetryRecord]
        public let hostname: String?
        public let eC2InstanceId: String?
        public let resourceARN: String?

        public init(telemetryRecords: [TelemetryRecord], hostname: String? = nil, eC2InstanceId: String? = nil, resourceARN: String? = nil) {
            self.telemetryRecords = telemetryRecords
            self.hostname = hostname
            self.eC2InstanceId = eC2InstanceId
            self.resourceARN = resourceARN
        }

        private enum CodingKeys: String, CodingKey {
            case telemetryRecords = "TelemetryRecords"
            case hostname = "Hostname"
            case eC2InstanceId = "EC2InstanceId"
            case resourceARN = "ResourceARN"
        }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public struct PutTraceSegmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceSegmentDocuments", required: true, type: .list)
        ]
        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case traceSegmentDocuments = "TraceSegmentDocuments"
        }
    }

    public struct TraceUser: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list)
        ]
        /// The user's name.
        public let userName: String?
        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?

        public init(userName: String? = nil, serviceIds: [ServiceId]? = nil) {
            self.userName = userName
            self.serviceIds = serviceIds
        }

        private enum CodingKeys: String, CodingKey {
            case userName = "UserName"
            case serviceIds = "ServiceIds"
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {

    }

    public struct GetTraceSummariesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TracesProcessedCount", required: false, type: .long), 
            AWSShapeMember(label: "ApproximateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "TraceSummaries", required: false, type: .list)
        ]
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The total number of traces processed, including traces that did not match the specified filter expression.
        public let tracesProcessedCount: Int64?
        /// The start time of this page of results.
        public let approximateTime: TimeStamp?
        /// Trace IDs and metadata for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?

        public init(nextToken: String? = nil, tracesProcessedCount: Int64? = nil, approximateTime: TimeStamp? = nil, traceSummaries: [TraceSummary]? = nil) {
            self.nextToken = nextToken
            self.tracesProcessedCount = tracesProcessedCount
            self.approximateTime = approximateTime
            self.traceSummaries = traceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tracesProcessedCount = "TracesProcessedCount"
            case approximateTime = "ApproximateTime"
            case traceSummaries = "TraceSummaries"
        }
    }

    public struct Http: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientIp", required: false, type: .string), 
            AWSShapeMember(label: "HttpMethod", required: false, type: .string), 
            AWSShapeMember(label: "HttpStatus", required: false, type: .integer), 
            AWSShapeMember(label: "UserAgent", required: false, type: .string), 
            AWSShapeMember(label: "HttpURL", required: false, type: .string)
        ]
        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int32?
        /// The request's user agent string.
        public let userAgent: String?
        /// The request URL.
        public let httpURL: String?

        public init(clientIp: String? = nil, httpMethod: String? = nil, httpStatus: Int32? = nil, userAgent: String? = nil, httpURL: String? = nil) {
            self.clientIp = clientIp
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.userAgent = userAgent
            self.httpURL = httpURL
        }

        private enum CodingKeys: String, CodingKey {
            case clientIp = "ClientIp"
            case httpMethod = "HttpMethod"
            case httpStatus = "HttpStatus"
            case userAgent = "UserAgent"
            case httpURL = "HttpURL"
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string)
        ]
        /// The segment's ID.
        public let id: String?
        /// The error message.
        public let message: String?
        /// The error that caused processing to fail.
        public let errorCode: String?

        public init(id: String? = nil, message: String? = nil, errorCode: String? = nil) {
            self.id = id
            self.message = message
            self.errorCode = errorCode
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case message = "Message"
            case errorCode = "ErrorCode"
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HTTPCode5XXCount", required: false, type: .integer), 
            AWSShapeMember(label: "OtherCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimeoutCount", required: false, type: .integer), 
            AWSShapeMember(label: "UnknownHostCount", required: false, type: .integer), 
            AWSShapeMember(label: "ConnectionRefusedCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode4XXCount", required: false, type: .integer)
        ]
        public let hTTPCode5XXCount: Int32?
        public let otherCount: Int32?
        public let timeoutCount: Int32?
        public let unknownHostCount: Int32?
        public let connectionRefusedCount: Int32?
        public let hTTPCode4XXCount: Int32?

        public init(hTTPCode5XXCount: Int32? = nil, otherCount: Int32? = nil, timeoutCount: Int32? = nil, unknownHostCount: Int32? = nil, connectionRefusedCount: Int32? = nil, hTTPCode4XXCount: Int32? = nil) {
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
            self.connectionRefusedCount = connectionRefusedCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
        }

        private enum CodingKeys: String, CodingKey {
            case hTTPCode5XXCount = "HTTPCode5XXCount"
            case otherCount = "OtherCount"
            case timeoutCount = "TimeoutCount"
            case unknownHostCount = "UnknownHostCount"
            case connectionRefusedCount = "ConnectionRefusedCount"
            case hTTPCode4XXCount = "HTTPCode4XXCount"
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TraceIds", required: true, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct Edge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Aliases", required: false, type: .list), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp)
        ]
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?
        /// The end time of the last segment on the edge.
        public let endTime: TimeStamp?
        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// A histogram that maps the spread of client response times on an edge.
        public let responseTimeHistogram: [HistogramEntry]?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int32?
        /// The start time of the first segment on the edge.
        public let startTime: TimeStamp?

        public init(summaryStatistics: EdgeStatistics? = nil, endTime: TimeStamp? = nil, aliases: [Alias]? = nil, responseTimeHistogram: [HistogramEntry]? = nil, referenceId: Int32? = nil, startTime: TimeStamp? = nil) {
            self.summaryStatistics = summaryStatistics
            self.endTime = endTime
            self.aliases = aliases
            self.responseTimeHistogram = responseTimeHistogram
            self.referenceId = referenceId
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case summaryStatistics = "SummaryStatistics"
            case endTime = "EndTime"
            case aliases = "Aliases"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case referenceId = "ReferenceId"
            case startTime = "StartTime"
        }
    }

    public struct Service: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DurationHistogram", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "Edges", required: false, type: .list), 
            AWSShapeMember(label: "Root", required: false, type: .boolean), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list)
        ]
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// The start time of the first segment that the service generated.
        public let startTime: TimeStamp?
        /// The canonical name of the service.
        public let name: String?
        /// The service's state.
        public let state: String?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The end time of the last segment that the service generated.
        public let endTime: TimeStamp?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public let `type`: String?
        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int32?
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?

        public init(durationHistogram: [HistogramEntry]? = nil, startTime: TimeStamp? = nil, name: String? = nil, state: String? = nil, edges: [Edge]? = nil, root: Bool? = nil, endTime: TimeStamp? = nil, type: String? = nil, accountId: String? = nil, names: [String]? = nil, summaryStatistics: ServiceStatistics? = nil, referenceId: Int32? = nil, responseTimeHistogram: [HistogramEntry]? = nil) {
            self.durationHistogram = durationHistogram
            self.startTime = startTime
            self.name = name
            self.state = state
            self.edges = edges
            self.root = root
            self.endTime = endTime
            self.`type` = `type`
            self.accountId = accountId
            self.names = names
            self.summaryStatistics = summaryStatistics
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
        }

        private enum CodingKeys: String, CodingKey {
            case durationHistogram = "DurationHistogram"
            case startTime = "StartTime"
            case name = "Name"
            case state = "State"
            case edges = "Edges"
            case root = "Root"
            case endTime = "EndTime"
            case `type` = "Type"
            case accountId = "AccountId"
            case names = "Names"
            case summaryStatistics = "SummaryStatistics"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
        }
    }

    public struct HistogramEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Count", required: false, type: .integer), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]
        /// The prevalence of the entry.
        public let count: Int32?
        /// The value of the entry.
        public let value: Double?

        public init(count: Int32? = nil, value: Double? = nil) {
            self.count = count
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case value = "Value"
        }
    }

    public struct PutEncryptionConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure)
        ]
        /// The new encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct BatchGetTracesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedTraceIds", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Traces", required: false, type: .list)
        ]
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?

        public init(unprocessedTraceIds: [String]? = nil, nextToken: String? = nil, traces: [Trace]? = nil) {
            self.unprocessedTraceIds = unprocessedTraceIds
            self.nextToken = nextToken
            self.traces = traces
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceIds = "UnprocessedTraceIds"
            case nextToken = "NextToken"
            case traces = "Traces"
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnnotationValue", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list)
        ]
        /// Values of the annotation.
        public let annotationValue: AnnotationValue?
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?

        public init(annotationValue: AnnotationValue? = nil, serviceIds: [ServiceId]? = nil) {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }

        private enum CodingKeys: String, CodingKey {
            case annotationValue = "AnnotationValue"
            case serviceIds = "ServiceIds"
        }
    }

    public struct ServiceId: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "AccountId", required: false, type: .string)
        ]
        public let name: String?
        public let `type`: String?
        public let names: [String]?
        public let accountId: String?

        public init(name: String? = nil, type: String? = nil, names: [String]? = nil, accountId: String? = nil) {
            self.name = name
            self.`type` = `type`
            self.names = names
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case `type` = "Type"
            case names = "Names"
            case accountId = "AccountId"
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TraceIds", required: true, type: .list)
        ]
        /// Pagination token. Not used.
        public let nextToken: String?
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct PutEncryptionConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "KeyId", required: false, type: .string)
        ]
        /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
        public let `type`: EncryptionType
        /// An AWS KMS customer master key (CMK) in one of the following formats:    Alias - The name of the key. For example, alias/MyKey.    Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456.    ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.   Omit this key if you set Type to NONE.
        public let keyId: String?

        public init(type: EncryptionType, keyId: String? = nil) {
            self.`type` = `type`
            self.keyId = keyId
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case keyId = "KeyId"
        }
    }

}