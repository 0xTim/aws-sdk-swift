// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Signer {

    public struct EncryptionAlgorithmOptions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultValue", required: true, type: .enum), 
            AWSShapeMember(label: "allowedValues", required: true, type: .list)
        ]
        /// The default encryption algorithm that is used by an AWS Signer job.
        public let defaultValue: EncryptionAlgorithm
        /// The set of accepted encryption algorithms that are allowed in an AWS Signer job.
        public let allowedValues: [EncryptionAlgorithm]

        public init(allowedValues: [EncryptionAlgorithm], defaultValue: EncryptionAlgorithm) {
            self.defaultValue = defaultValue
            self.allowedValues = allowedValues
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case allowedValues = "allowedValues"
        }
    }

    public enum EncryptionAlgorithm: String, CustomStringConvertible, Codable {
        case rsa = "RSA"
        case ecdsa = "ECDSA"
        public var description: String { return self.rawValue }
    }

    public struct S3Destination: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: false, type: .string), 
            AWSShapeMember(label: "prefix", required: false, type: .string)
        ]
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// An Amazon S3 prefix that you can use to limit responses to those that begin with the specified prefix.
        public let prefix: String?

        public init(bucketName: String? = nil, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case prefix = "prefix"
        }
    }

    public struct Source: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3", required: false, type: .structure)
        ]
        /// The S3Source object.
        public let s3: S3Source?

        public init(s3: S3Source? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct CancelSigningProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "profileName", location: .uri(locationName: "profileName"), required: true, type: .string)
        ]
        /// The name of the signing profile to be canceled.
        public let profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }

        private enum CodingKeys: String, CodingKey {
            case profileName = "profileName"
        }
    }

    public struct SigningJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "signingMaterial", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "signedObject", required: false, type: .structure), 
            AWSShapeMember(label: "jobId", required: false, type: .string), 
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "source", required: false, type: .structure)
        ]
        /// A SigningMaterial object that contains the Amazon Resource Name (ARN) of the certificate used for the signing job.
        public let signingMaterial: SigningMaterial?
        /// The status of the signing job.
        public let status: SigningStatus?
        /// A SignedObject structure that contains information about a signing job's signed code image.
        public let signedObject: SignedObject?
        /// The ID of the signing job.
        public let jobId: String?
        /// The date and time that the signing job was created.
        public let createdAt: TimeStamp?
        /// A Source that contains information about a signing job's code image source.
        public let source: Source?

        public init(createdAt: TimeStamp? = nil, jobId: String? = nil, signedObject: SignedObject? = nil, signingMaterial: SigningMaterial? = nil, source: Source? = nil, status: SigningStatus? = nil) {
            self.signingMaterial = signingMaterial
            self.status = status
            self.signedObject = signedObject
            self.jobId = jobId
            self.createdAt = createdAt
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case signingMaterial = "signingMaterial"
            case status = "status"
            case signedObject = "signedObject"
            case jobId = "jobId"
            case createdAt = "createdAt"
            case source = "source"
        }
    }

    public struct StartSigningJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "jobId", required: false, type: .string)
        ]
        /// The ID of your signing job.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct SigningConfigurationOverrides: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "encryptionAlgorithm", required: false, type: .enum), 
            AWSShapeMember(label: "hashAlgorithm", required: false, type: .enum)
        ]
        /// A specified override of the default encryption algorithm that is used in an AWS Signer job.
        public let encryptionAlgorithm: EncryptionAlgorithm?
        /// A specified override of the default hash algorithm that is used in an AWS Signer job.
        public let hashAlgorithm: HashAlgorithm?

        public init(encryptionAlgorithm: EncryptionAlgorithm? = nil, hashAlgorithm: HashAlgorithm? = nil) {
            self.encryptionAlgorithm = encryptionAlgorithm
            self.hashAlgorithm = hashAlgorithm
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAlgorithm = "encryptionAlgorithm"
            case hashAlgorithm = "hashAlgorithm"
        }
    }

    public struct ListSigningJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "jobs", required: false, type: .list)
        ]
        /// String for specifying the next set of paginated results.
        public let nextToken: String?
        /// A list of your signing jobs.
        public let jobs: [SigningJob]?

        public init(jobs: [SigningJob]? = nil, nextToken: String? = nil) {
            self.nextToken = nextToken
            self.jobs = jobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case jobs = "jobs"
        }
    }

    public struct ListSigningProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "includeCanceled", location: .querystring(locationName: "includeCanceled"), required: false, type: .boolean), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]
        /// Designates whether to include profiles with the status of CANCELED.
        public let includeCanceled: Bool?
        /// The maximum number of profiles to be returned.
        public let maxResults: Int32?
        /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
        public let nextToken: String?

        public init(includeCanceled: Bool? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.includeCanceled = includeCanceled
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case includeCanceled = "includeCanceled"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SigningMaterial: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateArn", required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the certificates that is used to sign your code.
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct PutSigningProfileResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the signing profile created.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DescribeSigningJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "jobId", location: .uri(locationName: "jobId"), required: true, type: .string)
        ]
        /// The ID of the signing job on input.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct ListSigningJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "platformId", location: .querystring(locationName: "platformId"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "status", location: .querystring(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "requestedBy", location: .querystring(locationName: "requestedBy"), required: false, type: .string)
        ]
        /// String for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// The ID of microcontroller platform that you specified for the distribution of your code image.
        public let platformId: String?
        /// Specifies the maximum number of items to return in the response. Use this parameter when paginating results. If additional items exist beyond the number you specify, the nextToken element is set in the response. Use the nextToken value in a subsequent request to retrieve additional items. 
        public let maxResults: Int32?
        /// A status value with which to filter your results.
        public let status: SigningStatus?
        /// The IAM principal that requested the signing job.
        public let requestedBy: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil, platformId: String? = nil, requestedBy: String? = nil, status: SigningStatus? = nil) {
            self.nextToken = nextToken
            self.platformId = platformId
            self.maxResults = maxResults
            self.status = status
            self.requestedBy = requestedBy
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case platformId = "platformId"
            case maxResults = "maxResults"
            case status = "status"
            case requestedBy = "requestedBy"
        }
    }

    public struct SigningPlatformOverrides: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "signingConfiguration", required: false, type: .structure)
        ]
        public let signingConfiguration: SigningConfigurationOverrides?

        public init(signingConfiguration: SigningConfigurationOverrides? = nil) {
            self.signingConfiguration = signingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case signingConfiguration = "signingConfiguration"
        }
    }

    public struct DescribeSigningJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "signingMaterial", required: false, type: .structure), 
            AWSShapeMember(label: "completedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "signingParameters", required: false, type: .map), 
            AWSShapeMember(label: "requestedBy", required: false, type: .string), 
            AWSShapeMember(label: "signedObject", required: false, type: .structure), 
            AWSShapeMember(label: "overrides", required: false, type: .structure), 
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "statusReason", required: false, type: .string), 
            AWSShapeMember(label: "profileName", required: false, type: .string), 
            AWSShapeMember(label: "jobId", required: false, type: .string), 
            AWSShapeMember(label: "platformId", required: false, type: .string), 
            AWSShapeMember(label: "source", required: false, type: .structure)
        ]
        /// Amazon Resource Name (ARN) of your code signing certificate.
        public let signingMaterial: SigningMaterial?
        /// Date and time that the signing job was completed.
        public let completedAt: TimeStamp?
        /// Status of the signing job.
        public let status: SigningStatus?
        /// Map of user-assigned key-value pairs used during signing. These values contain any information that you specified for use in your signing job. 
        public let signingParameters: [String: String]?
        /// The IAM principal that requested the signing job.
        public let requestedBy: String?
        /// Name of the S3 bucket where the signed code image is saved by AWS Signer.
        public let signedObject: SignedObject?
        /// A list of any overrides that were applied to the signing operation.
        public let overrides: SigningPlatformOverrides?
        /// Date and time that the signing job was created.
        public let createdAt: TimeStamp?
        /// String value that contains the status reason.
        public let statusReason: String?
        /// The name of the profile that initiated the signing operation.
        public let profileName: String?
        /// The ID of the signing job on output.
        public let jobId: String?
        /// The microcontroller platform to which your signed code image will be distributed.
        public let platformId: String?
        /// The object that contains the name of your S3 bucket or your raw code.
        public let source: Source?

        public init(completedAt: TimeStamp? = nil, createdAt: TimeStamp? = nil, jobId: String? = nil, overrides: SigningPlatformOverrides? = nil, platformId: String? = nil, profileName: String? = nil, requestedBy: String? = nil, signedObject: SignedObject? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, source: Source? = nil, status: SigningStatus? = nil, statusReason: String? = nil) {
            self.signingMaterial = signingMaterial
            self.completedAt = completedAt
            self.status = status
            self.signingParameters = signingParameters
            self.requestedBy = requestedBy
            self.signedObject = signedObject
            self.overrides = overrides
            self.createdAt = createdAt
            self.statusReason = statusReason
            self.profileName = profileName
            self.jobId = jobId
            self.platformId = platformId
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case signingMaterial = "signingMaterial"
            case completedAt = "completedAt"
            case status = "status"
            case signingParameters = "signingParameters"
            case requestedBy = "requestedBy"
            case signedObject = "signedObject"
            case overrides = "overrides"
            case createdAt = "createdAt"
            case statusReason = "statusReason"
            case profileName = "profileName"
            case jobId = "jobId"
            case platformId = "platformId"
            case source = "source"
        }
    }

    public struct ListSigningPlatformsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "platforms", required: false, type: .list)
        ]
        /// Value for specifying the next set of paginated results to return.
        public let nextToken: String?
        /// A list of all platforms that match the request parameters.
        public let platforms: [SigningPlatform]?

        public init(nextToken: String? = nil, platforms: [SigningPlatform]? = nil) {
            self.nextToken = nextToken
            self.platforms = platforms
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case platforms = "platforms"
        }
    }

    public struct SigningProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "profileName", required: false, type: .string), 
            AWSShapeMember(label: "platformId", required: false, type: .string), 
            AWSShapeMember(label: "signingParameters", required: false, type: .map), 
            AWSShapeMember(label: "signingMaterial", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]
        /// The name of the AWS Signer profile.
        public let profileName: String?
        /// The ID of a platform that is available for use by a signing profile.
        public let platformId: String?
        /// The parameters that are available for use by an AWS Signer user.
        public let signingParameters: [String: String]?
        /// The ACM certificate that is available for use by a signing profile.
        public let signingMaterial: SigningMaterial?
        /// The status of an AWS Signer profile.
        public let status: SigningProfileStatus?

        public init(platformId: String? = nil, profileName: String? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, status: SigningProfileStatus? = nil) {
            self.profileName = profileName
            self.platformId = platformId
            self.signingParameters = signingParameters
            self.signingMaterial = signingMaterial
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case profileName = "profileName"
            case platformId = "platformId"
            case signingParameters = "signingParameters"
            case signingMaterial = "signingMaterial"
            case status = "status"
        }
    }

    public struct SigningConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "encryptionAlgorithmOptions", required: true, type: .structure), 
            AWSShapeMember(label: "hashAlgorithmOptions", required: true, type: .structure)
        ]
        /// The encryption algorithm options that are available for an AWS Signer job.
        public let encryptionAlgorithmOptions: EncryptionAlgorithmOptions
        /// The hash algorithm options that are available for an AWS Signer job.
        public let hashAlgorithmOptions: HashAlgorithmOptions

        public init(encryptionAlgorithmOptions: EncryptionAlgorithmOptions, hashAlgorithmOptions: HashAlgorithmOptions) {
            self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
            self.hashAlgorithmOptions = hashAlgorithmOptions
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAlgorithmOptions = "encryptionAlgorithmOptions"
            case hashAlgorithmOptions = "hashAlgorithmOptions"
        }
    }

    public struct GetSigningProfileResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "platformId", required: false, type: .string), 
            AWSShapeMember(label: "profileName", required: false, type: .string), 
            AWSShapeMember(label: "signingParameters", required: false, type: .map), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "signingMaterial", required: false, type: .structure), 
            AWSShapeMember(label: "overrides", required: false, type: .structure)
        ]
        /// The ID of the platform that is used by the target signing profile.
        public let platformId: String?
        /// The name of the target signing profile.
        public let profileName: String?
        /// A map of key-value pairs for signing operations that is attached to the target signing profile.
        public let signingParameters: [String: String]?
        /// The status of the target signing profile.
        public let status: SigningProfileStatus?
        /// The ARN of the certificate that the target profile uses for signing operations.
        public let signingMaterial: SigningMaterial?
        /// A list of overrides applied by the target signing profile for signing operations.
        public let overrides: SigningPlatformOverrides?

        public init(overrides: SigningPlatformOverrides? = nil, platformId: String? = nil, profileName: String? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, status: SigningProfileStatus? = nil) {
            self.platformId = platformId
            self.profileName = profileName
            self.signingParameters = signingParameters
            self.status = status
            self.signingMaterial = signingMaterial
            self.overrides = overrides
        }

        private enum CodingKeys: String, CodingKey {
            case platformId = "platformId"
            case profileName = "profileName"
            case signingParameters = "signingParameters"
            case status = "status"
            case signingMaterial = "signingMaterial"
            case overrides = "overrides"
        }
    }

    public struct SignedObject: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3", required: false, type: .structure)
        ]
        /// The S3SignedObject.
        public let s3: S3SignedObject?

        public init(s3: S3SignedObject? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct HashAlgorithmOptions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultValue", required: true, type: .enum), 
            AWSShapeMember(label: "allowedValues", required: true, type: .list)
        ]
        /// The default hash algorithm that is used in an AWS Signer job.
        public let defaultValue: HashAlgorithm
        /// The set of accepted hash algorithms allowed in an AWS Signer job.
        public let allowedValues: [HashAlgorithm]

        public init(allowedValues: [HashAlgorithm], defaultValue: HashAlgorithm) {
            self.defaultValue = defaultValue
            self.allowedValues = allowedValues
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case allowedValues = "allowedValues"
        }
    }

    public struct ListSigningProfilesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "profiles", required: false, type: .list)
        ]
        /// Value for specifying the next set of paginated results to return.
        public let nextToken: String?
        /// A list of profiles that are available in the AWS account. This includes profiles with the status of CANCELED if the includeCanceled parameter is set to true.
        public let profiles: [SigningProfile]?

        public init(nextToken: String? = nil, profiles: [SigningProfile]? = nil) {
            self.nextToken = nextToken
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case profiles = "profiles"
        }
    }

    public struct Destination: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3", required: false, type: .structure)
        ]
        /// The S3Destination object.
        public let s3: S3Destination?

        public init(s3: S3Destination? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public enum HashAlgorithm: String, CustomStringConvertible, Codable {
        case sha1 = "SHA1"
        case sha256 = "SHA256"
        public var description: String { return self.rawValue }
    }

    public struct ListSigningPlatformsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "target", location: .querystring(locationName: "target"), required: false, type: .string), 
            AWSShapeMember(label: "partner", location: .querystring(locationName: "partner"), required: false, type: .string), 
            AWSShapeMember(label: "maxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "category", location: .querystring(locationName: "category"), required: false, type: .string)
        ]
        /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// The validation template that is used by the target signing platform.
        public let target: String?
        /// Any partner entities connected to a signing platform.
        public let partner: String?
        /// The maximum number of results to be returned by this operation.
        public let maxResults: Int32?
        /// The category type of a signing platform.
        public let category: String?

        public init(category: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil, partner: String? = nil, target: String? = nil) {
            self.nextToken = nextToken
            self.target = target
            self.partner = partner
            self.maxResults = maxResults
            self.category = category
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case target = "target"
            case partner = "partner"
            case maxResults = "maxResults"
            case category = "category"
        }
    }

    public struct SigningImageFormat: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultFormat", required: true, type: .enum), 
            AWSShapeMember(label: "supportedFormats", required: true, type: .list)
        ]
        /// The default format of an AWS Signer signing image.
        public let defaultFormat: ImageFormat
        /// The supported formats of an AWS Signer signing image.
        public let supportedFormats: [ImageFormat]

        public init(defaultFormat: ImageFormat, supportedFormats: [ImageFormat]) {
            self.defaultFormat = defaultFormat
            self.supportedFormats = supportedFormats
        }

        private enum CodingKeys: String, CodingKey {
            case defaultFormat = "defaultFormat"
            case supportedFormats = "supportedFormats"
        }
    }

    public struct S3Source: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "bucketName", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .string)
        ]
        /// Key name of the bucket object that contains your unsigned code.
        public let key: String
        /// Name of the S3 bucket.
        public let bucketName: String
        /// Version of your source image in your version enabled S3 bucket.
        public let version: String

        public init(bucketName: String, key: String, version: String) {
            self.key = key
            self.bucketName = bucketName
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case bucketName = "bucketName"
            case version = "version"
        }
    }

    public enum SigningProfileStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case canceled = "Canceled"
        public var description: String { return self.rawValue }
    }

    public struct GetSigningPlatformResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "signingImageFormat", required: false, type: .structure), 
            AWSShapeMember(label: "partner", required: false, type: .string), 
            AWSShapeMember(label: "signingConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "platformId", required: false, type: .string), 
            AWSShapeMember(label: "target", required: false, type: .string), 
            AWSShapeMember(label: "category", required: false, type: .enum), 
            AWSShapeMember(label: "maxSizeInMB", required: false, type: .integer), 
            AWSShapeMember(label: "displayName", required: false, type: .string)
        ]
        /// The format of the target platform's signing image.
        public let signingImageFormat: SigningImageFormat?
        /// A list of partner entities that use the target signing platform.
        public let partner: String?
        /// A list of configurations applied to the target platform at signing.
        public let signingConfiguration: SigningConfiguration?
        /// The ID of the target signing platform.
        public let platformId: String?
        /// The validation template that is used by the target signing platform.
        public let target: String?
        /// The category type of the target signing platform.
        public let category: Category?
        /// The maximum size (in MB) of the payload that can be signed by the target platform.
        public let maxSizeInMB: Int32?
        /// The display name of the target signing platform.
        public let displayName: String?

        public init(category: Category? = nil, displayName: String? = nil, maxSizeInMB: Int32? = nil, partner: String? = nil, platformId: String? = nil, signingConfiguration: SigningConfiguration? = nil, signingImageFormat: SigningImageFormat? = nil, target: String? = nil) {
            self.signingImageFormat = signingImageFormat
            self.partner = partner
            self.signingConfiguration = signingConfiguration
            self.platformId = platformId
            self.target = target
            self.category = category
            self.maxSizeInMB = maxSizeInMB
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case signingImageFormat = "signingImageFormat"
            case partner = "partner"
            case signingConfiguration = "signingConfiguration"
            case platformId = "platformId"
            case target = "target"
            case category = "category"
            case maxSizeInMB = "maxSizeInMB"
            case displayName = "displayName"
        }
    }

    public enum ImageFormat: String, CustomStringConvertible, Codable {
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum Category: String, CustomStringConvertible, Codable {
        case awsiot = "AWSIoT"
        public var description: String { return self.rawValue }
    }

    public struct StartSigningJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientRequestToken", required: true, type: .string), 
            AWSShapeMember(label: "source", required: true, type: .structure), 
            AWSShapeMember(label: "destination", required: true, type: .structure), 
            AWSShapeMember(label: "profileName", required: false, type: .string)
        ]
        /// String that identifies the signing request. All calls after the first that use this token return the same response as the first call.
        public let clientRequestToken: String
        /// The S3 bucket that contains the object to sign or a BLOB that contains your raw code.
        public let source: Source
        /// The S3 bucket in which to save your signed object. The destination contains the name of your bucket and an optional prefix.
        public let destination: Destination
        /// The name of the signing profile.
        public let profileName: String?

        public init(clientRequestToken: String, destination: Destination, profileName: String? = nil, source: Source) {
            self.clientRequestToken = clientRequestToken
            self.source = source
            self.destination = destination
            self.profileName = profileName
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case source = "source"
            case destination = "destination"
            case profileName = "profileName"
        }
    }

    public enum SigningStatus: String, CustomStringConvertible, Codable {
        case inprogress = "InProgress"
        case failed = "Failed"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public struct GetSigningPlatformRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "platformId", location: .uri(locationName: "platformId"), required: true, type: .string)
        ]
        /// The ID of the target signing platform.
        public let platformId: String

        public init(platformId: String) {
            self.platformId = platformId
        }

        private enum CodingKeys: String, CodingKey {
            case platformId = "platformId"
        }
    }

    public struct S3SignedObject: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: false, type: .string), 
            AWSShapeMember(label: "key", required: false, type: .string)
        ]
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// Key name that uniquely identifies a signed code image in your bucket.
        public let key: String?

        public init(bucketName: String? = nil, key: String? = nil) {
            self.bucketName = bucketName
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case key = "key"
        }
    }

    public struct PutSigningProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "profileName", location: .uri(locationName: "profileName"), required: true, type: .string), 
            AWSShapeMember(label: "platformId", required: true, type: .string), 
            AWSShapeMember(label: "signingParameters", required: false, type: .map), 
            AWSShapeMember(label: "signingMaterial", required: true, type: .structure), 
            AWSShapeMember(label: "overrides", required: false, type: .structure)
        ]
        /// The name of the signing profile to be created.
        public let profileName: String
        /// The ID of the signing profile to be created.
        public let platformId: String
        /// Map of key-value pairs for signing. These can include any information that you want to use during signing.
        public let signingParameters: [String: String]?
        /// The AWS Certificate Manager certificate that will be used to sign code with the new signing profile.
        public let signingMaterial: SigningMaterial
        /// A subfield of platform. This specifies any different configuration options that you want to apply to the chosen platform (such as a different hash-algorithm or signing-algorithm).
        public let overrides: SigningPlatformOverrides?

        public init(overrides: SigningPlatformOverrides? = nil, platformId: String, profileName: String, signingMaterial: SigningMaterial, signingParameters: [String: String]? = nil) {
            self.profileName = profileName
            self.platformId = platformId
            self.signingParameters = signingParameters
            self.signingMaterial = signingMaterial
            self.overrides = overrides
        }

        private enum CodingKeys: String, CodingKey {
            case profileName = "profileName"
            case platformId = "platformId"
            case signingParameters = "signingParameters"
            case signingMaterial = "signingMaterial"
            case overrides = "overrides"
        }
    }

    public struct SigningPlatform: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "platformId", required: false, type: .string), 
            AWSShapeMember(label: "partner", required: false, type: .string), 
            AWSShapeMember(label: "displayName", required: false, type: .string), 
            AWSShapeMember(label: "target", required: false, type: .string), 
            AWSShapeMember(label: "maxSizeInMB", required: false, type: .integer), 
            AWSShapeMember(label: "category", required: false, type: .enum), 
            AWSShapeMember(label: "signingImageFormat", required: false, type: .structure), 
            AWSShapeMember(label: "signingConfiguration", required: false, type: .structure)
        ]
        /// The ID of an AWS Signer platform.
        public let platformId: String?
        /// Any partner entities linked to an AWS Signer platform.
        public let partner: String?
        /// The display name of an AWS Signer platform.
        public let displayName: String?
        /// The types of targets that can be signed by an AWS Signer platform.
        public let target: String?
        /// The maximum size (in MB) of code that can be signed by a AWS Signer platform.
        public let maxSizeInMB: Int32?
        /// The category of an AWS Signer platform.
        public let category: Category?
        /// The signing image format that is used by an AWS Signer platform.
        public let signingImageFormat: SigningImageFormat?
        /// The configuration of an AWS Signer platform. This includes the designated hash algorithm and encryption algorithm of a signing platform.
        public let signingConfiguration: SigningConfiguration?

        public init(category: Category? = nil, displayName: String? = nil, maxSizeInMB: Int32? = nil, partner: String? = nil, platformId: String? = nil, signingConfiguration: SigningConfiguration? = nil, signingImageFormat: SigningImageFormat? = nil, target: String? = nil) {
            self.platformId = platformId
            self.partner = partner
            self.displayName = displayName
            self.target = target
            self.maxSizeInMB = maxSizeInMB
            self.category = category
            self.signingImageFormat = signingImageFormat
            self.signingConfiguration = signingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case platformId = "platformId"
            case partner = "partner"
            case displayName = "displayName"
            case target = "target"
            case maxSizeInMB = "maxSizeInMB"
            case category = "category"
            case signingImageFormat = "signingImageFormat"
            case signingConfiguration = "signingConfiguration"
        }
    }

    public struct GetSigningProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "profileName", location: .uri(locationName: "profileName"), required: true, type: .string)
        ]
        /// The name of the target signing profile.
        public let profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }

        private enum CodingKeys: String, CodingKey {
            case profileName = "profileName"
        }
    }

}