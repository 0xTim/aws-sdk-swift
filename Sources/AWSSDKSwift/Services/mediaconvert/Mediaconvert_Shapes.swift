// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Mediaconvert {

    public enum H264GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public enum NoiseReducerFilter: String, CustomStringConvertible, Codable {
        case bilateral = "BILATERAL"
        case mean = "MEAN"
        case gaussian = "GAUSSIAN"
        case lanczos = "LANCZOS"
        case sharpen = "SHARPEN"
        case conserve = "CONSERVE"
        case spatial = "SPATIAL"
        public var description: String { return self.rawValue }
    }

    public enum AacAudioDescriptionBroadcasterMix: String, CustomStringConvertible, Codable {
        case broadcasterMixedAd = "BROADCASTER_MIXED_AD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationAlgorithm: String, CustomStringConvertible, Codable {
        case ituBs17701 = "ITU_BS_1770_1"
        case ituBs17702 = "ITU_BS_1770_2"
        public var description: String { return self.rawValue }
    }

    public enum Ac3BitstreamMode: String, CustomStringConvertible, Codable {
        case completeMain = "COMPLETE_MAIN"
        case commentary = "COMMENTARY"
        case dialogue = "DIALOGUE"
        case emergency = "EMERGENCY"
        case hearingImpaired = "HEARING_IMPAIRED"
        case musicAndEffects = "MUSIC_AND_EFFECTS"
        case visuallyImpaired = "VISUALLY_IMPAIRED"
        case voiceOver = "VOICE_OVER"
        public var description: String { return self.rawValue }
    }

    public struct UpdateJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public enum TtmlStylePassthrough: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeinterlaceAlgorithm: String, CustomStringConvertible, Codable {
        case interpolate = "INTERPOLATE"
        case interpolateTicker = "INTERPOLATE_TICKER"
        case blend = "BLEND"
        case blendTicker = "BLEND_TICKER"
        public var description: String { return self.rawValue }
    }

    public struct RemixSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelsOut", location: .body(locationName: "channelsOut"), required: false, type: .integer), 
            AWSShapeMember(label: "ChannelMapping", location: .body(locationName: "channelMapping"), required: false, type: .structure), 
            AWSShapeMember(label: "ChannelsIn", location: .body(locationName: "channelsIn"), required: false, type: .integer)
        ]
        /// Specify the number of channels in this output after remixing. Valid values: 1, 2, 4, 6, 8
        public let channelsOut: Int32?
        public let channelMapping: ChannelMapping?
        /// Specify the number of audio channels from your input that you want to use in your output. With remixing, you might combine or split the data in these channels, so the number of channels in your final output might be different.
        public let channelsIn: Int32?

        public init(channelsOut: Int32? = nil, channelMapping: ChannelMapping? = nil, channelsIn: Int32? = nil) {
            self.channelsOut = channelsOut
            self.channelMapping = channelMapping
            self.channelsIn = channelsIn
        }

        private enum CodingKeys: String, CodingKey {
            case channelsOut = "channelsOut"
            case channelMapping = "channelMapping"
            case channelsIn = "channelsIn"
        }
    }

    public enum Mpeg2FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum ColorMetadata: String, CustomStringConvertible, Codable {
        case ignore = "IGNORE"
        case insert = "INSERT"
        public var description: String { return self.rawValue }
    }

    public enum ColorSpaceUsage: String, CustomStringConvertible, Codable {
        case force = "FORCE"
        case fallback = "FALLBACK"
        public var description: String { return self.rawValue }
    }

    public enum Ac3DynamicRangeCompressionProfile: String, CustomStringConvertible, Codable {
        case filmStandard = "FILM_STANDARD"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum MovPaddingControl: String, CustomStringConvertible, Codable {
        case omneon = "OMNEON"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct TtmlDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StylePassthrough", location: .body(locationName: "stylePassthrough"), required: false, type: .enum)
        ]
        public let stylePassthrough: TtmlStylePassthrough?

        public init(stylePassthrough: TtmlStylePassthrough? = nil) {
            self.stylePassthrough = stylePassthrough
        }

        private enum CodingKeys: String, CodingKey {
            case stylePassthrough = "stylePassthrough"
        }
    }

    public enum ProresFramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum H264SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct Endpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string)
        ]
        /// URL of endpoint
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public struct OutputGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CustomName", location: .body(locationName: "customName"), required: false, type: .string), 
            AWSShapeMember(label: "OutputGroupSettings", location: .body(locationName: "outputGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Outputs", location: .body(locationName: "outputs"), required: false, type: .list), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string)
        ]
        /// Use Custom Group Name (CustomName) to specify a name for the output group. This value is displayed on the console and can make your job settings JSON more human-readable. It does not affect your outputs. Use up to twelve characters that are either letters, numbers, spaces, or underscores.
        public let customName: String?
        public let outputGroupSettings: OutputGroupSettings?
        /// This object holds groups of encoding settings, one group of settings per output.
        public let outputs: [Output]?
        /// Name of the output group
        public let name: String?

        public init(customName: String? = nil, outputGroupSettings: OutputGroupSettings? = nil, outputs: [Output]? = nil, name: String? = nil) {
            self.customName = customName
            self.outputGroupSettings = outputGroupSettings
            self.outputs = outputs
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case customName = "customName"
            case outputGroupSettings = "outputGroupSettings"
            case outputs = "outputs"
            case name = "name"
        }
    }

    public struct Eac3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DynamicRangeCompressionRf", location: .body(locationName: "dynamicRangeCompressionRf"), required: false, type: .enum), 
            AWSShapeMember(label: "LtRtCenterMixLevel", location: .body(locationName: "ltRtCenterMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "StereoDownmix", location: .body(locationName: "stereoDownmix"), required: false, type: .enum), 
            AWSShapeMember(label: "Dialnorm", location: .body(locationName: "dialnorm"), required: false, type: .integer), 
            AWSShapeMember(label: "DcFilter", location: .body(locationName: "dcFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "LtRtSurroundMixLevel", location: .body(locationName: "ltRtSurroundMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "SurroundExMode", location: .body(locationName: "surroundExMode"), required: false, type: .enum), 
            AWSShapeMember(label: "MetadataControl", location: .body(locationName: "metadataControl"), required: false, type: .enum), 
            AWSShapeMember(label: "SurroundMode", location: .body(locationName: "surroundMode"), required: false, type: .enum), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeFilter", location: .body(locationName: "lfeFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "BitstreamMode", location: .body(locationName: "bitstreamMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "PassthroughControl", location: .body(locationName: "passthroughControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LoRoSurroundMixLevel", location: .body(locationName: "loRoSurroundMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "LoRoCenterMixLevel", location: .body(locationName: "loRoCenterMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "PhaseControl", location: .body(locationName: "phaseControl"), required: false, type: .enum), 
            AWSShapeMember(label: "AttenuationControl", location: .body(locationName: "attenuationControl"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicRangeCompressionLine", location: .body(locationName: "dynamicRangeCompressionLine"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeControl", location: .body(locationName: "lfeControl"), required: false, type: .enum)
        ]
        public let dynamicRangeCompressionRf: Eac3DynamicRangeCompressionRf?
        /// Left total/Right total center mix level. Only used for 3/2 coding mode.
        /// Valid values: 3.0, 1.5, 0.0, -1.5 -3.0 -4.5 -6.0 -60
        public let ltRtCenterMixLevel: Double?
        public let stereoDownmix: Eac3StereoDownmix?
        /// Sets the dialnorm for the output. If blank and input audio is Dolby Digital Plus, dialnorm will be passed through.
        public let dialnorm: Int32?
        public let dcFilter: Eac3DcFilter?
        /// Left total/Right total surround mix level. Only used for 3/2 coding mode.
        /// Valid values: -1.5 -3.0 -4.5 -6.0 -60
        public let ltRtSurroundMixLevel: Double?
        /// Average bitrate in bits/second. Valid bitrates depend on the coding mode.
        public let bitrate: Int32?
        public let surroundExMode: Eac3SurroundExMode?
        public let metadataControl: Eac3MetadataControl?
        public let surroundMode: Eac3SurroundMode?
        public let codingMode: Eac3CodingMode?
        public let lfeFilter: Eac3LfeFilter?
        public let bitstreamMode: Eac3BitstreamMode?
        /// Sample rate in hz. Sample rate is always 48000.
        public let sampleRate: Int32?
        public let passthroughControl: Eac3PassthroughControl?
        /// Left only/Right only surround mix level. Only used for 3/2 coding mode.
        /// Valid values: -1.5 -3.0 -4.5 -6.0 -60
        public let loRoSurroundMixLevel: Double?
        /// Left only/Right only center mix level. Only used for 3/2 coding mode.
        /// Valid values: 3.0, 1.5, 0.0, -1.5 -3.0 -4.5 -6.0 -60
        public let loRoCenterMixLevel: Double?
        public let phaseControl: Eac3PhaseControl?
        public let attenuationControl: Eac3AttenuationControl?
        public let dynamicRangeCompressionLine: Eac3DynamicRangeCompressionLine?
        public let lfeControl: Eac3LfeControl?

        public init(dynamicRangeCompressionRf: Eac3DynamicRangeCompressionRf? = nil, ltRtCenterMixLevel: Double? = nil, stereoDownmix: Eac3StereoDownmix? = nil, dialnorm: Int32? = nil, dcFilter: Eac3DcFilter? = nil, ltRtSurroundMixLevel: Double? = nil, bitrate: Int32? = nil, surroundExMode: Eac3SurroundExMode? = nil, metadataControl: Eac3MetadataControl? = nil, surroundMode: Eac3SurroundMode? = nil, codingMode: Eac3CodingMode? = nil, lfeFilter: Eac3LfeFilter? = nil, bitstreamMode: Eac3BitstreamMode? = nil, sampleRate: Int32? = nil, passthroughControl: Eac3PassthroughControl? = nil, loRoSurroundMixLevel: Double? = nil, loRoCenterMixLevel: Double? = nil, phaseControl: Eac3PhaseControl? = nil, attenuationControl: Eac3AttenuationControl? = nil, dynamicRangeCompressionLine: Eac3DynamicRangeCompressionLine? = nil, lfeControl: Eac3LfeControl? = nil) {
            self.dynamicRangeCompressionRf = dynamicRangeCompressionRf
            self.ltRtCenterMixLevel = ltRtCenterMixLevel
            self.stereoDownmix = stereoDownmix
            self.dialnorm = dialnorm
            self.dcFilter = dcFilter
            self.ltRtSurroundMixLevel = ltRtSurroundMixLevel
            self.bitrate = bitrate
            self.surroundExMode = surroundExMode
            self.metadataControl = metadataControl
            self.surroundMode = surroundMode
            self.codingMode = codingMode
            self.lfeFilter = lfeFilter
            self.bitstreamMode = bitstreamMode
            self.sampleRate = sampleRate
            self.passthroughControl = passthroughControl
            self.loRoSurroundMixLevel = loRoSurroundMixLevel
            self.loRoCenterMixLevel = loRoCenterMixLevel
            self.phaseControl = phaseControl
            self.attenuationControl = attenuationControl
            self.dynamicRangeCompressionLine = dynamicRangeCompressionLine
            self.lfeControl = lfeControl
        }

        private enum CodingKeys: String, CodingKey {
            case dynamicRangeCompressionRf = "dynamicRangeCompressionRf"
            case ltRtCenterMixLevel = "ltRtCenterMixLevel"
            case stereoDownmix = "stereoDownmix"
            case dialnorm = "dialnorm"
            case dcFilter = "dcFilter"
            case ltRtSurroundMixLevel = "ltRtSurroundMixLevel"
            case bitrate = "bitrate"
            case surroundExMode = "surroundExMode"
            case metadataControl = "metadataControl"
            case surroundMode = "surroundMode"
            case codingMode = "codingMode"
            case lfeFilter = "lfeFilter"
            case bitstreamMode = "bitstreamMode"
            case sampleRate = "sampleRate"
            case passthroughControl = "passthroughControl"
            case loRoSurroundMixLevel = "loRoSurroundMixLevel"
            case loRoCenterMixLevel = "loRoCenterMixLevel"
            case phaseControl = "phaseControl"
            case attenuationControl = "attenuationControl"
            case dynamicRangeCompressionLine = "dynamicRangeCompressionLine"
            case lfeControl = "lfeControl"
        }
    }

    public enum InputFilterEnable: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case disable = "DISABLE"
        case force = "FORCE"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable {
        case eng = "ENG"
        case spa = "SPA"
        case fra = "FRA"
        case deu = "DEU"
        case ger = "GER"
        case zho = "ZHO"
        case ara = "ARA"
        case hin = "HIN"
        case jpn = "JPN"
        case rus = "RUS"
        case por = "POR"
        case ita = "ITA"
        case urd = "URD"
        case vie = "VIE"
        case kor = "KOR"
        case pan = "PAN"
        case abk = "ABK"
        case aar = "AAR"
        case afr = "AFR"
        case aka = "AKA"
        case sqi = "SQI"
        case amh = "AMH"
        case arg = "ARG"
        case hye = "HYE"
        case asm = "ASM"
        case ava = "AVA"
        case ave = "AVE"
        case aym = "AYM"
        case aze = "AZE"
        case bam = "BAM"
        case bak = "BAK"
        case eus = "EUS"
        case bel = "BEL"
        case ben = "BEN"
        case bih = "BIH"
        case bis = "BIS"
        case bos = "BOS"
        case bre = "BRE"
        case bul = "BUL"
        case mya = "MYA"
        case cat = "CAT"
        case khm = "KHM"
        case cha = "CHA"
        case che = "CHE"
        case nya = "NYA"
        case chu = "CHU"
        case chv = "CHV"
        case cor = "COR"
        case cos = "COS"
        case cre = "CRE"
        case hrv = "HRV"
        case ces = "CES"
        case dan = "DAN"
        case div = "DIV"
        case nld = "NLD"
        case dzo = "DZO"
        case enm = "ENM"
        case epo = "EPO"
        case est = "EST"
        case ewe = "EWE"
        case fao = "FAO"
        case fij = "FIJ"
        case fin = "FIN"
        case frm = "FRM"
        case ful = "FUL"
        case gla = "GLA"
        case glg = "GLG"
        case lug = "LUG"
        case kat = "KAT"
        case ell = "ELL"
        case grn = "GRN"
        case guj = "GUJ"
        case hat = "HAT"
        case hau = "HAU"
        case heb = "HEB"
        case her = "HER"
        case hmo = "HMO"
        case hun = "HUN"
        case isl = "ISL"
        case ido = "IDO"
        case ibo = "IBO"
        case ind = "IND"
        case ina = "INA"
        case ile = "ILE"
        case iku = "IKU"
        case ipk = "IPK"
        case gle = "GLE"
        case jav = "JAV"
        case kal = "KAL"
        case kan = "KAN"
        case kau = "KAU"
        case kas = "KAS"
        case kaz = "KAZ"
        case kik = "KIK"
        case kin = "KIN"
        case kir = "KIR"
        case kom = "KOM"
        case kon = "KON"
        case kua = "KUA"
        case kur = "KUR"
        case lao = "LAO"
        case lat = "LAT"
        case lav = "LAV"
        case lim = "LIM"
        case lin = "LIN"
        case lit = "LIT"
        case lub = "LUB"
        case ltz = "LTZ"
        case mkd = "MKD"
        case mlg = "MLG"
        case msa = "MSA"
        case mal = "MAL"
        case mlt = "MLT"
        case glv = "GLV"
        case mri = "MRI"
        case mar = "MAR"
        case mah = "MAH"
        case mon = "MON"
        case nau = "NAU"
        case nav = "NAV"
        case nde = "NDE"
        case nbl = "NBL"
        case ndo = "NDO"
        case nep = "NEP"
        case sme = "SME"
        case nor = "NOR"
        case nob = "NOB"
        case nno = "NNO"
        case oci = "OCI"
        case oji = "OJI"
        case ori = "ORI"
        case orm = "ORM"
        case oss = "OSS"
        case pli = "PLI"
        case fas = "FAS"
        case pol = "POL"
        case pus = "PUS"
        case que = "QUE"
        case qaa = "QAA"
        case ron = "RON"
        case roh = "ROH"
        case run = "RUN"
        case smo = "SMO"
        case sag = "SAG"
        case san = "SAN"
        case srd = "SRD"
        case srb = "SRB"
        case sna = "SNA"
        case iii = "III"
        case snd = "SND"
        case sin = "SIN"
        case slk = "SLK"
        case slv = "SLV"
        case som = "SOM"
        case sot = "SOT"
        case sun = "SUN"
        case swa = "SWA"
        case ssw = "SSW"
        case swe = "SWE"
        case tgl = "TGL"
        case tah = "TAH"
        case tgk = "TGK"
        case tam = "TAM"
        case tat = "TAT"
        case tel = "TEL"
        case tha = "THA"
        case bod = "BOD"
        case tir = "TIR"
        case ton = "TON"
        case tso = "TSO"
        case tsn = "TSN"
        case tur = "TUR"
        case tuk = "TUK"
        case twi = "TWI"
        case uig = "UIG"
        case ukr = "UKR"
        case uzb = "UZB"
        case ven = "VEN"
        case vol = "VOL"
        case wln = "WLN"
        case cym = "CYM"
        case fry = "FRY"
        case wol = "WOL"
        case xho = "XHO"
        case yid = "YID"
        case yor = "YOR"
        case zha = "ZHA"
        case zul = "ZUL"
        case orj = "ORJ"
        case qpc = "QPC"
        case tng = "TNG"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleShadowColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum Ac3LfeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct DeleteQueueResponse: AWSShape {

    }

    public enum Ac3CodingMode: String, CustomStringConvertible, Codable {
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode11 = "CODING_MODE_1_1"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode32Lfe = "CODING_MODE_3_2_LFE"
        public var description: String { return self.rawValue }
    }

    public enum MsSmoothManifestEncoding: String, CustomStringConvertible, Codable {
        case utf8 = "UTF8"
        case utf16 = "UTF16"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public struct GetPresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public enum F4vMoovPlacement: String, CustomStringConvertible, Codable {
        case progressiveDownload = "PROGRESSIVE_DOWNLOAD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public struct HlsEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InitializationVectorInManifest", location: .body(locationName: "initializationVectorInManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "StaticKeyProvider", location: .body(locationName: "staticKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "ConstantInitializationVector", location: .body(locationName: "constantInitializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum)
        ]
        public let initializationVectorInManifest: HlsInitializationVectorInManifest?
        public let staticKeyProvider: StaticKeyProvider?
        /// This is a 128-bit, 16-byte hex value represented by a 32-character text string. If this parameter is not set then the Initialization Vector will follow the segment number by default.
        public let constantInitializationVector: String?
        public let encryptionMethod: HlsEncryptionType?
        public let spekeKeyProvider: SpekeKeyProvider?
        public let `type`: HlsKeyProviderType?

        public init(initializationVectorInManifest: HlsInitializationVectorInManifest? = nil, staticKeyProvider: StaticKeyProvider? = nil, constantInitializationVector: String? = nil, encryptionMethod: HlsEncryptionType? = nil, spekeKeyProvider: SpekeKeyProvider? = nil, type: HlsKeyProviderType? = nil) {
            self.initializationVectorInManifest = initializationVectorInManifest
            self.staticKeyProvider = staticKeyProvider
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.spekeKeyProvider = spekeKeyProvider
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case initializationVectorInManifest = "initializationVectorInManifest"
            case staticKeyProvider = "staticKeyProvider"
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case spekeKeyProvider = "spekeKeyProvider"
            case `type` = "type"
        }
    }

    public enum H265SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct GetJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the job template.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum Eac3SurroundMode: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeinterlacerControl: String, CustomStringConvertible, Codable {
        case forceAllFrames = "FORCE_ALL_FRAMES"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum ColorSpaceConversion: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case force601 = "FORCE_601"
        case force709 = "FORCE_709"
        case forceHdr10 = "FORCE_HDR10"
        case forceHlg2020 = "FORCE_HLG_2020"
        public var description: String { return self.rawValue }
    }

    public enum M2tsScte35Source: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct CancelJobResponse: AWSShape {

    }

    public enum H265SampleAdaptiveOffsetFilterMode: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case adaptive = "ADAPTIVE"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public struct AncillarySourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceAncillaryChannelNumber", location: .body(locationName: "sourceAncillaryChannelNumber"), required: false, type: .integer)
        ]
        /// Specifies the 608 channel number in the ancillary data track from which to extract captions. Unused for passthrough.
        public let sourceAncillaryChannelNumber: Int32?

        public init(sourceAncillaryChannelNumber: Int32? = nil) {
            self.sourceAncillaryChannelNumber = sourceAncillaryChannelNumber
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAncillaryChannelNumber = "sourceAncillaryChannelNumber"
        }
    }

    public enum Eac3SurroundExMode: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct VideoSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ColorSpace", location: .body(locationName: "colorSpace"), required: false, type: .enum), 
            AWSShapeMember(label: "ColorSpaceUsage", location: .body(locationName: "colorSpaceUsage"), required: false, type: .enum), 
            AWSShapeMember(label: "Pid", location: .body(locationName: "pid"), required: false, type: .integer), 
            AWSShapeMember(label: "Hdr10Metadata", location: .body(locationName: "hdr10Metadata"), required: false, type: .structure), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer)
        ]
        public let colorSpace: ColorSpace?
        public let colorSpaceUsage: ColorSpaceUsage?
        /// Use PID (Pid) to select specific video data from an input file. Specify this value as an integer; the system automatically converts it to the hexidecimal value. For example, 257 selects PID 0x101. A PID, or packet identifier, is an identifier for a set of data in an MPEG-2 transport stream container.
        public let pid: Int32?
        public let hdr10Metadata: Hdr10Metadata?
        /// Selects a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported.
        public let programNumber: Int32?

        public init(colorSpace: ColorSpace? = nil, colorSpaceUsage: ColorSpaceUsage? = nil, pid: Int32? = nil, hdr10Metadata: Hdr10Metadata? = nil, programNumber: Int32? = nil) {
            self.colorSpace = colorSpace
            self.colorSpaceUsage = colorSpaceUsage
            self.pid = pid
            self.hdr10Metadata = hdr10Metadata
            self.programNumber = programNumber
        }

        private enum CodingKeys: String, CodingKey {
            case colorSpace = "colorSpace"
            case colorSpaceUsage = "colorSpaceUsage"
            case pid = "pid"
            case hdr10Metadata = "hdr10Metadata"
            case programNumber = "programNumber"
        }
    }

    public enum H265TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265FlickerAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct DvbSubSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Pid", location: .body(locationName: "pid"), required: false, type: .integer)
        ]
        /// When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        public let pid: Int32?

        public init(pid: Int32? = nil) {
            self.pid = pid
        }

        private enum CodingKeys: String, CodingKey {
            case pid = "pid"
        }
    }

    public enum H264Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public struct GetJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", location: .body(locationName: "job"), required: false, type: .structure)
        ]
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct ListQueuesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        public let listBy: QueueListBy?
        /// Use this string, provided with the response to a previous request, to request the next batch of queues.
        public let nextToken: String?
        public let order: Order?
        /// Optional. Number of queues, up to twenty, that will be returned at one time.
        public let maxResults: Int32?

        public init(listBy: QueueListBy? = nil, nextToken: String? = nil, order: Order? = nil, maxResults: Int32? = nil) {
            self.listBy = listBy
            self.nextToken = nextToken
            self.order = order
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case listBy = "listBy"
            case nextToken = "nextToken"
            case order = "order"
            case maxResults = "maxResults"
        }
    }

    public enum ProresFramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct InputTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterStrength", location: .body(locationName: "filterStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "DenoiseFilter", location: .body(locationName: "denoiseFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "DeblockFilter", location: .body(locationName: "deblockFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "InputClippings", location: .body(locationName: "inputClippings"), required: false, type: .list), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "FilterEnable", location: .body(locationName: "filterEnable"), required: false, type: .enum), 
            AWSShapeMember(label: "VideoSelector", location: .body(locationName: "videoSelector"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioSelectors", location: .body(locationName: "audioSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "AudioSelectorGroups", location: .body(locationName: "audioSelectorGroups"), required: false, type: .map), 
            AWSShapeMember(label: "CaptionSelectors", location: .body(locationName: "captionSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "TimecodeSource", location: .body(locationName: "timecodeSource"), required: false, type: .enum), 
            AWSShapeMember(label: "PsiControl", location: .body(locationName: "psiControl"), required: false, type: .enum)
        ]
        /// Use Filter strength (FilterStrength) to adjust the magnitude the input filter settings (Deblock and Denoise). The range is -5 to 5. Default is 0.
        public let filterStrength: Int32?
        public let denoiseFilter: InputDenoiseFilter?
        public let deblockFilter: InputDeblockFilter?
        /// (InputClippings) contains sets of start and end times that together specify a portion of the input to be used in the outputs. If you provide only a start time, the clip will be the entire input from that point to the end. If you provide only an end time, it will be the entire input up to that point. When you specify more than one input clip, the transcoding service creates the job outputs by stringing the clips together in the order you specify them.
        public let inputClippings: [InputClipping]?
        /// Use Program (programNumber) to select a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported. Default is the first program within the transport stream. If the program you specify doesn't exist, the transcoding service will use this default.
        public let programNumber: Int32?
        public let filterEnable: InputFilterEnable?
        public let videoSelector: VideoSelector?
        /// Use Audio selectors (AudioSelectors) to specify a track or set of tracks from the input that you will use in your outputs. You can use mutiple Audio selectors per input.
        public let audioSelectors: [String: AudioSelector]?
        /// Specifies set of audio selectors within an input to combine. An input may have multiple audio selector groups. See "Audio Selector Group":#inputs-audio_selector_group for more information.
        public let audioSelectorGroups: [String: AudioSelectorGroup]?
        /// Use Captions selectors (CaptionSelectors) to specify the captions data from the input that you will use in your outputs. You can use mutiple captions selectors per input.
        public let captionSelectors: [String: CaptionSelector]?
        public let timecodeSource: InputTimecodeSource?
        public let psiControl: InputPsiControl?

        public init(filterStrength: Int32? = nil, denoiseFilter: InputDenoiseFilter? = nil, deblockFilter: InputDeblockFilter? = nil, inputClippings: [InputClipping]? = nil, programNumber: Int32? = nil, filterEnable: InputFilterEnable? = nil, videoSelector: VideoSelector? = nil, audioSelectors: [String: AudioSelector]? = nil, audioSelectorGroups: [String: AudioSelectorGroup]? = nil, captionSelectors: [String: CaptionSelector]? = nil, timecodeSource: InputTimecodeSource? = nil, psiControl: InputPsiControl? = nil) {
            self.filterStrength = filterStrength
            self.denoiseFilter = denoiseFilter
            self.deblockFilter = deblockFilter
            self.inputClippings = inputClippings
            self.programNumber = programNumber
            self.filterEnable = filterEnable
            self.videoSelector = videoSelector
            self.audioSelectors = audioSelectors
            self.audioSelectorGroups = audioSelectorGroups
            self.captionSelectors = captionSelectors
            self.timecodeSource = timecodeSource
            self.psiControl = psiControl
        }

        private enum CodingKeys: String, CodingKey {
            case filterStrength = "filterStrength"
            case denoiseFilter = "denoiseFilter"
            case deblockFilter = "deblockFilter"
            case inputClippings = "inputClippings"
            case programNumber = "programNumber"
            case filterEnable = "filterEnable"
            case videoSelector = "videoSelector"
            case audioSelectors = "audioSelectors"
            case audioSelectorGroups = "audioSelectorGroups"
            case captionSelectors = "captionSelectors"
            case timecodeSource = "timecodeSource"
            case psiControl = "psiControl"
        }
    }

    public struct CreateQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The name of the queue you are creating.
        public let name: String?
        /// Optional. A description of the queue you are creating.
        public let description: String?

        public init(name: String? = nil, description: String? = nil) {
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case description = "description"
        }
    }

    public enum DashIsoSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public struct DvbSubDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BackgroundColor", location: .body(locationName: "backgroundColor"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundOpacity", location: .body(locationName: "backgroundOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "YPosition", location: .body(locationName: "yPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "FontOpacity", location: .body(locationName: "fontOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowXOffset", location: .body(locationName: "shadowXOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Alignment", location: .body(locationName: "alignment"), required: false, type: .enum), 
            AWSShapeMember(label: "XPosition", location: .body(locationName: "xPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowOpacity", location: .body(locationName: "shadowOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "FontColor", location: .body(locationName: "fontColor"), required: false, type: .enum), 
            AWSShapeMember(label: "OutlineColor", location: .body(locationName: "outlineColor"), required: false, type: .enum), 
            AWSShapeMember(label: "ShadowColor", location: .body(locationName: "shadowColor"), required: false, type: .enum), 
            AWSShapeMember(label: "TeletextSpacing", location: .body(locationName: "teletextSpacing"), required: false, type: .enum), 
            AWSShapeMember(label: "FontResolution", location: .body(locationName: "fontResolution"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowYOffset", location: .body(locationName: "shadowYOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "OutlineSize", location: .body(locationName: "outlineSize"), required: false, type: .integer)
        ]
        public let backgroundColor: DvbSubtitleBackgroundColor?
        /// Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let backgroundOpacity: Int32?
        /// Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit y_position is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let yPosition: Int32?
        /// Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontOpacity: Int32?
        /// Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        public let shadowXOffset: Int32?
        /// A positive integer indicates the exact font size in points. Set to 0 for automatic font size selection. All burn-in and DVB-Sub font settings must match.
        public let fontSize: Int32?
        public let alignment: DvbSubtitleAlignment?
        /// Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit x_position is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let xPosition: Int32?
        /// Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let shadowOpacity: Int32?
        public let fontColor: DvbSubtitleFontColor?
        public let outlineColor: DvbSubtitleOutlineColor?
        public let shadowColor: DvbSubtitleShadowColor?
        public let teletextSpacing: DvbSubtitleTeletextSpacing?
        /// Font resolution in DPI (dots per inch); default is 96 dpi.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontResolution: Int32?
        /// Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        public let shadowYOffset: Int32?
        /// Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let outlineSize: Int32?

        public init(backgroundColor: DvbSubtitleBackgroundColor? = nil, backgroundOpacity: Int32? = nil, yPosition: Int32? = nil, fontOpacity: Int32? = nil, shadowXOffset: Int32? = nil, fontSize: Int32? = nil, alignment: DvbSubtitleAlignment? = nil, xPosition: Int32? = nil, shadowOpacity: Int32? = nil, fontColor: DvbSubtitleFontColor? = nil, outlineColor: DvbSubtitleOutlineColor? = nil, shadowColor: DvbSubtitleShadowColor? = nil, teletextSpacing: DvbSubtitleTeletextSpacing? = nil, fontResolution: Int32? = nil, shadowYOffset: Int32? = nil, outlineSize: Int32? = nil) {
            self.backgroundColor = backgroundColor
            self.backgroundOpacity = backgroundOpacity
            self.yPosition = yPosition
            self.fontOpacity = fontOpacity
            self.shadowXOffset = shadowXOffset
            self.fontSize = fontSize
            self.alignment = alignment
            self.xPosition = xPosition
            self.shadowOpacity = shadowOpacity
            self.fontColor = fontColor
            self.outlineColor = outlineColor
            self.shadowColor = shadowColor
            self.teletextSpacing = teletextSpacing
            self.fontResolution = fontResolution
            self.shadowYOffset = shadowYOffset
            self.outlineSize = outlineSize
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "backgroundColor"
            case backgroundOpacity = "backgroundOpacity"
            case yPosition = "yPosition"
            case fontOpacity = "fontOpacity"
            case shadowXOffset = "shadowXOffset"
            case fontSize = "fontSize"
            case alignment = "alignment"
            case xPosition = "xPosition"
            case shadowOpacity = "shadowOpacity"
            case fontColor = "fontColor"
            case outlineColor = "outlineColor"
            case shadowColor = "shadowColor"
            case teletextSpacing = "teletextSpacing"
            case fontResolution = "fontResolution"
            case shadowYOffset = "shadowYOffset"
            case outlineSize = "outlineSize"
        }
    }

    public enum H264QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case singlePassHq = "SINGLE_PASS_HQ"
        case multiPassHq = "MULTI_PASS_HQ"
        public var description: String { return self.rawValue }
    }

    public struct DashIsoGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "MinBufferTime", location: .body(locationName: "minBufferTime"), required: false, type: .integer), 
            AWSShapeMember(label: "HbbtvCompliance", location: .body(locationName: "hbbtvCompliance"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum)
        ]
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        /// Length of fragments to generate (in seconds). Fragment length must be compatible with GOP size and Framerate. Note that fragments will end on the next keyframe after this number of seconds, so actual fragment length may be longer. When Emit Single File is checked, the fragmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let fragmentLength: Int32?
        /// Minimum time of initially buffered media that is needed to ensure smooth playout.
        public let minBufferTime: Int32?
        public let hbbtvCompliance: DashIsoHbbtvCompliance?
        /// DRM settings.
        public let encryption: DashIsoEncryptionSettings?
        /// A partial URI prefix that will be put in the manifest (.mpd) file at the top level BaseURL element. Can be used if streams are delivered from a different URL than the manifest file.
        public let baseUrl: String?
        /// Length of mpd segments to create (in seconds). Note that segments will end on the next keyframe after this number of seconds, so actual segment length may be longer. When Emit Single File is checked, the segmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let segmentLength: Int32?
        public let segmentControl: DashIsoSegmentControl?

        public init(destination: String? = nil, fragmentLength: Int32? = nil, minBufferTime: Int32? = nil, hbbtvCompliance: DashIsoHbbtvCompliance? = nil, encryption: DashIsoEncryptionSettings? = nil, baseUrl: String? = nil, segmentLength: Int32? = nil, segmentControl: DashIsoSegmentControl? = nil) {
            self.destination = destination
            self.fragmentLength = fragmentLength
            self.minBufferTime = minBufferTime
            self.hbbtvCompliance = hbbtvCompliance
            self.encryption = encryption
            self.baseUrl = baseUrl
            self.segmentLength = segmentLength
            self.segmentControl = segmentControl
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case fragmentLength = "fragmentLength"
            case minBufferTime = "minBufferTime"
            case hbbtvCompliance = "hbbtvCompliance"
            case encryption = "encryption"
            case baseUrl = "baseUrl"
            case segmentLength = "segmentLength"
            case segmentControl = "segmentControl"
        }
    }

    public enum BurninSubtitleTeletextSpacing: String, CustomStringConvertible, Codable {
        case fixedGrid = "FIXED_GRID"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationLoudnessLogging: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case dontLog = "DONT_LOG"
        public var description: String { return self.rawValue }
    }

    public enum Eac3LfeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleAlignment: String, CustomStringConvertible, Codable {
        case centered = "CENTERED"
        case left = "LEFT"
        public var description: String { return self.rawValue }
    }

    public enum AudioTypeControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public struct InsertableImage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .string), 
            AWSShapeMember(label: "ImageX", location: .body(locationName: "imageX"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageY", location: .body(locationName: "imageY"), required: false, type: .integer), 
            AWSShapeMember(label: "Opacity", location: .body(locationName: "opacity"), required: false, type: .integer), 
            AWSShapeMember(label: "FadeIn", location: .body(locationName: "fadeIn"), required: false, type: .integer), 
            AWSShapeMember(label: "FadeOut", location: .body(locationName: "fadeOut"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageInserterInput", location: .body(locationName: "imageInserterInput"), required: false, type: .string), 
            AWSShapeMember(label: "Duration", location: .body(locationName: "duration"), required: false, type: .integer), 
            AWSShapeMember(label: "Layer", location: .body(locationName: "layer"), required: false, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer)
        ]
        /// Specify the Height (Height) of the inserted image. Use a value that is less than or equal to the video resolution height. Leave this setting blank to use the native height of the image.
        public let height: Int32?
        /// Use Start time (StartTime) to specify the video timecode when the image is inserted in the output. This must be in timecode format (HH:MM:SS:FF)
        public let startTime: String?
        /// Use Left (ImageX) to set the distance, in pixels, between the inserted image and the left edge of the frame. Required for BMP, PNG and TGA input.
        public let imageX: Int32?
        /// Use Top (ImageY) to set the distance, in pixels, between the inserted image and the top edge of the video frame. Required for BMP, PNG and TGA input.
        public let imageY: Int32?
        /// Use Opacity (Opacity) to specify how much of the underlying video shows through the inserted image. 0 is transparent and 100 is fully opaque. Default is 50.
        public let opacity: Int32?
        /// Use Fade in (FadeIut) to set the length, in milliseconds, of the inserted image fade in. If you don't specify a value for Fade in, the image will appear abruptly at the Start time.
        public let fadeIn: Int32?
        /// Use Fade out (FadeOut) to set the length, in milliseconds, of the inserted image fade out. If you don't specify a value for Fade out, the image will disappear abruptly at the end of the inserted image duration.
        public let fadeOut: Int32?
        /// Use Image location (imageInserterInput) to specify the Amazon S3 location of the image to be inserted into the output. Use a 32 bit BMP, PNG, or TGA file that fits inside the video frame.
        public let imageInserterInput: String?
        /// Use Duration (Duration) to set the time, in milliseconds, for the image to remain on the output video.
        public let duration: Int32?
        /// Use Layer (Layer) to specify how overlapping inserted images appear. Images with higher values of layer appear on top of images with lower values of layer.
        public let layer: Int32?
        /// Specify the Width (Width) of the inserted image. Use a value that is less than or equal to the video resolution width. Leave this setting blank to use the native width of the image.
        public let width: Int32?

        public init(height: Int32? = nil, startTime: String? = nil, imageX: Int32? = nil, imageY: Int32? = nil, opacity: Int32? = nil, fadeIn: Int32? = nil, fadeOut: Int32? = nil, imageInserterInput: String? = nil, duration: Int32? = nil, layer: Int32? = nil, width: Int32? = nil) {
            self.height = height
            self.startTime = startTime
            self.imageX = imageX
            self.imageY = imageY
            self.opacity = opacity
            self.fadeIn = fadeIn
            self.fadeOut = fadeOut
            self.imageInserterInput = imageInserterInput
            self.duration = duration
            self.layer = layer
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case startTime = "startTime"
            case imageX = "imageX"
            case imageY = "imageY"
            case opacity = "opacity"
            case fadeIn = "fadeIn"
            case fadeOut = "fadeOut"
            case imageInserterInput = "imageInserterInput"
            case duration = "duration"
            case layer = "layer"
            case width = "width"
        }
    }

    public enum M2tsEbpPlacement: String, CustomStringConvertible, Codable {
        case videoAndAudioPids = "VIDEO_AND_AUDIO_PIDS"
        case videoPid = "VIDEO_PID"
        public var description: String { return self.rawValue }
    }

    public enum AacCodingMode: String, CustomStringConvertible, Codable {
        case adReceiverMix = "AD_RECEIVER_MIX"
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode11 = "CODING_MODE_1_1"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode51 = "CODING_MODE_5_1"
        public var description: String { return self.rawValue }
    }

    public enum AudioCodec: String, CustomStringConvertible, Codable {
        case aac = "AAC"
        case mp2 = "MP2"
        case wav = "WAV"
        case aiff = "AIFF"
        case ac3 = "AC3"
        case eac3 = "EAC3"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleShadowColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MsSmoothAudioDeduplication: String, CustomStringConvertible, Codable {
        case combineDuplicateStreams = "COMBINE_DUPLICATE_STREAMS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H264FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum CaptionSourceType: String, CustomStringConvertible, Codable {
        case ancillary = "ANCILLARY"
        case dvbSub = "DVB_SUB"
        case embedded = "EMBEDDED"
        case scc = "SCC"
        case ttml = "TTML"
        case stl = "STL"
        case srt = "SRT"
        case teletext = "TELETEXT"
        case nullSource = "NULL_SOURCE"
        public var description: String { return self.rawValue }
    }

    public enum OutputSdt: String, CustomStringConvertible, Codable {
        case sdtFollow = "SDT_FOLLOW"
        case sdtFollowIfPresent = "SDT_FOLLOW_IF_PRESENT"
        case sdtManual = "SDT_MANUAL"
        case sdtNone = "SDT_NONE"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleBackgroundColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum TimecodeBurninPosition: String, CustomStringConvertible, Codable {
        case topCenter = "TOP_CENTER"
        case topLeft = "TOP_LEFT"
        case topRight = "TOP_RIGHT"
        case middleLeft = "MIDDLE_LEFT"
        case middleCenter = "MIDDLE_CENTER"
        case middleRight = "MIDDLE_RIGHT"
        case bottomLeft = "BOTTOM_LEFT"
        case bottomCenter = "BOTTOM_CENTER"
        case bottomRight = "BOTTOM_RIGHT"
        public var description: String { return self.rawValue }
    }

    public enum H265GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public struct OutputSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HlsSettings", location: .body(locationName: "hlsSettings"), required: false, type: .structure)
        ]
        public let hlsSettings: HlsSettings?

        public init(hlsSettings: HlsSettings? = nil) {
            self.hlsSettings = hlsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case hlsSettings = "hlsSettings"
        }
    }

    public enum Mpeg2TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Role", location: .body(locationName: "role"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "ClientRequestToken", location: .body(locationName: "clientRequestToken"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "UserMetadata", location: .body(locationName: "userMetadata"), required: false, type: .map)
        ]
        /// Required. The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html.
        public let role: String?
        public let settings: JobSettings?
        /// Idempotency token for CreateJob operation.
        public let clientRequestToken: String?
        /// When you create a job, you can either specify a job template or specify the transcoding settings individually
        public let jobTemplate: String?
        /// Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html.
        public let queue: String?
        /// User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.
        public let userMetadata: [String: String]?

        public init(role: String? = nil, settings: JobSettings? = nil, clientRequestToken: String? = nil, jobTemplate: String? = nil, queue: String? = nil, userMetadata: [String: String]? = nil) {
            self.role = role
            self.settings = settings
            self.clientRequestToken = clientRequestToken
            self.jobTemplate = jobTemplate
            self.queue = queue
            self.userMetadata = userMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case role = "role"
            case settings = "settings"
            case clientRequestToken = "clientRequestToken"
            case jobTemplate = "jobTemplate"
            case queue = "queue"
            case userMetadata = "userMetadata"
        }
    }

    public enum Mpeg2IntraDcPrecision: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case intraDcPrecision8 = "INTRA_DC_PRECISION_8"
        case intraDcPrecision9 = "INTRA_DC_PRECISION_9"
        case intraDcPrecision10 = "INTRA_DC_PRECISION_10"
        case intraDcPrecision11 = "INTRA_DC_PRECISION_11"
        public var description: String { return self.rawValue }
    }

    public enum ProresCodecProfile: String, CustomStringConvertible, Codable {
        case appleProres422 = "APPLE_PRORES_422"
        case appleProres422Hq = "APPLE_PRORES_422_HQ"
        case appleProres422Lt = "APPLE_PRORES_422_LT"
        case appleProres422Proxy = "APPLE_PRORES_422_PROXY"
        public var description: String { return self.rawValue }
    }

    public enum H265CodecProfile: String, CustomStringConvertible, Codable {
        case mainMain = "MAIN_MAIN"
        case mainHigh = "MAIN_HIGH"
        case main10Main = "MAIN10_MAIN"
        case main10High = "MAIN10_HIGH"
        case main4228BitMain = "MAIN_422_8BIT_MAIN"
        case main4228BitHigh = "MAIN_422_8BIT_HIGH"
        case main42210BitMain = "MAIN_422_10BIT_MAIN"
        case main42210BitHigh = "MAIN_422_10BIT_HIGH"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public enum InputPsiControl: String, CustomStringConvertible, Codable {
        case ignorePsi = "IGNORE_PSI"
        case usePsi = "USE_PSI"
        public var description: String { return self.rawValue }
    }

    public enum Eac3AttenuationControl: String, CustomStringConvertible, Codable {
        case attenuate3Db = "ATTENUATE_3_DB"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum HlsInitializationVectorInManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct ListJobTemplatesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .querystring(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// Optionally, specify a job template category to limit responses to only job templates from that category.
        public let category: String?
        public let listBy: JobTemplateListBy?
        /// Use this string, provided with the response to a previous request, to request the next batch of job templates.
        public let nextToken: String?
        public let order: Order?
        /// Optional. Number of job templates, up to twenty, that will be returned at one time.
        public let maxResults: Int32?

        public init(category: String? = nil, listBy: JobTemplateListBy? = nil, nextToken: String? = nil, order: Order? = nil, maxResults: Int32? = nil) {
            self.category = category
            self.listBy = listBy
            self.nextToken = nextToken
            self.order = order
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case listBy = "listBy"
            case nextToken = "nextToken"
            case order = "order"
            case maxResults = "maxResults"
        }
    }

    public enum HlsCodecSpecification: String, CustomStringConvertible, Codable {
        case rfc6381 = "RFC_6381"
        case rfc4281 = "RFC_4281"
        public var description: String { return self.rawValue }
    }

    public enum Eac3DynamicRangeCompressionLine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case filmStandard = "FILM_STANDARD"
        case filmLight = "FILM_LIGHT"
        case musicStandard = "MUSIC_STANDARD"
        case musicLight = "MUSIC_LIGHT"
        case speech = "SPEECH"
        public var description: String { return self.rawValue }
    }

    public enum AacVbrQuality: String, CustomStringConvertible, Codable {
        case low = "LOW"
        case mediumLow = "MEDIUM_LOW"
        case mediumHigh = "MEDIUM_HIGH"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public struct ImageInserter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsertableImages", location: .body(locationName: "insertableImages"), required: false, type: .list)
        ]
        /// Image to insert. Must be 32 bit windows BMP, PNG, or TGA file. Must not be  larger than the output frames.
        public let insertableImages: [InsertableImage]?

        public init(insertableImages: [InsertableImage]? = nil) {
            self.insertableImages = insertableImages
        }

        private enum CodingKeys: String, CodingKey {
            case insertableImages = "insertableImages"
        }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case submitted = "SUBMITTED"
        case progressing = "PROGRESSING"
        case complete = "COMPLETE"
        case canceled = "CANCELED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public struct DeleteJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the job template to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum M2tsEsRateInPes: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct UpdatePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The new category for the preset, if you are changing it.
        public let category: String?
        public let settings: PresetSettings?
        /// The name of the preset you are modifying.
        public let name: String
        /// The new description for the preset, if you are changing it.
        public let description: String?

        public init(category: String? = nil, settings: PresetSettings? = nil, name: String, description: String? = nil) {
            self.category = category
            self.settings = settings
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case settings = "settings"
            case name = "name"
            case description = "description"
        }
    }

    public struct M2tsSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PcrControl", location: .body(locationName: "pcrControl"), required: false, type: .enum), 
            AWSShapeMember(label: "PatInterval", location: .body(locationName: "patInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtPid", location: .body(locationName: "pmtPid"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoPid", location: .body(locationName: "videoPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrPid", location: .body(locationName: "pcrPid"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Source", location: .body(locationName: "scte35Source"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbTdtSettings", location: .body(locationName: "dvbTdtSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "RateMode", location: .body(locationName: "rateMode"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbSdtSettings", location: .body(locationName: "dvbSdtSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioFramesPerPes", location: .body(locationName: "audioFramesPerPes"), required: false, type: .integer), 
            AWSShapeMember(label: "BufferModel", location: .body(locationName: "bufferModel"), required: false, type: .enum), 
            AWSShapeMember(label: "PrivateMetadataPid", location: .body(locationName: "privateMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioBufferModel", location: .body(locationName: "audioBufferModel"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxPcrInterval", location: .body(locationName: "maxPcrInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentationTime", location: .body(locationName: "segmentationTime"), required: false, type: .double), 
            AWSShapeMember(label: "SegmentationStyle", location: .body(locationName: "segmentationStyle"), required: false, type: .enum), 
            AWSShapeMember(label: "MinEbpInterval", location: .body(locationName: "minEbpInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbNitSettings", location: .body(locationName: "dvbNitSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "EbpAudioInterval", location: .body(locationName: "ebpAudioInterval"), required: false, type: .enum), 
            AWSShapeMember(label: "PmtInterval", location: .body(locationName: "pmtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "FragmentTime", location: .body(locationName: "fragmentTime"), required: false, type: .double), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Pid", location: .body(locationName: "scte35Pid"), required: false, type: .integer), 
            AWSShapeMember(label: "EbpPlacement", location: .body(locationName: "ebpPlacement"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbTeletextPid", location: .body(locationName: "dvbTeletextPid"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentationMarkers", location: .body(locationName: "segmentationMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioPids", location: .body(locationName: "audioPids"), required: false, type: .list), 
            AWSShapeMember(label: "DvbSubPids", location: .body(locationName: "dvbSubPids"), required: false, type: .list), 
            AWSShapeMember(label: "TransportStreamId", location: .body(locationName: "transportStreamId"), required: false, type: .integer), 
            AWSShapeMember(label: "NullPacketBitrate", location: .body(locationName: "nullPacketBitrate"), required: false, type: .double), 
            AWSShapeMember(label: "EsRateInPes", location: .body(locationName: "esRateInPes"), required: false, type: .enum)
        ]
        public let pcrControl: M2tsPcrControl?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let patInterval: Int32?
        /// Packet Identifier (PID) for the Program Map Table (PMT) in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let pmtPid: Int32?
        /// Packet Identifier (PID) of the elementary video stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let videoPid: Int32?
        /// Packet Identifier (PID) of the Program Clock Reference (PCR) in the transport stream. When no value is given, the encoder will assign the same value as the Video PID. Can be entered as a decimal or hexadecimal value.
        public let pcrPid: Int32?
        public let scte35Source: M2tsScte35Source?
        public let dvbTdtSettings: DvbTdtSettings?
        public let rateMode: M2tsRateMode?
        public let dvbSdtSettings: DvbSdtSettings?
        /// The value of the program number field in the Program Map Table.
        public let programNumber: Int32?
        /// The number of audio frames to insert for each PES packet.
        public let audioFramesPerPes: Int32?
        public let bufferModel: M2tsBufferModel?
        /// Packet Identifier (PID) of the private metadata stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let privateMetadataPid: Int32?
        public let audioBufferModel: M2tsAudioBufferModel?
        /// Maximum time in milliseconds between Program Clock References (PCRs) inserted into the transport stream.
        public let maxPcrInterval: Int32?
        /// The length in seconds of each segment. Required unless markers is set to _none_.
        public let segmentationTime: Double?
        public let segmentationStyle: M2tsSegmentationStyle?
        /// When set, enforces that Encoder Boundary Points do not come within the specified time interval of each other by looking ahead at input video. If another EBP is going to come in within the specified time interval, the current EBP is not emitted, and the segment is "stretched" to the next marker. The lookahead value does not add latency to the system. The Live Event must be configured elsewhere to create sufficient latency to make the lookahead accurate.
        public let minEbpInterval: Int32?
        public let dvbNitSettings: DvbNitSettings?
        public let ebpAudioInterval: M2tsEbpAudioInterval?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let pmtInterval: Int32?
        /// The length in seconds of each fragment. Only used with EBP markers.
        public let fragmentTime: Double?
        /// The output bitrate of the transport stream in bits per second. Setting to 0 lets the muxer automatically determine the appropriate bitrate. Other common values are 3750000, 7500000, and 15000000.
        public let bitrate: Int32?
        /// Packet Identifier (PID) of the SCTE-35 stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let scte35Pid: Int32?
        public let ebpPlacement: M2tsEbpPlacement?
        /// Packet Identifier (PID) for input source DVB Teletext data to this output. Can be entered as a decimal or hexadecimal value.
        public let dvbTeletextPid: Int32?
        public let segmentationMarkers: M2tsSegmentationMarkers?
        /// Packet Identifier (PID) of the elementary audio stream(s) in the transport stream. Multiple values are accepted, and can be entered in ranges and/or by comma separation. Can be entered as decimal or hexadecimal values.
        public let audioPids: [Int32]?
        /// Packet Identifier (PID) for input source DVB Subtitle data to this output. Multiple values are accepted, and can be entered in ranges and/or by comma separation. Can be entered as decimal or hexadecimal values.
        public let dvbSubPids: [Int32]?
        /// The value of the transport stream ID field in the Program Map Table.
        public let transportStreamId: Int32?
        /// Value in bits per second of extra null packets to insert into the transport stream. This can be used if a downstream encryption system requires periodic null packets.
        public let nullPacketBitrate: Double?
        public let esRateInPes: M2tsEsRateInPes?

        public init(pcrControl: M2tsPcrControl? = nil, patInterval: Int32? = nil, pmtPid: Int32? = nil, videoPid: Int32? = nil, pcrPid: Int32? = nil, scte35Source: M2tsScte35Source? = nil, dvbTdtSettings: DvbTdtSettings? = nil, rateMode: M2tsRateMode? = nil, dvbSdtSettings: DvbSdtSettings? = nil, programNumber: Int32? = nil, audioFramesPerPes: Int32? = nil, bufferModel: M2tsBufferModel? = nil, privateMetadataPid: Int32? = nil, audioBufferModel: M2tsAudioBufferModel? = nil, maxPcrInterval: Int32? = nil, segmentationTime: Double? = nil, segmentationStyle: M2tsSegmentationStyle? = nil, minEbpInterval: Int32? = nil, dvbNitSettings: DvbNitSettings? = nil, ebpAudioInterval: M2tsEbpAudioInterval? = nil, pmtInterval: Int32? = nil, fragmentTime: Double? = nil, bitrate: Int32? = nil, scte35Pid: Int32? = nil, ebpPlacement: M2tsEbpPlacement? = nil, dvbTeletextPid: Int32? = nil, segmentationMarkers: M2tsSegmentationMarkers? = nil, audioPids: [Int32]? = nil, dvbSubPids: [Int32]? = nil, transportStreamId: Int32? = nil, nullPacketBitrate: Double? = nil, esRateInPes: M2tsEsRateInPes? = nil) {
            self.pcrControl = pcrControl
            self.patInterval = patInterval
            self.pmtPid = pmtPid
            self.videoPid = videoPid
            self.pcrPid = pcrPid
            self.scte35Source = scte35Source
            self.dvbTdtSettings = dvbTdtSettings
            self.rateMode = rateMode
            self.dvbSdtSettings = dvbSdtSettings
            self.programNumber = programNumber
            self.audioFramesPerPes = audioFramesPerPes
            self.bufferModel = bufferModel
            self.privateMetadataPid = privateMetadataPid
            self.audioBufferModel = audioBufferModel
            self.maxPcrInterval = maxPcrInterval
            self.segmentationTime = segmentationTime
            self.segmentationStyle = segmentationStyle
            self.minEbpInterval = minEbpInterval
            self.dvbNitSettings = dvbNitSettings
            self.ebpAudioInterval = ebpAudioInterval
            self.pmtInterval = pmtInterval
            self.fragmentTime = fragmentTime
            self.bitrate = bitrate
            self.scte35Pid = scte35Pid
            self.ebpPlacement = ebpPlacement
            self.dvbTeletextPid = dvbTeletextPid
            self.segmentationMarkers = segmentationMarkers
            self.audioPids = audioPids
            self.dvbSubPids = dvbSubPids
            self.transportStreamId = transportStreamId
            self.nullPacketBitrate = nullPacketBitrate
            self.esRateInPes = esRateInPes
        }

        private enum CodingKeys: String, CodingKey {
            case pcrControl = "pcrControl"
            case patInterval = "patInterval"
            case pmtPid = "pmtPid"
            case videoPid = "videoPid"
            case pcrPid = "pcrPid"
            case scte35Source = "scte35Source"
            case dvbTdtSettings = "dvbTdtSettings"
            case rateMode = "rateMode"
            case dvbSdtSettings = "dvbSdtSettings"
            case programNumber = "programNumber"
            case audioFramesPerPes = "audioFramesPerPes"
            case bufferModel = "bufferModel"
            case privateMetadataPid = "privateMetadataPid"
            case audioBufferModel = "audioBufferModel"
            case maxPcrInterval = "maxPcrInterval"
            case segmentationTime = "segmentationTime"
            case segmentationStyle = "segmentationStyle"
            case minEbpInterval = "minEbpInterval"
            case dvbNitSettings = "dvbNitSettings"
            case ebpAudioInterval = "ebpAudioInterval"
            case pmtInterval = "pmtInterval"
            case fragmentTime = "fragmentTime"
            case bitrate = "bitrate"
            case scte35Pid = "scte35Pid"
            case ebpPlacement = "ebpPlacement"
            case dvbTeletextPid = "dvbTeletextPid"
            case segmentationMarkers = "segmentationMarkers"
            case audioPids = "audioPids"
            case dvbSubPids = "dvbSubPids"
            case transportStreamId = "transportStreamId"
            case nullPacketBitrate = "nullPacketBitrate"
            case esRateInPes = "esRateInPes"
        }
    }

    public enum FileSourceConvert608To708: String, CustomStringConvertible, Codable {
        case upconvert = "UPCONVERT"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum Eac3PassthroughControl: String, CustomStringConvertible, Codable {
        case whenPossible = "WHEN_POSSIBLE"
        case noPassthrough = "NO_PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public struct ListPresetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .querystring(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// Optionally, specify a preset category to limit responses to only presets from that category.
        public let category: String?
        public let listBy: PresetListBy?
        /// Use this string, provided with the response to a previous request, to request the next batch of presets.
        public let nextToken: String?
        public let order: Order?
        /// Optional. Number of presets, up to twenty, that will be returned at one time
        public let maxResults: Int32?

        public init(category: String? = nil, listBy: PresetListBy? = nil, nextToken: String? = nil, order: Order? = nil, maxResults: Int32? = nil) {
            self.category = category
            self.listBy = listBy
            self.nextToken = nextToken
            self.order = order
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case listBy = "listBy"
            case nextToken = "nextToken"
            case order = "order"
            case maxResults = "maxResults"
        }
    }

    public enum HlsAudioTrackType: String, CustomStringConvertible, Codable {
        case alternateAudioAutoSelectDefault = "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT"
        case alternateAudioAutoSelect = "ALTERNATE_AUDIO_AUTO_SELECT"
        case alternateAudioNotAutoSelect = "ALTERNATE_AUDIO_NOT_AUTO_SELECT"
        case audioOnlyVariantStream = "AUDIO_ONLY_VARIANT_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum H265QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case singlePassHq = "SINGLE_PASS_HQ"
        case multiPassHq = "MULTI_PASS_HQ"
        public var description: String { return self.rawValue }
    }

    public struct VideoCodecSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "H264Settings", location: .body(locationName: "h264Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "ProresSettings", location: .body(locationName: "proresSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "H265Settings", location: .body(locationName: "h265Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Codec", location: .body(locationName: "codec"), required: false, type: .enum), 
            AWSShapeMember(label: "FrameCaptureSettings", location: .body(locationName: "frameCaptureSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Mpeg2Settings", location: .body(locationName: "mpeg2Settings"), required: false, type: .structure)
        ]
        public let h264Settings: H264Settings?
        public let proresSettings: ProresSettings?
        public let h265Settings: H265Settings?
        public let codec: VideoCodec?
        public let frameCaptureSettings: FrameCaptureSettings?
        public let mpeg2Settings: Mpeg2Settings?

        public init(h264Settings: H264Settings? = nil, proresSettings: ProresSettings? = nil, h265Settings: H265Settings? = nil, codec: VideoCodec? = nil, frameCaptureSettings: FrameCaptureSettings? = nil, mpeg2Settings: Mpeg2Settings? = nil) {
            self.h264Settings = h264Settings
            self.proresSettings = proresSettings
            self.h265Settings = h265Settings
            self.codec = codec
            self.frameCaptureSettings = frameCaptureSettings
            self.mpeg2Settings = mpeg2Settings
        }

        private enum CodingKeys: String, CodingKey {
            case h264Settings = "h264Settings"
            case proresSettings = "proresSettings"
            case h265Settings = "h265Settings"
            case codec = "codec"
            case frameCaptureSettings = "frameCaptureSettings"
            case mpeg2Settings = "mpeg2Settings"
        }
    }

    public struct Rectangle: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "X", location: .body(locationName: "x"), required: false, type: .integer), 
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "Y", location: .body(locationName: "y"), required: false, type: .integer)
        ]
        /// The distance, in pixels, between the rectangle and the left edge of the video frame.
        public let x: Int32?
        /// Height of rectangle in pixels.
        public let height: Int32?
        /// Width of rectangle in pixels.
        public let width: Int32?
        /// The distance, in pixels, between the rectangle and the top edge of the video frame.
        public let y: Int32?

        public init(x: Int32? = nil, height: Int32? = nil, width: Int32? = nil, y: Int32? = nil) {
            self.x = x
            self.height = height
            self.width = width
            self.y = y
        }

        private enum CodingKeys: String, CodingKey {
            case x = "x"
            case height = "height"
            case width = "width"
            case y = "y"
        }
    }

    public struct BurninDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BackgroundColor", location: .body(locationName: "backgroundColor"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundOpacity", location: .body(locationName: "backgroundOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "YPosition", location: .body(locationName: "yPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "FontOpacity", location: .body(locationName: "fontOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowXOffset", location: .body(locationName: "shadowXOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Alignment", location: .body(locationName: "alignment"), required: false, type: .enum), 
            AWSShapeMember(label: "XPosition", location: .body(locationName: "xPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowOpacity", location: .body(locationName: "shadowOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "FontColor", location: .body(locationName: "fontColor"), required: false, type: .enum), 
            AWSShapeMember(label: "OutlineColor", location: .body(locationName: "outlineColor"), required: false, type: .enum), 
            AWSShapeMember(label: "ShadowColor", location: .body(locationName: "shadowColor"), required: false, type: .enum), 
            AWSShapeMember(label: "TeletextSpacing", location: .body(locationName: "teletextSpacing"), required: false, type: .enum), 
            AWSShapeMember(label: "FontResolution", location: .body(locationName: "fontResolution"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowYOffset", location: .body(locationName: "shadowYOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "OutlineSize", location: .body(locationName: "outlineSize"), required: false, type: .integer)
        ]
        public let backgroundColor: BurninSubtitleBackgroundColor?
        /// Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let backgroundOpacity: Int32?
        /// Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit y_position is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let yPosition: Int32?
        /// Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontOpacity: Int32?
        /// Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        public let shadowXOffset: Int32?
        /// A positive integer indicates the exact font size in points. Set to 0 for automatic font size selection. All burn-in and DVB-Sub font settings must match.
        public let fontSize: Int32?
        public let alignment: BurninSubtitleAlignment?
        /// Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit x_position is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let xPosition: Int32?
        /// Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let shadowOpacity: Int32?
        public let fontColor: BurninSubtitleFontColor?
        public let outlineColor: BurninSubtitleOutlineColor?
        public let shadowColor: BurninSubtitleShadowColor?
        public let teletextSpacing: BurninSubtitleTeletextSpacing?
        /// Font resolution in DPI (dots per inch); default is 96 dpi.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontResolution: Int32?
        /// Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        public let shadowYOffset: Int32?
        /// Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let outlineSize: Int32?

        public init(backgroundColor: BurninSubtitleBackgroundColor? = nil, backgroundOpacity: Int32? = nil, yPosition: Int32? = nil, fontOpacity: Int32? = nil, shadowXOffset: Int32? = nil, fontSize: Int32? = nil, alignment: BurninSubtitleAlignment? = nil, xPosition: Int32? = nil, shadowOpacity: Int32? = nil, fontColor: BurninSubtitleFontColor? = nil, outlineColor: BurninSubtitleOutlineColor? = nil, shadowColor: BurninSubtitleShadowColor? = nil, teletextSpacing: BurninSubtitleTeletextSpacing? = nil, fontResolution: Int32? = nil, shadowYOffset: Int32? = nil, outlineSize: Int32? = nil) {
            self.backgroundColor = backgroundColor
            self.backgroundOpacity = backgroundOpacity
            self.yPosition = yPosition
            self.fontOpacity = fontOpacity
            self.shadowXOffset = shadowXOffset
            self.fontSize = fontSize
            self.alignment = alignment
            self.xPosition = xPosition
            self.shadowOpacity = shadowOpacity
            self.fontColor = fontColor
            self.outlineColor = outlineColor
            self.shadowColor = shadowColor
            self.teletextSpacing = teletextSpacing
            self.fontResolution = fontResolution
            self.shadowYOffset = shadowYOffset
            self.outlineSize = outlineSize
        }

        private enum CodingKeys: String, CodingKey {
            case backgroundColor = "backgroundColor"
            case backgroundOpacity = "backgroundOpacity"
            case yPosition = "yPosition"
            case fontOpacity = "fontOpacity"
            case shadowXOffset = "shadowXOffset"
            case fontSize = "fontSize"
            case alignment = "alignment"
            case xPosition = "xPosition"
            case shadowOpacity = "shadowOpacity"
            case fontColor = "fontColor"
            case outlineColor = "outlineColor"
            case shadowColor = "shadowColor"
            case teletextSpacing = "teletextSpacing"
            case fontResolution = "fontResolution"
            case shadowYOffset = "shadowYOffset"
            case outlineSize = "outlineSize"
        }
    }

    public struct H264Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FlickerAdaptiveQuantization", location: .body(locationName: "flickerAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "GopBReference", location: .body(locationName: "gopBReference"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "Slices", location: .body(locationName: "slices"), required: false, type: .integer), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "EntropyEncoding", location: .body(locationName: "entropyEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberReferenceFrames", location: .body(locationName: "numberReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "FieldEncoding", location: .body(locationName: "fieldEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "Syntax", location: .body(locationName: "syntax"), required: false, type: .enum), 
            AWSShapeMember(label: "RepeatPps", location: .body(locationName: "repeatPps"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "UnregisteredSeiTimecode", location: .body(locationName: "unregisteredSeiTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "Softness", location: .body(locationName: "softness"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum)
        ]
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        public let parControl: H264ParControl?
        public let flickerAdaptiveQuantization: H264FlickerAdaptiveQuantization?
        public let gopBReference: H264GopBReference?
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures.
        public let slices: Int32?
        /// Size of buffer (HRD buffer model). Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m.
        public let hrdBufferSize: Int32?
        public let entropyEncoding: H264EntropyEncoding?
        public let spatialAdaptiveQuantization: H264SpatialAdaptiveQuantization?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let codecProfile: H264CodecProfile?
        public let qualityTuningLevel: H264QualityTuningLevel?
        public let codecLevel: H264CodecLevel?
        /// Maximum bitrate in bits/second (for VBR mode only). Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m.
        public let maxBitrate: Int32?
        public let adaptiveQuantization: H264AdaptiveQuantization?
        public let gopSizeUnits: H264GopSizeUnits?
        public let sceneChangeDetect: H264SceneChangeDetect?
        public let slowPal: H264SlowPal?
        public let temporalAdaptiveQuantization: H264TemporalAdaptiveQuantization?
        /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
        public let numberReferenceFrames: Int32?
        public let rateControlMode: H264RateControlMode?
        /// When you use the API for transcode jobs that use framerate conversion, specify the framerate as a fraction. For example,  24000 / 1001 = 23.976 fps. Use FramerateDenominator to specify the denominator of this fraction. In this example, use 1001 for the value of FramerateDenominator. When you use the console for transcode jobs that use framerate conversion, provide the value as a decimal number for Framerate. In this example, specify 23.976.
        public let framerateDenominator: Int32?
        public let framerateConversionAlgorithm: H264FramerateConversionAlgorithm?
        public let fieldEncoding: H264FieldEncoding?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        /// Average bitrate in bits/second. Required for VBR, CBR, and ABR. Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let interlaceMode: H264InterlaceMode?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let syntax: H264Syntax?
        public let repeatPps: H264RepeatPps?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        public let unregisteredSeiTimecode: H264UnregisteredSeiTimecode?
        /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image.
        public let softness: Int32?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        public let framerateControl: H264FramerateControl?
        public let telecine: H264Telecine?

        public init(numberBFramesBetweenReferenceFrames: Int32? = nil, parControl: H264ParControl? = nil, flickerAdaptiveQuantization: H264FlickerAdaptiveQuantization? = nil, gopBReference: H264GopBReference? = nil, framerateNumerator: Int32? = nil, slices: Int32? = nil, hrdBufferSize: Int32? = nil, entropyEncoding: H264EntropyEncoding? = nil, spatialAdaptiveQuantization: H264SpatialAdaptiveQuantization? = nil, parNumerator: Int32? = nil, codecProfile: H264CodecProfile? = nil, qualityTuningLevel: H264QualityTuningLevel? = nil, codecLevel: H264CodecLevel? = nil, maxBitrate: Int32? = nil, adaptiveQuantization: H264AdaptiveQuantization? = nil, gopSizeUnits: H264GopSizeUnits? = nil, sceneChangeDetect: H264SceneChangeDetect? = nil, slowPal: H264SlowPal? = nil, temporalAdaptiveQuantization: H264TemporalAdaptiveQuantization? = nil, numberReferenceFrames: Int32? = nil, rateControlMode: H264RateControlMode? = nil, framerateDenominator: Int32? = nil, framerateConversionAlgorithm: H264FramerateConversionAlgorithm? = nil, fieldEncoding: H264FieldEncoding? = nil, parDenominator: Int32? = nil, gopClosedCadence: Int32? = nil, bitrate: Int32? = nil, interlaceMode: H264InterlaceMode? = nil, minIInterval: Int32? = nil, syntax: H264Syntax? = nil, repeatPps: H264RepeatPps? = nil, hrdBufferInitialFillPercentage: Int32? = nil, unregisteredSeiTimecode: H264UnregisteredSeiTimecode? = nil, softness: Int32? = nil, gopSize: Double? = nil, framerateControl: H264FramerateControl? = nil, telecine: H264Telecine? = nil) {
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.parControl = parControl
            self.flickerAdaptiveQuantization = flickerAdaptiveQuantization
            self.gopBReference = gopBReference
            self.framerateNumerator = framerateNumerator
            self.slices = slices
            self.hrdBufferSize = hrdBufferSize
            self.entropyEncoding = entropyEncoding
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.parNumerator = parNumerator
            self.codecProfile = codecProfile
            self.qualityTuningLevel = qualityTuningLevel
            self.codecLevel = codecLevel
            self.maxBitrate = maxBitrate
            self.adaptiveQuantization = adaptiveQuantization
            self.gopSizeUnits = gopSizeUnits
            self.sceneChangeDetect = sceneChangeDetect
            self.slowPal = slowPal
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.numberReferenceFrames = numberReferenceFrames
            self.rateControlMode = rateControlMode
            self.framerateDenominator = framerateDenominator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.fieldEncoding = fieldEncoding
            self.parDenominator = parDenominator
            self.gopClosedCadence = gopClosedCadence
            self.bitrate = bitrate
            self.interlaceMode = interlaceMode
            self.minIInterval = minIInterval
            self.syntax = syntax
            self.repeatPps = repeatPps
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.unregisteredSeiTimecode = unregisteredSeiTimecode
            self.softness = softness
            self.gopSize = gopSize
            self.framerateControl = framerateControl
            self.telecine = telecine
        }

        private enum CodingKeys: String, CodingKey {
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case parControl = "parControl"
            case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
            case gopBReference = "gopBReference"
            case framerateNumerator = "framerateNumerator"
            case slices = "slices"
            case hrdBufferSize = "hrdBufferSize"
            case entropyEncoding = "entropyEncoding"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case parNumerator = "parNumerator"
            case codecProfile = "codecProfile"
            case qualityTuningLevel = "qualityTuningLevel"
            case codecLevel = "codecLevel"
            case maxBitrate = "maxBitrate"
            case adaptiveQuantization = "adaptiveQuantization"
            case gopSizeUnits = "gopSizeUnits"
            case sceneChangeDetect = "sceneChangeDetect"
            case slowPal = "slowPal"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case numberReferenceFrames = "numberReferenceFrames"
            case rateControlMode = "rateControlMode"
            case framerateDenominator = "framerateDenominator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case fieldEncoding = "fieldEncoding"
            case parDenominator = "parDenominator"
            case gopClosedCadence = "gopClosedCadence"
            case bitrate = "bitrate"
            case interlaceMode = "interlaceMode"
            case minIInterval = "minIInterval"
            case syntax = "syntax"
            case repeatPps = "repeatPps"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case unregisteredSeiTimecode = "unregisteredSeiTimecode"
            case softness = "softness"
            case gopSize = "gopSize"
            case framerateControl = "framerateControl"
            case telecine = "telecine"
        }
    }

    public struct MovSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Reference", location: .body(locationName: "reference"), required: false, type: .enum), 
            AWSShapeMember(label: "ClapAtom", location: .body(locationName: "clapAtom"), required: false, type: .enum), 
            AWSShapeMember(label: "Mpeg2FourCCControl", location: .body(locationName: "mpeg2FourCCControl"), required: false, type: .enum), 
            AWSShapeMember(label: "PaddingControl", location: .body(locationName: "paddingControl"), required: false, type: .enum), 
            AWSShapeMember(label: "CslgAtom", location: .body(locationName: "cslgAtom"), required: false, type: .enum)
        ]
        public let reference: MovReference?
        public let clapAtom: MovClapAtom?
        public let mpeg2FourCCControl: MovMpeg2FourCCControl?
        public let paddingControl: MovPaddingControl?
        public let cslgAtom: MovCslgAtom?

        public init(reference: MovReference? = nil, clapAtom: MovClapAtom? = nil, mpeg2FourCCControl: MovMpeg2FourCCControl? = nil, paddingControl: MovPaddingControl? = nil, cslgAtom: MovCslgAtom? = nil) {
            self.reference = reference
            self.clapAtom = clapAtom
            self.mpeg2FourCCControl = mpeg2FourCCControl
            self.paddingControl = paddingControl
            self.cslgAtom = cslgAtom
        }

        private enum CodingKeys: String, CodingKey {
            case reference = "reference"
            case clapAtom = "clapAtom"
            case mpeg2FourCCControl = "mpeg2FourCCControl"
            case paddingControl = "paddingControl"
            case cslgAtom = "cslgAtom"
        }
    }

    public enum H264CodecProfile: String, CustomStringConvertible, Codable {
        case baseline = "BASELINE"
        case high = "HIGH"
        case high10Bit = "HIGH_10BIT"
        case high422 = "HIGH_422"
        case high42210Bit = "HIGH_422_10BIT"
        case main = "MAIN"
        public var description: String { return self.rawValue }
    }

    public enum MovReference: String, CustomStringConvertible, Codable {
        case selfContained = "SELF_CONTAINED"
        case external = "EXTERNAL"
        public var description: String { return self.rawValue }
    }

    public enum H265RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum H265ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleBackgroundColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum M3u8PcrControl: String, CustomStringConvertible, Codable {
        case pcrEveryPesPacket = "PCR_EVERY_PES_PACKET"
        case configuredPcrPeriod = "CONFIGURED_PCR_PERIOD"
        public var description: String { return self.rawValue }
    }

    public struct CaptionSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "SourceSettings", location: .body(locationName: "sourceSettings"), required: false, type: .structure)
        ]
        /// The specific language to extract from source. If input is SCTE-27, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub and output is Burn-in or SMPTE-TT, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub that is being passed through, omit this field (and PID field); there is no way to extract a specific language with pass-through captions.
        public let languageCode: LanguageCode?
        public let sourceSettings: CaptionSourceSettings?

        public init(languageCode: LanguageCode? = nil, sourceSettings: CaptionSourceSettings? = nil) {
            self.languageCode = languageCode
            self.sourceSettings = sourceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "languageCode"
            case sourceSettings = "sourceSettings"
        }
    }

    public enum AudioSelectorType: String, CustomStringConvertible, Codable {
        case pid = "PID"
        case track = "TRACK"
        case languageCode = "LANGUAGE_CODE"
        public var description: String { return self.rawValue }
    }

    public enum JobTemplateListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum HlsAdMarkers: String, CustomStringConvertible, Codable {
        case elemental = "ELEMENTAL"
        case elementalScte35 = "ELEMENTAL_SCTE35"
        public var description: String { return self.rawValue }
    }

    public enum H264FieldEncoding: String, CustomStringConvertible, Codable {
        case paff = "PAFF"
        case forceField = "FORCE_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct NoiseReducerSpatialFilterSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PostFilterSharpenStrength", location: .body(locationName: "postFilterSharpenStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "Speed", location: .body(locationName: "speed"), required: false, type: .integer), 
            AWSShapeMember(label: "Strength", location: .body(locationName: "strength"), required: false, type: .integer)
        ]
        /// Specify strength of post noise reduction sharpening filter, with 0 disabling the filter and 3 enabling it at maximum strength.
        public let postFilterSharpenStrength: Int32?
        /// The speed of the filter, from -2 (lower speed) to 3 (higher speed), with 0 being the nominal value.
        public let speed: Int32?
        /// Relative strength of noise reducing filter. Higher values produce stronger filtering.
        public let strength: Int32?

        public init(postFilterSharpenStrength: Int32? = nil, speed: Int32? = nil, strength: Int32? = nil) {
            self.postFilterSharpenStrength = postFilterSharpenStrength
            self.speed = speed
            self.strength = strength
        }

        private enum CodingKeys: String, CodingKey {
            case postFilterSharpenStrength = "postFilterSharpenStrength"
            case speed = "speed"
            case strength = "strength"
        }
    }

    public struct CaptionSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FileSourceSettings", location: .body(locationName: "fileSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DvbSubSourceSettings", location: .body(locationName: "dvbSubSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "AncillarySourceSettings", location: .body(locationName: "ancillarySourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TeletextSourceSettings", location: .body(locationName: "teletextSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SourceType", location: .body(locationName: "sourceType"), required: false, type: .enum), 
            AWSShapeMember(label: "EmbeddedSourceSettings", location: .body(locationName: "embeddedSourceSettings"), required: false, type: .structure)
        ]
        public let fileSourceSettings: FileSourceSettings?
        public let dvbSubSourceSettings: DvbSubSourceSettings?
        public let ancillarySourceSettings: AncillarySourceSettings?
        public let teletextSourceSettings: TeletextSourceSettings?
        public let sourceType: CaptionSourceType?
        public let embeddedSourceSettings: EmbeddedSourceSettings?

        public init(fileSourceSettings: FileSourceSettings? = nil, dvbSubSourceSettings: DvbSubSourceSettings? = nil, ancillarySourceSettings: AncillarySourceSettings? = nil, teletextSourceSettings: TeletextSourceSettings? = nil, sourceType: CaptionSourceType? = nil, embeddedSourceSettings: EmbeddedSourceSettings? = nil) {
            self.fileSourceSettings = fileSourceSettings
            self.dvbSubSourceSettings = dvbSubSourceSettings
            self.ancillarySourceSettings = ancillarySourceSettings
            self.teletextSourceSettings = teletextSourceSettings
            self.sourceType = sourceType
            self.embeddedSourceSettings = embeddedSourceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case fileSourceSettings = "fileSourceSettings"
            case dvbSubSourceSettings = "dvbSubSourceSettings"
            case ancillarySourceSettings = "ancillarySourceSettings"
            case teletextSourceSettings = "teletextSourceSettings"
            case sourceType = "sourceType"
            case embeddedSourceSettings = "embeddedSourceSettings"
        }
    }

    public enum VideoTimecodeInsertion: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case picTimingSei = "PIC_TIMING_SEI"
        public var description: String { return self.rawValue }
    }

    public enum H265UnregisteredSeiTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum VideoCodec: String, CustomStringConvertible, Codable {
        case frameCapture = "FRAME_CAPTURE"
        case h264 = "H_264"
        case h265 = "H_265"
        case mpeg2 = "MPEG2"
        case prores = "PRORES"
        public var description: String { return self.rawValue }
    }

    public struct Mpeg2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "IntraDcPrecision", location: .body(locationName: "intraDcPrecision"), required: false, type: .enum), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "Syntax", location: .body(locationName: "syntax"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "Softness", location: .body(locationName: "softness"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum)
        ]
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        public let parControl: Mpeg2ParControl?
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        /// Size of buffer (HRD buffer model). Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m.
        public let hrdBufferSize: Int32?
        public let spatialAdaptiveQuantization: Mpeg2SpatialAdaptiveQuantization?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let codecProfile: Mpeg2CodecProfile?
        public let qualityTuningLevel: Mpeg2QualityTuningLevel?
        public let codecLevel: Mpeg2CodecLevel?
        public let adaptiveQuantization: Mpeg2AdaptiveQuantization?
        /// Maximum bitrate in bits/second (for VBR mode only). Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m.
        public let maxBitrate: Int32?
        public let gopSizeUnits: Mpeg2GopSizeUnits?
        public let sceneChangeDetect: Mpeg2SceneChangeDetect?
        public let slowPal: Mpeg2SlowPal?
        public let temporalAdaptiveQuantization: Mpeg2TemporalAdaptiveQuantization?
        public let intraDcPrecision: Mpeg2IntraDcPrecision?
        public let rateControlMode: Mpeg2RateControlMode?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let framerateConversionAlgorithm: Mpeg2FramerateConversionAlgorithm?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        /// Average bitrate in bits/second. Required for VBR, CBR, and ABR. Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let interlaceMode: Mpeg2InterlaceMode?
        public let syntax: Mpeg2Syntax?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image.
        public let softness: Int32?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        public let framerateControl: Mpeg2FramerateControl?
        public let telecine: Mpeg2Telecine?

        public init(numberBFramesBetweenReferenceFrames: Int32? = nil, parControl: Mpeg2ParControl? = nil, framerateNumerator: Int32? = nil, hrdBufferSize: Int32? = nil, spatialAdaptiveQuantization: Mpeg2SpatialAdaptiveQuantization? = nil, parNumerator: Int32? = nil, codecProfile: Mpeg2CodecProfile? = nil, qualityTuningLevel: Mpeg2QualityTuningLevel? = nil, codecLevel: Mpeg2CodecLevel? = nil, adaptiveQuantization: Mpeg2AdaptiveQuantization? = nil, maxBitrate: Int32? = nil, gopSizeUnits: Mpeg2GopSizeUnits? = nil, sceneChangeDetect: Mpeg2SceneChangeDetect? = nil, slowPal: Mpeg2SlowPal? = nil, temporalAdaptiveQuantization: Mpeg2TemporalAdaptiveQuantization? = nil, intraDcPrecision: Mpeg2IntraDcPrecision? = nil, rateControlMode: Mpeg2RateControlMode? = nil, framerateDenominator: Int32? = nil, framerateConversionAlgorithm: Mpeg2FramerateConversionAlgorithm? = nil, parDenominator: Int32? = nil, gopClosedCadence: Int32? = nil, bitrate: Int32? = nil, minIInterval: Int32? = nil, interlaceMode: Mpeg2InterlaceMode? = nil, syntax: Mpeg2Syntax? = nil, hrdBufferInitialFillPercentage: Int32? = nil, softness: Int32? = nil, gopSize: Double? = nil, framerateControl: Mpeg2FramerateControl? = nil, telecine: Mpeg2Telecine? = nil) {
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.parControl = parControl
            self.framerateNumerator = framerateNumerator
            self.hrdBufferSize = hrdBufferSize
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.parNumerator = parNumerator
            self.codecProfile = codecProfile
            self.qualityTuningLevel = qualityTuningLevel
            self.codecLevel = codecLevel
            self.adaptiveQuantization = adaptiveQuantization
            self.maxBitrate = maxBitrate
            self.gopSizeUnits = gopSizeUnits
            self.sceneChangeDetect = sceneChangeDetect
            self.slowPal = slowPal
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.intraDcPrecision = intraDcPrecision
            self.rateControlMode = rateControlMode
            self.framerateDenominator = framerateDenominator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.parDenominator = parDenominator
            self.gopClosedCadence = gopClosedCadence
            self.bitrate = bitrate
            self.minIInterval = minIInterval
            self.interlaceMode = interlaceMode
            self.syntax = syntax
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.softness = softness
            self.gopSize = gopSize
            self.framerateControl = framerateControl
            self.telecine = telecine
        }

        private enum CodingKeys: String, CodingKey {
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case parControl = "parControl"
            case framerateNumerator = "framerateNumerator"
            case hrdBufferSize = "hrdBufferSize"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case parNumerator = "parNumerator"
            case codecProfile = "codecProfile"
            case qualityTuningLevel = "qualityTuningLevel"
            case codecLevel = "codecLevel"
            case adaptiveQuantization = "adaptiveQuantization"
            case maxBitrate = "maxBitrate"
            case gopSizeUnits = "gopSizeUnits"
            case sceneChangeDetect = "sceneChangeDetect"
            case slowPal = "slowPal"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case intraDcPrecision = "intraDcPrecision"
            case rateControlMode = "rateControlMode"
            case framerateDenominator = "framerateDenominator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case parDenominator = "parDenominator"
            case gopClosedCadence = "gopClosedCadence"
            case bitrate = "bitrate"
            case minIInterval = "minIInterval"
            case interlaceMode = "interlaceMode"
            case syntax = "syntax"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case softness = "softness"
            case gopSize = "gopSize"
            case framerateControl = "framerateControl"
            case telecine = "telecine"
        }
    }

    public struct MsSmoothGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "ManifestEncoding", location: .body(locationName: "manifestEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioDeduplication", location: .body(locationName: "audioDeduplication"), required: false, type: .enum)
        ]
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        /// Use Fragment length (FragmentLength) to specify the mp4 fragment sizes in seconds.  Fragment length must be compatible with GOP size and framerate.
        public let fragmentLength: Int32?
        public let encryption: MsSmoothEncryptionSettings?
        public let manifestEncoding: MsSmoothManifestEncoding?
        public let audioDeduplication: MsSmoothAudioDeduplication?

        public init(destination: String? = nil, fragmentLength: Int32? = nil, encryption: MsSmoothEncryptionSettings? = nil, manifestEncoding: MsSmoothManifestEncoding? = nil, audioDeduplication: MsSmoothAudioDeduplication? = nil) {
            self.destination = destination
            self.fragmentLength = fragmentLength
            self.encryption = encryption
            self.manifestEncoding = manifestEncoding
            self.audioDeduplication = audioDeduplication
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case fragmentLength = "fragmentLength"
            case encryption = "encryption"
            case manifestEncoding = "manifestEncoding"
            case audioDeduplication = "audioDeduplication"
        }
    }

    public struct NoiseReducer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterSettings", location: .body(locationName: "filterSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SpatialFilterSettings", location: .body(locationName: "spatialFilterSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Filter", location: .body(locationName: "filter"), required: false, type: .enum)
        ]
        public let filterSettings: NoiseReducerFilterSettings?
        public let spatialFilterSettings: NoiseReducerSpatialFilterSettings?
        public let filter: NoiseReducerFilter?

        public init(filterSettings: NoiseReducerFilterSettings? = nil, spatialFilterSettings: NoiseReducerSpatialFilterSettings? = nil, filter: NoiseReducerFilter? = nil) {
            self.filterSettings = filterSettings
            self.spatialFilterSettings = spatialFilterSettings
            self.filter = filter
        }

        private enum CodingKeys: String, CodingKey {
            case filterSettings = "filterSettings"
            case spatialFilterSettings = "spatialFilterSettings"
            case filter = "filter"
        }
    }

    public enum RespondToAfd: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case respond = "RESPOND"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case system = "SYSTEM"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum SccDestinationFramerate: String, CustomStringConvertible, Codable {
        case framerate2397 = "FRAMERATE_23_97"
        case framerate24 = "FRAMERATE_24"
        case framerate2997Dropframe = "FRAMERATE_29_97_DROPFRAME"
        case framerate2997NonDropframe = "FRAMERATE_29_97_NON_DROPFRAME"
        public var description: String { return self.rawValue }
    }

    public struct TeletextSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageNumber", location: .body(locationName: "pageNumber"), required: false, type: .string)
        ]
        /// Use Page Number (PageNumber) to specify the three-digit hexadecimal page number that will be used for Teletext captions. Do not use this setting if you are passing through teletext from the input source to output.
        public let pageNumber: String?

        public init(pageNumber: String? = nil) {
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "pageNumber"
        }
    }

    public enum H264InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct WavSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BitDepth", location: .body(locationName: "bitDepth"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer)
        ]
        /// Specify Bit depth (BitDepth), in bits per sample, to choose the encoding quality for this audio track.
        public let bitDepth: Int32?
        /// Set Channels to specify the number of channels in this output audio track. With WAV, valid values 1, 2, 4, and 8. In the console, these values are Mono, Stereo, 4-Channel, and 8-Channel, respectively.
        public let channels: Int32?
        /// Sample rate in Hz.
        public let sampleRate: Int32?

        public init(bitDepth: Int32? = nil, channels: Int32? = nil, sampleRate: Int32? = nil) {
            self.bitDepth = bitDepth
            self.channels = channels
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case bitDepth = "bitDepth"
            case channels = "channels"
            case sampleRate = "sampleRate"
        }
    }

    public struct CreatePresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public enum M2tsAudioBufferModel: String, CustomStringConvertible, Codable {
        case dvb = "DVB"
        case atsc = "ATSC"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case low = "LOW"
        case main = "MAIN"
        case high1440 = "HIGH1440"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public struct VideoDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WidthInPx", location: .body(locationName: "widthInPx"), required: false, type: .integer), 
            AWSShapeMember(label: "HeightInPx", location: .body(locationName: "heightInPx"), required: false, type: .integer)
        ]
        /// Width in pixels for the output
        public let widthInPx: Int32?
        /// Height in pixels for the output
        public let heightInPx: Int32?

        public init(widthInPx: Int32? = nil, heightInPx: Int32? = nil) {
            self.widthInPx = widthInPx
            self.heightInPx = heightInPx
        }

        private enum CodingKeys: String, CodingKey {
            case widthInPx = "widthInPx"
            case heightInPx = "heightInPx"
        }
    }

    public struct GetJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        /// the job ID of the job.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CaptionDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BurninDestinationSettings", location: .body(locationName: "burninDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TeletextDestinationSettings", location: .body(locationName: "teletextDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DestinationType", location: .body(locationName: "destinationType"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbSubDestinationSettings", location: .body(locationName: "dvbSubDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SccDestinationSettings", location: .body(locationName: "sccDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TtmlDestinationSettings", location: .body(locationName: "ttmlDestinationSettings"), required: false, type: .structure)
        ]
        public let burninDestinationSettings: BurninDestinationSettings?
        public let teletextDestinationSettings: TeletextDestinationSettings?
        /// Type of Caption output, including Burn-In, Embedded, SCC, SRT, TTML, WebVTT, DVB-Sub, Teletext.
        public let destinationType: CaptionDestinationType?
        public let dvbSubDestinationSettings: DvbSubDestinationSettings?
        public let sccDestinationSettings: SccDestinationSettings?
        /// Settings specific to TTML caption outputs, including Pass style information (TtmlStylePassthrough).
        public let ttmlDestinationSettings: TtmlDestinationSettings?

        public init(burninDestinationSettings: BurninDestinationSettings? = nil, teletextDestinationSettings: TeletextDestinationSettings? = nil, destinationType: CaptionDestinationType? = nil, dvbSubDestinationSettings: DvbSubDestinationSettings? = nil, sccDestinationSettings: SccDestinationSettings? = nil, ttmlDestinationSettings: TtmlDestinationSettings? = nil) {
            self.burninDestinationSettings = burninDestinationSettings
            self.teletextDestinationSettings = teletextDestinationSettings
            self.destinationType = destinationType
            self.dvbSubDestinationSettings = dvbSubDestinationSettings
            self.sccDestinationSettings = sccDestinationSettings
            self.ttmlDestinationSettings = ttmlDestinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case burninDestinationSettings = "burninDestinationSettings"
            case teletextDestinationSettings = "teletextDestinationSettings"
            case destinationType = "destinationType"
            case dvbSubDestinationSettings = "dvbSubDestinationSettings"
            case sccDestinationSettings = "sccDestinationSettings"
            case ttmlDestinationSettings = "ttmlDestinationSettings"
        }
    }

    public enum H264RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public struct VideoDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "TimecodeInsertion", location: .body(locationName: "timecodeInsertion"), required: false, type: .enum), 
            AWSShapeMember(label: "FixedAfd", location: .body(locationName: "fixedAfd"), required: false, type: .integer), 
            AWSShapeMember(label: "ColorMetadata", location: .body(locationName: "colorMetadata"), required: false, type: .enum), 
            AWSShapeMember(label: "VideoPreprocessors", location: .body(locationName: "videoPreprocessors"), required: false, type: .structure), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecSettings", location: .body(locationName: "codecSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DropFrameTimecode", location: .body(locationName: "dropFrameTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "Sharpness", location: .body(locationName: "sharpness"), required: false, type: .integer), 
            AWSShapeMember(label: "Position", location: .body(locationName: "position"), required: false, type: .structure), 
            AWSShapeMember(label: "AfdSignaling", location: .body(locationName: "afdSignaling"), required: false, type: .enum), 
            AWSShapeMember(label: "Crop", location: .body(locationName: "crop"), required: false, type: .structure), 
            AWSShapeMember(label: "AntiAlias", location: .body(locationName: "antiAlias"), required: false, type: .enum), 
            AWSShapeMember(label: "ScalingBehavior", location: .body(locationName: "scalingBehavior"), required: false, type: .enum), 
            AWSShapeMember(label: "RespondToAfd", location: .body(locationName: "respondToAfd"), required: false, type: .enum)
        ]
        /// Use the Height (Height) setting to define the video resolution height for this output. Specify in pixels. If you don't provide a value here, the service will use the input height.
        public let height: Int32?
        public let timecodeInsertion: VideoTimecodeInsertion?
        /// Applies only if you set AFD Signaling(AfdSignaling) to Fixed (FIXED). Use Fixed (FixedAfd) to specify a four-bit AFD value which the service will write on all  frames of this video output.
        public let fixedAfd: Int32?
        public let colorMetadata: ColorMetadata?
        /// Find additional transcoding features under Preprocessors (VideoPreprocessors). Enable the features at each output individually. These features are disabled by default.
        public let videoPreprocessors: VideoPreprocessor?
        /// Use Width (Width) to define the video resolution width, in pixels, for this output. If you don't provide a value here, the service will use the input width.
        public let width: Int32?
        public let codecSettings: VideoCodecSettings?
        public let dropFrameTimecode: DropFrameTimecode?
        /// Use Sharpness (Sharpness)setting to specify the strength of anti-aliasing. This setting changes the width of the anti-alias filter kernel used for scaling. Sharpness only applies if your output resolution is different from your input resolution, and if you set Anti-alias (AntiAlias) to ENABLED. 0 is the softest setting, 100 the sharpest, and 50 recommended for most content.
        public let sharpness: Int32?
        /// Use Position (Position) to point to a rectangle object to define your position. This setting overrides any other aspect ratio.
        public let position: Rectangle?
        public let afdSignaling: AfdSignaling?
        /// Applies only if your input aspect ratio is different from your output aspect ratio. Use Input cropping rectangle (Crop) to specify the  video area the service will include in the output. This will crop the input source, causing video pixels to be removed on encode. Do not use this setting if you have enabled Stretch to output (stretchToOutput) in your output settings.
        public let crop: Rectangle?
        public let antiAlias: AntiAlias?
        public let scalingBehavior: ScalingBehavior?
        public let respondToAfd: RespondToAfd?

        public init(height: Int32? = nil, timecodeInsertion: VideoTimecodeInsertion? = nil, fixedAfd: Int32? = nil, colorMetadata: ColorMetadata? = nil, videoPreprocessors: VideoPreprocessor? = nil, width: Int32? = nil, codecSettings: VideoCodecSettings? = nil, dropFrameTimecode: DropFrameTimecode? = nil, sharpness: Int32? = nil, position: Rectangle? = nil, afdSignaling: AfdSignaling? = nil, crop: Rectangle? = nil, antiAlias: AntiAlias? = nil, scalingBehavior: ScalingBehavior? = nil, respondToAfd: RespondToAfd? = nil) {
            self.height = height
            self.timecodeInsertion = timecodeInsertion
            self.fixedAfd = fixedAfd
            self.colorMetadata = colorMetadata
            self.videoPreprocessors = videoPreprocessors
            self.width = width
            self.codecSettings = codecSettings
            self.dropFrameTimecode = dropFrameTimecode
            self.sharpness = sharpness
            self.position = position
            self.afdSignaling = afdSignaling
            self.crop = crop
            self.antiAlias = antiAlias
            self.scalingBehavior = scalingBehavior
            self.respondToAfd = respondToAfd
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case timecodeInsertion = "timecodeInsertion"
            case fixedAfd = "fixedAfd"
            case colorMetadata = "colorMetadata"
            case videoPreprocessors = "videoPreprocessors"
            case width = "width"
            case codecSettings = "codecSettings"
            case dropFrameTimecode = "dropFrameTimecode"
            case sharpness = "sharpness"
            case position = "position"
            case afdSignaling = "afdSignaling"
            case crop = "crop"
            case antiAlias = "antiAlias"
            case scalingBehavior = "scalingBehavior"
            case respondToAfd = "respondToAfd"
        }
    }

    public struct GetQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum H264FlickerAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case paused = "PAUSED"
        public var description: String { return self.rawValue }
    }

    public struct ListJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Jobs", location: .body(locationName: "jobs"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        /// List of jobs
        public let jobs: [Job]?
        /// Use this string to request the next batch of jobs.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public enum InputTimecodeSource: String, CustomStringConvertible, Codable {
        case embedded = "EMBEDDED"
        case zerobased = "ZEROBASED"
        case specifiedstart = "SPECIFIEDSTART"
        public var description: String { return self.rawValue }
    }

    public struct UpdateQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum HlsOutputSelection: String, CustomStringConvertible, Codable {
        case manifestsAndSegments = "MANIFESTS_AND_SEGMENTS"
        case segmentsOnly = "SEGMENTS_ONLY"
        public var description: String { return self.rawValue }
    }

    public struct F4vSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MoovPlacement", location: .body(locationName: "moovPlacement"), required: false, type: .enum)
        ]
        public let moovPlacement: F4vMoovPlacement?

        public init(moovPlacement: F4vMoovPlacement? = nil) {
            self.moovPlacement = moovPlacement
        }

        private enum CodingKeys: String, CodingKey {
            case moovPlacement = "moovPlacement"
        }
    }

    public struct Output: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerSettings", location: .body(locationName: "containerSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputSettings", location: .body(locationName: "outputSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .string), 
            AWSShapeMember(label: "AudioDescriptions", location: .body(locationName: "audioDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "NameModifier", location: .body(locationName: "nameModifier"), required: false, type: .string), 
            AWSShapeMember(label: "CaptionDescriptions", location: .body(locationName: "captionDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "VideoDescription", location: .body(locationName: "videoDescription"), required: false, type: .structure), 
            AWSShapeMember(label: "Extension", location: .body(locationName: "extension"), required: false, type: .string)
        ]
        public let containerSettings: ContainerSettings?
        public let outputSettings: OutputSettings?
        /// Use Preset (Preset) to specifiy a preset for your transcoding settings. Provide the system or custom preset name. You can specify either Preset (Preset) or Container settings (ContainerSettings), but not both.
        public let preset: String?
        /// (AudioDescriptions) contains groups of audio encoding settings organized by audio codec. Include one instance of (AudioDescriptions) per output. (AudioDescriptions) can contain multiple groups of encoding settings.
        public let audioDescriptions: [AudioDescription]?
        /// Use Name modifier (NameModifier) to have the service add a string to the end of each output filename. You specify the base filename as part of your destination URI. When you create multiple outputs in the same output group, Name modifier is required. Name modifier also accepts format identifiers. For DASH ISO outputs, if you use the format identifiers $Number$ or $Time$ in one output, you must use them in the same way in all outputs of the output group.
        public let nameModifier: String?
        /// (CaptionDescriptions) contains groups of captions settings. For each output that has captions, include one instance of (CaptionDescriptions). (CaptionDescriptions) can contain multiple groups of captions settings.
        public let captionDescriptions: [CaptionDescription]?
        /// (VideoDescription) contains a group of video encoding settings. The specific video settings depend on the video codec you choose when you specify a value for Video codec (codec). Include one instance of (VideoDescription) per output.
        public let videoDescription: VideoDescription?
        /// Use Extension (Extension) to specify the file extension for outputs in File output groups. If you do not specify a value, the service will use default extensions by container type as follows * MPEG-2 transport stream, m2ts * Quicktime, mov * MXF container, mxf * MPEG-4 container, mp4 * No Container, the service will use codec extensions (e.g. AAC, H265, H265, AC3)
        public let `extension`: String?

        public init(containerSettings: ContainerSettings? = nil, outputSettings: OutputSettings? = nil, preset: String? = nil, audioDescriptions: [AudioDescription]? = nil, nameModifier: String? = nil, captionDescriptions: [CaptionDescription]? = nil, videoDescription: VideoDescription? = nil, extension: String? = nil) {
            self.containerSettings = containerSettings
            self.outputSettings = outputSettings
            self.preset = preset
            self.audioDescriptions = audioDescriptions
            self.nameModifier = nameModifier
            self.captionDescriptions = captionDescriptions
            self.videoDescription = videoDescription
            self.`extension` = `extension`
        }

        private enum CodingKeys: String, CodingKey {
            case containerSettings = "containerSettings"
            case outputSettings = "outputSettings"
            case preset = "preset"
            case audioDescriptions = "audioDescriptions"
            case nameModifier = "nameModifier"
            case captionDescriptions = "captionDescriptions"
            case videoDescription = "videoDescription"
            case `extension` = "extension"
        }
    }

    public enum Eac3CodingMode: String, CustomStringConvertible, Codable {
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode32 = "CODING_MODE_3_2"
        public var description: String { return self.rawValue }
    }

    public enum Eac3MetadataControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleTeletextSpacing: String, CustomStringConvertible, Codable {
        case fixedGrid = "FIXED_GRID"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public struct HlsCaptionLanguageMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "CaptionChannel", location: .body(locationName: "captionChannel"), required: false, type: .integer)
        ]
        public let languageCode: LanguageCode?
        /// Caption language description.
        public let languageDescription: String?
        /// Caption channel.
        public let captionChannel: Int32?

        public init(languageCode: LanguageCode? = nil, languageDescription: String? = nil, captionChannel: Int32? = nil) {
            self.languageCode = languageCode
            self.languageDescription = languageDescription
            self.captionChannel = captionChannel
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "languageCode"
            case languageDescription = "languageDescription"
            case captionChannel = "captionChannel"
        }
    }

    public enum Mpeg2ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct AiffSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BitDepth", location: .body(locationName: "bitDepth"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer)
        ]
        /// Specify Bit depth (BitDepth), in bits per sample, to choose the encoding quality for this audio track.
        public let bitDepth: Int32?
        /// Set Channels to specify the number of channels in this output audio track. Choosing Mono in the console will give you 1 output channel; choosing Stereo will give you 2. In the API, valid values are 1 and 2.
        public let channels: Int32?
        /// Sample rate in hz.
        public let sampleRate: Int32?

        public init(bitDepth: Int32? = nil, channels: Int32? = nil, sampleRate: Int32? = nil) {
            self.bitDepth = bitDepth
            self.channels = channels
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case bitDepth = "bitDepth"
            case channels = "channels"
            case sampleRate = "sampleRate"
        }
    }

    public struct TimedMetadataInsertion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id3Insertions", location: .body(locationName: "id3Insertions"), required: false, type: .list)
        ]
        /// Id3Insertions contains the array of Id3Insertion instances.
        public let id3Insertions: [Id3Insertion]?

        public init(id3Insertions: [Id3Insertion]? = nil) {
            self.id3Insertions = id3Insertions
        }

        private enum CodingKeys: String, CodingKey {
            case id3Insertions = "id3Insertions"
        }
    }

    public struct HlsSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SegmentModifier", location: .body(locationName: "segmentModifier"), required: false, type: .string), 
            AWSShapeMember(label: "AudioGroupId", location: .body(locationName: "audioGroupId"), required: false, type: .string), 
            AWSShapeMember(label: "AudioTrackType", location: .body(locationName: "audioTrackType"), required: false, type: .enum), 
            AWSShapeMember(label: "IFrameOnlyManifest", location: .body(locationName: "iFrameOnlyManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioRenditionSets", location: .body(locationName: "audioRenditionSets"), required: false, type: .string)
        ]
        /// String concatenated to end of segment filenames. Accepts "Format Identifiers":#format_identifier_parameters.
        public let segmentModifier: String?
        /// Specifies the group to which the audio Rendition belongs.
        public let audioGroupId: String?
        public let audioTrackType: HlsAudioTrackType?
        public let iFrameOnlyManifest: HlsIFrameOnlyManifest?
        /// List all the audio groups that are used with the video output stream. Input all the audio GROUP-IDs that are associated to the video, separate by ','.
        public let audioRenditionSets: String?

        public init(segmentModifier: String? = nil, audioGroupId: String? = nil, audioTrackType: HlsAudioTrackType? = nil, iFrameOnlyManifest: HlsIFrameOnlyManifest? = nil, audioRenditionSets: String? = nil) {
            self.segmentModifier = segmentModifier
            self.audioGroupId = audioGroupId
            self.audioTrackType = audioTrackType
            self.iFrameOnlyManifest = iFrameOnlyManifest
            self.audioRenditionSets = audioRenditionSets
        }

        private enum CodingKeys: String, CodingKey {
            case segmentModifier = "segmentModifier"
            case audioGroupId = "audioGroupId"
            case audioTrackType = "audioTrackType"
            case iFrameOnlyManifest = "iFrameOnlyManifest"
            case audioRenditionSets = "audioRenditionSets"
        }
    }

    public enum Mpeg2QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case multiPass = "MULTI_PASS"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2Syntax: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case d10 = "D_10"
        public var description: String { return self.rawValue }
    }

    public struct AudioSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SelectorType", location: .body(locationName: "selectorType"), required: false, type: .enum), 
            AWSShapeMember(label: "Tracks", location: .body(locationName: "tracks"), required: false, type: .list), 
            AWSShapeMember(label: "ExternalAudioFileInput", location: .body(locationName: "externalAudioFileInput"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgramSelection", location: .body(locationName: "programSelection"), required: false, type: .integer), 
            AWSShapeMember(label: "Offset", location: .body(locationName: "offset"), required: false, type: .integer), 
            AWSShapeMember(label: "Pids", location: .body(locationName: "pids"), required: false, type: .list), 
            AWSShapeMember(label: "RemixSettings", location: .body(locationName: "remixSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DefaultSelection", location: .body(locationName: "defaultSelection"), required: false, type: .enum)
        ]
        public let selectorType: AudioSelectorType?
        /// Identify the channel to include in this selector by entering the 1-based track index.  To combine several tracks, enter a comma-separated list, e.g. "1,2,3" for tracks 1-3.
        public let tracks: [Int32]?
        /// Specifies audio data from an external file source. Auto populated when Infer External Filename is checked
        public let externalAudioFileInput: String?
        /// Selects a specific language code from within an audio source.
        public let languageCode: LanguageCode?
        /// Applies only when input streams contain Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. "All channels" means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect.
        public let programSelection: Int32?
        /// Specifies a time delta in milliseconds to offset the audio from the input video.
        public let offset: Int32?
        /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
        public let pids: [Int32]?
        /// Advanced audio remixing settings.
        public let remixSettings: RemixSettings?
        public let defaultSelection: AudioDefaultSelection?

        public init(selectorType: AudioSelectorType? = nil, tracks: [Int32]? = nil, externalAudioFileInput: String? = nil, languageCode: LanguageCode? = nil, programSelection: Int32? = nil, offset: Int32? = nil, pids: [Int32]? = nil, remixSettings: RemixSettings? = nil, defaultSelection: AudioDefaultSelection? = nil) {
            self.selectorType = selectorType
            self.tracks = tracks
            self.externalAudioFileInput = externalAudioFileInput
            self.languageCode = languageCode
            self.programSelection = programSelection
            self.offset = offset
            self.pids = pids
            self.remixSettings = remixSettings
            self.defaultSelection = defaultSelection
        }

        private enum CodingKeys: String, CodingKey {
            case selectorType = "selectorType"
            case tracks = "tracks"
            case externalAudioFileInput = "externalAudioFileInput"
            case languageCode = "languageCode"
            case programSelection = "programSelection"
            case offset = "offset"
            case pids = "pids"
            case remixSettings = "remixSettings"
            case defaultSelection = "defaultSelection"
        }
    }

    public struct DvbNitSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NitInterval", location: .body(locationName: "nitInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "NetworkId", location: .body(locationName: "networkId"), required: false, type: .integer), 
            AWSShapeMember(label: "NetworkName", location: .body(locationName: "networkName"), required: false, type: .string)
        ]
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let nitInterval: Int32?
        /// The numeric value placed in the Network Information Table (NIT).
        public let networkId: Int32?
        /// The network name text placed in the network_name_descriptor inside the Network Information Table. Maximum length is 256 characters.
        public let networkName: String?

        public init(nitInterval: Int32? = nil, networkId: Int32? = nil, networkName: String? = nil) {
            self.nitInterval = nitInterval
            self.networkId = networkId
            self.networkName = networkName
        }

        private enum CodingKeys: String, CodingKey {
            case nitInterval = "nitInterval"
            case networkId = "networkId"
            case networkName = "networkName"
        }
    }

    public enum HlsDirectoryStructure: String, CustomStringConvertible, Codable {
        case singleDirectory = "SINGLE_DIRECTORY"
        case subdirectoryPerStream = "SUBDIRECTORY_PER_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum M2tsRateMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum H264EntropyEncoding: String, CustomStringConvertible, Codable {
        case cabac = "CABAC"
        case cavlc = "CAVLC"
        public var description: String { return self.rawValue }
    }

    public enum Eac3DynamicRangeCompressionRf: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case filmStandard = "FILM_STANDARD"
        case filmLight = "FILM_LIGHT"
        case musicStandard = "MUSIC_STANDARD"
        case musicLight = "MUSIC_LIGHT"
        case speech = "SPEECH"
        public var description: String { return self.rawValue }
    }

    public enum H264FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct AacSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioDescriptionBroadcasterMix", location: .body(locationName: "audioDescriptionBroadcasterMix"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "VbrQuality", location: .body(locationName: "vbrQuality"), required: false, type: .enum), 
            AWSShapeMember(label: "Specification", location: .body(locationName: "specification"), required: false, type: .enum), 
            AWSShapeMember(label: "RawFormat", location: .body(locationName: "rawFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum)
        ]
        public let codingMode: AacCodingMode?
        public let codecProfile: AacCodecProfile?
        /// Sample rate in Hz. Valid values depend on rate control mode and profile.
        public let sampleRate: Int32?
        public let audioDescriptionBroadcasterMix: AacAudioDescriptionBroadcasterMix?
        /// Average bitrate in bits/second. Valid values depend on rate control mode and profile.
        public let bitrate: Int32?
        public let vbrQuality: AacVbrQuality?
        public let specification: AacSpecification?
        public let rawFormat: AacRawFormat?
        public let rateControlMode: AacRateControlMode?

        public init(codingMode: AacCodingMode? = nil, codecProfile: AacCodecProfile? = nil, sampleRate: Int32? = nil, audioDescriptionBroadcasterMix: AacAudioDescriptionBroadcasterMix? = nil, bitrate: Int32? = nil, vbrQuality: AacVbrQuality? = nil, specification: AacSpecification? = nil, rawFormat: AacRawFormat? = nil, rateControlMode: AacRateControlMode? = nil) {
            self.codingMode = codingMode
            self.codecProfile = codecProfile
            self.sampleRate = sampleRate
            self.audioDescriptionBroadcasterMix = audioDescriptionBroadcasterMix
            self.bitrate = bitrate
            self.vbrQuality = vbrQuality
            self.specification = specification
            self.rawFormat = rawFormat
            self.rateControlMode = rateControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case codingMode = "codingMode"
            case codecProfile = "codecProfile"
            case sampleRate = "sampleRate"
            case audioDescriptionBroadcasterMix = "audioDescriptionBroadcasterMix"
            case bitrate = "bitrate"
            case vbrQuality = "vbrQuality"
            case specification = "specification"
            case rawFormat = "rawFormat"
            case rateControlMode = "rateControlMode"
        }
    }

    public struct Deinterlacer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Algorithm", location: .body(locationName: "algorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "Control", location: .body(locationName: "control"), required: false, type: .enum), 
            AWSShapeMember(label: "Mode", location: .body(locationName: "mode"), required: false, type: .enum)
        ]
        public let algorithm: DeinterlaceAlgorithm?
        public let control: DeinterlacerControl?
        public let mode: DeinterlacerMode?

        public init(algorithm: DeinterlaceAlgorithm? = nil, control: DeinterlacerControl? = nil, mode: DeinterlacerMode? = nil) {
            self.algorithm = algorithm
            self.control = control
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
            case control = "control"
            case mode = "mode"
        }
    }

    public struct CancelJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        /// The Job ID of the job to be cancelled.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public enum H265CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case level1 = "LEVEL_1"
        case level2 = "LEVEL_2"
        case level21 = "LEVEL_2_1"
        case level3 = "LEVEL_3"
        case level31 = "LEVEL_3_1"
        case level4 = "LEVEL_4"
        case level41 = "LEVEL_4_1"
        case level5 = "LEVEL_5"
        case level51 = "LEVEL_5_1"
        case level52 = "LEVEL_5_2"
        case level6 = "LEVEL_6"
        case level61 = "LEVEL_6_1"
        case level62 = "LEVEL_6_2"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Endpoints", location: .body(locationName: "endpoints"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of endpoints.
        public let nextToken: String?
        /// List of endpoints
        public let endpoints: [Endpoint]?

        public init(nextToken: String? = nil, endpoints: [Endpoint]? = nil) {
            self.nextToken = nextToken
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case endpoints = "endpoints"
        }
    }

    public enum PresetListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum HlsManifestDurationFormat: String, CustomStringConvertible, Codable {
        case floatingPoint = "FLOATING_POINT"
        case integer = "INTEGER"
        public var description: String { return self.rawValue }
    }

    public enum Mp4CslgAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct MsSmoothEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public enum H265FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public struct TimecodeBurnin: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Position", location: .body(locationName: "position"), required: false, type: .enum), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Prefix", location: .body(locationName: "prefix"), required: false, type: .string)
        ]
        public let position: TimecodeBurninPosition?
        /// Use Font Size (FontSize) to set the font size of any burned-in timecode. Valid values are 10, 16, 32, 48.
        public let fontSize: Int32?
        /// Use Prefix (Prefix) to place ASCII characters before any burned-in timecode. For example, a prefix of "EZ-" will result in the timecode "EZ-00:00:00:00". Provide either the characters themselves or the ASCII code equivalents. The supported range of characters is 0x20 through 0x7e. This includes letters, numbers, and all special characters represented on a standard English keyboard.
        public let prefix: String?

        public init(position: TimecodeBurninPosition? = nil, fontSize: Int32? = nil, prefix: String? = nil) {
            self.position = position
            self.fontSize = fontSize
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case position = "position"
            case fontSize = "fontSize"
            case prefix = "prefix"
        }
    }

    public struct JobTemplateSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TimedMetadataInsertion", location: .body(locationName: "timedMetadataInsertion"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputGroups", location: .body(locationName: "outputGroups"), required: false, type: .list), 
            AWSShapeMember(label: "NielsenConfiguration", location: .body(locationName: "nielsenConfiguration"), required: false, type: .structure), 
            AWSShapeMember(label: "Inputs", location: .body(locationName: "inputs"), required: false, type: .list), 
            AWSShapeMember(label: "AdAvailOffset", location: .body(locationName: "adAvailOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "AvailBlanking", location: .body(locationName: "availBlanking"), required: false, type: .structure), 
            AWSShapeMember(label: "TimecodeConfig", location: .body(locationName: "timecodeConfig"), required: false, type: .structure)
        ]
        public let timedMetadataInsertion: TimedMetadataInsertion?
        /// **!!**(OutputGroups) contains one group of settings for each set of outputs that share a common package type. All unpackaged files (MPEG-4, MPEG-2 TS, Quicktime, MXF, and no container) are grouped in a single output group as well. Required in (OutputGroups) is a group of settings that apply to the whole group. This required object depends on the value you set for (Type) under (OutputGroups)>(OutputGroupSettings). Type, settings object pairs are as follows. * FILE_GROUP_SETTINGS, FileGroupSettings * HLS_GROUP_SETTINGS, HlsGroupSettings * DASH_ISO_GROUP_SETTINGS, DashIsoGroupSettings * MS_SMOOTH_GROUP_SETTINGS, MsSmoothGroupSettings
        public let outputGroups: [OutputGroup]?
        public let nielsenConfiguration: NielsenConfiguration?
        /// Use Inputs (inputs) to define the source file used in the transcode job. There can only be one input in a job template.  Using the API, you can include multiple inputs when referencing a job template.
        public let inputs: [InputTemplate]?
        /// When specified, this offset (in milliseconds) is added to the input Ad Avail PTS time.
        public let adAvailOffset: Int32?
        /// Settings for ad avail blanking.  Video can be blanked or overlaid with an image, and audio muted during SCTE-35 triggered ad avails.
        public let availBlanking: AvailBlanking?
        /// Contains settings used to acquire and adjust timecode information from inputs.
        public let timecodeConfig: TimecodeConfig?

        public init(timedMetadataInsertion: TimedMetadataInsertion? = nil, outputGroups: [OutputGroup]? = nil, nielsenConfiguration: NielsenConfiguration? = nil, inputs: [InputTemplate]? = nil, adAvailOffset: Int32? = nil, availBlanking: AvailBlanking? = nil, timecodeConfig: TimecodeConfig? = nil) {
            self.timedMetadataInsertion = timedMetadataInsertion
            self.outputGroups = outputGroups
            self.nielsenConfiguration = nielsenConfiguration
            self.inputs = inputs
            self.adAvailOffset = adAvailOffset
            self.availBlanking = availBlanking
            self.timecodeConfig = timecodeConfig
        }

        private enum CodingKeys: String, CodingKey {
            case timedMetadataInsertion = "timedMetadataInsertion"
            case outputGroups = "outputGroups"
            case nielsenConfiguration = "nielsenConfiguration"
            case inputs = "inputs"
            case adAvailOffset = "adAvailOffset"
            case availBlanking = "availBlanking"
            case timecodeConfig = "timecodeConfig"
        }
    }

    public enum H265Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum H264CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case level1 = "LEVEL_1"
        case level11 = "LEVEL_1_1"
        case level12 = "LEVEL_1_2"
        case level13 = "LEVEL_1_3"
        case level2 = "LEVEL_2"
        case level21 = "LEVEL_2_1"
        case level22 = "LEVEL_2_2"
        case level3 = "LEVEL_3"
        case level31 = "LEVEL_3_1"
        case level32 = "LEVEL_3_2"
        case level4 = "LEVEL_4"
        case level41 = "LEVEL_4_1"
        case level42 = "LEVEL_4_2"
        case level5 = "LEVEL_5"
        case level51 = "LEVEL_5_1"
        case level52 = "LEVEL_5_2"
        public var description: String { return self.rawValue }
    }

    public struct ContainerSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "M2tsSettings", location: .body(locationName: "m2tsSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "MovSettings", location: .body(locationName: "movSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Mp4Settings", location: .body(locationName: "mp4Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "F4vSettings", location: .body(locationName: "f4vSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Container", location: .body(locationName: "container"), required: false, type: .enum), 
            AWSShapeMember(label: "M3u8Settings", location: .body(locationName: "m3u8Settings"), required: false, type: .structure)
        ]
        public let m2tsSettings: M2tsSettings?
        public let movSettings: MovSettings?
        public let mp4Settings: Mp4Settings?
        public let f4vSettings: F4vSettings?
        public let container: ContainerType?
        public let m3u8Settings: M3u8Settings?

        public init(m2tsSettings: M2tsSettings? = nil, movSettings: MovSettings? = nil, mp4Settings: Mp4Settings? = nil, f4vSettings: F4vSettings? = nil, container: ContainerType? = nil, m3u8Settings: M3u8Settings? = nil) {
            self.m2tsSettings = m2tsSettings
            self.movSettings = movSettings
            self.mp4Settings = mp4Settings
            self.f4vSettings = f4vSettings
            self.container = container
            self.m3u8Settings = m3u8Settings
        }

        private enum CodingKeys: String, CodingKey {
            case m2tsSettings = "m2tsSettings"
            case movSettings = "movSettings"
            case mp4Settings = "mp4Settings"
            case f4vSettings = "f4vSettings"
            case container = "container"
            case m3u8Settings = "m3u8Settings"
        }
    }

    public enum Mpeg2GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public enum ProresTelecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public struct SpekeKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "SystemIds", location: .body(locationName: "systemIds"), required: false, type: .list)
        ]
        /// The SPEKE-compliant server uses Resource ID (ResourceId) to identify content.
        public let resourceId: String?
        /// Use URL (Url) to specify the SPEKE-compliant server that will provide keys for content.
        public let url: String?
        /// Relates to SPEKE implementation. DRM system identifiers. DASH output groups support a max of two system ids. Other group types support one system id.
        public let systemIds: [String]?

        public init(resourceId: String? = nil, url: String? = nil, systemIds: [String]? = nil) {
            self.resourceId = resourceId
            self.url = url
            self.systemIds = systemIds
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "resourceId"
            case url = "url"
            case systemIds = "systemIds"
        }
    }

    public struct PresetSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainerSettings", location: .body(locationName: "containerSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CaptionDescriptions", location: .body(locationName: "captionDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "VideoDescription", location: .body(locationName: "videoDescription"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioDescriptions", location: .body(locationName: "audioDescriptions"), required: false, type: .list)
        ]
        public let containerSettings: ContainerSettings?
        /// Caption settings for this preset. There can be multiple caption settings in a single output.
        public let captionDescriptions: [CaptionDescriptionPreset]?
        /// (VideoDescription) contains a group of video encoding settings. The specific video settings depend on the video codec you choose when you specify a value for Video codec (codec). Include one instance of (VideoDescription) per output.
        public let videoDescription: VideoDescription?
        /// (AudioDescriptions) contains groups of audio encoding settings organized by audio codec. Include one instance of (AudioDescriptions) per output. (AudioDescriptions) can contain multiple groups of encoding settings.
        public let audioDescriptions: [AudioDescription]?

        public init(containerSettings: ContainerSettings? = nil, captionDescriptions: [CaptionDescriptionPreset]? = nil, videoDescription: VideoDescription? = nil, audioDescriptions: [AudioDescription]? = nil) {
            self.containerSettings = containerSettings
            self.captionDescriptions = captionDescriptions
            self.videoDescription = videoDescription
            self.audioDescriptions = audioDescriptions
        }

        private enum CodingKeys: String, CodingKey {
            case containerSettings = "containerSettings"
            case captionDescriptions = "captionDescriptions"
            case videoDescription = "videoDescription"
            case audioDescriptions = "audioDescriptions"
        }
    }

    public enum Eac3DcFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct VideoPreprocessor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Deinterlacer", location: .body(locationName: "deinterlacer"), required: false, type: .structure), 
            AWSShapeMember(label: "NoiseReducer", location: .body(locationName: "noiseReducer"), required: false, type: .structure), 
            AWSShapeMember(label: "ImageInserter", location: .body(locationName: "imageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "TimecodeBurnin", location: .body(locationName: "timecodeBurnin"), required: false, type: .structure), 
            AWSShapeMember(label: "ColorCorrector", location: .body(locationName: "colorCorrector"), required: false, type: .structure)
        ]
        /// Use Deinterlacer (Deinterlacer) to produce smoother motion and a clearer picture.
        public let deinterlacer: Deinterlacer?
        /// Enable the Noise reducer (NoiseReducer) feature to remove noise from your video output if necessary. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let noiseReducer: NoiseReducer?
        /// Enable the Image inserter (ImageInserter) feature to include a graphic overlay on your video. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let imageInserter: ImageInserter?
        /// Timecode burn-in (TimecodeBurnIn)--Burns the output timecode and specified prefix into the output.
        public let timecodeBurnin: TimecodeBurnin?
        /// Enable the Color corrector (ColorCorrector) feature if necessary. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let colorCorrector: ColorCorrector?

        public init(deinterlacer: Deinterlacer? = nil, noiseReducer: NoiseReducer? = nil, imageInserter: ImageInserter? = nil, timecodeBurnin: TimecodeBurnin? = nil, colorCorrector: ColorCorrector? = nil) {
            self.deinterlacer = deinterlacer
            self.noiseReducer = noiseReducer
            self.imageInserter = imageInserter
            self.timecodeBurnin = timecodeBurnin
            self.colorCorrector = colorCorrector
        }

        private enum CodingKeys: String, CodingKey {
            case deinterlacer = "deinterlacer"
            case noiseReducer = "noiseReducer"
            case imageInserter = "imageInserter"
            case timecodeBurnin = "timecodeBurnin"
            case colorCorrector = "colorCorrector"
        }
    }

    public enum DropFrameTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HlsKeyProviderType: String, CustomStringConvertible, Codable {
        case speke = "SPEKE"
        case staticKey = "STATIC_KEY"
        public var description: String { return self.rawValue }
    }

    public enum H265SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct Preset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The timestamp in epoch seconds for preset creation.
        public let createdAt: TimeStamp?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// A name you create for each preset. Each name must be unique within your account.
        public let name: String?
        /// An optional category you create to organize your presets.
        public let category: String?
        /// The timestamp in epoch seconds when the preset was last updated.
        public let lastUpdated: TimeStamp?
        public let settings: PresetSettings?
        /// A preset can be of two types: system or custom. System or built-in preset can’t be modified or deleted by the user.
        public let `type`: `Type`?
        /// An optional description you create for each preset.
        public let description: String?

        public init(createdAt: TimeStamp? = nil, arn: String? = nil, name: String? = nil, category: String? = nil, lastUpdated: TimeStamp? = nil, settings: PresetSettings? = nil, type: `Type`? = nil, description: String? = nil) {
            self.createdAt = createdAt
            self.arn = arn
            self.name = name
            self.category = category
            self.lastUpdated = lastUpdated
            self.settings = settings
            self.`type` = `type`
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case arn = "arn"
            case name = "name"
            case category = "category"
            case lastUpdated = "lastUpdated"
            case settings = "settings"
            case `type` = "type"
            case description = "description"
        }
    }

    public struct UpdateJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The new category for the job template, if you are changing it.
        public let category: String?
        public let settings: JobTemplateSettings?
        /// The name of the job template you are modifying
        public let name: String
        /// The new queue for the job template, if you are changing it.
        public let queue: String?
        /// The new description for the job template, if you are changing it.
        public let description: String?

        public init(category: String? = nil, settings: JobTemplateSettings? = nil, name: String, queue: String? = nil, description: String? = nil) {
            self.category = category
            self.settings = settings
            self.name = name
            self.queue = queue
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case settings = "settings"
            case name = "name"
            case queue = "queue"
            case description = "description"
        }
    }

    public enum H264Syntax: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case rp2027 = "RP2027"
        public var description: String { return self.rawValue }
    }

    public enum HlsCaptionLanguageSetting: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case omit = "OMIT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDescriptionPreset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "DestinationSettings", location: .body(locationName: "destinationSettings"), required: false, type: .structure)
        ]
        /// Indicates the language of the caption output track.
        public let languageCode: LanguageCode?
        /// Human readable information to indicate captions available for players (eg. English, or Spanish). Alphanumeric characters, spaces, and underscore are legal.
        public let languageDescription: String?
        public let destinationSettings: CaptionDestinationSettings?

        public init(languageCode: LanguageCode? = nil, languageDescription: String? = nil, destinationSettings: CaptionDestinationSettings? = nil) {
            self.languageCode = languageCode
            self.languageDescription = languageDescription
            self.destinationSettings = destinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "languageCode"
            case languageDescription = "languageDescription"
            case destinationSettings = "destinationSettings"
        }
    }

    public struct OutputChannelMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputChannels", location: .body(locationName: "inputChannels"), required: false, type: .list)
        ]
        /// List of input channels
        public let inputChannels: [Int32]?

        public init(inputChannels: [Int32]? = nil) {
            self.inputChannels = inputChannels
        }

        private enum CodingKeys: String, CodingKey {
            case inputChannels = "inputChannels"
        }
    }

    public struct ChannelMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputChannels", location: .body(locationName: "outputChannels"), required: false, type: .list)
        ]
        /// List of output channels
        public let outputChannels: [OutputChannelMapping]?

        public init(outputChannels: [OutputChannelMapping]? = nil) {
            self.outputChannels = outputChannels
        }

        private enum CodingKeys: String, CodingKey {
            case outputChannels = "outputChannels"
        }
    }

    public struct AvailBlanking: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailBlankingImage", location: .body(locationName: "availBlankingImage"), required: false, type: .string)
        ]
        /// Blanking image to be used. Leave empty for solid black. Only bmp and png images are supported.
        public let availBlankingImage: String?

        public init(availBlankingImage: String? = nil) {
            self.availBlankingImage = availBlankingImage
        }

        private enum CodingKeys: String, CodingKey {
            case availBlankingImage = "availBlankingImage"
        }
    }

    public struct TimecodeConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Source", location: .body(locationName: "source"), required: false, type: .enum), 
            AWSShapeMember(label: "Start", location: .body(locationName: "start"), required: false, type: .string), 
            AWSShapeMember(label: "Anchor", location: .body(locationName: "anchor"), required: false, type: .string), 
            AWSShapeMember(label: "TimestampOffset", location: .body(locationName: "timestampOffset"), required: false, type: .string)
        ]
        public let source: TimecodeSource?
        /// Only use when you set Timecode Source (TimecodeSource) to Specified Start (SPECIFIEDSTART). Use Start timecode (Start) to specify the timecode for the initial frame. Use 24-hour format with frame number, (HH:MM:SS:FF) or (HH:MM:SS;FF).
        public let start: String?
        /// If you use an editing platform that relies on an anchor timecode, use Anchor Timecode (Anchor) to specify a timecode that will match the input video frame to the output video frame. Use 24-hour format with frame number, (HH:MM:SS:FF) or (HH:MM:SS;FF). This setting ignores framerate conversion. System behavior for Anchor Timecode varies depending on your setting for Timecode source (TimecodeSource). * If Timecode source (TimecodeSource) is set to Specified Start (specifiedstart), the first input frame is the specified value in Start Timecode (Start). Anchor Timecode (Anchor) and Start Timecode (Start) are used calculate output timecode. * If Timecode source (TimecodeSource) is set to Start at 0 (zerobased)  the  first frame is 00:00:00:00. * If Timecode source (TimecodeSource) is set to Embedded (embedded), the  first frame is the timecode value on the first input frame of the input.
        public let anchor: String?
        /// Only applies to outputs that support program-date-time stamp. Use Time  stamp offset (TimestampOffset) to overwrite the timecode date without affecting the time and frame number. Provide the new date as a string in the format "yyyy-mm-dd".  To use Time stamp offset, you must also enable Insert program-date-time (InsertProgramDateTime) in the output settings.
        public let timestampOffset: String?

        public init(source: TimecodeSource? = nil, start: String? = nil, anchor: String? = nil, timestampOffset: String? = nil) {
            self.source = source
            self.start = start
            self.anchor = anchor
            self.timestampOffset = timestampOffset
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case start = "start"
            case anchor = "anchor"
            case timestampOffset = "timestampOffset"
        }
    }

    public enum BurninSubtitleFontColor: String, CustomStringConvertible, Codable {
        case white = "WHITE"
        case black = "BLACK"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public struct ColorCorrector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Brightness", location: .body(locationName: "brightness"), required: false, type: .integer), 
            AWSShapeMember(label: "Hue", location: .body(locationName: "hue"), required: false, type: .integer), 
            AWSShapeMember(label: "Saturation", location: .body(locationName: "saturation"), required: false, type: .integer), 
            AWSShapeMember(label: "Hdr10Metadata", location: .body(locationName: "hdr10Metadata"), required: false, type: .structure), 
            AWSShapeMember(label: "ColorSpaceConversion", location: .body(locationName: "colorSpaceConversion"), required: false, type: .enum), 
            AWSShapeMember(label: "Contrast", location: .body(locationName: "contrast"), required: false, type: .integer)
        ]
        /// Brightness level.
        public let brightness: Int32?
        /// Hue in degrees.
        public let hue: Int32?
        /// Saturation level.
        public let saturation: Int32?
        public let hdr10Metadata: Hdr10Metadata?
        public let colorSpaceConversion: ColorSpaceConversion?
        /// Contrast level.
        public let contrast: Int32?

        public init(brightness: Int32? = nil, hue: Int32? = nil, saturation: Int32? = nil, hdr10Metadata: Hdr10Metadata? = nil, colorSpaceConversion: ColorSpaceConversion? = nil, contrast: Int32? = nil) {
            self.brightness = brightness
            self.hue = hue
            self.saturation = saturation
            self.hdr10Metadata = hdr10Metadata
            self.colorSpaceConversion = colorSpaceConversion
            self.contrast = contrast
        }

        private enum CodingKeys: String, CodingKey {
            case brightness = "brightness"
            case hue = "hue"
            case saturation = "saturation"
            case hdr10Metadata = "hdr10Metadata"
            case colorSpaceConversion = "colorSpaceConversion"
            case contrast = "contrast"
        }
    }

    public struct DashIsoEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider?

        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct DeletePresetResponse: AWSShape {

    }

    public enum AudioDefaultSelection: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case notDefault = "NOT_DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ProresSlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Eac3BitstreamMode: String, CustomStringConvertible, Codable {
        case completeMain = "COMPLETE_MAIN"
        case commentary = "COMMENTARY"
        case emergency = "EMERGENCY"
        case hearingImpaired = "HEARING_IMPAIRED"
        case visuallyImpaired = "VISUALLY_IMPAIRED"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationPeakCalculation: String, CustomStringConvertible, Codable {
        case truePeak = "TRUE_PEAK"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct CreatePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Optional. A category for the preset you are creating.
        public let category: String?
        public let settings: PresetSettings?
        /// The name of the preset you are creating.
        public let name: String?
        /// Optional. A description of the preset you are creating.
        public let description: String?

        public init(category: String? = nil, settings: PresetSettings? = nil, name: String? = nil, description: String? = nil) {
            self.category = category
            self.settings = settings
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case settings = "settings"
            case name = "name"
            case description = "description"
        }
    }

    public enum CaptionDestinationType: String, CustomStringConvertible, Codable {
        case burnIn = "BURN_IN"
        case dvbSub = "DVB_SUB"
        case embedded = "EMBEDDED"
        case scc = "SCC"
        case srt = "SRT"
        case teletext = "TELETEXT"
        case ttml = "TTML"
        case webvtt = "WEBVTT"
        public var description: String { return self.rawValue }
    }

    public enum H265GopBReference: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct UpdatePresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public struct InputClipping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTimecode", location: .body(locationName: "startTimecode"), required: false, type: .string), 
            AWSShapeMember(label: "EndTimecode", location: .body(locationName: "endTimecode"), required: false, type: .string)
        ]
        /// Set Start timecode (StartTimecode) to the beginning of the portion of the input you are clipping. The frame corresponding to the Start timecode value is included in the clip. Start timecode or End timecode may be left blank, but not both. When choosing this value, take into account your setting for Input timecode source. For example, if you have embedded timecodes that start at 01:00:00:00 and you want your clip to begin five minutes into the video, use 01:00:05:00.
        public let startTimecode: String?
        /// Set End timecode (EndTimecode) to the end of the portion of the input you are clipping. The frame corresponding to the End timecode value is included in the clip. Start timecode or End timecode may be left blank, but not both. When choosing this value, take into account your setting for Input timecode source. For example, if you have embedded timecodes that start at 01:00:00:00 and you want your clip to begin five minutes into the video, use 01:00:05:00.
        public let endTimecode: String?

        public init(startTimecode: String? = nil, endTimecode: String? = nil) {
            self.startTimecode = startTimecode
            self.endTimecode = endTimecode
        }

        private enum CodingKeys: String, CodingKey {
            case startTimecode = "startTimecode"
            case endTimecode = "endTimecode"
        }
    }

    public enum M2tsBufferModel: String, CustomStringConvertible, Codable {
        case multiplex = "MULTIPLEX"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AfdSignaling: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case auto = "AUTO"
        case fixed = "FIXED"
        public var description: String { return self.rawValue }
    }

    public struct M3u8Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TimedMetadataPid", location: .body(locationName: "timedMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrControl", location: .body(locationName: "pcrControl"), required: false, type: .enum), 
            AWSShapeMember(label: "PatInterval", location: .body(locationName: "patInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "TimedMetadata", location: .body(locationName: "timedMetadata"), required: false, type: .enum), 
            AWSShapeMember(label: "PmtPid", location: .body(locationName: "pmtPid"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoPid", location: .body(locationName: "videoPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrPid", location: .body(locationName: "pcrPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtInterval", location: .body(locationName: "pmtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Pid", location: .body(locationName: "scte35Pid"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Source", location: .body(locationName: "scte35Source"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioPids", location: .body(locationName: "audioPids"), required: false, type: .list), 
            AWSShapeMember(label: "AudioFramesPerPes", location: .body(locationName: "audioFramesPerPes"), required: false, type: .integer), 
            AWSShapeMember(label: "TransportStreamId", location: .body(locationName: "transportStreamId"), required: false, type: .integer), 
            AWSShapeMember(label: "PrivateMetadataPid", location: .body(locationName: "privateMetadataPid"), required: false, type: .integer)
        ]
        /// Packet Identifier (PID) of the timed metadata stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let timedMetadataPid: Int32?
        public let pcrControl: M3u8PcrControl?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let patInterval: Int32?
        public let timedMetadata: TimedMetadata?
        /// Packet Identifier (PID) for the Program Map Table (PMT) in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let pmtPid: Int32?
        /// Packet Identifier (PID) of the elementary video stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let videoPid: Int32?
        /// Packet Identifier (PID) of the Program Clock Reference (PCR) in the transport stream. When no value is given, the encoder will assign the same value as the Video PID. Can be entered as a decimal or hexadecimal value.
        public let pcrPid: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let pmtInterval: Int32?
        /// Packet Identifier (PID) of the SCTE-35 stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let scte35Pid: Int32?
        public let scte35Source: M3u8Scte35Source?
        /// The value of the program number field in the Program Map Table.
        public let programNumber: Int32?
        /// Packet Identifier (PID) of the elementary audio stream(s) in the transport stream. Multiple values are accepted, and can be entered in ranges and/or by comma separation. Can be entered as decimal or hexadecimal values.
        public let audioPids: [Int32]?
        /// The number of audio frames to insert for each PES packet.
        public let audioFramesPerPes: Int32?
        /// The value of the transport stream ID field in the Program Map Table.
        public let transportStreamId: Int32?
        /// Packet Identifier (PID) of the private metadata stream in the transport stream. Can be entered as a decimal or hexadecimal value.
        public let privateMetadataPid: Int32?

        public init(timedMetadataPid: Int32? = nil, pcrControl: M3u8PcrControl? = nil, patInterval: Int32? = nil, timedMetadata: TimedMetadata? = nil, pmtPid: Int32? = nil, videoPid: Int32? = nil, pcrPid: Int32? = nil, pmtInterval: Int32? = nil, scte35Pid: Int32? = nil, scte35Source: M3u8Scte35Source? = nil, programNumber: Int32? = nil, audioPids: [Int32]? = nil, audioFramesPerPes: Int32? = nil, transportStreamId: Int32? = nil, privateMetadataPid: Int32? = nil) {
            self.timedMetadataPid = timedMetadataPid
            self.pcrControl = pcrControl
            self.patInterval = patInterval
            self.timedMetadata = timedMetadata
            self.pmtPid = pmtPid
            self.videoPid = videoPid
            self.pcrPid = pcrPid
            self.pmtInterval = pmtInterval
            self.scte35Pid = scte35Pid
            self.scte35Source = scte35Source
            self.programNumber = programNumber
            self.audioPids = audioPids
            self.audioFramesPerPes = audioFramesPerPes
            self.transportStreamId = transportStreamId
            self.privateMetadataPid = privateMetadataPid
        }

        private enum CodingKeys: String, CodingKey {
            case timedMetadataPid = "timedMetadataPid"
            case pcrControl = "pcrControl"
            case patInterval = "patInterval"
            case timedMetadata = "timedMetadata"
            case pmtPid = "pmtPid"
            case videoPid = "videoPid"
            case pcrPid = "pcrPid"
            case pmtInterval = "pmtInterval"
            case scte35Pid = "scte35Pid"
            case scte35Source = "scte35Source"
            case programNumber = "programNumber"
            case audioPids = "audioPids"
            case audioFramesPerPes = "audioFramesPerPes"
            case transportStreamId = "transportStreamId"
            case privateMetadataPid = "privateMetadataPid"
        }
    }

    public struct OutputDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "VideoDetails", location: .body(locationName: "videoDetails"), required: false, type: .structure), 
            AWSShapeMember(label: "DurationInMs", location: .body(locationName: "durationInMs"), required: false, type: .integer)
        ]
        public let videoDetails: VideoDetail?
        /// Duration in milliseconds
        public let durationInMs: Int32?

        public init(videoDetails: VideoDetail? = nil, durationInMs: Int32? = nil) {
            self.videoDetails = videoDetails
            self.durationInMs = durationInMs
        }

        private enum CodingKeys: String, CodingKey {
            case videoDetails = "videoDetails"
            case durationInMs = "durationInMs"
        }
    }

    public struct ListPresetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Presets", location: .body(locationName: "presets"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        /// List of presets
        public let presets: [Preset]?
        /// Use this string to request the next batch of presets.
        public let nextToken: String?

        public init(presets: [Preset]? = nil, nextToken: String? = nil) {
            self.presets = presets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case presets = "presets"
            case nextToken = "nextToken"
        }
    }

    public enum AacSpecification: String, CustomStringConvertible, Codable {
        case mpeg2 = "MPEG2"
        case mpeg4 = "MPEG4"
        public var description: String { return self.rawValue }
    }

    public enum DashIsoHbbtvCompliance: String, CustomStringConvertible, Codable {
        case hbbtv15 = "HBBTV_1_5"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct GetPresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the preset.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum HlsEncryptionType: String, CustomStringConvertible, Codable {
        case aes128 = "AES128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum H264SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Eac3LfeControl: String, CustomStringConvertible, Codable {
        case lfe = "LFE"
        case noLfe = "NO_LFE"
        public var description: String { return self.rawValue }
    }

    public struct JobSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TimedMetadataInsertion", location: .body(locationName: "timedMetadataInsertion"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputGroups", location: .body(locationName: "outputGroups"), required: false, type: .list), 
            AWSShapeMember(label: "NielsenConfiguration", location: .body(locationName: "nielsenConfiguration"), required: false, type: .structure), 
            AWSShapeMember(label: "Inputs", location: .body(locationName: "inputs"), required: false, type: .list), 
            AWSShapeMember(label: "AdAvailOffset", location: .body(locationName: "adAvailOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "AvailBlanking", location: .body(locationName: "availBlanking"), required: false, type: .structure), 
            AWSShapeMember(label: "TimecodeConfig", location: .body(locationName: "timecodeConfig"), required: false, type: .structure)
        ]
        public let timedMetadataInsertion: TimedMetadataInsertion?
        /// **!!**(OutputGroups) contains one group of settings for each set of outputs that share a common package type. All unpackaged files (MPEG-4, MPEG-2 TS, Quicktime, MXF, and no container) are grouped in a single output group as well. Required in (OutputGroups) is a group of settings that apply to the whole group. This required object depends on the value you set for (Type) under (OutputGroups)>(OutputGroupSettings). Type, settings object pairs are as follows. * FILE_GROUP_SETTINGS, FileGroupSettings * HLS_GROUP_SETTINGS, HlsGroupSettings * DASH_ISO_GROUP_SETTINGS, DashIsoGroupSettings * MS_SMOOTH_GROUP_SETTINGS, MsSmoothGroupSettings
        public let outputGroups: [OutputGroup]?
        public let nielsenConfiguration: NielsenConfiguration?
        /// Use Inputs (inputs) to define source file used in the transcode job. There can be multiple inputs add in a job. These inputs will be concantenated together to create the output.
        public let inputs: [Input]?
        /// When specified, this offset (in milliseconds) is added to the input Ad Avail PTS time.
        public let adAvailOffset: Int32?
        /// Settings for ad avail blanking.  Video can be blanked or overlaid with an image, and audio muted during SCTE-35 triggered ad avails.
        public let availBlanking: AvailBlanking?
        /// Contains settings used to acquire and adjust timecode information from inputs.
        public let timecodeConfig: TimecodeConfig?

        public init(timedMetadataInsertion: TimedMetadataInsertion? = nil, outputGroups: [OutputGroup]? = nil, nielsenConfiguration: NielsenConfiguration? = nil, inputs: [Input]? = nil, adAvailOffset: Int32? = nil, availBlanking: AvailBlanking? = nil, timecodeConfig: TimecodeConfig? = nil) {
            self.timedMetadataInsertion = timedMetadataInsertion
            self.outputGroups = outputGroups
            self.nielsenConfiguration = nielsenConfiguration
            self.inputs = inputs
            self.adAvailOffset = adAvailOffset
            self.availBlanking = availBlanking
            self.timecodeConfig = timecodeConfig
        }

        private enum CodingKeys: String, CodingKey {
            case timedMetadataInsertion = "timedMetadataInsertion"
            case outputGroups = "outputGroups"
            case nielsenConfiguration = "nielsenConfiguration"
            case inputs = "inputs"
            case adAvailOffset = "adAvailOffset"
            case availBlanking = "availBlanking"
            case timecodeConfig = "timecodeConfig"
        }
    }

    public enum Mpeg2SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleOutlineColor: String, CustomStringConvertible, Codable {
        case black = "BLACK"
        case white = "WHITE"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public struct Mp4Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FreeSpaceBox", location: .body(locationName: "freeSpaceBox"), required: false, type: .enum), 
            AWSShapeMember(label: "MoovPlacement", location: .body(locationName: "moovPlacement"), required: false, type: .enum), 
            AWSShapeMember(label: "Mp4MajorBrand", location: .body(locationName: "mp4MajorBrand"), required: false, type: .string), 
            AWSShapeMember(label: "CslgAtom", location: .body(locationName: "cslgAtom"), required: false, type: .enum)
        ]
        public let freeSpaceBox: Mp4FreeSpaceBox?
        public let moovPlacement: Mp4MoovPlacement?
        /// Overrides the "Major Brand" field in the output file. Usually not necessary to specify.
        public let mp4MajorBrand: String?
        public let cslgAtom: Mp4CslgAtom?

        public init(freeSpaceBox: Mp4FreeSpaceBox? = nil, moovPlacement: Mp4MoovPlacement? = nil, mp4MajorBrand: String? = nil, cslgAtom: Mp4CslgAtom? = nil) {
            self.freeSpaceBox = freeSpaceBox
            self.moovPlacement = moovPlacement
            self.mp4MajorBrand = mp4MajorBrand
            self.cslgAtom = cslgAtom
        }

        private enum CodingKeys: String, CodingKey {
            case freeSpaceBox = "freeSpaceBox"
            case moovPlacement = "moovPlacement"
            case mp4MajorBrand = "mp4MajorBrand"
            case cslgAtom = "cslgAtom"
        }
    }

    public enum H264AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case higher = "HIGHER"
        case max = "MAX"
        public var description: String { return self.rawValue }
    }

    public enum MovMpeg2FourCCControl: String, CustomStringConvertible, Codable {
        case xdcam = "XDCAM"
        case mpeg = "MPEG"
        public var description: String { return self.rawValue }
    }

    public struct FrameCaptureSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxCaptures", location: .body(locationName: "maxCaptures"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "Quality", location: .body(locationName: "quality"), required: false, type: .integer)
        ]
        /// Frame capture will encode the first frame of the output stream, then one frame every framerateDenominator/framerateNumerator seconds. For example, settings of framerateNumerator = 1 and framerateDenominator = 3 (a rate of 1/3 frame per second) will capture the first frame, then 1 frame every 3s. Files will be named as filename.n.jpg where n is the 0-based sequence number of each Capture.
        public let framerateDenominator: Int32?
        /// Maximum number of captures (encoded jpg output files).
        public let maxCaptures: Int32?
        /// Frame capture will encode the first frame of the output stream, then one frame every framerateDenominator/framerateNumerator seconds. For example, settings of framerateNumerator = 1 and framerateDenominator = 3 (a rate of 1/3 frame per second) will capture the first frame, then 1 frame every 3s. Files will be named as filename.NNNNNNN.jpg where N is the 0-based frame sequence number zero padded to 7 decimal places.
        public let framerateNumerator: Int32?
        /// JPEG Quality - a higher value equals higher quality.
        public let quality: Int32?

        public init(framerateDenominator: Int32? = nil, maxCaptures: Int32? = nil, framerateNumerator: Int32? = nil, quality: Int32? = nil) {
            self.framerateDenominator = framerateDenominator
            self.maxCaptures = maxCaptures
            self.framerateNumerator = framerateNumerator
            self.quality = quality
        }

        private enum CodingKeys: String, CodingKey {
            case framerateDenominator = "framerateDenominator"
            case maxCaptures = "maxCaptures"
            case framerateNumerator = "framerateNumerator"
            case quality = "quality"
        }
    }

    public struct UpdateQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        public let status: QueueStatus?
        /// The name of the queue you are modifying.
        public let name: String
        /// The new description for the queue, if you are changing it.
        public let description: String?

        public init(status: QueueStatus? = nil, name: String, description: String? = nil) {
            self.status = status
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case name = "name"
            case description = "description"
        }
    }

    public enum QueueListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        public var description: String { return self.rawValue }
    }

    public enum AacCodecProfile: String, CustomStringConvertible, Codable {
        case lc = "LC"
        case hev1 = "HEV1"
        case hev2 = "HEV2"
        public var description: String { return self.rawValue }
    }

    public enum HlsClientCache: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AudioLanguageCodeControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum H265SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct Ac3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeFilter", location: .body(locationName: "lfeFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "BitstreamMode", location: .body(locationName: "bitstreamMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "MetadataControl", location: .body(locationName: "metadataControl"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicRangeCompressionProfile", location: .body(locationName: "dynamicRangeCompressionProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "Dialnorm", location: .body(locationName: "dialnorm"), required: false, type: .integer)
        ]
        public let codingMode: Ac3CodingMode?
        public let lfeFilter: Ac3LfeFilter?
        public let bitstreamMode: Ac3BitstreamMode?
        /// Sample rate in hz. Sample rate is always 48000.
        public let sampleRate: Int32?
        /// Average bitrate in bits/second. Valid bitrates depend on the coding mode.
        public let bitrate: Int32?
        public let metadataControl: Ac3MetadataControl?
        public let dynamicRangeCompressionProfile: Ac3DynamicRangeCompressionProfile?
        /// Sets the dialnorm for the output. If blank and input audio is Dolby Digital, dialnorm will be passed through.
        public let dialnorm: Int32?

        public init(codingMode: Ac3CodingMode? = nil, lfeFilter: Ac3LfeFilter? = nil, bitstreamMode: Ac3BitstreamMode? = nil, sampleRate: Int32? = nil, bitrate: Int32? = nil, metadataControl: Ac3MetadataControl? = nil, dynamicRangeCompressionProfile: Ac3DynamicRangeCompressionProfile? = nil, dialnorm: Int32? = nil) {
            self.codingMode = codingMode
            self.lfeFilter = lfeFilter
            self.bitstreamMode = bitstreamMode
            self.sampleRate = sampleRate
            self.bitrate = bitrate
            self.metadataControl = metadataControl
            self.dynamicRangeCompressionProfile = dynamicRangeCompressionProfile
            self.dialnorm = dialnorm
        }

        private enum CodingKeys: String, CodingKey {
            case codingMode = "codingMode"
            case lfeFilter = "lfeFilter"
            case bitstreamMode = "bitstreamMode"
            case sampleRate = "sampleRate"
            case bitrate = "bitrate"
            case metadataControl = "metadataControl"
            case dynamicRangeCompressionProfile = "dynamicRangeCompressionProfile"
            case dialnorm = "dialnorm"
        }
    }

    public struct ProresSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer)
        ]
        public let telecine: ProresTelecine?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let parControl: ProresParControl?
        public let framerateConversionAlgorithm: ProresFramerateConversionAlgorithm?
        /// When you use the API for transcode jobs that use framerate conversion, specify the framerate as a fraction. For example,  24000 / 1001 = 23.976 fps. Use FramerateNumerator to specify the numerator of this fraction. In this example, use 24000 for the value of FramerateNumerator.
        public let framerateNumerator: Int32?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        public let codecProfile: ProresCodecProfile?
        public let interlaceMode: ProresInterlaceMode?
        public let slowPal: ProresSlowPal?
        public let framerateControl: ProresFramerateControl?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?

        public init(telecine: ProresTelecine? = nil, framerateDenominator: Int32? = nil, parControl: ProresParControl? = nil, framerateConversionAlgorithm: ProresFramerateConversionAlgorithm? = nil, framerateNumerator: Int32? = nil, parDenominator: Int32? = nil, codecProfile: ProresCodecProfile? = nil, interlaceMode: ProresInterlaceMode? = nil, slowPal: ProresSlowPal? = nil, framerateControl: ProresFramerateControl? = nil, parNumerator: Int32? = nil) {
            self.telecine = telecine
            self.framerateDenominator = framerateDenominator
            self.parControl = parControl
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.framerateNumerator = framerateNumerator
            self.parDenominator = parDenominator
            self.codecProfile = codecProfile
            self.interlaceMode = interlaceMode
            self.slowPal = slowPal
            self.framerateControl = framerateControl
            self.parNumerator = parNumerator
        }

        private enum CodingKeys: String, CodingKey {
            case telecine = "telecine"
            case framerateDenominator = "framerateDenominator"
            case parControl = "parControl"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case framerateNumerator = "framerateNumerator"
            case parDenominator = "parDenominator"
            case codecProfile = "codecProfile"
            case interlaceMode = "interlaceMode"
            case slowPal = "slowPal"
            case framerateControl = "framerateControl"
            case parNumerator = "parNumerator"
        }
    }

    public struct ListJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", location: .querystring(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .querystring(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer)
        ]
        public let status: JobStatus?
        public let order: Order?
        /// Use this string, provided with the response to a previous request, to request the next batch of jobs.
        public let nextToken: String?
        /// Provide a queue name to get back only jobs from that queue.
        public let queue: String?
        /// Optional. Number of jobs, up to twenty, that will be returned at one time.
        public let maxResults: Int32?

        public init(status: JobStatus? = nil, order: Order? = nil, nextToken: String? = nil, queue: String? = nil, maxResults: Int32? = nil) {
            self.status = status
            self.order = order
            self.nextToken = nextToken
            self.queue = queue
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case order = "order"
            case nextToken = "nextToken"
            case queue = "queue"
            case maxResults = "maxResults"
        }
    }

    public enum HlsProgramDateTime: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum Mp4MoovPlacement: String, CustomStringConvertible, Codable {
        case progressiveDownload = "PROGRESSIVE_DOWNLOAD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleFontColor: String, CustomStringConvertible, Codable {
        case white = "WHITE"
        case black = "BLACK"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum InputDenoiseFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CaptionSelectorName", location: .body(locationName: "captionSelectorName"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "DestinationSettings", location: .body(locationName: "destinationSettings"), required: false, type: .structure)
        ]
        /// Specifies which "Caption Selector":#inputs-caption_selector to use from each input when generating captions. The name should be of the format "Caption Selector ", which denotes that the Nth Caption Selector will be used from each input.
        public let captionSelectorName: String?
        /// Human readable information to indicate captions available for players (eg. English, or Spanish). Alphanumeric characters, spaces, and underscore are legal.
        public let languageDescription: String?
        /// Indicates the language of the caption output track.
        public let languageCode: LanguageCode?
        public let destinationSettings: CaptionDestinationSettings?

        public init(captionSelectorName: String? = nil, languageDescription: String? = nil, languageCode: LanguageCode? = nil, destinationSettings: CaptionDestinationSettings? = nil) {
            self.captionSelectorName = captionSelectorName
            self.languageDescription = languageDescription
            self.languageCode = languageCode
            self.destinationSettings = destinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case captionSelectorName = "captionSelectorName"
            case languageDescription = "languageDescription"
            case languageCode = "languageCode"
            case destinationSettings = "destinationSettings"
        }
    }

    public struct Hdr10Metadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BluePrimaryX", location: .body(locationName: "bluePrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "WhitePointX", location: .body(locationName: "whitePointX"), required: false, type: .integer), 
            AWSShapeMember(label: "WhitePointY", location: .body(locationName: "whitePointY"), required: false, type: .integer), 
            AWSShapeMember(label: "RedPrimaryY", location: .body(locationName: "redPrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "GreenPrimaryY", location: .body(locationName: "greenPrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxLuminance", location: .body(locationName: "maxLuminance"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxFrameAverageLightLevel", location: .body(locationName: "maxFrameAverageLightLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "RedPrimaryX", location: .body(locationName: "redPrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "MinLuminance", location: .body(locationName: "minLuminance"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxContentLightLevel", location: .body(locationName: "maxContentLightLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "BluePrimaryY", location: .body(locationName: "bluePrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "GreenPrimaryX", location: .body(locationName: "greenPrimaryX"), required: false, type: .integer)
        ]
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let bluePrimaryX: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let whitePointX: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let whitePointY: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let redPrimaryY: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let greenPrimaryY: Int32?
        /// Nominal maximum mastering display luminance in units of of 0.0001 candelas per square meter.
        public let maxLuminance: Int32?
        /// Maximum average light level of any frame in the coded video sequence, in units of candelas per square meter.
        public let maxFrameAverageLightLevel: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let redPrimaryX: Int32?
        /// Nominal minimum mastering display luminance in units of of 0.0001 candelas per square meter
        public let minLuminance: Int32?
        /// Maximum light level among all samples in the coded video sequence, in units of candelas per square meter.
        public let maxContentLightLevel: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let bluePrimaryY: Int32?
        /// HDR Master Display Information comes from the color grader and the color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate.
        public let greenPrimaryX: Int32?

        public init(bluePrimaryX: Int32? = nil, whitePointX: Int32? = nil, whitePointY: Int32? = nil, redPrimaryY: Int32? = nil, greenPrimaryY: Int32? = nil, maxLuminance: Int32? = nil, maxFrameAverageLightLevel: Int32? = nil, redPrimaryX: Int32? = nil, minLuminance: Int32? = nil, maxContentLightLevel: Int32? = nil, bluePrimaryY: Int32? = nil, greenPrimaryX: Int32? = nil) {
            self.bluePrimaryX = bluePrimaryX
            self.whitePointX = whitePointX
            self.whitePointY = whitePointY
            self.redPrimaryY = redPrimaryY
            self.greenPrimaryY = greenPrimaryY
            self.maxLuminance = maxLuminance
            self.maxFrameAverageLightLevel = maxFrameAverageLightLevel
            self.redPrimaryX = redPrimaryX
            self.minLuminance = minLuminance
            self.maxContentLightLevel = maxContentLightLevel
            self.bluePrimaryY = bluePrimaryY
            self.greenPrimaryX = greenPrimaryX
        }

        private enum CodingKeys: String, CodingKey {
            case bluePrimaryX = "bluePrimaryX"
            case whitePointX = "whitePointX"
            case whitePointY = "whitePointY"
            case redPrimaryY = "redPrimaryY"
            case greenPrimaryY = "greenPrimaryY"
            case maxLuminance = "maxLuminance"
            case maxFrameAverageLightLevel = "maxFrameAverageLightLevel"
            case redPrimaryX = "redPrimaryX"
            case minLuminance = "minLuminance"
            case maxContentLightLevel = "maxContentLightLevel"
            case bluePrimaryY = "bluePrimaryY"
            case greenPrimaryX = "greenPrimaryX"
        }
    }

    public struct GetJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public struct CreateJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Optional. A category for the job template you are creating
        public let category: String?
        public let settings: JobTemplateSettings?
        /// The name of the job template you are creating.
        public let name: String?
        /// Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
        public let queue: String?
        /// Optional. A description of the job template you are creating.
        public let description: String?

        public init(category: String? = nil, settings: JobTemplateSettings? = nil, name: String? = nil, queue: String? = nil, description: String? = nil) {
            self.category = category
            self.settings = settings
            self.name = name
            self.queue = queue
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case settings = "settings"
            case name = "name"
            case queue = "queue"
            case description = "description"
        }
    }

    public enum Eac3PhaseControl: String, CustomStringConvertible, Codable {
        case shift90Degrees = "SHIFT_90_DEGREES"
        case noShift = "NO_SHIFT"
        public var description: String { return self.rawValue }
    }

    public enum ProresParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum H265InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct SccDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Framerate", location: .body(locationName: "framerate"), required: false, type: .enum)
        ]
        public let framerate: SccDestinationFramerate?

        public init(framerate: SccDestinationFramerate? = nil) {
            self.framerate = framerate
        }

        private enum CodingKeys: String, CodingKey {
            case framerate = "framerate"
        }
    }

    public enum H264GopBReference: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HlsStreamInfResolution: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the queue to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum M3u8Scte35Source: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct OutputGroupDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputDetails", location: .body(locationName: "outputDetails"), required: false, type: .list)
        ]
        /// Details about the output
        public let outputDetails: [OutputDetail]?

        public init(outputDetails: [OutputDetail]? = nil) {
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case outputDetails = "outputDetails"
        }
    }

    public enum H264UnregisteredSeiTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum H265Tiles: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct AudioSelectorGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioSelectorNames", location: .body(locationName: "audioSelectorNames"), required: false, type: .list)
        ]
        /// Name of an "Audio Selector":#inputs-audio_selector within the same input to include in the group.  Audio selector names are standardized, based on their order within the input (e.g. "Audio Selector 1").  The audio_selector_name parameter can be repeated to add any number of audio selectors to the group.
        public let audioSelectorNames: [String]?

        public init(audioSelectorNames: [String]? = nil) {
            self.audioSelectorNames = audioSelectorNames
        }

        private enum CodingKeys: String, CodingKey {
            case audioSelectorNames = "audioSelectorNames"
        }
    }

    public struct CreateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", location: .body(locationName: "job"), required: false, type: .structure)
        ]
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct Input: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DeblockFilter", location: .body(locationName: "deblockFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "FilterEnable", location: .body(locationName: "filterEnable"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioSelectors", location: .body(locationName: "audioSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "PsiControl", location: .body(locationName: "psiControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FilterStrength", location: .body(locationName: "filterStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "DenoiseFilter", location: .body(locationName: "denoiseFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "InputClippings", location: .body(locationName: "inputClippings"), required: false, type: .list), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoSelector", location: .body(locationName: "videoSelector"), required: false, type: .structure), 
            AWSShapeMember(label: "FileInput", location: .body(locationName: "fileInput"), required: false, type: .string), 
            AWSShapeMember(label: "AudioSelectorGroups", location: .body(locationName: "audioSelectorGroups"), required: false, type: .map), 
            AWSShapeMember(label: "CaptionSelectors", location: .body(locationName: "captionSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "TimecodeSource", location: .body(locationName: "timecodeSource"), required: false, type: .enum)
        ]
        public let deblockFilter: InputDeblockFilter?
        public let filterEnable: InputFilterEnable?
        /// Use Audio selectors (AudioSelectors) to specify a track or set of tracks from the input that you will use in your outputs. You can use mutiple Audio selectors per input.
        public let audioSelectors: [String: AudioSelector]?
        public let psiControl: InputPsiControl?
        /// Use Filter strength (FilterStrength) to adjust the magnitude the input filter settings (Deblock and Denoise). The range is -5 to 5. Default is 0.
        public let filterStrength: Int32?
        public let denoiseFilter: InputDenoiseFilter?
        /// (InputClippings) contains sets of start and end times that together specify a portion of the input to be used in the outputs. If you provide only a start time, the clip will be the entire input from that point to the end. If you provide only an end time, it will be the entire input up to that point. When you specify more than one input clip, the transcoding service creates the job outputs by stringing the clips together in the order you specify them.
        public let inputClippings: [InputClipping]?
        /// Use Program (programNumber) to select a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported. Default is the first program within the transport stream. If the program you specify doesn't exist, the transcoding service will use this default.
        public let programNumber: Int32?
        public let videoSelector: VideoSelector?
        /// Use Input (fileInput) to define the source file used in the transcode job. There can be multiple inputs in a job. These inputs are concantenated, in the order they are specified in the job, to create the output.
        public let fileInput: String?
        /// Specifies set of audio selectors within an input to combine. An input may have multiple audio selector groups. See "Audio Selector Group":#inputs-audio_selector_group for more information.
        public let audioSelectorGroups: [String: AudioSelectorGroup]?
        /// Use Captions selectors (CaptionSelectors) to specify the captions data from the input that you will use in your outputs. You can use mutiple captions selectors per input.
        public let captionSelectors: [String: CaptionSelector]?
        public let timecodeSource: InputTimecodeSource?

        public init(deblockFilter: InputDeblockFilter? = nil, filterEnable: InputFilterEnable? = nil, audioSelectors: [String: AudioSelector]? = nil, psiControl: InputPsiControl? = nil, filterStrength: Int32? = nil, denoiseFilter: InputDenoiseFilter? = nil, inputClippings: [InputClipping]? = nil, programNumber: Int32? = nil, videoSelector: VideoSelector? = nil, fileInput: String? = nil, audioSelectorGroups: [String: AudioSelectorGroup]? = nil, captionSelectors: [String: CaptionSelector]? = nil, timecodeSource: InputTimecodeSource? = nil) {
            self.deblockFilter = deblockFilter
            self.filterEnable = filterEnable
            self.audioSelectors = audioSelectors
            self.psiControl = psiControl
            self.filterStrength = filterStrength
            self.denoiseFilter = denoiseFilter
            self.inputClippings = inputClippings
            self.programNumber = programNumber
            self.videoSelector = videoSelector
            self.fileInput = fileInput
            self.audioSelectorGroups = audioSelectorGroups
            self.captionSelectors = captionSelectors
            self.timecodeSource = timecodeSource
        }

        private enum CodingKeys: String, CodingKey {
            case deblockFilter = "deblockFilter"
            case filterEnable = "filterEnable"
            case audioSelectors = "audioSelectors"
            case psiControl = "psiControl"
            case filterStrength = "filterStrength"
            case denoiseFilter = "denoiseFilter"
            case inputClippings = "inputClippings"
            case programNumber = "programNumber"
            case videoSelector = "videoSelector"
            case fileInput = "fileInput"
            case audioSelectorGroups = "audioSelectorGroups"
            case captionSelectors = "captionSelectors"
            case timecodeSource = "timecodeSource"
        }
    }

    public enum H264SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H264ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct DeletePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the preset to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum EmbeddedConvert608To708: String, CustomStringConvertible, Codable {
        case upconvert = "UPCONVERT"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum Mp4FreeSpaceBox: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct OutputGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MsSmoothGroupSettings", location: .body(locationName: "msSmoothGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "FileGroupSettings", location: .body(locationName: "fileGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "HlsGroupSettings", location: .body(locationName: "hlsGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DashIsoGroupSettings", location: .body(locationName: "dashIsoGroupSettings"), required: false, type: .structure)
        ]
        public let msSmoothGroupSettings: MsSmoothGroupSettings?
        public let fileGroupSettings: FileGroupSettings?
        /// Type of output group (File group, Apple HLS, DASH ISO, Microsoft Smooth Streaming)
        public let `type`: OutputGroupType?
        public let hlsGroupSettings: HlsGroupSettings?
        public let dashIsoGroupSettings: DashIsoGroupSettings?

        public init(msSmoothGroupSettings: MsSmoothGroupSettings? = nil, fileGroupSettings: FileGroupSettings? = nil, type: OutputGroupType? = nil, hlsGroupSettings: HlsGroupSettings? = nil, dashIsoGroupSettings: DashIsoGroupSettings? = nil) {
            self.msSmoothGroupSettings = msSmoothGroupSettings
            self.fileGroupSettings = fileGroupSettings
            self.`type` = `type`
            self.hlsGroupSettings = hlsGroupSettings
            self.dashIsoGroupSettings = dashIsoGroupSettings
        }

        private enum CodingKeys: String, CodingKey {
            case msSmoothGroupSettings = "msSmoothGroupSettings"
            case fileGroupSettings = "fileGroupSettings"
            case `type` = "type"
            case hlsGroupSettings = "hlsGroupSettings"
            case dashIsoGroupSettings = "dashIsoGroupSettings"
        }
    }

    public struct JobTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The timestamp in epoch seconds for Job template creation.
        public let createdAt: TimeStamp?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// A name you create for each job template. Each name must be unique within your account.
        public let name: String?
        /// An optional category you create to organize your job templates.
        public let category: String?
        /// The timestamp in epoch seconds when the Job template was last updated.
        public let lastUpdated: TimeStamp?
        public let settings: JobTemplateSettings?
        /// A job template can be of two types: system or custom. System or built-in job templates can’t be modified or deleted by the user.
        public let `type`: `Type`?
        /// Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
        public let queue: String?
        /// An optional description you create for each job template.
        public let description: String?

        public init(createdAt: TimeStamp? = nil, arn: String? = nil, name: String? = nil, category: String? = nil, lastUpdated: TimeStamp? = nil, settings: JobTemplateSettings? = nil, type: `Type`? = nil, queue: String? = nil, description: String? = nil) {
            self.createdAt = createdAt
            self.arn = arn
            self.name = name
            self.category = category
            self.lastUpdated = lastUpdated
            self.settings = settings
            self.`type` = `type`
            self.queue = queue
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case arn = "arn"
            case name = "name"
            case category = "category"
            case lastUpdated = "lastUpdated"
            case settings = "settings"
            case `type` = "type"
            case queue = "queue"
            case description = "description"
        }
    }

    public struct StaticKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StaticKeyValue", location: .body(locationName: "staticKeyValue"), required: false, type: .string), 
            AWSShapeMember(label: "KeyFormat", location: .body(locationName: "keyFormat"), required: false, type: .string), 
            AWSShapeMember(label: "KeyFormatVersions", location: .body(locationName: "keyFormatVersions"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string)
        ]
        /// Relates to DRM implementation. Use a 32-character hexidecimal string to specify Key Value (StaticKeyValue).
        public let staticKeyValue: String?
        /// Relates to DRM implementation. Sets the value of the KEYFORMAT attribute. Must be 'identity' or a reverse DNS string. May be omitted to indicate an implicit value of 'identity'.
        public let keyFormat: String?
        /// Relates to DRM implementation. Either a single positive integer version value or a slash delimited list of version values (1/2/3).
        public let keyFormatVersions: String?
        /// Relates to DRM implementation. The location of the license server used for protecting content.
        public let url: String?

        public init(staticKeyValue: String? = nil, keyFormat: String? = nil, keyFormatVersions: String? = nil, url: String? = nil) {
            self.staticKeyValue = staticKeyValue
            self.keyFormat = keyFormat
            self.keyFormatVersions = keyFormatVersions
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case staticKeyValue = "staticKeyValue"
            case keyFormat = "keyFormat"
            case keyFormatVersions = "keyFormatVersions"
            case url = "url"
        }
    }

    public struct DvbTdtSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TdtInterval", location: .body(locationName: "tdtInterval"), required: false, type: .integer)
        ]
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let tdtInterval: Int32?

        public init(tdtInterval: Int32? = nil) {
            self.tdtInterval = tdtInterval
        }

        private enum CodingKeys: String, CodingKey {
            case tdtInterval = "tdtInterval"
        }
    }

    public struct AudioNormalizationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Algorithm", location: .body(locationName: "algorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "CorrectionGateLevel", location: .body(locationName: "correctionGateLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "PeakCalculation", location: .body(locationName: "peakCalculation"), required: false, type: .enum), 
            AWSShapeMember(label: "LoudnessLogging", location: .body(locationName: "loudnessLogging"), required: false, type: .enum), 
            AWSShapeMember(label: "AlgorithmControl", location: .body(locationName: "algorithmControl"), required: false, type: .enum), 
            AWSShapeMember(label: "TargetLkfs", location: .body(locationName: "targetLkfs"), required: false, type: .double)
        ]
        public let algorithm: AudioNormalizationAlgorithm?
        /// Content measuring above this level will be corrected to the target level. Content measuring below this level will not be corrected. Gating only applies when not using real_time_correction.
        public let correctionGateLevel: Int32?
        public let peakCalculation: AudioNormalizationPeakCalculation?
        public let loudnessLogging: AudioNormalizationLoudnessLogging?
        public let algorithmControl: AudioNormalizationAlgorithmControl?
        /// Target LKFS(loudness) to adjust volume to. If no value is entered, a default value will be used according to the chosen algorithm. The CALM Act (1770-1) recommends a target of -24 LKFS. The EBU R-128 specification (1770-2) recommends a target of -23 LKFS.
        public let targetLkfs: Double?

        public init(algorithm: AudioNormalizationAlgorithm? = nil, correctionGateLevel: Int32? = nil, peakCalculation: AudioNormalizationPeakCalculation? = nil, loudnessLogging: AudioNormalizationLoudnessLogging? = nil, algorithmControl: AudioNormalizationAlgorithmControl? = nil, targetLkfs: Double? = nil) {
            self.algorithm = algorithm
            self.correctionGateLevel = correctionGateLevel
            self.peakCalculation = peakCalculation
            self.loudnessLogging = loudnessLogging
            self.algorithmControl = algorithmControl
            self.targetLkfs = targetLkfs
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
            case correctionGateLevel = "correctionGateLevel"
            case peakCalculation = "peakCalculation"
            case loudnessLogging = "loudnessLogging"
            case algorithmControl = "algorithmControl"
            case targetLkfs = "targetLkfs"
        }
    }

    public struct DvbSdtSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputSdt", location: .body(locationName: "outputSdt"), required: false, type: .enum), 
            AWSShapeMember(label: "ServiceName", location: .body(locationName: "serviceName"), required: false, type: .string), 
            AWSShapeMember(label: "SdtInterval", location: .body(locationName: "sdtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "ServiceProviderName", location: .body(locationName: "serviceProviderName"), required: false, type: .string)
        ]
        public let outputSdt: OutputSdt?
        /// The service name placed in the service_descriptor in the Service Description Table. Maximum length is 256 characters.
        public let serviceName: String?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let sdtInterval: Int32?
        /// The service provider name placed in the service_descriptor in the Service Description Table. Maximum length is 256 characters.
        public let serviceProviderName: String?

        public init(outputSdt: OutputSdt? = nil, serviceName: String? = nil, sdtInterval: Int32? = nil, serviceProviderName: String? = nil) {
            self.outputSdt = outputSdt
            self.serviceName = serviceName
            self.sdtInterval = sdtInterval
            self.serviceProviderName = serviceProviderName
        }

        private enum CodingKeys: String, CodingKey {
            case outputSdt = "outputSdt"
            case serviceName = "serviceName"
            case sdtInterval = "sdtInterval"
            case serviceProviderName = "serviceProviderName"
        }
    }

    public enum AntiAlias: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Eac3StereoDownmix: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case loRo = "LO_RO"
        case ltRt = "LT_RT"
        case dpl2 = "DPL2"
        public var description: String { return self.rawValue }
    }

    public enum M2tsSegmentationStyle: String, CustomStringConvertible, Codable {
        case maintainCadence = "MAINTAIN_CADENCE"
        case resetCadence = "RESET_CADENCE"
        public var description: String { return self.rawValue }
    }

    public enum M2tsSegmentationMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case raiSegstart = "RAI_SEGSTART"
        case raiAdapt = "RAI_ADAPT"
        case psiSegstart = "PSI_SEGSTART"
        case ebp = "EBP"
        case ebpLegacy = "EBP_LEGACY"
        public var description: String { return self.rawValue }
    }

    public struct FileSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceFile", location: .body(locationName: "sourceFile"), required: false, type: .string), 
            AWSShapeMember(label: "TimeDelta", location: .body(locationName: "timeDelta"), required: false, type: .integer), 
            AWSShapeMember(label: "Convert608To708", location: .body(locationName: "convert608To708"), required: false, type: .enum)
        ]
        /// External caption file used for loading captions. Accepted file extensions are 'scc', 'ttml', 'dfxp', 'stl', 'srt', and 'smi'. Auto-populated when Infer External Filename is checked.
        public let sourceFile: String?
        /// Specifies a time delta in seconds to offset the captions from the source file.
        public let timeDelta: Int32?
        public let convert608To708: FileSourceConvert608To708?

        public init(sourceFile: String? = nil, timeDelta: Int32? = nil, convert608To708: FileSourceConvert608To708? = nil) {
            self.sourceFile = sourceFile
            self.timeDelta = timeDelta
            self.convert608To708 = convert608To708
        }

        private enum CodingKeys: String, CodingKey {
            case sourceFile = "sourceFile"
            case timeDelta = "timeDelta"
            case convert608To708 = "convert608To708"
        }
    }

    public enum Mpeg2InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .body(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of endpoints.
        public let nextToken: String?
        /// Optional. Max number of endpoints, up to twenty, that will be returned at one time.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public enum Mpeg2FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum HlsSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public enum TimedMetadata: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H264TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ColorSpace: String, CustomStringConvertible, Codable {
        case follow = "FOLLOW"
        case rec601 = "REC_601"
        case rec709 = "REC_709"
        case hdr10 = "HDR10"
        case hlg2020 = "HLG_2020"
        public var description: String { return self.rawValue }
    }

    public struct Mp2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer)
        ]
        /// Average bitrate in bits/second.
        public let bitrate: Int32?
        /// Set Channels to specify the number of channels in this output audio track. Choosing Mono in the console will give you 1 output channel; choosing Stereo will give you 2. In the API, valid values are 1 and 2.
        public let channels: Int32?
        /// Sample rate in hz.
        public let sampleRate: Int32?

        public init(bitrate: Int32? = nil, channels: Int32? = nil, sampleRate: Int32? = nil) {
            self.bitrate = bitrate
            self.channels = channels
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case bitrate = "bitrate"
            case channels = "channels"
            case sampleRate = "sampleRate"
        }
    }

    public struct AudioCodecSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Eac3Settings", location: .body(locationName: "eac3Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "AiffSettings", location: .body(locationName: "aiffSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Codec", location: .body(locationName: "codec"), required: false, type: .enum), 
            AWSShapeMember(label: "Ac3Settings", location: .body(locationName: "ac3Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "WavSettings", location: .body(locationName: "wavSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Mp2Settings", location: .body(locationName: "mp2Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "AacSettings", location: .body(locationName: "aacSettings"), required: false, type: .structure)
        ]
        public let eac3Settings: Eac3Settings?
        public let aiffSettings: AiffSettings?
        public let codec: AudioCodec?
        public let ac3Settings: Ac3Settings?
        public let wavSettings: WavSettings?
        public let mp2Settings: Mp2Settings?
        public let aacSettings: AacSettings?

        public init(eac3Settings: Eac3Settings? = nil, aiffSettings: AiffSettings? = nil, codec: AudioCodec? = nil, ac3Settings: Ac3Settings? = nil, wavSettings: WavSettings? = nil, mp2Settings: Mp2Settings? = nil, aacSettings: AacSettings? = nil) {
            self.eac3Settings = eac3Settings
            self.aiffSettings = aiffSettings
            self.codec = codec
            self.ac3Settings = ac3Settings
            self.wavSettings = wavSettings
            self.mp2Settings = mp2Settings
            self.aacSettings = aacSettings
        }

        private enum CodingKeys: String, CodingKey {
            case eac3Settings = "eac3Settings"
            case aiffSettings = "aiffSettings"
            case codec = "codec"
            case ac3Settings = "ac3Settings"
            case wavSettings = "wavSettings"
            case mp2Settings = "mp2Settings"
            case aacSettings = "aacSettings"
        }
    }

    public enum HlsManifestCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct GetQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the queue.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct NoiseReducerFilterSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Strength", location: .body(locationName: "strength"), required: false, type: .integer)
        ]
        /// Relative strength of noise reducing filter. Higher values produce stronger filtering.
        public let strength: Int32?

        public init(strength: Int32? = nil) {
            self.strength = strength
        }

        private enum CodingKeys: String, CodingKey {
            case strength = "strength"
        }
    }

    public enum H265TemporalIds: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AacRawFormat: String, CustomStringConvertible, Codable {
        case latmLoas = "LATM_LOAS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H264RepeatPps: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct ListJobTemplatesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplates", location: .body(locationName: "jobTemplates"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of job templates.
        public let nextToken: String?
        /// List of Job templates.
        public let jobTemplates: [JobTemplate]?

        public init(nextToken: String? = nil, jobTemplates: [JobTemplate]? = nil) {
            self.nextToken = nextToken
            self.jobTemplates = jobTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case jobTemplates = "jobTemplates"
        }
    }

    public struct EmbeddedSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Source608ChannelNumber", location: .body(locationName: "source608ChannelNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Convert608To708", location: .body(locationName: "convert608To708"), required: false, type: .enum), 
            AWSShapeMember(label: "Source608TrackNumber", location: .body(locationName: "source608TrackNumber"), required: false, type: .integer)
        ]
        /// Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        public let source608ChannelNumber: Int32?
        public let convert608To708: EmbeddedConvert608To708?
        /// Specifies the video track index used for extracting captions. The system only supports one input video track, so this should always be set to '1'.
        public let source608TrackNumber: Int32?

        public init(source608ChannelNumber: Int32? = nil, convert608To708: EmbeddedConvert608To708? = nil, source608TrackNumber: Int32? = nil) {
            self.source608ChannelNumber = source608ChannelNumber
            self.convert608To708 = convert608To708
            self.source608TrackNumber = source608TrackNumber
        }

        private enum CodingKeys: String, CodingKey {
            case source608ChannelNumber = "source608ChannelNumber"
            case convert608To708 = "convert608To708"
            case source608TrackNumber = "source608TrackNumber"
        }
    }

    public enum ScalingBehavior: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case stretchToOutput = "STRETCH_TO_OUTPUT"
        public var description: String { return self.rawValue }
    }

    public struct ExceptionBody: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", location: .body(locationName: "message"), required: false, type: .string)
        ]
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public enum DvbSubtitleOutlineColor: String, CustomStringConvertible, Codable {
        case black = "BLACK"
        case white = "WHITE"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable {
        case f4v = "F4V"
        case ismv = "ISMV"
        case m2ts = "M2TS"
        case m3u8 = "M3U8"
        case mov = "MOV"
        case mp4 = "MP4"
        case mpd = "MPD"
        case mxf = "MXF"
        case raw = "RAW"
        public var description: String { return self.rawValue }
    }

    public enum OutputGroupType: String, CustomStringConvertible, Codable {
        case hlsGroupSettings = "HLS_GROUP_SETTINGS"
        case dashIsoGroupSettings = "DASH_ISO_GROUP_SETTINGS"
        case fileGroupSettings = "FILE_GROUP_SETTINGS"
        case msSmoothGroupSettings = "MS_SMOOTH_GROUP_SETTINGS"
        public var description: String { return self.rawValue }
    }

    public enum InputDeblockFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct NielsenConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DistributorId", location: .body(locationName: "distributorId"), required: false, type: .string), 
            AWSShapeMember(label: "BreakoutCode", location: .body(locationName: "breakoutCode"), required: false, type: .integer)
        ]
        /// Use Distributor ID (DistributorID) to specify the distributor ID that is assigned to your organization by Neilsen.
        public let distributorId: String?
        /// Use Nielsen Configuration (NielsenConfiguration) to set the Nielsen measurement system breakout code. Supported values are 0, 3, 7, and 9.
        public let breakoutCode: Int32?

        public init(distributorId: String? = nil, breakoutCode: Int32? = nil) {
            self.distributorId = distributorId
            self.breakoutCode = breakoutCode
        }

        private enum CodingKeys: String, CodingKey {
            case distributorId = "distributorId"
            case breakoutCode = "breakoutCode"
        }
    }

    public struct H265Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FlickerAdaptiveQuantization", location: .body(locationName: "flickerAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "GopBReference", location: .body(locationName: "gopBReference"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "Slices", location: .body(locationName: "slices"), required: false, type: .integer), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberReferenceFrames", location: .body(locationName: "numberReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "TemporalIds", location: .body(locationName: "temporalIds"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleAdaptiveOffsetFilterMode", location: .body(locationName: "sampleAdaptiveOffsetFilterMode"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "AlternateTransferFunctionSei", location: .body(locationName: "alternateTransferFunctionSei"), required: false, type: .enum), 
            AWSShapeMember(label: "Tiles", location: .body(locationName: "tiles"), required: false, type: .enum), 
            AWSShapeMember(label: "UnregisteredSeiTimecode", location: .body(locationName: "unregisteredSeiTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum)
        ]
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        public let parControl: H265ParControl?
        public let flickerAdaptiveQuantization: H265FlickerAdaptiveQuantization?
        public let gopBReference: H265GopBReference?
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures.
        public let slices: Int32?
        /// Size of buffer (HRD buffer model). Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m.
        public let hrdBufferSize: Int32?
        public let spatialAdaptiveQuantization: H265SpatialAdaptiveQuantization?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let codecProfile: H265CodecProfile?
        public let qualityTuningLevel: H265QualityTuningLevel?
        public let codecLevel: H265CodecLevel?
        /// Maximum bitrate in bits/second (for VBR mode only). Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m.
        public let maxBitrate: Int32?
        public let adaptiveQuantization: H265AdaptiveQuantization?
        public let gopSizeUnits: H265GopSizeUnits?
        public let sceneChangeDetect: H265SceneChangeDetect?
        public let slowPal: H265SlowPal?
        public let temporalAdaptiveQuantization: H265TemporalAdaptiveQuantization?
        /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
        public let numberReferenceFrames: Int32?
        public let rateControlMode: H265RateControlMode?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let framerateConversionAlgorithm: H265FramerateConversionAlgorithm?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        /// Average bitrate in bits/second. Required for VBR, CBR, and ABR. Five megabits can be entered as 5000000 or 5m. Five hundred kilobits can be entered as 500000 or 0.5m. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let interlaceMode: H265InterlaceMode?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let temporalIds: H265TemporalIds?
        public let sampleAdaptiveOffsetFilterMode: H265SampleAdaptiveOffsetFilterMode?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        public let alternateTransferFunctionSei: H265AlternateTransferFunctionSei?
        public let tiles: H265Tiles?
        public let unregisteredSeiTimecode: H265UnregisteredSeiTimecode?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        public let framerateControl: H265FramerateControl?
        public let telecine: H265Telecine?

        public init(numberBFramesBetweenReferenceFrames: Int32? = nil, parControl: H265ParControl? = nil, flickerAdaptiveQuantization: H265FlickerAdaptiveQuantization? = nil, gopBReference: H265GopBReference? = nil, framerateNumerator: Int32? = nil, slices: Int32? = nil, hrdBufferSize: Int32? = nil, spatialAdaptiveQuantization: H265SpatialAdaptiveQuantization? = nil, parNumerator: Int32? = nil, codecProfile: H265CodecProfile? = nil, qualityTuningLevel: H265QualityTuningLevel? = nil, codecLevel: H265CodecLevel? = nil, maxBitrate: Int32? = nil, adaptiveQuantization: H265AdaptiveQuantization? = nil, gopSizeUnits: H265GopSizeUnits? = nil, sceneChangeDetect: H265SceneChangeDetect? = nil, slowPal: H265SlowPal? = nil, temporalAdaptiveQuantization: H265TemporalAdaptiveQuantization? = nil, numberReferenceFrames: Int32? = nil, rateControlMode: H265RateControlMode? = nil, framerateDenominator: Int32? = nil, framerateConversionAlgorithm: H265FramerateConversionAlgorithm? = nil, parDenominator: Int32? = nil, gopClosedCadence: Int32? = nil, bitrate: Int32? = nil, interlaceMode: H265InterlaceMode? = nil, minIInterval: Int32? = nil, temporalIds: H265TemporalIds? = nil, sampleAdaptiveOffsetFilterMode: H265SampleAdaptiveOffsetFilterMode? = nil, hrdBufferInitialFillPercentage: Int32? = nil, alternateTransferFunctionSei: H265AlternateTransferFunctionSei? = nil, tiles: H265Tiles? = nil, unregisteredSeiTimecode: H265UnregisteredSeiTimecode? = nil, gopSize: Double? = nil, framerateControl: H265FramerateControl? = nil, telecine: H265Telecine? = nil) {
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.parControl = parControl
            self.flickerAdaptiveQuantization = flickerAdaptiveQuantization
            self.gopBReference = gopBReference
            self.framerateNumerator = framerateNumerator
            self.slices = slices
            self.hrdBufferSize = hrdBufferSize
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.parNumerator = parNumerator
            self.codecProfile = codecProfile
            self.qualityTuningLevel = qualityTuningLevel
            self.codecLevel = codecLevel
            self.maxBitrate = maxBitrate
            self.adaptiveQuantization = adaptiveQuantization
            self.gopSizeUnits = gopSizeUnits
            self.sceneChangeDetect = sceneChangeDetect
            self.slowPal = slowPal
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.numberReferenceFrames = numberReferenceFrames
            self.rateControlMode = rateControlMode
            self.framerateDenominator = framerateDenominator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.parDenominator = parDenominator
            self.gopClosedCadence = gopClosedCadence
            self.bitrate = bitrate
            self.interlaceMode = interlaceMode
            self.minIInterval = minIInterval
            self.temporalIds = temporalIds
            self.sampleAdaptiveOffsetFilterMode = sampleAdaptiveOffsetFilterMode
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.alternateTransferFunctionSei = alternateTransferFunctionSei
            self.tiles = tiles
            self.unregisteredSeiTimecode = unregisteredSeiTimecode
            self.gopSize = gopSize
            self.framerateControl = framerateControl
            self.telecine = telecine
        }

        private enum CodingKeys: String, CodingKey {
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case parControl = "parControl"
            case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
            case gopBReference = "gopBReference"
            case framerateNumerator = "framerateNumerator"
            case slices = "slices"
            case hrdBufferSize = "hrdBufferSize"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case parNumerator = "parNumerator"
            case codecProfile = "codecProfile"
            case qualityTuningLevel = "qualityTuningLevel"
            case codecLevel = "codecLevel"
            case maxBitrate = "maxBitrate"
            case adaptiveQuantization = "adaptiveQuantization"
            case gopSizeUnits = "gopSizeUnits"
            case sceneChangeDetect = "sceneChangeDetect"
            case slowPal = "slowPal"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case numberReferenceFrames = "numberReferenceFrames"
            case rateControlMode = "rateControlMode"
            case framerateDenominator = "framerateDenominator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case parDenominator = "parDenominator"
            case gopClosedCadence = "gopClosedCadence"
            case bitrate = "bitrate"
            case interlaceMode = "interlaceMode"
            case minIInterval = "minIInterval"
            case temporalIds = "temporalIds"
            case sampleAdaptiveOffsetFilterMode = "sampleAdaptiveOffsetFilterMode"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case alternateTransferFunctionSei = "alternateTransferFunctionSei"
            case tiles = "tiles"
            case unregisteredSeiTimecode = "unregisteredSeiTimecode"
            case gopSize = "gopSize"
            case framerateControl = "framerateControl"
            case telecine = "telecine"
        }
    }

    public enum H265AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case higher = "HIGHER"
        case max = "MAX"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleAlignment: String, CustomStringConvertible, Codable {
        case centered = "CENTERED"
        case left = "LEFT"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public enum HlsTimedMetadataId3Frame: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case priv = "PRIV"
        case tdrl = "TDRL"
        public var description: String { return self.rawValue }
    }

    public struct CreateQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum AacRateControlMode: String, CustomStringConvertible, Codable {
        case cbr = "CBR"
        case vbr = "VBR"
        public var description: String { return self.rawValue }
    }

    public enum M2tsPcrControl: String, CustomStringConvertible, Codable {
        case pcrEveryPesPacket = "PCR_EVERY_PES_PACKET"
        case configuredPcrPeriod = "CONFIGURED_PCR_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum Ac3MetadataControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum H265FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum H265AlternateTransferFunctionSei: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeinterlacerMode: String, CustomStringConvertible, Codable {
        case deinterlace = "DEINTERLACE"
        case inverseTelecine = "INVERSE_TELECINE"
        case adaptive = "ADAPTIVE"
        public var description: String { return self.rawValue }
    }

    public struct DeleteJobTemplateResponse: AWSShape {

    }

    public enum MovClapAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct Queue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        public let status: QueueStatus?
        /// The timestamp in epoch seconds for queue creation.
        public let createdAt: TimeStamp?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// A name you create for each queue. Each name must be unique within your account.
        public let name: String?
        /// The timestamp in epoch seconds when the queue was last updated.
        public let lastUpdated: TimeStamp?
        /// A queue can be of two types: system or custom. System or built-in queues can’t be modified or deleted by the user.
        public let `type`: `Type`?
        /// An optional description you create for each queue.
        public let description: String?

        public init(status: QueueStatus? = nil, createdAt: TimeStamp? = nil, arn: String? = nil, name: String? = nil, lastUpdated: TimeStamp? = nil, type: `Type`? = nil, description: String? = nil) {
            self.status = status
            self.createdAt = createdAt
            self.arn = arn
            self.name = name
            self.lastUpdated = lastUpdated
            self.`type` = `type`
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case createdAt = "createdAt"
            case arn = "arn"
            case name = "name"
            case lastUpdated = "lastUpdated"
            case `type` = "type"
            case description = "description"
        }
    }

    public enum ProresInterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct TeletextDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageNumber", location: .body(locationName: "pageNumber"), required: false, type: .string)
        ]
        /// Set pageNumber to the Teletext page number for the destination captions for this output.  This value must be a three-digit hexadecimal string; strings ending in -FF are invalid. If you are passing through the entire set of Teletext data, do not use this field.
        public let pageNumber: String?

        public init(pageNumber: String? = nil) {
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "pageNumber"
        }
    }

    public enum HlsIFrameOnlyManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct FileGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string)
        ]
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?

        public init(destination: String? = nil) {
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
        }
    }

    public struct ListQueuesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queues", location: .body(locationName: "queues"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        /// List of queues
        public let queues: [Queue]?
        /// Use this string to request the next batch of queues.
        public let nextToken: String?

        public init(queues: [Queue]? = nil, nextToken: String? = nil) {
            self.queues = queues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case queues = "queues"
            case nextToken = "nextToken"
        }
    }

    public struct Id3Insertion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id3", location: .body(locationName: "id3"), required: false, type: .string), 
            AWSShapeMember(label: "Timecode", location: .body(locationName: "timecode"), required: false, type: .string)
        ]
        /// Use ID3 tag (Id3) to provide a tag value in base64-encode format.
        public let id3: String?
        /// Provide a Timecode (TimeCode) in HH:MM:SS:FF or HH:MM:SS;FF format.
        public let timecode: String?

        public init(id3: String? = nil, timecode: String? = nil) {
            self.id3 = id3
            self.timecode = timecode
        }

        private enum CodingKeys: String, CodingKey {
            case id3 = "id3"
            case timecode = "timecode"
        }
    }

    public enum MovCslgAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum M2tsEbpAudioInterval: String, CustomStringConvertible, Codable {
        case videoAndFixedIntervals = "VIDEO_AND_FIXED_INTERVALS"
        case videoInterval = "VIDEO_INTERVAL"
        public var description: String { return self.rawValue }
    }

    public struct Job: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Timing", location: .body(locationName: "timing"), required: false, type: .structure), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "OutputGroupDetails", location: .body(locationName: "outputGroupDetails"), required: false, type: .list), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "ErrorMessage", location: .body(locationName: "errorMessage"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", location: .body(locationName: "errorCode"), required: false, type: .integer), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Role", location: .body(locationName: "role"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "UserMetadata", location: .body(locationName: "userMetadata"), required: false, type: .map)
        ]
        public let timing: Timing?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// List of output group details
        public let outputGroupDetails: [OutputGroupDetail]?
        public let settings: JobSettings?
        /// Error message of Job
        public let errorMessage: String?
        /// The job template that the job is created from, if it is created from a job template.
        public let jobTemplate: String?
        /// Error code for the job
        public let errorCode: Int32?
        /// A portion of the job's ARN, unique within your AWS Elemental MediaConvert resources
        public let id: String?
        public let status: JobStatus?
        /// The time, in Unix epoch format in seconds, when the job got created.
        public let createdAt: TimeStamp?
        /// The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html
        public let role: String?
        /// Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
        public let queue: String?
        /// User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.
        public let userMetadata: [String: String]?

        public init(timing: Timing? = nil, arn: String? = nil, outputGroupDetails: [OutputGroupDetail]? = nil, settings: JobSettings? = nil, errorMessage: String? = nil, jobTemplate: String? = nil, errorCode: Int32? = nil, id: String? = nil, status: JobStatus? = nil, createdAt: TimeStamp? = nil, role: String? = nil, queue: String? = nil, userMetadata: [String: String]? = nil) {
            self.timing = timing
            self.arn = arn
            self.outputGroupDetails = outputGroupDetails
            self.settings = settings
            self.errorMessage = errorMessage
            self.jobTemplate = jobTemplate
            self.errorCode = errorCode
            self.id = id
            self.status = status
            self.createdAt = createdAt
            self.role = role
            self.queue = queue
            self.userMetadata = userMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case timing = "timing"
            case arn = "arn"
            case outputGroupDetails = "outputGroupDetails"
            case settings = "settings"
            case errorMessage = "errorMessage"
            case jobTemplate = "jobTemplate"
            case errorCode = "errorCode"
            case id = "id"
            case status = "status"
            case createdAt = "createdAt"
            case role = "role"
            case queue = "queue"
            case userMetadata = "userMetadata"
        }
    }

    public enum Mpeg2CodecProfile: String, CustomStringConvertible, Codable {
        case main = "MAIN"
        case profile422 = "PROFILE_422"
        public var description: String { return self.rawValue }
    }

    public struct HlsGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputSelection", location: .body(locationName: "outputSelection"), required: false, type: .enum), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "StreamInfResolution", location: .body(locationName: "streamInfResolution"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestCompression", location: .body(locationName: "manifestCompression"), required: false, type: .enum), 
            AWSShapeMember(label: "DirectoryStructure", location: .body(locationName: "directoryStructure"), required: false, type: .enum), 
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .list), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ClientCache", location: .body(locationName: "clientCache"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgramDateTimePeriod", location: .body(locationName: "programDateTimePeriod"), required: false, type: .integer), 
            AWSShapeMember(label: "TimestampDeltaMilliseconds", location: .body(locationName: "timestampDeltaMilliseconds"), required: false, type: .integer), 
            AWSShapeMember(label: "CaptionLanguageSetting", location: .body(locationName: "captionLanguageSetting"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "ManifestDurationFormat", location: .body(locationName: "manifestDurationFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionLanguageMappings", location: .body(locationName: "captionLanguageMappings"), required: false, type: .list), 
            AWSShapeMember(label: "TimedMetadataId3Period", location: .body(locationName: "timedMetadataId3Period"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramDateTime", location: .body(locationName: "programDateTime"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecSpecification", location: .body(locationName: "codecSpecification"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentsPerSubdirectory", location: .body(locationName: "segmentsPerSubdirectory"), required: false, type: .integer), 
            AWSShapeMember(label: "TimedMetadataId3Frame", location: .body(locationName: "timedMetadataId3Frame"), required: false, type: .enum), 
            AWSShapeMember(label: "MinSegmentLength", location: .body(locationName: "minSegmentLength"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: false, type: .integer)
        ]
        public let outputSelection: HlsOutputSelection?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        public let streamInfResolution: HlsStreamInfResolution?
        public let manifestCompression: HlsManifestCompression?
        public let directoryStructure: HlsDirectoryStructure?
        /// Choose one or more ad marker types to pass SCTE35 signals through to this group of Apple HLS outputs.
        public let adMarkers: [HlsAdMarkers]?
        /// A partial URI prefix that will be prepended to each output in the media .m3u8 file. Can be used if base manifest is delivered from a different URL than the main .m3u8 file.
        public let baseUrl: String?
        public let clientCache: HlsClientCache?
        public let segmentControl: HlsSegmentControl?
        /// Period of insertion of EXT-X-PROGRAM-DATE-TIME entry, in seconds.
        public let programDateTimePeriod: Int32?
        /// Provides an extra millisecond delta offset to fine tune the timestamps.
        public let timestampDeltaMilliseconds: Int32?
        public let captionLanguageSetting: HlsCaptionLanguageSetting?
        /// DRM settings.
        public let encryption: HlsEncryptionSettings?
        public let manifestDurationFormat: HlsManifestDurationFormat?
        /// Language to be used on Caption outputs
        public let captionLanguageMappings: [HlsCaptionLanguageMapping]?
        /// Timed Metadata interval in seconds.
        public let timedMetadataId3Period: Int32?
        public let programDateTime: HlsProgramDateTime?
        public let codecSpecification: HlsCodecSpecification?
        /// Number of segments to write to a subdirectory before starting a new one. directoryStructure must be SINGLE_DIRECTORY for this setting to have an effect.
        public let segmentsPerSubdirectory: Int32?
        public let timedMetadataId3Frame: HlsTimedMetadataId3Frame?
        /// When set, Minimum Segment Size is enforced by looking ahead and back within the specified range for a nearby avail and extending the segment size if needed.
        public let minSegmentLength: Int32?
        /// Length of MPEG-2 Transport Stream segments to create (in seconds). Note that segments will end on the next keyframe after this number of seconds, so actual segment length may be longer.
        public let segmentLength: Int32?

        public init(outputSelection: HlsOutputSelection? = nil, destination: String? = nil, streamInfResolution: HlsStreamInfResolution? = nil, manifestCompression: HlsManifestCompression? = nil, directoryStructure: HlsDirectoryStructure? = nil, adMarkers: [HlsAdMarkers]? = nil, baseUrl: String? = nil, clientCache: HlsClientCache? = nil, segmentControl: HlsSegmentControl? = nil, programDateTimePeriod: Int32? = nil, timestampDeltaMilliseconds: Int32? = nil, captionLanguageSetting: HlsCaptionLanguageSetting? = nil, encryption: HlsEncryptionSettings? = nil, manifestDurationFormat: HlsManifestDurationFormat? = nil, captionLanguageMappings: [HlsCaptionLanguageMapping]? = nil, timedMetadataId3Period: Int32? = nil, programDateTime: HlsProgramDateTime? = nil, codecSpecification: HlsCodecSpecification? = nil, segmentsPerSubdirectory: Int32? = nil, timedMetadataId3Frame: HlsTimedMetadataId3Frame? = nil, minSegmentLength: Int32? = nil, segmentLength: Int32? = nil) {
            self.outputSelection = outputSelection
            self.destination = destination
            self.streamInfResolution = streamInfResolution
            self.manifestCompression = manifestCompression
            self.directoryStructure = directoryStructure
            self.adMarkers = adMarkers
            self.baseUrl = baseUrl
            self.clientCache = clientCache
            self.segmentControl = segmentControl
            self.programDateTimePeriod = programDateTimePeriod
            self.timestampDeltaMilliseconds = timestampDeltaMilliseconds
            self.captionLanguageSetting = captionLanguageSetting
            self.encryption = encryption
            self.manifestDurationFormat = manifestDurationFormat
            self.captionLanguageMappings = captionLanguageMappings
            self.timedMetadataId3Period = timedMetadataId3Period
            self.programDateTime = programDateTime
            self.codecSpecification = codecSpecification
            self.segmentsPerSubdirectory = segmentsPerSubdirectory
            self.timedMetadataId3Frame = timedMetadataId3Frame
            self.minSegmentLength = minSegmentLength
            self.segmentLength = segmentLength
        }

        private enum CodingKeys: String, CodingKey {
            case outputSelection = "outputSelection"
            case destination = "destination"
            case streamInfResolution = "streamInfResolution"
            case manifestCompression = "manifestCompression"
            case directoryStructure = "directoryStructure"
            case adMarkers = "adMarkers"
            case baseUrl = "baseUrl"
            case clientCache = "clientCache"
            case segmentControl = "segmentControl"
            case programDateTimePeriod = "programDateTimePeriod"
            case timestampDeltaMilliseconds = "timestampDeltaMilliseconds"
            case captionLanguageSetting = "captionLanguageSetting"
            case encryption = "encryption"
            case manifestDurationFormat = "manifestDurationFormat"
            case captionLanguageMappings = "captionLanguageMappings"
            case timedMetadataId3Period = "timedMetadataId3Period"
            case programDateTime = "programDateTime"
            case codecSpecification = "codecSpecification"
            case segmentsPerSubdirectory = "segmentsPerSubdirectory"
            case timedMetadataId3Frame = "timedMetadataId3Frame"
            case minSegmentLength = "minSegmentLength"
            case segmentLength = "segmentLength"
        }
    }

    public enum AudioNormalizationAlgorithmControl: String, CustomStringConvertible, Codable {
        case correctAudio = "CORRECT_AUDIO"
        case measureOnly = "MEASURE_ONLY"
        public var description: String { return self.rawValue }
    }

    public struct AudioDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioNormalizationSettings", location: .body(locationName: "audioNormalizationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "LanguageCodeControl", location: .body(locationName: "languageCodeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioTypeControl", location: .body(locationName: "audioTypeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioType", location: .body(locationName: "audioType"), required: false, type: .integer), 
            AWSShapeMember(label: "StreamName", location: .body(locationName: "streamName"), required: false, type: .string), 
            AWSShapeMember(label: "RemixSettings", location: .body(locationName: "remixSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioSourceName", location: .body(locationName: "audioSourceName"), required: false, type: .string), 
            AWSShapeMember(label: "CodecSettings", location: .body(locationName: "codecSettings"), required: false, type: .structure)
        ]
        /// Settings for Audio Normalization
        public let audioNormalizationSettings: AudioNormalizationSettings?
        /// Indicates the language of the audio output track. The ISO 639 language specified in the 'Language Code' drop down will be used when 'Follow Input Language Code' is not selected or when 'Follow Input Language Code' is selected but there is no ISO 639 language code specified by the input.
        public let languageCode: LanguageCode?
        public let languageCodeControl: AudioLanguageCodeControl?
        public let audioTypeControl: AudioTypeControl?
        /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
        public let audioType: Int32?
        /// Used for MS Smooth and Apple HLS outputs. Indicates the name displayed by the player (eg. English, or Director Commentary). Alphanumeric characters, spaces, and underscore are legal.
        public let streamName: String?
        /// Advanced audio remixing settings.
        public let remixSettings: RemixSettings?
        /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
        public let audioSourceName: String?
        public let codecSettings: AudioCodecSettings?

        public init(audioNormalizationSettings: AudioNormalizationSettings? = nil, languageCode: LanguageCode? = nil, languageCodeControl: AudioLanguageCodeControl? = nil, audioTypeControl: AudioTypeControl? = nil, audioType: Int32? = nil, streamName: String? = nil, remixSettings: RemixSettings? = nil, audioSourceName: String? = nil, codecSettings: AudioCodecSettings? = nil) {
            self.audioNormalizationSettings = audioNormalizationSettings
            self.languageCode = languageCode
            self.languageCodeControl = languageCodeControl
            self.audioTypeControl = audioTypeControl
            self.audioType = audioType
            self.streamName = streamName
            self.remixSettings = remixSettings
            self.audioSourceName = audioSourceName
            self.codecSettings = codecSettings
        }

        private enum CodingKeys: String, CodingKey {
            case audioNormalizationSettings = "audioNormalizationSettings"
            case languageCode = "languageCode"
            case languageCodeControl = "languageCodeControl"
            case audioTypeControl = "audioTypeControl"
            case audioType = "audioType"
            case streamName = "streamName"
            case remixSettings = "remixSettings"
            case audioSourceName = "audioSourceName"
            case codecSettings = "codecSettings"
        }
    }

    public enum TimecodeSource: String, CustomStringConvertible, Codable {
        case embedded = "EMBEDDED"
        case zerobased = "ZEROBASED"
        case specifiedstart = "SPECIFIEDSTART"
        public var description: String { return self.rawValue }
    }

    public struct Timing: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .timestamp), 
            AWSShapeMember(label: "FinishTime", location: .body(locationName: "finishTime"), required: false, type: .timestamp), 
            AWSShapeMember(label: "SubmitTime", location: .body(locationName: "submitTime"), required: false, type: .timestamp)
        ]
        /// The time, in Unix epoch format, that transcoding for the job began.
        public let startTime: TimeStamp?
        /// The time, in Unix epoch format, that the transcoding job finished
        public let finishTime: TimeStamp?
        /// The time, in Unix epoch format, that you submitted the job.
        public let submitTime: TimeStamp?

        public init(startTime: TimeStamp? = nil, finishTime: TimeStamp? = nil, submitTime: TimeStamp? = nil) {
            self.startTime = startTime
            self.finishTime = finishTime
            self.submitTime = submitTime
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "startTime"
            case finishTime = "finishTime"
            case submitTime = "submitTime"
        }
    }

}