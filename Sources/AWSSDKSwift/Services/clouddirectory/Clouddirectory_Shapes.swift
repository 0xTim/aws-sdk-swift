// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Clouddirectory {

    public struct FacetAttribute: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A facet attribute consists of either a definition or a reference. This structure contains the attribute definition. See Attribute References for more information.
        public var attributeDefinition: FacetAttributeDefinition? = nil
        /// Attribute reference associated with the attribute. See Attribute References for more information.
        public var attributeReference: FacetAttributeReference? = nil
        /// The name of the facet attribute.
        public var name: String = ""
        /// The required behavior of the FacetAttribute.
        public var requiredBehavior: String? = nil

        public init() {}

        public init(attributeDefinition: FacetAttributeDefinition? = nil, attributeReference: FacetAttributeReference? = nil, name: String, requiredBehavior: String? = nil) {
            self.attributeDefinition = attributeDefinition
            self.attributeReference = attributeReference
            self.name = name
            self.requiredBehavior = requiredBehavior
        }

        public init(dictionary: [String: Any]) throws {
            if let attributeDefinition = dictionary["AttributeDefinition"] as? [String: Any] { self.attributeDefinition = try Clouddirectory.FacetAttributeDefinition(dictionary: attributeDefinition) }
            if let attributeReference = dictionary["AttributeReference"] as? [String: Any] { self.attributeReference = try Clouddirectory.FacetAttributeReference(dictionary: attributeReference) }
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            self.requiredBehavior = dictionary["RequiredBehavior"] as? String
        }
    }

    public struct TagResourceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN of the resource. Tagging is only supported for directories.
        public var resourceArn: String = ""
        /// List of tag key value pairs.
        public var tags: [Tag] = []

        public init() {}

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["ResourceArn"] as? String else { throw InitializableError.missingRequiredParam("ResourceArn") }
            self.resourceArn = resourceArn
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
        }
    }

    public struct UpdateSchemaResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN associated with the updated schema. For more information, see arns.
        public var schemaArn: String? = nil

        public init() {}

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            self.schemaArn = dictionary["SchemaArn"] as? String
        }
    }

    public struct Rule: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of attribute validation rule.
        public var type: String? = nil
        /// Min and max parameters associated with the rule.
        public var parameters: [String: String]? = nil

        public init() {}

        public init(type: String? = nil, parameters: [String: String]? = nil) {
            self.type = type
            self.parameters = parameters
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["Type"] as? String
            if let parameters = dictionary["Parameters"] as? [String: String] {
                self.parameters = parameters
            }
        }
    }

    public struct GetDirectoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// The ARN of the directory.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ListObjectChildrenResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Children structure, which is a map with key as the LinkName and ObjectIdentifier as the value.
        public var children: [String: String]? = nil

        public init() {}

        public init(nextToken: String? = nil, children: [String: String]? = nil) {
            self.nextToken = nextToken
            self.children = children
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let children = dictionary["Children"] as? [String: String] {
                self.children = children
            }
        }
    }

    public struct AddFacetToObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct TypedAttributeValueRange: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The attribute value to terminate the range at.
        public var endValue: TypedAttributeValue? = nil
        /// Inclusive or exclusive range end.
        public var endMode: String = ""
        /// The value to start the range at.
        public var startValue: TypedAttributeValue? = nil
        /// Inclusive or exclusive range start.
        public var startMode: String = ""

        public init() {}

        public init(endValue: TypedAttributeValue? = nil, endMode: String, startValue: TypedAttributeValue? = nil, startMode: String) {
            self.endValue = endValue
            self.endMode = endMode
            self.startValue = startValue
            self.startMode = startMode
        }

        public init(dictionary: [String: Any]) throws {
            if let endValue = dictionary["EndValue"] as? [String: Any] { self.endValue = try Clouddirectory.TypedAttributeValue(dictionary: endValue) }
            guard let endMode = dictionary["EndMode"] as? String else { throw InitializableError.missingRequiredParam("EndMode") }
            self.endMode = endMode
            if let startValue = dictionary["StartValue"] as? [String: Any] { self.startValue = try Clouddirectory.TypedAttributeValue(dictionary: startValue) }
            guard let startMode = dictionary["StartMode"] as? String else { throw InitializableError.missingRequiredParam("StartMode") }
            self.startMode = startMode
        }
    }

    public struct GetSchemaAsJsonResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The JSON representation of the schema document.
        public var document: String? = nil
        /// The name of the retrieved schema.
        public var name: String? = nil

        public init() {}

        public init(document: String? = nil, name: String? = nil) {
            self.document = document
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.document = dictionary["Document"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct AddFacetToObjectRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// ARN associated with the Directory where the object resides. For more information, see arns.
        public var directoryArn: String = ""
        /// Identifiers for the facet that you are adding to the object.
        public var schemaFacet: SchemaFacet = SchemaFacet()
        /// Attributes on the facet you are adding to the object.
        public var objectAttributeList: [AttributeKeyAndValue]? = nil
        /// A reference to the object you are adding the specified facet to.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(directoryArn: String, schemaFacet: SchemaFacet, objectAttributeList: [AttributeKeyAndValue]? = nil, objectReference: ObjectReference) {
            self.directoryArn = directoryArn
            self.schemaFacet = schemaFacet
            self.objectAttributeList = objectAttributeList
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            guard let schemaFacet = dictionary["SchemaFacet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SchemaFacet") }
            self.schemaFacet = try Clouddirectory.SchemaFacet(dictionary: schemaFacet)
            if let objectAttributeList = dictionary["ObjectAttributeList"] as? [[String: Any]] {
                self.objectAttributeList = try objectAttributeList.map({ try AttributeKeyAndValue(dictionary: $0) })
            }
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct ListDevelopmentSchemaArnsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The maximum number of results to retrieve.
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct Directory: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The date and time when the directory was created.
        public var creationDateTime: Date? = nil
        /// ARN associated with the directory. For more information, see arns.
        public var directoryArn: String? = nil
        /// The name of the directory.
        public var name: String? = nil
        /// The state of the directory. Can be either Enabled, Disabled, or Deleted.
        public var state: String? = nil

        public init() {}

        public init(creationDateTime: Date? = nil, directoryArn: String? = nil, name: String? = nil, state: String? = nil) {
            self.creationDateTime = creationDateTime
            self.directoryArn = directoryArn
            self.name = name
            self.state = state
        }

        public init(dictionary: [String: Any]) throws {
            self.creationDateTime = dictionary["CreationDateTime"] as? Date
            self.directoryArn = dictionary["DirectoryArn"] as? String
            self.name = dictionary["Name"] as? String
            self.state = dictionary["State"] as? String
        }
    }

    public struct LookupPolicyResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType.
        public var policyToPathList: [PolicyToPath]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(policyToPathList: [PolicyToPath]? = nil, nextToken: String? = nil) {
            self.policyToPathList = policyToPathList
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let policyToPathList = dictionary["PolicyToPathList"] as? [[String: Any]] {
                self.policyToPathList = try policyToPathList.map({ try PolicyToPath(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct BatchRemoveFacetFromObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct CreateSchemaResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN associated with the schema. For more information, see arns.
        public var schemaArn: String? = nil

        public init() {}

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            self.schemaArn = dictionary["SchemaArn"] as? String
        }
    }

    public struct RemoveFacetFromObjectRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// The facet to remove.
        public var schemaFacet: SchemaFacet = SchemaFacet()
        /// A reference to the object to remove the facet from.
        public var objectReference: ObjectReference = ObjectReference()
        /// The ARN of the directory in which the object resides.
        public var directoryArn: String = ""

        public init() {}

        public init(schemaFacet: SchemaFacet, objectReference: ObjectReference, directoryArn: String) {
            self.schemaFacet = schemaFacet
            self.objectReference = objectReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaFacet = dictionary["SchemaFacet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SchemaFacet") }
            self.schemaFacet = try Clouddirectory.SchemaFacet(dictionary: schemaFacet)
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ObjectAttributeRange: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The range of attribute values being selected.
        public var range: TypedAttributeValueRange? = nil
        /// The key of the attribute the attribute range covers.
        public var attributeKey: AttributeKey? = nil

        public init() {}

        public init(range: TypedAttributeValueRange? = nil, attributeKey: AttributeKey? = nil) {
            self.range = range
            self.attributeKey = attributeKey
        }

        public init(dictionary: [String: Any]) throws {
            if let range = dictionary["Range"] as? [String: Any] { self.range = try Clouddirectory.TypedAttributeValueRange(dictionary: range) }
            if let attributeKey = dictionary["AttributeKey"] as? [String: Any] { self.attributeKey = try Clouddirectory.AttributeKey(dictionary: attributeKey) }
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Value associated with the tag.
        public var value: String? = nil
        /// Key associated with the tag.
        public var key: String? = nil

        public init() {}

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct BatchWriteOperationResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Result of an add facet to object batch operation.
        public var addFacetToObject: BatchAddFacetToObjectResponse? = nil
        /// Updates a given object’s attributes.
        public var updateObjectAttributes: BatchUpdateObjectAttributesResponse? = nil
        /// Detaches an object from a Directory.
        public var detachObject: BatchDetachObjectResponse? = nil
        /// Attaches an object to a Directory.
        public var attachObject: BatchAttachObjectResponse? = nil
        /// Creates an object in a Directory.
        public var createObject: BatchCreateObjectResponse? = nil
        /// Deletes an object in a Directory.
        public var deleteObject: BatchDeleteObjectResponse? = nil
        /// Result of a batch remove facet from object operation.
        public var removeFacetFromObject: BatchRemoveFacetFromObjectResponse? = nil

        public init() {}

        public init(addFacetToObject: BatchAddFacetToObjectResponse? = nil, updateObjectAttributes: BatchUpdateObjectAttributesResponse? = nil, detachObject: BatchDetachObjectResponse? = nil, attachObject: BatchAttachObjectResponse? = nil, createObject: BatchCreateObjectResponse? = nil, deleteObject: BatchDeleteObjectResponse? = nil, removeFacetFromObject: BatchRemoveFacetFromObjectResponse? = nil) {
            self.addFacetToObject = addFacetToObject
            self.updateObjectAttributes = updateObjectAttributes
            self.detachObject = detachObject
            self.attachObject = attachObject
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.removeFacetFromObject = removeFacetFromObject
        }

        public init(dictionary: [String: Any]) throws {
            if let addFacetToObject = dictionary["AddFacetToObject"] as? [String: Any] { self.addFacetToObject = try Clouddirectory.BatchAddFacetToObjectResponse(dictionary: addFacetToObject) }
            if let updateObjectAttributes = dictionary["UpdateObjectAttributes"] as? [String: Any] { self.updateObjectAttributes = try Clouddirectory.BatchUpdateObjectAttributesResponse(dictionary: updateObjectAttributes) }
            if let detachObject = dictionary["DetachObject"] as? [String: Any] { self.detachObject = try Clouddirectory.BatchDetachObjectResponse(dictionary: detachObject) }
            if let attachObject = dictionary["AttachObject"] as? [String: Any] { self.attachObject = try Clouddirectory.BatchAttachObjectResponse(dictionary: attachObject) }
            if let createObject = dictionary["CreateObject"] as? [String: Any] { self.createObject = try Clouddirectory.BatchCreateObjectResponse(dictionary: createObject) }
            if let deleteObject = dictionary["DeleteObject"] as? [String: Any] { self.deleteObject = try Clouddirectory.BatchDeleteObjectResponse(dictionary: deleteObject) }
            if let removeFacetFromObject = dictionary["RemoveFacetFromObject"] as? [String: Any] { self.removeFacetFromObject = try Clouddirectory.BatchRemoveFacetFromObjectResponse(dictionary: removeFacetFromObject) }
        }
    }

    public struct ApplySchemaRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Published schema ARN that needs to be copied. For more information, see arns.
        public var publishedSchemaArn: String = ""
        /// ARN associated with the Directory into which the schema is copied. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(publishedSchemaArn: String, directoryArn: String) {
            self.publishedSchemaArn = publishedSchemaArn
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let publishedSchemaArn = dictionary["PublishedSchemaArn"] as? String else { throw InitializableError.missingRequiredParam("PublishedSchemaArn") }
            self.publishedSchemaArn = publishedSchemaArn
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ListIndexRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// The reference to the index to list.
        public var indexReference: ObjectReference = ObjectReference()
        /// The ARN of the directory that the index exists in.
        public var directoryArn: String = ""
        /// The consistency level to execute the request at.
        public var consistencyLevel: String? = nil
        /// Specifies the ranges of indexed values that you want to query.
        public var rangesOnIndexedValues: [ObjectAttributeRange]? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The maximum number of results to retrieve from the index.
        public var maxResults: Int32? = nil

        public init() {}

        public init(indexReference: ObjectReference, directoryArn: String, consistencyLevel: String? = nil, rangesOnIndexedValues: [ObjectAttributeRange]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.indexReference = indexReference
            self.directoryArn = directoryArn
            self.consistencyLevel = consistencyLevel
            self.rangesOnIndexedValues = rangesOnIndexedValues
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let indexReference = dictionary["IndexReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IndexReference") }
            self.indexReference = try Clouddirectory.ObjectReference(dictionary: indexReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            if let rangesOnIndexedValues = dictionary["RangesOnIndexedValues"] as? [[String: Any]] {
                self.rangesOnIndexedValues = try rangesOnIndexedValues.map({ try ObjectAttributeRange(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct AttachToIndexRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// A reference to the object that you are attaching to the index.
        public var targetReference: ObjectReference = ObjectReference()
        /// A reference to the index that you are attaching the object to.
        public var indexReference: ObjectReference = ObjectReference()
        /// The ARN of the directory where the object and index exist.
        public var directoryArn: String = ""

        public init() {}

        public init(targetReference: ObjectReference, indexReference: ObjectReference, directoryArn: String) {
            self.targetReference = targetReference
            self.indexReference = indexReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let targetReference = dictionary["TargetReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TargetReference") }
            self.targetReference = try Clouddirectory.ObjectReference(dictionary: targetReference)
            guard let indexReference = dictionary["IndexReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IndexReference") }
            self.indexReference = try Clouddirectory.ObjectReference(dictionary: indexReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct BatchListObjectAttributesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Attributes map associated with the object. AttributeArn is the key; attribute value is the value.
        public var attributes: [AttributeKeyAndValue]? = nil

        public init() {}

        public init(nextToken: String? = nil, attributes: [AttributeKeyAndValue]? = nil) {
            self.nextToken = nextToken
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let attributes = dictionary["Attributes"] as? [[String: Any]] {
                self.attributes = try attributes.map({ try AttributeKeyAndValue(dictionary: $0) })
            }
        }
    }

    public struct DeleteDirectoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// The ARN of the directory to delete.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct DeleteFacetResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct BatchWriteResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// List of all the responses for each batch write.
        public var responses: [BatchWriteOperationResponse]? = nil

        public init() {}

        public init(responses: [BatchWriteOperationResponse]? = nil) {
            self.responses = responses
        }

        public init(dictionary: [String: Any]) throws {
            if let responses = dictionary["Responses"] as? [[String: Any]] {
                self.responses = try responses.map({ try BatchWriteOperationResponse(dictionary: $0) })
            }
        }
    }

    public struct DeleteDirectoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the deleted directory.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct AttachObjectRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Parent object reference.
        public var parentReference: ObjectReference = ObjectReference()
        /// Child object reference to be attached to the object.
        public var childReference: ObjectReference = ObjectReference()
        /// ARN associated with the Directory where both objects reside. For more information, see arns.
        public var directoryArn: String = ""
        /// Link name with which the child object is attached to the parent.
        public var linkName: String = ""

        public init() {}

        public init(parentReference: ObjectReference, childReference: ObjectReference, directoryArn: String, linkName: String) {
            self.parentReference = parentReference
            self.childReference = childReference
            self.directoryArn = directoryArn
            self.linkName = linkName
        }

        public init(dictionary: [String: Any]) throws {
            guard let parentReference = dictionary["ParentReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ParentReference") }
            self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference)
            guard let childReference = dictionary["ChildReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ChildReference") }
            self.childReference = try Clouddirectory.ObjectReference(dictionary: childReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            guard let linkName = dictionary["LinkName"] as? String else { throw InitializableError.missingRequiredParam("LinkName") }
            self.linkName = linkName
        }
    }

    public struct GetObjectInformationRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// The consistency level at which to retrieve the object information.
        public var consistencyLevel: String? = nil
        /// A reference to the object.
        public var objectReference: ObjectReference = ObjectReference()
        /// The ARN of the directory being retrieved.
        public var directoryArn: String = ""

        public init() {}

        public init(consistencyLevel: String? = nil, objectReference: ObjectReference, directoryArn: String) {
            self.consistencyLevel = consistencyLevel
            self.objectReference = objectReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct DeleteObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListAttachedIndicesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// The ARN of the directory.
        public var directoryArn: String = ""
        /// A reference to the object to that has indices attached.
        public var targetReference: ObjectReference = ObjectReference()
        /// The pagination token.
        public var nextToken: String? = nil
        /// The consistency level to use for this operation.
        public var consistencyLevel: String? = nil
        /// The maximum number of results to retrieve.
        public var maxResults: Int32? = nil

        public init() {}

        public init(directoryArn: String, targetReference: ObjectReference, nextToken: String? = nil, consistencyLevel: String? = nil, maxResults: Int32? = nil) {
            self.directoryArn = directoryArn
            self.targetReference = targetReference
            self.nextToken = nextToken
            self.consistencyLevel = consistencyLevel
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            guard let targetReference = dictionary["TargetReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TargetReference") }
            self.targetReference = try Clouddirectory.ObjectReference(dictionary: targetReference)
            self.nextToken = dictionary["NextToken"] as? String
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CreateIndexResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ObjectIdentifier of the index created by this operation.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(objectIdentifier: String? = nil) {
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct PolicyAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The type of policy that can be associated with PolicyAttachment.
        public var policyType: String? = nil
        /// The ObjectIdentifier associated with PolicyAttachment.
        public var objectIdentifier: String? = nil
        /// The ID of PolicyAttachment.
        public var policyId: String? = nil

        public init() {}

        public init(policyType: String? = nil, objectIdentifier: String? = nil, policyId: String? = nil) {
            self.policyType = policyType
            self.objectIdentifier = objectIdentifier
            self.policyId = policyId
        }

        public init(dictionary: [String: Any]) throws {
            self.policyType = dictionary["PolicyType"] as? String
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
            self.policyId = dictionary["PolicyId"] as? String
        }
    }

    public struct ListAppliedSchemaArnsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARNs of schemas that are applied to the directory.
        public var schemaArns: [String]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(schemaArns: [String]? = nil, nextToken: String? = nil) {
            self.schemaArns = schemaArns
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let schemaArns = dictionary["SchemaArns"] as? [String] {
                self.schemaArns = schemaArns
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct EnableDirectoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the enabled directory.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN of the resource. Tagging is only supported for directories.
        public var resourceArn: String = ""
        /// The pagination token. This is for future use. Currently pagination is not supported for tagging.
        public var nextToken: String? = nil
        /// The MaxResults parameter sets the maximum number of results returned in a single page. This is for future use and is not supported currently.
        public var maxResults: Int32? = nil

        public init() {}

        public init(resourceArn: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.resourceArn = resourceArn
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["ResourceArn"] as? String else { throw InitializableError.missingRequiredParam("ResourceArn") }
            self.resourceArn = resourceArn
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public var nextToken: String? = nil
        /// List of tag key value pairs associated with the response.
        public var tags: [Tag]? = nil

        public init() {}

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            }
        }
    }

    public struct ListPolicyAttachmentsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// List of ObjectIdentifiers to which the policy is attached.
        public var objectIdentifiers: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, objectIdentifiers: [String]? = nil) {
            self.nextToken = nextToken
            self.objectIdentifiers = objectIdentifiers
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let objectIdentifiers = dictionary["ObjectIdentifiers"] as? [String] {
                self.objectIdentifiers = objectIdentifiers
            }
        }
    }

    public struct ListObjectParentsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil
        /// ARN associated with the Directory where the object resides. For more information, see arns.
        public var directoryArn: String = ""
        /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
        public var consistencyLevel: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Reference that identifies the object for which parent objects are being listed.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(maxResults: Int32? = nil, directoryArn: String, consistencyLevel: String? = nil, nextToken: String? = nil, objectReference: ObjectReference) {
            self.maxResults = maxResults
            self.directoryArn = directoryArn
            self.consistencyLevel = consistencyLevel
            self.nextToken = nextToken
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct PutSchemaFromJsonRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// The replacement JSON schema.
        public var document: String = ""
        /// The ARN of the schema to update.
        public var schemaArn: String = ""

        public init() {}

        public init(document: String, schemaArn: String) {
            self.document = document
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let document = dictionary["Document"] as? String else { throw InitializableError.missingRequiredParam("Document") }
            self.document = document
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct ListAppliedSchemaArnsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The maximum number of results to retrieve.
        public var maxResults: Int32? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The ARN of the directory you are listing.
        public var directoryArn: String = ""

        public init() {}

        public init(maxResults: Int32? = nil, nextToken: String? = nil, directoryArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ObjectAttributeAction: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Type can be either Update or Delete.
        public var objectAttributeActionType: String? = nil
        /// The value that you want to update to.
        public var objectAttributeUpdateValue: TypedAttributeValue? = nil

        public init() {}

        public init(objectAttributeActionType: String? = nil, objectAttributeUpdateValue: TypedAttributeValue? = nil) {
            self.objectAttributeActionType = objectAttributeActionType
            self.objectAttributeUpdateValue = objectAttributeUpdateValue
        }

        public init(dictionary: [String: Any]) throws {
            self.objectAttributeActionType = dictionary["ObjectAttributeActionType"] as? String
            if let objectAttributeUpdateValue = dictionary["ObjectAttributeUpdateValue"] as? [String: Any] { self.objectAttributeUpdateValue = try Clouddirectory.TypedAttributeValue(dictionary: objectAttributeUpdateValue) }
        }
    }

    public struct DetachObjectRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Link name associated with the object that needs to be detached.
        public var linkName: String = ""
        /// Parent reference from which the object with the specified link name is detached.
        public var parentReference: ObjectReference = ObjectReference()
        /// ARN associated with the Directory where objects reside. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(linkName: String, parentReference: ObjectReference, directoryArn: String) {
            self.linkName = linkName
            self.parentReference = parentReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let linkName = dictionary["LinkName"] as? String else { throw InitializableError.missingRequiredParam("LinkName") }
            self.linkName = linkName
            guard let parentReference = dictionary["ParentReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ParentReference") }
            self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct DetachPolicyRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Reference that identifies the policy object.
        public var policyReference: ObjectReference = ObjectReference()
        /// Reference that identifies the object whose policy object will be detached.
        public var objectReference: ObjectReference = ObjectReference()
        /// ARN associated with the Directory where both objects reside. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(policyReference: ObjectReference, objectReference: ObjectReference, directoryArn: String) {
            self.policyReference = policyReference
            self.objectReference = objectReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyReference = dictionary["PolicyReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("PolicyReference") }
            self.policyReference = try Clouddirectory.ObjectReference(dictionary: policyReference)
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct SchemaFacet: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the schema that contains the facet.
        public var schemaArn: String? = nil
        /// The name of the facet.
        public var facetName: String? = nil

        public init() {}

        public init(schemaArn: String? = nil, facetName: String? = nil) {
            self.schemaArn = schemaArn
            self.facetName = facetName
        }

        public init(dictionary: [String: Any]) throws {
            self.schemaArn = dictionary["SchemaArn"] as? String
            self.facetName = dictionary["FacetName"] as? String
        }
    }

    public struct PublishSchemaRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DevelopmentSchemaArn"]
        }
        /// ARN associated with the development schema. For more information, see arns.
        public var developmentSchemaArn: String = ""
        /// New name under which the schema will be published. If this is not provided, the development schema is considered.
        public var name: String? = nil
        /// Version under which the schema will be published.
        public var version: String = ""

        public init() {}

        public init(developmentSchemaArn: String, name: String? = nil, version: String) {
            self.developmentSchemaArn = developmentSchemaArn
            self.name = name
            self.version = version
        }

        public init(dictionary: [String: Any]) throws {
            guard let developmentSchemaArn = dictionary["DevelopmentSchemaArn"] as? String else { throw InitializableError.missingRequiredParam("DevelopmentSchemaArn") }
            self.developmentSchemaArn = developmentSchemaArn
            self.name = dictionary["Name"] as? String
            guard let version = dictionary["Version"] as? String else { throw InitializableError.missingRequiredParam("Version") }
            self.version = version
        }
    }

    public struct GetDirectoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Metadata about the directory.
        public var directory: Directory = Directory()

        public init() {}

        public init(directory: Directory) {
            self.directory = directory
        }

        public init(dictionary: [String: Any]) throws {
            guard let directory = dictionary["Directory"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Directory") }
            self.directory = try Clouddirectory.Directory(dictionary: directory)
        }
    }

    public struct BatchReadResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// List of all the responses for each batch read.
        public var responses: [BatchReadOperationResponse]? = nil

        public init() {}

        public init(responses: [BatchReadOperationResponse]? = nil) {
            self.responses = responses
        }

        public init(dictionary: [String: Any]) throws {
            if let responses = dictionary["Responses"] as? [[String: Any]] {
                self.responses = try responses.map({ try BatchReadOperationResponse(dictionary: $0) })
            }
        }
    }

    public struct BatchDetachObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ObjectIdentifier of the detached object.
        public var detachedObjectIdentifier: String? = nil

        public init() {}

        public init(detachedObjectIdentifier: String? = nil) {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.detachedObjectIdentifier = dictionary["detachedObjectIdentifier"] as? String
        }
    }

    public struct FacetAttributeReference: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Target attribute name associated with the facet reference. See Attribute References for more information.
        public var targetAttributeName: String = ""
        /// Target facet name associated with the facet reference. See Attribute References for more information.
        public var targetFacetName: String = ""

        public init() {}

        public init(targetAttributeName: String, targetFacetName: String) {
            self.targetAttributeName = targetAttributeName
            self.targetFacetName = targetFacetName
        }

        public init(dictionary: [String: Any]) throws {
            guard let targetAttributeName = dictionary["TargetAttributeName"] as? String else { throw InitializableError.missingRequiredParam("TargetAttributeName") }
            self.targetAttributeName = targetAttributeName
            guard let targetFacetName = dictionary["TargetFacetName"] as? String else { throw InitializableError.missingRequiredParam("TargetFacetName") }
            self.targetFacetName = targetFacetName
        }
    }

    public struct BatchDeleteObject: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Reference that identifies the object.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(objectReference: ObjectReference) {
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct CreateObjectRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// List of facet ARNs to be associated with the object. For more information, see arns.
        public var schemaFacets: [SchemaFacet] = []
        /// If specified, the parent reference to which this object will be attached.
        public var parentReference: ObjectReference? = nil
        /// ARN associated with the Directory in which the object will be created. For more information, see arns.
        public var directoryArn: String = ""
        /// Attribute map whose attribute ARN contains the key and attribute value as the map value.
        public var objectAttributeList: [AttributeKeyAndValue]? = nil
        /// The name of link that is used to attach this object to a parent.
        public var linkName: String? = nil

        public init() {}

        public init(schemaFacets: [SchemaFacet], parentReference: ObjectReference? = nil, directoryArn: String, objectAttributeList: [AttributeKeyAndValue]? = nil, linkName: String? = nil) {
            self.schemaFacets = schemaFacets
            self.parentReference = parentReference
            self.directoryArn = directoryArn
            self.objectAttributeList = objectAttributeList
            self.linkName = linkName
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaFacets = dictionary["SchemaFacets"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("SchemaFacets") }
            self.schemaFacets = try schemaFacets.map({ try SchemaFacet(dictionary: $0) })
            if let parentReference = dictionary["ParentReference"] as? [String: Any] { self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference) }
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            if let objectAttributeList = dictionary["ObjectAttributeList"] as? [[String: Any]] {
                self.objectAttributeList = try objectAttributeList.map({ try AttributeKeyAndValue(dictionary: $0) })
            }
            self.linkName = dictionary["LinkName"] as? String
        }
    }

    public struct ApplySchemaResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Applied schema ARN associated with the copied schema in the Directory. You can use this ARN to describe the schema information applied on this directory. For more information, see arns.
        public var appliedSchemaArn: String? = nil
        /// ARN associated with the Directory. For more information, see arns.
        public var directoryArn: String? = nil

        public init() {}

        public init(appliedSchemaArn: String? = nil, directoryArn: String? = nil) {
            self.appliedSchemaArn = appliedSchemaArn
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            self.appliedSchemaArn = dictionary["AppliedSchemaArn"] as? String
            self.directoryArn = dictionary["DirectoryArn"] as? String
        }
    }

    public struct CreateFacetResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct LookupPolicyRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil
        /// ARN associated with the Directory. For more information, see arns.
        public var directoryArn: String = ""
        /// The token to request the next page of results.
        public var nextToken: String? = nil
        /// Reference that identifies the object whose policies will be looked up.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(maxResults: Int32? = nil, directoryArn: String, nextToken: String? = nil, objectReference: ObjectReference) {
            self.maxResults = maxResults
            self.directoryArn = directoryArn
            self.nextToken = nextToken
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.nextToken = dictionary["NextToken"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct BatchReadOperationResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Identifies which operation in a batch has failed.
        public var exceptionResponse: BatchReadException? = nil
        /// Identifies which operation in a batch has succeeded.
        public var successfulResponse: BatchReadSuccessfulResponse? = nil

        public init() {}

        public init(exceptionResponse: BatchReadException? = nil, successfulResponse: BatchReadSuccessfulResponse? = nil) {
            self.exceptionResponse = exceptionResponse
            self.successfulResponse = successfulResponse
        }

        public init(dictionary: [String: Any]) throws {
            if let exceptionResponse = dictionary["ExceptionResponse"] as? [String: Any] { self.exceptionResponse = try Clouddirectory.BatchReadException(dictionary: exceptionResponse) }
            if let successfulResponse = dictionary["SuccessfulResponse"] as? [String: Any] { self.successfulResponse = try Clouddirectory.BatchReadSuccessfulResponse(dictionary: successfulResponse) }
        }
    }

    public struct ListAttachedIndicesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The indices attached to the specified object.
        public var indexAttachments: [IndexAttachment]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(indexAttachments: [IndexAttachment]? = nil, nextToken: String? = nil) {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let indexAttachments = dictionary["IndexAttachments"] as? [[String: Any]] {
                self.indexAttachments = try indexAttachments.map({ try IndexAttachment(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct BatchAddFacetToObject: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Represents the facet being added to the object.
        public var schemaFacet: SchemaFacet = SchemaFacet()
        /// The attributes to set on the object.
        public var objectAttributeList: [AttributeKeyAndValue] = []
        /// A reference to the object being mutated.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(schemaFacet: SchemaFacet, objectAttributeList: [AttributeKeyAndValue], objectReference: ObjectReference) {
            self.schemaFacet = schemaFacet
            self.objectAttributeList = objectAttributeList
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaFacet = dictionary["SchemaFacet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SchemaFacet") }
            self.schemaFacet = try Clouddirectory.SchemaFacet(dictionary: schemaFacet)
            guard let objectAttributeList = dictionary["ObjectAttributeList"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("ObjectAttributeList") }
            self.objectAttributeList = try objectAttributeList.map({ try AttributeKeyAndValue(dictionary: $0) })
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct ListObjectAttributesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Attributes map associated with the object. AttributeArn is the key, and attribute value is the value.
        public var attributes: [AttributeKeyAndValue]? = nil

        public init() {}

        public init(nextToken: String? = nil, attributes: [AttributeKeyAndValue]? = nil) {
            self.nextToken = nextToken
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let attributes = dictionary["Attributes"] as? [[String: Any]] {
                self.attributes = try attributes.map({ try AttributeKeyAndValue(dictionary: $0) })
            }
        }
    }

    public struct BatchUpdateObjectAttributes: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Attributes update structure.
        public var attributeUpdates: [ObjectAttributeUpdate] = []
        /// Reference that identifies the object.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(attributeUpdates: [ObjectAttributeUpdate], objectReference: ObjectReference) {
            self.attributeUpdates = attributeUpdates
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            guard let attributeUpdates = dictionary["AttributeUpdates"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("AttributeUpdates") }
            self.attributeUpdates = try attributeUpdates.map({ try ObjectAttributeUpdate(dictionary: $0) })
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct CreateFacetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// Specifies whether a given object created from this facet is of type Node, Leaf Node, Policy or Index.   Node: Can have multiple children but one parent.     Leaf Node: Cannot have children but can have multiple parents.     Policy: Allows you to store a policy document and policy type. For more information, see Policies.     Index: Can be created with the Index API.  
        public var objectType: String = ""
        /// Attributes associated with the Facet.e
        public var attributes: [FacetAttribute]? = nil
        /// Name of the Facet, which is unique for a given schema.
        public var name: String = ""
        /// Schema ARN in which the new Facet will be created. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(objectType: String, attributes: [FacetAttribute]? = nil, name: String, schemaArn: String) {
            self.objectType = objectType
            self.attributes = attributes
            self.name = name
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let objectType = dictionary["ObjectType"] as? String else { throw InitializableError.missingRequiredParam("ObjectType") }
            self.objectType = objectType
            if let attributes = dictionary["Attributes"] as? [[String: Any]] {
                self.attributes = try attributes.map({ try FacetAttribute(dictionary: $0) })
            }
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct RemoveFacetFromObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListFacetNamesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The names of facets that exist within the schema.
        public var facetNames: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, facetNames: [String]? = nil) {
            self.nextToken = nextToken
            self.facetNames = facetNames
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let facetNames = dictionary["FacetNames"] as? [String] {
                self.facetNames = facetNames
            }
        }
    }

    public struct CreateDirectoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN associated with the Directory. For more information, see arns.
        public var directoryArn: String = ""
        /// Name of the Directory.
        public var name: String = ""
        /// The root object node of the created directory.
        public var objectIdentifier: String = ""
        /// ARN of the published schema in the Directory. Once a published schema is copied into the directory, it has its own ARN which is referred to applied schema ARN. For more information, see arns.
        public var appliedSchemaArn: String = ""

        public init() {}

        public init(directoryArn: String, name: String, objectIdentifier: String, appliedSchemaArn: String) {
            self.directoryArn = directoryArn
            self.name = name
            self.objectIdentifier = objectIdentifier
            self.appliedSchemaArn = appliedSchemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let objectIdentifier = dictionary["ObjectIdentifier"] as? String else { throw InitializableError.missingRequiredParam("ObjectIdentifier") }
            self.objectIdentifier = objectIdentifier
            guard let appliedSchemaArn = dictionary["AppliedSchemaArn"] as? String else { throw InitializableError.missingRequiredParam("AppliedSchemaArn") }
            self.appliedSchemaArn = appliedSchemaArn
        }
    }

    public struct AttachPolicyResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct BatchCreateObject: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// If specified, the parent reference to which this object will be attached.
        public var parentReference: ObjectReference = ObjectReference()
        /// List of FacetArns that will be associated with the object. For more information, see arns.
        public var schemaFacet: [SchemaFacet] = []
        /// The batch reference name. See Batches for more information.
        public var batchReferenceName: String = ""
        /// Attribute map, which contains an attribute ARN as the key and attribute value as the map value.
        public var objectAttributeList: [AttributeKeyAndValue] = []
        /// The name of the link.
        public var linkName: String = ""

        public init() {}

        public init(parentReference: ObjectReference, schemaFacet: [SchemaFacet], batchReferenceName: String, objectAttributeList: [AttributeKeyAndValue], linkName: String) {
            self.parentReference = parentReference
            self.schemaFacet = schemaFacet
            self.batchReferenceName = batchReferenceName
            self.objectAttributeList = objectAttributeList
            self.linkName = linkName
        }

        public init(dictionary: [String: Any]) throws {
            guard let parentReference = dictionary["ParentReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ParentReference") }
            self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference)
            guard let schemaFacet = dictionary["SchemaFacet"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("SchemaFacet") }
            self.schemaFacet = try schemaFacet.map({ try SchemaFacet(dictionary: $0) })
            guard let batchReferenceName = dictionary["BatchReferenceName"] as? String else { throw InitializableError.missingRequiredParam("BatchReferenceName") }
            self.batchReferenceName = batchReferenceName
            guard let objectAttributeList = dictionary["ObjectAttributeList"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("ObjectAttributeList") }
            self.objectAttributeList = try objectAttributeList.map({ try AttributeKeyAndValue(dictionary: $0) })
            guard let linkName = dictionary["LinkName"] as? String else { throw InitializableError.missingRequiredParam("LinkName") }
            self.linkName = linkName
        }
    }

    public struct UntagResourceRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN of the resource. Tagging is only supported for directories.
        public var resourceArn: String = ""
        /// Keys of the tag that needs to be removed from the resource.
        public var tagKeys: [String] = []

        public init() {}

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceArn = dictionary["ResourceArn"] as? String else { throw InitializableError.missingRequiredParam("ResourceArn") }
            self.resourceArn = resourceArn
            guard let tagKeys = dictionary["TagKeys"] as? [String] else { throw InitializableError.missingRequiredParam("TagKeys") }
            self.tagKeys = tagKeys
        }
    }

    public struct ListDirectoriesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Lists all directories associated with your account in pagination fashion.
        public var directories: [Directory] = []
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(directories: [Directory], nextToken: String? = nil) {
            self.directories = directories
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            guard let directories = dictionary["Directories"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Directories") }
            self.directories = try directories.map({ try Directory(dictionary: $0) })
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct BatchListObjectChildrenResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Children structure, which is a map with key as the LinkName and ObjectIdentifier as the value.
        public var children: [String: String]? = nil

        public init() {}

        public init(nextToken: String? = nil, children: [String: String]? = nil) {
            self.nextToken = nextToken
            self.children = children
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let children = dictionary["Children"] as? [String: String] {
                self.children = children
            }
        }
    }

    public struct ListObjectPoliciesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil
        /// ARN associated with the Directory where objects reside. For more information, see arns.
        public var directoryArn: String = ""
        /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
        public var consistencyLevel: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Reference that identifies the object for which policies will be listed.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(maxResults: Int32? = nil, directoryArn: String, consistencyLevel: String? = nil, nextToken: String? = nil, objectReference: ObjectReference) {
            self.maxResults = maxResults
            self.directoryArn = directoryArn
            self.consistencyLevel = consistencyLevel
            self.nextToken = nextToken
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct DisableDirectoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// The ARN of the directory to disable.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct DetachFromIndexResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ObjectIdentifier of the object that was detached from the index.
        public var detachedObjectIdentifier: String? = nil

        public init() {}

        public init(detachedObjectIdentifier: String? = nil) {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.detachedObjectIdentifier = dictionary["DetachedObjectIdentifier"] as? String
        }
    }

    public struct BatchAddFacetToObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct BatchListObjectAttributes: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Reference of the object whose attributes need to be listed.
        public var objectReference: ObjectReference = ObjectReference()
        /// The pagination token.
        public var nextToken: String? = nil
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil

        public init() {}

        public init(objectReference: ObjectReference, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.objectReference = objectReference
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct AttachObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Attached ObjectIdentifier, which is the child ObjectIdentifier.
        public var attachedObjectIdentifier: String? = nil

        public init() {}

        public init(attachedObjectIdentifier: String? = nil) {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.attachedObjectIdentifier = dictionary["AttachedObjectIdentifier"] as? String
        }
    }

    public struct ListObjectParentPathsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil
        /// The ARN of the directory to which the parent path applies.
        public var directoryArn: String = ""
        /// The pagination token.
        public var nextToken: String? = nil
        /// Reference that identifies the object whose parent paths are listed.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(maxResults: Int32? = nil, directoryArn: String, nextToken: String? = nil, objectReference: ObjectReference) {
            self.maxResults = maxResults
            self.directoryArn = directoryArn
            self.nextToken = nextToken
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.nextToken = dictionary["NextToken"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct CreateDirectoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// Name of the Directory. Should be unique per account, per region.
        public var name: String = ""
        /// ARN of the published schema that will be copied into the data Directory. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(name: String, schemaArn: String) {
            self.name = name
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct GetSchemaAsJsonRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// The ARN of the schema to retrieve.
        public var schemaArn: String = ""

        public init() {}

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct UpdateFacetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// Object type associated with the facet. See CreateFacetRequest$ObjectType for more details.
        public var objectType: String? = nil
        /// List of attributes that need to be updated in a given schema Facet. Each attribute is followed by AttributeAction, which specifies the type of update operation to perform. 
        public var attributeUpdates: [FacetAttributeUpdate]? = nil
        ///  
        public var name: String = ""
        /// ARN associated with the Facet. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(objectType: String? = nil, attributeUpdates: [FacetAttributeUpdate]? = nil, name: String, schemaArn: String) {
            self.objectType = objectType
            self.attributeUpdates = attributeUpdates
            self.name = name
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            self.objectType = dictionary["ObjectType"] as? String
            if let attributeUpdates = dictionary["AttributeUpdates"] as? [[String: Any]] {
                self.attributeUpdates = try attributeUpdates.map({ try FacetAttributeUpdate(dictionary: $0) })
            }
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct DisableDirectoryResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the directory that has been disabled.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct AttachPolicyRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Reference associated with the policy object.
        public var policyReference: ObjectReference = ObjectReference()
        /// Reference that identifies the object to which the policy will be attached.
        public var objectReference: ObjectReference = ObjectReference()
        /// ARN associated with the Directory where both objects reside. For more information, see arns.
        public var directoryArn: String? = nil

        public init() {}

        public init(policyReference: ObjectReference, objectReference: ObjectReference, directoryArn: String? = nil) {
            self.policyReference = policyReference
            self.objectReference = objectReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyReference = dictionary["PolicyReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("PolicyReference") }
            self.policyReference = try Clouddirectory.ObjectReference(dictionary: policyReference)
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            self.directoryArn = dictionary["DirectoryArn"] as? String
        }
    }

    public struct ListDevelopmentSchemaArnsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARNs of retrieved development schemas.
        public var schemaArns: [String]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(schemaArns: [String]? = nil, nextToken: String? = nil) {
            self.schemaArns = schemaArns
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let schemaArns = dictionary["SchemaArns"] as? [String] {
                self.schemaArns = schemaArns
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct BatchWriteRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// List of operations that are part of the batch.
        public var operations: [BatchWriteOperation] = []
        /// ARN associated with the Directory. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(operations: [BatchWriteOperation], directoryArn: String) {
            self.operations = operations
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let operations = dictionary["Operations"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Operations") }
            self.operations = try operations.map({ try BatchWriteOperation(dictionary: $0) })
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct BatchCreateObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ID associated with the object.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(objectIdentifier: String? = nil) {
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct BatchUpdateObjectAttributesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ID associated with the object.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(objectIdentifier: String? = nil) {
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct BatchReadRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
        public var consistencyLevel: String? = nil
        /// List of operations that are part of the batch.
        public var operations: [BatchReadOperation] = []
        /// ARN associated with the Directory. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(consistencyLevel: String? = nil, operations: [BatchReadOperation], directoryArn: String) {
            self.consistencyLevel = consistencyLevel
            self.operations = operations
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            guard let operations = dictionary["Operations"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Operations") }
            self.operations = try operations.map({ try BatchReadOperation(dictionary: $0) })
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ListPublishedSchemaArnsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARNs of published schemas.
        public var schemaArns: [String]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(schemaArns: [String]? = nil, nextToken: String? = nil) {
            self.schemaArns = schemaArns
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let schemaArns = dictionary["SchemaArns"] as? [String] {
                self.schemaArns = schemaArns
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct BatchReadSuccessfulResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns a paginated list of child objects associated with a given object.
        public var listObjectChildren: BatchListObjectChildrenResponse? = nil
        /// Lists all attributes associated with an object.
        public var listObjectAttributes: BatchListObjectAttributesResponse? = nil

        public init() {}

        public init(listObjectChildren: BatchListObjectChildrenResponse? = nil, listObjectAttributes: BatchListObjectAttributesResponse? = nil) {
            self.listObjectChildren = listObjectChildren
            self.listObjectAttributes = listObjectAttributes
        }

        public init(dictionary: [String: Any]) throws {
            if let listObjectChildren = dictionary["ListObjectChildren"] as? [String: Any] { self.listObjectChildren = try Clouddirectory.BatchListObjectChildrenResponse(dictionary: listObjectChildren) }
            if let listObjectAttributes = dictionary["ListObjectAttributes"] as? [String: Any] { self.listObjectAttributes = try Clouddirectory.BatchListObjectAttributesResponse(dictionary: listObjectAttributes) }
        }
    }

    public struct TypedAttributeValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// A string data value.
        public var stringValue: String? = nil
        /// A binary data value.
        public var binaryValue: Data? = nil
        /// A Boolean data value.
        public var booleanValue: Bool? = nil
        /// A date and time value.
        public var datetimeValue: Date? = nil
        /// A number data value.
        public var numberValue: String? = nil

        public init() {}

        public init(stringValue: String? = nil, binaryValue: Data? = nil, booleanValue: Bool? = nil, datetimeValue: Date? = nil, numberValue: String? = nil) {
            self.stringValue = stringValue
            self.binaryValue = binaryValue
            self.booleanValue = booleanValue
            self.datetimeValue = datetimeValue
            self.numberValue = numberValue
        }

        public init(dictionary: [String: Any]) throws {
            self.stringValue = dictionary["StringValue"] as? String
            self.binaryValue = dictionary["BinaryValue"] as? Data
            self.booleanValue = dictionary["BooleanValue"] as? Bool
            self.datetimeValue = dictionary["DatetimeValue"] as? Date
            self.numberValue = dictionary["NumberValue"] as? String
        }
    }

    public struct ListObjectParentPathsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Returns the path to the ObjectIdentifiers associated with the directory.
        public var pathToObjectIdentifiersList: [PathToObjectIdentifiers]? = nil

        public init() {}

        public init(nextToken: String? = nil, pathToObjectIdentifiersList: [PathToObjectIdentifiers]? = nil) {
            self.nextToken = nextToken
            self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let pathToObjectIdentifiersList = dictionary["PathToObjectIdentifiersList"] as? [[String: Any]] {
                self.pathToObjectIdentifiersList = try pathToObjectIdentifiersList.map({ try PathToObjectIdentifiers(dictionary: $0) })
            }
        }
    }

    public struct AttributeKey: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The name of the attribute.
        public var name: String = ""
        /// The ARN of the schema that contains the facet and attribute.
        public var schemaArn: String = ""
        /// The name of the facet the attribute exists within.
        public var facetName: String = ""

        public init() {}

        public init(name: String, schemaArn: String, facetName: String) {
            self.name = name
            self.schemaArn = schemaArn
            self.facetName = facetName
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
            guard let facetName = dictionary["FacetName"] as? String else { throw InitializableError.missingRequiredParam("FacetName") }
            self.facetName = facetName
        }
    }

    public struct PathToObjectIdentifiers: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Lists ObjectIdentifiers starting from directory root to the object in the request.
        public var objectIdentifiers: [String]? = nil
        /// The path used to identify the object starting from directory root.
        public var path: String? = nil

        public init() {}

        public init(objectIdentifiers: [String]? = nil, path: String? = nil) {
            self.objectIdentifiers = objectIdentifiers
            self.path = path
        }

        public init(dictionary: [String: Any]) throws {
            if let objectIdentifiers = dictionary["ObjectIdentifiers"] as? [String] {
                self.objectIdentifiers = objectIdentifiers
            }
            self.path = dictionary["Path"] as? String
        }
    }

    public struct BatchDetachObject: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The batch reference name. See Batches for more information.
        public var batchReferenceName: String = ""
        /// Parent reference from which the object with the specified link name is detached.
        public var parentReference: ObjectReference = ObjectReference()
        /// The name of the link.
        public var linkName: String = ""

        public init() {}

        public init(batchReferenceName: String, parentReference: ObjectReference, linkName: String) {
            self.batchReferenceName = batchReferenceName
            self.parentReference = parentReference
            self.linkName = linkName
        }

        public init(dictionary: [String: Any]) throws {
            guard let batchReferenceName = dictionary["BatchReferenceName"] as? String else { throw InitializableError.missingRequiredParam("BatchReferenceName") }
            self.batchReferenceName = batchReferenceName
            guard let parentReference = dictionary["ParentReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ParentReference") }
            self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference)
            guard let linkName = dictionary["LinkName"] as? String else { throw InitializableError.missingRequiredParam("LinkName") }
            self.linkName = linkName
        }
    }

    public struct GetFacetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// The name of the facet to retrieve.
        public var name: String = ""
        /// ARN associated with the Facet. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(name: String, schemaArn: String) {
            self.name = name
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct UpdateSchemaRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// Name of the schema.
        public var name: String = ""
        /// ARN of the development schema. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(name: String, schemaArn: String) {
            self.name = name
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct IndexAttachment: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The indexed attribute values.
        public var indexedAttributes: [AttributeKeyAndValue]? = nil
        /// The ObjectIdentifier of the object attached to the index.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(indexedAttributes: [AttributeKeyAndValue]? = nil, objectIdentifier: String? = nil) {
            self.indexedAttributes = indexedAttributes
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            if let indexedAttributes = dictionary["IndexedAttributes"] as? [[String: Any]] {
                self.indexedAttributes = try indexedAttributes.map({ try AttributeKeyAndValue(dictionary: $0) })
            }
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct ObjectAttributeUpdate: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The key of the attribute being updated.
        public var objectAttributeKey: AttributeKey? = nil
        /// The action to perform as part of the attribute update.
        public var objectAttributeAction: ObjectAttributeAction? = nil

        public init() {}

        public init(objectAttributeKey: AttributeKey? = nil, objectAttributeAction: ObjectAttributeAction? = nil) {
            self.objectAttributeKey = objectAttributeKey
            self.objectAttributeAction = objectAttributeAction
        }

        public init(dictionary: [String: Any]) throws {
            if let objectAttributeKey = dictionary["ObjectAttributeKey"] as? [String: Any] { self.objectAttributeKey = try Clouddirectory.AttributeKey(dictionary: objectAttributeKey) }
            if let objectAttributeAction = dictionary["ObjectAttributeAction"] as? [String: Any] { self.objectAttributeAction = try Clouddirectory.ObjectAttributeAction(dictionary: objectAttributeAction) }
        }
    }

    public struct CreateIndexRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Specifies the Attributes that should be indexed on. Currently only a single attribute is supported.
        public var orderedIndexedAttributeList: [AttributeKey] = []
        /// Indicates whether objects with the same indexed attribute value can be added to the index.
        public var isUnique: Bool = false
        /// A reference to the parent object that contains the index object.
        public var parentReference: ObjectReference? = nil
        /// The ARN of the directory where the index should be created.
        public var directoryArn: String = ""
        /// The name of the link between the parent object and the index object.
        public var linkName: String? = nil

        public init() {}

        public init(orderedIndexedAttributeList: [AttributeKey], isUnique: Bool, parentReference: ObjectReference? = nil, directoryArn: String, linkName: String? = nil) {
            self.orderedIndexedAttributeList = orderedIndexedAttributeList
            self.isUnique = isUnique
            self.parentReference = parentReference
            self.directoryArn = directoryArn
            self.linkName = linkName
        }

        public init(dictionary: [String: Any]) throws {
            guard let orderedIndexedAttributeList = dictionary["OrderedIndexedAttributeList"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("OrderedIndexedAttributeList") }
            self.orderedIndexedAttributeList = try orderedIndexedAttributeList.map({ try AttributeKey(dictionary: $0) })
            guard let isUnique = dictionary["IsUnique"] as? Bool else { throw InitializableError.missingRequiredParam("IsUnique") }
            self.isUnique = isUnique
            if let parentReference = dictionary["ParentReference"] as? [String: Any] { self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference) }
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.linkName = dictionary["LinkName"] as? String
        }
    }

    public struct Facet: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Object type associated with the facet. See CreateFacetRequest$ObjectType for more details.
        public var objectType: String? = nil
        /// The name of the Facet.
        public var name: String? = nil

        public init() {}

        public init(objectType: String? = nil, name: String? = nil) {
            self.objectType = objectType
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            self.objectType = dictionary["ObjectType"] as? String
            self.name = dictionary["Name"] as? String
        }
    }

    public struct ListDirectoriesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The state of the directories in the list. Can be either Enabled, Disabled, or Deleted.
        public var state: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The maximum number of results to retrieve.
        public var maxResults: Int32? = nil

        public init() {}

        public init(state: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.state = state
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.state = dictionary["state"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct FacetAttributeDefinition: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Whether the attribute is mutable or not.
        public var isImmutable: Bool? = nil
        /// Validation rules attached to the attribute definition.
        public var rules: [String: Rule]? = nil
        /// The type of the attribute.
        public var type: String = ""
        /// The default value of the attribute (if configured).
        public var defaultValue: TypedAttributeValue? = nil

        public init() {}

        public init(isImmutable: Bool? = nil, rules: [String: Rule]? = nil, type: String, defaultValue: TypedAttributeValue? = nil) {
            self.isImmutable = isImmutable
            self.rules = rules
            self.type = type
            self.defaultValue = defaultValue
        }

        public init(dictionary: [String: Any]) throws {
            self.isImmutable = dictionary["IsImmutable"] as? Bool
            if let rules = dictionary["Rules"] as? [String: Any] {
                var rulesDict: [String: Rule] = [:]
                for (key, value) in rules {
                    guard let ruleDict = value as? [String: Any] else { throw InitializableError.convertingError }
                    rulesDict[key] = try Rule(dictionary: ruleDict)
                }
                self.rules = rulesDict
            }
            guard let type = dictionary["Type"] as? String else { throw InitializableError.missingRequiredParam("Type") }
            self.type = type
            if let defaultValue = dictionary["DefaultValue"] as? [String: Any] { self.defaultValue = try Clouddirectory.TypedAttributeValue(dictionary: defaultValue) }
        }
    }

    public struct DetachPolicyResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListObjectAttributesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil
        /// ARN associated with the Directory where the object resides. For more information, see arns.
        public var directoryArn: String = ""
        /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
        public var consistencyLevel: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Reference that identifies the object whose attributes will be listed.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(maxResults: Int32? = nil, directoryArn: String, consistencyLevel: String? = nil, nextToken: String? = nil, objectReference: ObjectReference) {
            self.maxResults = maxResults
            self.directoryArn = directoryArn
            self.consistencyLevel = consistencyLevel
            self.nextToken = nextToken
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct PublishSchemaResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// ARN associated with the published schema. For more information, see arns.
        public var publishedSchemaArn: String? = nil

        public init() {}

        public init(publishedSchemaArn: String? = nil) {
            self.publishedSchemaArn = publishedSchemaArn
        }

        public init(dictionary: [String: Any]) throws {
            self.publishedSchemaArn = dictionary["PublishedSchemaArn"] as? String
        }
    }

    public struct CreateObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Identifier associated with the object.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(objectIdentifier: String? = nil) {
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct DeleteSchemaRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// ARN of the development schema. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

    public struct GetObjectInformationResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The facets attached to the specified object.
        public var schemaFacets: [SchemaFacet]? = nil
        /// The ObjectIdentifier of the specified object.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(schemaFacets: [SchemaFacet]? = nil, objectIdentifier: String? = nil) {
            self.schemaFacets = schemaFacets
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            if let schemaFacets = dictionary["SchemaFacets"] as? [[String: Any]] {
                self.schemaFacets = try schemaFacets.map({ try SchemaFacet(dictionary: $0) })
            }
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct TagResourceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListIndexResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The objects and indexed values attached to the index.
        public var indexAttachments: [IndexAttachment]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(indexAttachments: [IndexAttachment]? = nil, nextToken: String? = nil) {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let indexAttachments = dictionary["IndexAttachments"] as? [[String: Any]] {
                self.indexAttachments = try indexAttachments.map({ try IndexAttachment(dictionary: $0) })
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct UpdateObjectAttributesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Reference that identifies the object.
        public var objectReference: ObjectReference = ObjectReference()
        /// Attributes update structure.
        public var attributeUpdates: [ObjectAttributeUpdate] = []
        /// ARN associated with the Directory where the object resides. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(objectReference: ObjectReference, attributeUpdates: [ObjectAttributeUpdate], directoryArn: String) {
            self.objectReference = objectReference
            self.attributeUpdates = attributeUpdates
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            guard let attributeUpdates = dictionary["AttributeUpdates"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("AttributeUpdates") }
            self.attributeUpdates = try attributeUpdates.map({ try ObjectAttributeUpdate(dictionary: $0) })
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct BatchWriteOperation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Batch operation adding a facet to an object.
        public var addFacetToObject: BatchAddFacetToObject? = nil
        /// Update a given object's attributes.
        public var updateObjectAttributes: BatchUpdateObjectAttributes? = nil
        /// Detaches an object from a Directory.
        public var detachObject: BatchDetachObject? = nil
        /// Attaches an object to a Directory.
        public var attachObject: BatchAttachObject? = nil
        /// Creates an object.
        public var createObject: BatchCreateObject? = nil
        /// Deletes an object in a Directory.
        public var deleteObject: BatchDeleteObject? = nil
        /// Batch operation removing a facet from an object.
        public var removeFacetFromObject: BatchRemoveFacetFromObject? = nil

        public init() {}

        public init(addFacetToObject: BatchAddFacetToObject? = nil, updateObjectAttributes: BatchUpdateObjectAttributes? = nil, detachObject: BatchDetachObject? = nil, attachObject: BatchAttachObject? = nil, createObject: BatchCreateObject? = nil, deleteObject: BatchDeleteObject? = nil, removeFacetFromObject: BatchRemoveFacetFromObject? = nil) {
            self.addFacetToObject = addFacetToObject
            self.updateObjectAttributes = updateObjectAttributes
            self.detachObject = detachObject
            self.attachObject = attachObject
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.removeFacetFromObject = removeFacetFromObject
        }

        public init(dictionary: [String: Any]) throws {
            if let addFacetToObject = dictionary["AddFacetToObject"] as? [String: Any] { self.addFacetToObject = try Clouddirectory.BatchAddFacetToObject(dictionary: addFacetToObject) }
            if let updateObjectAttributes = dictionary["UpdateObjectAttributes"] as? [String: Any] { self.updateObjectAttributes = try Clouddirectory.BatchUpdateObjectAttributes(dictionary: updateObjectAttributes) }
            if let detachObject = dictionary["DetachObject"] as? [String: Any] { self.detachObject = try Clouddirectory.BatchDetachObject(dictionary: detachObject) }
            if let attachObject = dictionary["AttachObject"] as? [String: Any] { self.attachObject = try Clouddirectory.BatchAttachObject(dictionary: attachObject) }
            if let createObject = dictionary["CreateObject"] as? [String: Any] { self.createObject = try Clouddirectory.BatchCreateObject(dictionary: createObject) }
            if let deleteObject = dictionary["DeleteObject"] as? [String: Any] { self.deleteObject = try Clouddirectory.BatchDeleteObject(dictionary: deleteObject) }
            if let removeFacetFromObject = dictionary["RemoveFacetFromObject"] as? [String: Any] { self.removeFacetFromObject = try Clouddirectory.BatchRemoveFacetFromObject(dictionary: removeFacetFromObject) }
        }
    }

    public struct DeleteSchemaResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Input ARN that is returned as part of the response. For more information, see arns.
        public var schemaArn: String? = nil

        public init() {}

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            self.schemaArn = dictionary["SchemaArn"] as? String
        }
    }

    public struct ListObjectChildrenRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil
        /// ARN associated with the Directory where the object resides. For more information, see arns.
        public var directoryArn: String = ""
        /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
        public var consistencyLevel: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Reference that identifies the object for which child objects are being listed.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(maxResults: Int32? = nil, directoryArn: String, consistencyLevel: String? = nil, nextToken: String? = nil, objectReference: ObjectReference) {
            self.maxResults = maxResults
            self.directoryArn = directoryArn
            self.consistencyLevel = consistencyLevel
            self.nextToken = nextToken
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            self.maxResults = dictionary["MaxResults"] as? Int32
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            self.nextToken = dictionary["NextToken"] as? String
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct ListPublishedSchemaArnsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The maximum number of results to retrieve.
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct CreateSchemaRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Name associated with the schema. This is unique to each account and in each region.
        public var name: String = ""

        public init() {}

        public init(name: String) {
            self.name = name
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
        }
    }

    public struct GetFacetResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  Facet structure associated with the facet.
        public var facet: Facet? = nil

        public init() {}

        public init(facet: Facet? = nil) {
            self.facet = facet
        }

        public init(dictionary: [String: Any]) throws {
            if let facet = dictionary["Facet"] as? [String: Any] { self.facet = try Clouddirectory.Facet(dictionary: facet) }
        }
    }

    public struct ListObjectPoliciesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// List of policy ObjectIdentifiers, that are attached to the object.
        public var attachedPolicyIds: [String]? = nil
        /// The pagination token.
        public var nextToken: String? = nil

        public init() {}

        public init(attachedPolicyIds: [String]? = nil, nextToken: String? = nil) {
            self.attachedPolicyIds = attachedPolicyIds
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let attachedPolicyIds = dictionary["AttachedPolicyIds"] as? [String] {
                self.attachedPolicyIds = attachedPolicyIds
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct PutSchemaFromJsonResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ARN of the schema to update.
        public var arn: String? = nil

        public init() {}

        public init(arn: String? = nil) {
            self.arn = arn
        }

        public init(dictionary: [String: Any]) throws {
            self.arn = dictionary["Arn"] as? String
        }
    }

    public struct BatchAttachObject: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Child object reference to be attached to the object.
        public var childReference: ObjectReference = ObjectReference()
        /// Parent object reference.
        public var parentReference: ObjectReference = ObjectReference()
        /// The name of the link.
        public var linkName: String = ""

        public init() {}

        public init(childReference: ObjectReference, parentReference: ObjectReference, linkName: String) {
            self.childReference = childReference
            self.parentReference = parentReference
            self.linkName = linkName
        }

        public init(dictionary: [String: Any]) throws {
            guard let childReference = dictionary["ChildReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ChildReference") }
            self.childReference = try Clouddirectory.ObjectReference(dictionary: childReference)
            guard let parentReference = dictionary["ParentReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ParentReference") }
            self.parentReference = try Clouddirectory.ObjectReference(dictionary: parentReference)
            guard let linkName = dictionary["LinkName"] as? String else { throw InitializableError.missingRequiredParam("LinkName") }
            self.linkName = linkName
        }
    }

    public struct DetachObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ObjectIdentifier that was detached from the object.
        public var detachedObjectIdentifier: String? = nil

        public init() {}

        public init(detachedObjectIdentifier: String? = nil) {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.detachedObjectIdentifier = dictionary["DetachedObjectIdentifier"] as? String
        }
    }

    public struct AttributeKeyAndValue: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The value of the attribute.
        public var value: TypedAttributeValue = TypedAttributeValue()
        /// The key of the attribute.
        public var key: AttributeKey = AttributeKey()

        public init() {}

        public init(value: TypedAttributeValue, key: AttributeKey) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            guard let value = dictionary["Value"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Value") }
            self.value = try Clouddirectory.TypedAttributeValue(dictionary: value)
            guard let key = dictionary["Key"] as? [String: Any] else { throw InitializableError.missingRequiredParam("Key") }
            self.key = try Clouddirectory.AttributeKey(dictionary: key)
        }
    }

    public struct EnableDirectoryRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// The ARN of the directory to enable.
        public var directoryArn: String = ""

        public init() {}

        public init(directoryArn: String) {
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct ListFacetAttributesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// The attributes attached to the facet.
        public var attributes: [FacetAttribute]? = nil

        public init() {}

        public init(nextToken: String? = nil, attributes: [FacetAttribute]? = nil) {
            self.nextToken = nextToken
            self.attributes = attributes
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let attributes = dictionary["Attributes"] as? [[String: Any]] {
                self.attributes = try attributes.map({ try FacetAttribute(dictionary: $0) })
            }
        }
    }

    public struct BatchReadOperation: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: BatchListObjectChildren? = nil
        /// Lists all attributes associated with an object.
        public var listObjectAttributes: BatchListObjectAttributes? = nil

        public init() {}

        public init(listObjectChildren: BatchListObjectChildren? = nil, listObjectAttributes: BatchListObjectAttributes? = nil) {
            self.listObjectChildren = listObjectChildren
            self.listObjectAttributes = listObjectAttributes
        }

        public init(dictionary: [String: Any]) throws {
            if let listObjectChildren = dictionary["ListObjectChildren"] as? [String: Any] { self.listObjectChildren = try Clouddirectory.BatchListObjectChildren(dictionary: listObjectChildren) }
            if let listObjectAttributes = dictionary["ListObjectAttributes"] as? [String: Any] { self.listObjectAttributes = try Clouddirectory.BatchListObjectAttributes(dictionary: listObjectAttributes) }
        }
    }

    public struct ListFacetAttributesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// The pagination token.
        public var nextToken: String? = nil
        /// The name of the facet whose attributes will be retrieved.
        public var name: String = ""
        /// The ARN of the schema where the facet resides.
        public var schemaArn: String = ""
        /// The maximum number of results to retrieve.
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, name: String, schemaArn: String, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.name = name
            self.schemaArn = schemaArn
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BatchReadException: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Type of exception, such as InvalidArnException.
        public var type: String? = nil
        /// Exception message associated with the failure.
        public var message: String? = nil

        public init() {}

        public init(type: String? = nil, message: String? = nil) {
            self.type = type
            self.message = message
        }

        public init(dictionary: [String: Any]) throws {
            self.type = dictionary["Type"] as? String
            self.message = dictionary["Message"] as? String
        }
    }

    public struct DeleteObjectRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// Reference that identifies the object.
        public var objectReference: ObjectReference = ObjectReference()
        /// ARN associated with the Directory where the object resides. For more information, see arns.
        public var directoryArn: String = ""

        public init() {}

        public init(objectReference: ObjectReference, directoryArn: String) {
            self.objectReference = objectReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct BatchListObjectChildren: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Reference of the object for which child objects are being listed.
        public var objectReference: ObjectReference = ObjectReference()
        /// The pagination token.
        public var nextToken: String? = nil
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil

        public init() {}

        public init(objectReference: ObjectReference, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.objectReference = objectReference
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct UntagResourceResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct PolicyToPath: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// List of policy objects.
        public var policies: [PolicyAttachment]? = nil
        /// The path that is referenced from the root.
        public var path: String? = nil

        public init() {}

        public init(policies: [PolicyAttachment]? = nil, path: String? = nil) {
            self.policies = policies
            self.path = path
        }

        public init(dictionary: [String: Any]) throws {
            if let policies = dictionary["Policies"] as? [[String: Any]] {
                self.policies = try policies.map({ try PolicyAttachment(dictionary: $0) })
            }
            self.path = dictionary["Path"] as? String
        }
    }

    public struct ObjectReference: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// Allows you to specify an object. You can identify an object in one of the following ways:    $ObjectIdentifier - Identifies the object by ObjectIdentifier     /some/path - Identifies the object based on path    #SomeBatchReference - Identifies the object in a batch call  
        public var selector: String? = nil

        public init() {}

        public init(selector: String? = nil) {
            self.selector = selector
        }

        public init(dictionary: [String: Any]) throws {
            self.selector = dictionary["Selector"] as? String
        }
    }

    public struct UpdateFacetResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct AttachToIndexResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ObjectIdentifier of the object that was attached to the index.
        public var attachedObjectIdentifier: String? = nil

        public init() {}

        public init(attachedObjectIdentifier: String? = nil) {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.attachedObjectIdentifier = dictionary["AttachedObjectIdentifier"] as? String
        }
    }

    public struct DetachFromIndexRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "DirectoryArn"]
        }
        /// A reference to the object being detached from the index.
        public var targetReference: ObjectReference = ObjectReference()
        /// A reference to the index object.
        public var indexReference: ObjectReference = ObjectReference()
        /// The ARN of the directory the index and object exist in.
        public var directoryArn: String = ""

        public init() {}

        public init(targetReference: ObjectReference, indexReference: ObjectReference, directoryArn: String) {
            self.targetReference = targetReference
            self.indexReference = indexReference
            self.directoryArn = directoryArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let targetReference = dictionary["TargetReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("TargetReference") }
            self.targetReference = try Clouddirectory.ObjectReference(dictionary: targetReference)
            guard let indexReference = dictionary["IndexReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("IndexReference") }
            self.indexReference = try Clouddirectory.ObjectReference(dictionary: indexReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
        }
    }

    public struct BatchRemoveFacetFromObject: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The facet to remove from the object.
        public var schemaFacet: SchemaFacet = SchemaFacet()
        /// A reference to the object whose facet will be removed.
        public var objectReference: ObjectReference = ObjectReference()

        public init() {}

        public init(schemaFacet: SchemaFacet, objectReference: ObjectReference) {
            self.schemaFacet = schemaFacet
            self.objectReference = objectReference
        }

        public init(dictionary: [String: Any]) throws {
            guard let schemaFacet = dictionary["SchemaFacet"] as? [String: Any] else { throw InitializableError.missingRequiredParam("SchemaFacet") }
            self.schemaFacet = try Clouddirectory.SchemaFacet(dictionary: schemaFacet)
            guard let objectReference = dictionary["ObjectReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("ObjectReference") }
            self.objectReference = try Clouddirectory.ObjectReference(dictionary: objectReference)
        }
    }

    public struct ListFacetNamesRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// The pagination token.
        public var nextToken: String? = nil
        /// The ARN to retrieve facet names from.
        public var schemaArn: String = ""
        /// The maximum number of results to retrieve
        public var maxResults: Int32? = nil

        public init() {}

        public init(nextToken: String? = nil, schemaArn: String, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.schemaArn = schemaArn
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct BatchAttachObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The ObjectIdentifier of the object that has been attached.
        public var attachedObjectIdentifier: String? = nil

        public init() {}

        public init(attachedObjectIdentifier: String? = nil) {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.attachedObjectIdentifier = dictionary["attachedObjectIdentifier"] as? String
        }
    }

    public struct FacetAttributeUpdate: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The action to perform when updating the attribute.
        public var action: String? = nil
        /// The attribute to update.
        public var attribute: FacetAttribute? = nil

        public init() {}

        public init(action: String? = nil, attribute: FacetAttribute? = nil) {
            self.action = action
            self.attribute = attribute
        }

        public init(dictionary: [String: Any]) throws {
            self.action = dictionary["Action"] as? String
            if let attribute = dictionary["Attribute"] as? [String: Any] { self.attribute = try Clouddirectory.FacetAttribute(dictionary: attribute) }
        }
    }

    public struct UpdateObjectAttributesResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        ///  ObjectIdentifier of the updated object.
        public var objectIdentifier: String? = nil

        public init() {}

        public init(objectIdentifier: String? = nil) {
            self.objectIdentifier = objectIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.objectIdentifier = dictionary["ObjectIdentifier"] as? String
        }
    }

    public struct BatchDeleteObjectResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil

        public init() {}

        public init(dictionary: [String: Any]) throws {
        }
    }

    public struct ListPolicyAttachmentsRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-consistency-level": "ConsistencyLevel", "x-amz-data-partition": "DirectoryArn"]
        }
        /// Reference that identifies the policy object.
        public var policyReference: ObjectReference = ObjectReference()
        /// ARN associated with the Directory where objects reside. For more information, see arns.
        public var directoryArn: String = ""
        /// The pagination token.
        public var nextToken: String? = nil
        /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
        public var consistencyLevel: String? = nil
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Int32? = nil

        public init() {}

        public init(policyReference: ObjectReference, directoryArn: String, nextToken: String? = nil, consistencyLevel: String? = nil, maxResults: Int32? = nil) {
            self.policyReference = policyReference
            self.directoryArn = directoryArn
            self.nextToken = nextToken
            self.consistencyLevel = consistencyLevel
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            guard let policyReference = dictionary["PolicyReference"] as? [String: Any] else { throw InitializableError.missingRequiredParam("PolicyReference") }
            self.policyReference = try Clouddirectory.ObjectReference(dictionary: policyReference)
            guard let directoryArn = dictionary["DirectoryArn"] as? String else { throw InitializableError.missingRequiredParam("DirectoryArn") }
            self.directoryArn = directoryArn
            self.nextToken = dictionary["NextToken"] as? String
            self.consistencyLevel = dictionary["ConsistencyLevel"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct ListObjectParentsResponse: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        /// The pagination token.
        public var nextToken: String? = nil
        /// Parent structure, which is a map with key as the ObjectIdentifier and LinkName as the value.
        public var parents: [String: String]? = nil

        public init() {}

        public init(nextToken: String? = nil, parents: [String: String]? = nil) {
            self.nextToken = nextToken
            self.parents = parents
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let parents = dictionary["Parents"] as? [String: String] {
                self.parents = parents
            }
        }
    }

    public struct DeleteFacetRequest: AWSShape {
        /// The key for the payload
        public let _payload: String? = nil
        public var headerParams: [String: String] {
            return ["x-amz-data-partition": "SchemaArn"]
        }
        /// The name of the facet to delete.
        public var name: String = ""
        /// ARN associated with the Facet. For more information, see arns.
        public var schemaArn: String = ""

        public init() {}

        public init(name: String, schemaArn: String) {
            self.name = name
            self.schemaArn = schemaArn
        }

        public init(dictionary: [String: Any]) throws {
            guard let name = dictionary["Name"] as? String else { throw InitializableError.missingRequiredParam("Name") }
            self.name = name
            guard let schemaArn = dictionary["SchemaArn"] as? String else { throw InitializableError.missingRequiredParam("SchemaArn") }
            self.schemaArn = schemaArn
        }
    }

}