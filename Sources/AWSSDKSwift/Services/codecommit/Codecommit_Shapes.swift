// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import Core

extension Codecommit {

    public struct ListRepositoriesOutput: Serializable, Initializable {
        /// Lists the repositories called by the list repositories operation.
        var repositories: [RepositoryNameIdPair]? = nil
        /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
        var nextToken: String? = nil

        public init() {}

        public init(repositories: [RepositoryNameIdPair]? = nil, nextToken: String? = nil) {
            self.repositories = repositories
            self.nextToken = nextToken
        }

    }

    public struct UserInfo: Serializable, Initializable {
        /// The name of the user who made the specified commit.
        var name: String? = nil
        /// The date when the specified commit was pushed to the repository.
        var date: String? = nil
        /// The email address associated with the user who made the commit, if any.
        var email: String? = nil

        public init() {}

        public init(name: String? = nil, date: String? = nil, email: String? = nil) {
            self.name = name
            self.date = date
            self.email = email
        }

    }

    public struct BranchInfo: Serializable, Initializable {
        /// The name of the branch.
        var branchName: String? = nil
        /// The ID of the last commit made to the branch.
        var commitId: String? = nil

        public init() {}

        public init(branchName: String? = nil, commitId: String? = nil) {
            self.branchName = branchName
            self.commitId = commitId
        }

    }

    public struct GetCommitOutput: Serializable, Initializable {
        /// A commit data type object that contains information about the specified commit.
        var commit: Commit = Commit()

        public init() {}

        public init(commit: Commit) {
            self.commit = commit
        }

    }

    public struct DeleteRepositoryOutput: Serializable, Initializable {
        /// The ID of the repository that was deleted.
        var repositoryId: String? = nil

        public init() {}

        public init(repositoryId: String? = nil) {
            self.repositoryId = repositoryId
        }

    }

    public struct RepositoryMetadata: Serializable, Initializable {
        /// A comment or description about the repository.
        var repositoryDescription: String? = nil
        /// The Amazon Resource Name (ARN) of the repository.
        var arn: String? = nil
        /// The repository's name.
        var repositoryName: String? = nil
        /// The date and time the repository was created, in timestamp format.
        var creationDate: Date? = nil
        /// The URL to use for cloning the repository over SSH.
        var cloneUrlSsh: String? = nil
        /// The ID of the AWS account associated with the repository.
        var accountId: String? = nil
        /// The URL to use for cloning the repository over HTTPS.
        var cloneUrlHttp: String? = nil
        /// The ID of the repository.
        var repositoryId: String? = nil
        /// The date and time the repository was last modified, in timestamp format.
        var lastModifiedDate: Date? = nil
        /// The repository's default branch name.
        var defaultBranch: String? = nil

        public init() {}

        public init(repositoryDescription: String? = nil, arn: String? = nil, repositoryName: String? = nil, creationDate: Date? = nil, cloneUrlSsh: String? = nil, accountId: String? = nil, cloneUrlHttp: String? = nil, repositoryId: String? = nil, lastModifiedDate: Date? = nil, defaultBranch: String? = nil) {
            self.repositoryDescription = repositoryDescription
            self.arn = arn
            self.repositoryName = repositoryName
            self.creationDate = creationDate
            self.cloneUrlSsh = cloneUrlSsh
            self.accountId = accountId
            self.cloneUrlHttp = cloneUrlHttp
            self.repositoryId = repositoryId
            self.lastModifiedDate = lastModifiedDate
            self.defaultBranch = defaultBranch
        }

    }

    public struct ListBranchesOutput: Serializable, Initializable {
        /// An enumeration token that returns the batch of the results.
        var nextToken: String? = nil
        /// The list of branch names.
        var branches: [String]? = nil

        public init() {}

        public init(nextToken: String? = nil, branches: [String]? = nil) {
            self.nextToken = nextToken
            self.branches = branches
        }

    }

    public struct RepositoryTrigger: Serializable, Initializable {
        /// The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS).
        var destinationArn: String = ""
        /// The name of the trigger.
        var name: String = ""
        /// The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches.
        var branches: [String]? = nil
        /// Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
        var customData: String? = nil
        /// The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS).   The valid value "all" cannot be used with any other values. 
        var events: [String] = []

        public init() {}

        public init(destinationArn: String, name: String, branches: [String]? = nil, customData: String? = nil, events: [String]) {
            self.destinationArn = destinationArn
            self.name = name
            self.branches = branches
            self.customData = customData
            self.events = events
        }

    }

    public struct BlobMetadata: Serializable, Initializable {
        /// The full ID of the blob.
        var blobId: String? = nil
        /// The file mode permissions of the blob. File mode permission codes include:    100644 indicates read/write    100755 indicates read/write/execute    160000 indicates a submodule    120000 indicates a symlink  
        var mode: String? = nil
        /// The path to the blob and any associated file name, if any.
        var path: String? = nil

        public init() {}

        public init(blobId: String? = nil, mode: String? = nil, path: String? = nil) {
            self.blobId = blobId
            self.mode = mode
            self.path = path
        }

    }

    public struct Commit: Serializable, Initializable {
        /// The parent list for the specified commit.
        var parents: [String]? = nil
        /// The commit message associated with the specified commit.
        var message: String? = nil
        /// Information about the author of the specified commit. Information includes the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured in Git.
        var author: UserInfo? = nil
        /// Tree information for the specified commit.
        var treeId: String? = nil
        /// Any additional data associated with the specified commit.
        var additionalData: String? = nil
        /// Information about the person who committed the specified commit, also known as the committer. Information includes the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured in Git. For more information about the difference between an author and a committer in Git, see Viewing the Commit History in Pro Git by Scott Chacon and Ben Straub.
        var committer: UserInfo? = nil

        public init() {}

        public init(parents: [String]? = nil, message: String? = nil, author: UserInfo? = nil, treeId: String? = nil, additionalData: String? = nil, committer: UserInfo? = nil) {
            self.parents = parents
            self.message = message
            self.author = author
            self.treeId = treeId
            self.additionalData = additionalData
            self.committer = committer
        }

    }

    public struct UpdateDefaultBranchInput: Serializable, Initializable {
        /// The name of the branch to set as the default.
        var defaultBranchName: String = ""
        /// The name of the repository to set or change the default branch for.
        var repositoryName: String = ""

        public init() {}

        public init(defaultBranchName: String, repositoryName: String) {
            self.defaultBranchName = defaultBranchName
            self.repositoryName = repositoryName
        }

    }

    public struct GetRepositoryOutput: Serializable, Initializable {
        /// Information about the repository.
        var repositoryMetadata: RepositoryMetadata? = nil

        public init() {}

        public init(repositoryMetadata: RepositoryMetadata? = nil) {
            self.repositoryMetadata = repositoryMetadata
        }

    }

    public struct TestRepositoryTriggersOutput: Serializable, Initializable {
        /// The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.
        var successfulExecutions: [String]? = nil
        /// The list of triggers that were not able to be tested. This list provides the names of the triggers that could not be tested, separated by commas.
        var failedExecutions: [RepositoryTriggerExecutionFailure]? = nil

        public init() {}

        public init(successfulExecutions: [String]? = nil, failedExecutions: [RepositoryTriggerExecutionFailure]? = nil) {
            self.successfulExecutions = successfulExecutions
            self.failedExecutions = failedExecutions
        }

    }

    public struct TestRepositoryTriggersInput: Serializable, Initializable {
        /// The list of triggers to test.
        var triggers: [RepositoryTrigger] = []
        /// The name of the repository in which to test the triggers.
        var repositoryName: String = ""

        public init() {}

        public init(triggers: [RepositoryTrigger], repositoryName: String) {
            self.triggers = triggers
            self.repositoryName = repositoryName
        }

    }

    public struct UpdateRepositoryDescriptionInput: Serializable, Initializable {
        /// The name of the repository to set or change the comment or description for.
        var repositoryName: String = ""
        /// The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.
        var repositoryDescription: String? = nil

        public init() {}

        public init(repositoryName: String, repositoryDescription: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryDescription = repositoryDescription
        }

    }

    public struct PutRepositoryTriggersOutput: Serializable, Initializable {
        /// The system-generated unique ID for the create or update operation.
        var configurationId: String? = nil

        public init() {}

        public init(configurationId: String? = nil) {
            self.configurationId = configurationId
        }

    }

    public struct GetBranchInput: Serializable, Initializable {
        /// The name of the branch for which you want to retrieve information.
        var branchName: String? = nil
        /// The name of the repository that contains the branch for which you want to retrieve information.
        var repositoryName: String? = nil

        public init() {}

        public init(branchName: String? = nil, repositoryName: String? = nil) {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }

    }

    public struct CreateRepositoryOutput: Serializable, Initializable {
        /// Information about the newly created repository.
        var repositoryMetadata: RepositoryMetadata? = nil

        public init() {}

        public init(repositoryMetadata: RepositoryMetadata? = nil) {
            self.repositoryMetadata = repositoryMetadata
        }

    }

    public struct Difference: Serializable, Initializable {
        /// Whether the change type of the difference is an addition (A), deletion (D), or modification (M).
        var changeType: String? = nil
        /// Information about an afterBlob data type object, including the ID, the file mode permission code, and the path.
        var afterBlob: BlobMetadata? = nil
        /// Information about a beforeBlob data type object, including the ID, the file mode permission code, and the path.
        var beforeBlob: BlobMetadata? = nil

        public init() {}

        public init(changeType: String? = nil, afterBlob: BlobMetadata? = nil, beforeBlob: BlobMetadata? = nil) {
            self.changeType = changeType
            self.afterBlob = afterBlob
            self.beforeBlob = beforeBlob
        }

    }

    public struct RepositoryNameIdPair: Serializable, Initializable {
        /// The ID associated with the repository.
        var repositoryId: String? = nil
        /// The name associated with the repository.
        var repositoryName: String? = nil

        public init() {}

        public init(repositoryId: String? = nil, repositoryName: String? = nil) {
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }

    }

    public struct GetDifferencesInput: Serializable, Initializable {
        /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit.
        var afterCommitSpecifier: String = ""
        /// The name of the repository where you want to get differences.
        var repositoryName: String = ""
        /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit. For example, the full commit ID. Optional. If not specified, all changes prior to the afterCommitSpecifier value will be shown. If you do not use beforeCommitSpecifier in your request, consider limiting the results with maxResults.
        var beforeCommitSpecifier: String? = nil
        /// The file path in which to check for differences. Limits the results to this path. Can also be used to specify the previous name of a directory or folder. If beforePath and afterPath are not specified, differences will be shown for all paths.
        var beforePath: String? = nil
        /// The file path in which to check differences. Limits the results to this path. Can also be used to specify the changed name of a directory or folder, if it has changed. If not specified, differences will be shown for all paths.
        var afterPath: String? = nil
        /// An enumeration token that when provided in a request, returns the next batch of the results.
        var nextToken: String? = nil
        /// A non-negative integer used to limit the number of returned results.
        var maxResults: Int32? = nil

        public init() {}

        public init(afterCommitSpecifier: String, repositoryName: String, beforeCommitSpecifier: String? = nil, beforePath: String? = nil, afterPath: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.afterCommitSpecifier = afterCommitSpecifier
            self.repositoryName = repositoryName
            self.beforeCommitSpecifier = beforeCommitSpecifier
            self.beforePath = beforePath
            self.afterPath = afterPath
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

    }

    public struct CreateBranchInput: Serializable, Initializable {
        /// The name of the new branch to create.
        var branchName: String = ""
        /// The ID of the commit to point the new branch to.
        var commitId: String = ""
        /// The name of the repository in which you want to create the new branch.
        var repositoryName: String = ""

        public init() {}

        public init(branchName: String, commitId: String, repositoryName: String) {
            self.branchName = branchName
            self.commitId = commitId
            self.repositoryName = repositoryName
        }

    }

    public struct DeleteRepositoryInput: Serializable, Initializable {
        /// The name of the repository to delete.
        var repositoryName: String = ""

        public init() {}

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

    }

    public struct ListBranchesInput: Serializable, Initializable {
        /// An enumeration token that allows the operation to batch the results.
        var nextToken: String? = nil
        /// The name of the repository that contains the branches.
        var repositoryName: String = ""

        public init() {}

        public init(nextToken: String? = nil, repositoryName: String) {
            self.nextToken = nextToken
            self.repositoryName = repositoryName
        }

    }

    public struct GetBranchOutput: Serializable, Initializable {
        /// The name of the branch.
        var branch: BranchInfo? = nil

        public init() {}

        public init(branch: BranchInfo? = nil) {
            self.branch = branch
        }

    }

    public struct GetCommitInput: Serializable, Initializable {
        /// The commit ID.
        var commitId: String = ""
        /// The name of the repository to which the commit was made.
        var repositoryName: String = ""

        public init() {}

        public init(commitId: String, repositoryName: String) {
            self.commitId = commitId
            self.repositoryName = repositoryName
        }

    }

    public struct GetRepositoryInput: Serializable, Initializable {
        /// The name of the repository to get information about.
        var repositoryName: String = ""

        public init() {}

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

    }

    public struct GetRepositoryTriggersOutput: Serializable, Initializable {
        /// The system-generated unique ID for the trigger.
        var configurationId: String? = nil
        /// The JSON block of configuration information for each trigger.
        var triggers: [RepositoryTrigger]? = nil

        public init() {}

        public init(configurationId: String? = nil, triggers: [RepositoryTrigger]? = nil) {
            self.configurationId = configurationId
            self.triggers = triggers
        }

    }

    public struct GetRepositoryTriggersInput: Serializable, Initializable {
        /// The name of the repository for which the trigger is configured.
        var repositoryName: String = ""

        public init() {}

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

    }

    public struct UpdateRepositoryNameInput: Serializable, Initializable {
        /// The existing name of the repository.
        var oldName: String = ""
        /// The new name for the repository.
        var newName: String = ""

        public init() {}

        public init(oldName: String, newName: String) {
            self.oldName = oldName
            self.newName = newName
        }

    }

    public struct BatchGetRepositoriesOutput: Serializable, Initializable {
        /// A list of repositories returned by the batch get repositories operation.
        var repositories: [RepositoryMetadata]? = nil
        /// Returns a list of repository names for which information could not be found.
        var repositoriesNotFound: [String]? = nil

        public init() {}

        public init(repositories: [RepositoryMetadata]? = nil, repositoriesNotFound: [String]? = nil) {
            self.repositories = repositories
            self.repositoriesNotFound = repositoriesNotFound
        }

    }

    public struct GetDifferencesOutput: Serializable, Initializable {
        /// An enumeration token that can be used in a request to return the next batch of the results.
        var nextToken: String? = nil
        /// A differences data type object that contains information about the differences, including whether the difference is added, modified, or deleted (A, D, M).
        var differences: [Difference]? = nil

        public init() {}

        public init(nextToken: String? = nil, differences: [Difference]? = nil) {
            self.nextToken = nextToken
            self.differences = differences
        }

    }

    public struct ListRepositoriesInput: Serializable, Initializable {
        /// The criteria used to sort the results of a list repositories operation.
        var sortBy: String? = nil
        /// The order in which to sort the results of a list repositories operation.
        var order: String? = nil
        /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
        var nextToken: String? = nil

        public init() {}

        public init(sortBy: String? = nil, order: String? = nil, nextToken: String? = nil) {
            self.sortBy = sortBy
            self.order = order
            self.nextToken = nextToken
        }

    }

    public struct GetBlobOutput: Serializable, Initializable {
        /// The content of the blob, usually a file.
        var content: Data = Data()

        public init() {}

        public init(content: Data) {
            self.content = content
        }

    }

    public struct RepositoryTriggerExecutionFailure: Serializable, Initializable {
        /// Additional message information about the trigger that did not run.
        var failureMessage: String? = nil
        /// The name of the trigger that did not run.
        var trigger: String? = nil

        public init() {}

        public init(failureMessage: String? = nil, trigger: String? = nil) {
            self.failureMessage = failureMessage
            self.trigger = trigger
        }

    }

    public struct GetBlobInput: Serializable, Initializable {
        /// The ID of the blob, which is its SHA-1 pointer.
        var blobId: String = ""
        /// The name of the repository that contains the blob.
        var repositoryName: String = ""

        public init() {}

        public init(blobId: String, repositoryName: String) {
            self.blobId = blobId
            self.repositoryName = repositoryName
        }

    }

    public struct CreateRepositoryInput: Serializable, Initializable {
        /// The name of the new repository to be created.  The repository name must be unique across the calling AWS account. In addition, repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For a full description of the limits on repository names, see Limits in the AWS CodeCommit User Guide. The suffix ".git" is prohibited. 
        var repositoryName: String = ""
        /// A comment or description about the new repository.  The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a web page could expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a web page. 
        var repositoryDescription: String? = nil

        public init() {}

        public init(repositoryName: String, repositoryDescription: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryDescription = repositoryDescription
        }

    }

    public struct PutRepositoryTriggersInput: Serializable, Initializable {
        /// The JSON block of configuration information for each trigger.
        var triggers: [RepositoryTrigger] = []
        /// The name of the repository where you want to create or update the trigger.
        var repositoryName: String = ""

        public init() {}

        public init(triggers: [RepositoryTrigger], repositoryName: String) {
            self.triggers = triggers
            self.repositoryName = repositoryName
        }

    }

    public struct BatchGetRepositoriesInput: Serializable, Initializable {
        /// The names of the repositories to get information about.
        var repositoryNames: [String] = []

        public init() {}

        public init(repositoryNames: [String]) {
            self.repositoryNames = repositoryNames
        }

    }

}