// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Codecommit {

    public struct ListRepositoriesOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositories", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// Lists the repositories called by the list repositories operation.
        public let repositories: [RepositoryNameIdPair]?
        /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
        public let nextToken: String?

        public init(repositories: [RepositoryNameIdPair]? = nil, nextToken: String? = nil) {
            self.repositories = repositories
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case repositories = "repositories"
            case nextToken = "nextToken"
        }
    }

    public struct UserInfo: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "date", required: false, type: .string), 
            AWSShapeMember(label: "email", required: false, type: .string)
        ]
        /// The name of the user who made the specified commit.
        public let name: String?
        /// The date when the specified commit was pushed to the repository.
        public let date: String?
        /// The email address associated with the user who made the commit, if any.
        public let email: String?

        public init(name: String? = nil, date: String? = nil, email: String? = nil) {
            self.name = name
            self.date = date
            self.email = email
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case date = "date"
            case email = "email"
        }
    }

    public struct BranchInfo: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "branchName", required: false, type: .string), 
            AWSShapeMember(label: "commitId", required: false, type: .string)
        ]
        /// The name of the branch.
        public let branchName: String?
        /// The ID of the last commit made to the branch.
        public let commitId: String?

        public init(branchName: String? = nil, commitId: String? = nil) {
            self.branchName = branchName
            self.commitId = commitId
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case commitId = "commitId"
        }
    }

    public struct GetCommitOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "commit", required: true, type: .structure)
        ]
        /// A commit data type object that contains information about the specified commit.
        public let commit: Commit

        public init(commit: Commit) {
            self.commit = commit
        }

        private enum CodingKeys: String, CodingKey {
            case commit = "commit"
        }
    }

    public struct DeleteRepositoryOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryId", required: false, type: .string)
        ]
        /// The ID of the repository that was deleted.
        public let repositoryId: String?

        public init(repositoryId: String? = nil) {
            self.repositoryId = repositoryId
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryId = "repositoryId"
        }
    }

    public struct RepositoryMetadata: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryDescription", required: false, type: .string), 
            AWSShapeMember(label: "Arn", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string), 
            AWSShapeMember(label: "creationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "cloneUrlSsh", required: false, type: .string), 
            AWSShapeMember(label: "accountId", required: false, type: .string), 
            AWSShapeMember(label: "cloneUrlHttp", required: false, type: .string), 
            AWSShapeMember(label: "repositoryId", required: false, type: .string), 
            AWSShapeMember(label: "lastModifiedDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultBranch", required: false, type: .string)
        ]
        /// A comment or description about the repository.
        public let repositoryDescription: String?
        /// The Amazon Resource Name (ARN) of the repository.
        public let arn: String?
        /// The repository's name.
        public let repositoryName: String?
        /// The date and time the repository was created, in timestamp format.
        public let creationDate: Double?
        /// The URL to use for cloning the repository over SSH.
        public let cloneUrlSsh: String?
        /// The ID of the AWS account associated with the repository.
        public let accountId: String?
        /// The URL to use for cloning the repository over HTTPS.
        public let cloneUrlHttp: String?
        /// The ID of the repository.
        public let repositoryId: String?
        /// The date and time the repository was last modified, in timestamp format.
        public let lastModifiedDate: Double?
        /// The repository's default branch name.
        public let defaultBranch: String?

        public init(repositoryDescription: String? = nil, arn: String? = nil, repositoryName: String? = nil, creationDate: Double? = nil, cloneUrlSsh: String? = nil, accountId: String? = nil, cloneUrlHttp: String? = nil, repositoryId: String? = nil, lastModifiedDate: Double? = nil, defaultBranch: String? = nil) {
            self.repositoryDescription = repositoryDescription
            self.arn = arn
            self.repositoryName = repositoryName
            self.creationDate = creationDate
            self.cloneUrlSsh = cloneUrlSsh
            self.accountId = accountId
            self.cloneUrlHttp = cloneUrlHttp
            self.repositoryId = repositoryId
            self.lastModifiedDate = lastModifiedDate
            self.defaultBranch = defaultBranch
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryDescription = "repositoryDescription"
            case arn = "Arn"
            case repositoryName = "repositoryName"
            case creationDate = "creationDate"
            case cloneUrlSsh = "cloneUrlSsh"
            case accountId = "accountId"
            case cloneUrlHttp = "cloneUrlHttp"
            case repositoryId = "repositoryId"
            case lastModifiedDate = "lastModifiedDate"
            case defaultBranch = "defaultBranch"
        }
    }

    public struct ListBranchesOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "branches", required: false, type: .list)
        ]
        /// An enumeration token that returns the batch of the results.
        public let nextToken: String?
        /// The list of branch names.
        public let branches: [String]?

        public init(nextToken: String? = nil, branches: [String]? = nil) {
            self.nextToken = nextToken
            self.branches = branches
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case branches = "branches"
        }
    }

    public struct RepositoryTrigger: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "destinationArn", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "branches", required: false, type: .list), 
            AWSShapeMember(label: "customData", required: false, type: .string), 
            AWSShapeMember(label: "events", required: true, type: .list)
        ]
        /// The ARN of the resource that is the target for a trigger. For example, the ARN of a topic in Amazon Simple Notification Service (SNS).
        public let destinationArn: String
        /// The name of the trigger.
        public let name: String
        /// The branches that will be included in the trigger configuration. If no branches are specified, the trigger will apply to all branches.
        public let branches: [String]?
        /// Any custom data associated with the trigger that will be included in the information sent to the target of the trigger.
        public let customData: String?
        /// The repository events that will cause the trigger to run actions in another service, such as sending a notification through Amazon Simple Notification Service (SNS).   The valid value "all" cannot be used with any other values. 
        public let events: [RepositoryTriggerEventEnum]

        public init(destinationArn: String, name: String, branches: [String]? = nil, customData: String? = nil, events: [RepositoryTriggerEventEnum]) {
            self.destinationArn = destinationArn
            self.name = name
            self.branches = branches
            self.customData = customData
            self.events = events
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "destinationArn"
            case name = "name"
            case branches = "branches"
            case customData = "customData"
            case events = "events"
        }
    }

    public struct BlobMetadata: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "blobId", required: false, type: .string), 
            AWSShapeMember(label: "mode", required: false, type: .string), 
            AWSShapeMember(label: "path", required: false, type: .string)
        ]
        /// The full ID of the blob.
        public let blobId: String?
        /// The file mode permissions of the blob. File mode permission codes include:    100644 indicates read/write    100755 indicates read/write/execute    160000 indicates a submodule    120000 indicates a symlink  
        public let mode: String?
        /// The path to the blob and any associated file name, if any.
        public let path: String?

        public init(blobId: String? = nil, mode: String? = nil, path: String? = nil) {
            self.blobId = blobId
            self.mode = mode
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case blobId = "blobId"
            case mode = "mode"
            case path = "path"
        }
    }

    public struct Commit: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "parents", required: false, type: .list), 
            AWSShapeMember(label: "message", required: false, type: .string), 
            AWSShapeMember(label: "author", required: false, type: .structure), 
            AWSShapeMember(label: "treeId", required: false, type: .string), 
            AWSShapeMember(label: "additionalData", required: false, type: .string), 
            AWSShapeMember(label: "committer", required: false, type: .structure)
        ]
        /// The parent list for the specified commit.
        public let parents: [String]?
        /// The commit message associated with the specified commit.
        public let message: String?
        /// Information about the author of the specified commit. Information includes the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured in Git.
        public let author: UserInfo?
        /// Tree information for the specified commit.
        public let treeId: String?
        /// Any additional data associated with the specified commit.
        public let additionalData: String?
        /// Information about the person who committed the specified commit, also known as the committer. Information includes the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured in Git. For more information about the difference between an author and a committer in Git, see Viewing the Commit History in Pro Git by Scott Chacon and Ben Straub.
        public let committer: UserInfo?

        public init(parents: [String]? = nil, message: String? = nil, author: UserInfo? = nil, treeId: String? = nil, additionalData: String? = nil, committer: UserInfo? = nil) {
            self.parents = parents
            self.message = message
            self.author = author
            self.treeId = treeId
            self.additionalData = additionalData
            self.committer = committer
        }

        private enum CodingKeys: String, CodingKey {
            case parents = "parents"
            case message = "message"
            case author = "author"
            case treeId = "treeId"
            case additionalData = "additionalData"
            case committer = "committer"
        }
    }

    public struct UpdateDefaultBranchInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "defaultBranchName", required: true, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The name of the branch to set as the default.
        public let defaultBranchName: String
        /// The name of the repository to set or change the default branch for.
        public let repositoryName: String

        public init(defaultBranchName: String, repositoryName: String) {
            self.defaultBranchName = defaultBranchName
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case defaultBranchName = "defaultBranchName"
            case repositoryName = "repositoryName"
        }
    }

    public enum OrderEnum: String, CustomStringConvertible, Codable {
        case ascending = "ascending"
        case descending = "descending"
        public var description: String { return self.rawValue }
    }

    public struct GetRepositoryOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryMetadata", required: false, type: .structure)
        ]
        /// Information about the repository.
        public let repositoryMetadata: RepositoryMetadata?

        public init(repositoryMetadata: RepositoryMetadata? = nil) {
            self.repositoryMetadata = repositoryMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryMetadata = "repositoryMetadata"
        }
    }

    public struct TestRepositoryTriggersOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "successfulExecutions", required: false, type: .list), 
            AWSShapeMember(label: "failedExecutions", required: false, type: .list)
        ]
        /// The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.
        public let successfulExecutions: [String]?
        /// The list of triggers that were not able to be tested. This list provides the names of the triggers that could not be tested, separated by commas.
        public let failedExecutions: [RepositoryTriggerExecutionFailure]?

        public init(successfulExecutions: [String]? = nil, failedExecutions: [RepositoryTriggerExecutionFailure]? = nil) {
            self.successfulExecutions = successfulExecutions
            self.failedExecutions = failedExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case successfulExecutions = "successfulExecutions"
            case failedExecutions = "failedExecutions"
        }
    }

    public struct TestRepositoryTriggersInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "triggers", required: true, type: .list), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The list of triggers to test.
        public let triggers: [RepositoryTrigger]
        /// The name of the repository in which to test the triggers.
        public let repositoryName: String

        public init(triggers: [RepositoryTrigger], repositoryName: String) {
            self.triggers = triggers
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case triggers = "triggers"
            case repositoryName = "repositoryName"
        }
    }

    public enum ChangeTypeEnum: String, CustomStringConvertible, Codable {
        case a = "A"
        case m = "M"
        case d = "D"
        public var description: String { return self.rawValue }
    }

    public struct UpdateRepositoryDescriptionInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "repositoryDescription", required: false, type: .string)
        ]
        /// The name of the repository to set or change the comment or description for.
        public let repositoryName: String
        /// The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.
        public let repositoryDescription: String?

        public init(repositoryName: String, repositoryDescription: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryDescription = repositoryDescription
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
            case repositoryDescription = "repositoryDescription"
        }
    }

    public struct PutRepositoryTriggersOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "configurationId", required: false, type: .string)
        ]
        /// The system-generated unique ID for the create or update operation.
        public let configurationId: String?

        public init(configurationId: String? = nil) {
            self.configurationId = configurationId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
        }
    }

    public struct GetBranchInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "branchName", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The name of the branch for which you want to retrieve information.
        public let branchName: String?
        /// The name of the repository that contains the branch for which you want to retrieve information.
        public let repositoryName: String?

        public init(branchName: String? = nil, repositoryName: String? = nil) {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case repositoryName = "repositoryName"
        }
    }

    public struct CreateRepositoryOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryMetadata", required: false, type: .structure)
        ]
        /// Information about the newly created repository.
        public let repositoryMetadata: RepositoryMetadata?

        public init(repositoryMetadata: RepositoryMetadata? = nil) {
            self.repositoryMetadata = repositoryMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryMetadata = "repositoryMetadata"
        }
    }

    public enum SortByEnum: String, CustomStringConvertible, Codable {
        case repositoryname = "repositoryName"
        case lastmodifieddate = "lastModifiedDate"
        public var description: String { return self.rawValue }
    }

    public struct Difference: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "changeType", required: false, type: .enum), 
            AWSShapeMember(label: "afterBlob", required: false, type: .structure), 
            AWSShapeMember(label: "beforeBlob", required: false, type: .structure)
        ]
        /// Whether the change type of the difference is an addition (A), deletion (D), or modification (M).
        public let changeType: ChangeTypeEnum?
        /// Information about an afterBlob data type object, including the ID, the file mode permission code, and the path.
        public let afterBlob: BlobMetadata?
        /// Information about a beforeBlob data type object, including the ID, the file mode permission code, and the path.
        public let beforeBlob: BlobMetadata?

        public init(changeType: ChangeTypeEnum? = nil, afterBlob: BlobMetadata? = nil, beforeBlob: BlobMetadata? = nil) {
            self.changeType = changeType
            self.afterBlob = afterBlob
            self.beforeBlob = beforeBlob
        }

        private enum CodingKeys: String, CodingKey {
            case changeType = "changeType"
            case afterBlob = "afterBlob"
            case beforeBlob = "beforeBlob"
        }
    }

    public struct RepositoryNameIdPair: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryId", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: false, type: .string)
        ]
        /// The ID associated with the repository.
        public let repositoryId: String?
        /// The name associated with the repository.
        public let repositoryName: String?

        public init(repositoryId: String? = nil, repositoryName: String? = nil) {
            self.repositoryId = repositoryId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryId = "repositoryId"
            case repositoryName = "repositoryName"
        }
    }

    public enum RepositoryTriggerEventEnum: String, CustomStringConvertible, Codable {
        case all = "all"
        case updatereference = "updateReference"
        case createreference = "createReference"
        case deletereference = "deleteReference"
        public var description: String { return self.rawValue }
    }

    public struct GetDifferencesInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "afterCommitSpecifier", required: true, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "beforeCommitSpecifier", required: false, type: .string), 
            AWSShapeMember(label: "beforePath", required: false, type: .string), 
            AWSShapeMember(label: "afterPath", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer)
        ]
        /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit.
        public let afterCommitSpecifier: String
        /// The name of the repository where you want to get differences.
        public let repositoryName: String
        /// The branch, tag, HEAD, or other fully qualified reference used to identify a commit. For example, the full commit ID. Optional. If not specified, all changes prior to the afterCommitSpecifier value will be shown. If you do not use beforeCommitSpecifier in your request, consider limiting the results with maxResults.
        public let beforeCommitSpecifier: String?
        /// The file path in which to check for differences. Limits the results to this path. Can also be used to specify the previous name of a directory or folder. If beforePath and afterPath are not specified, differences will be shown for all paths.
        public let beforePath: String?
        /// The file path in which to check differences. Limits the results to this path. Can also be used to specify the changed name of a directory or folder, if it has changed. If not specified, differences will be shown for all paths.
        public let afterPath: String?
        /// An enumeration token that when provided in a request, returns the next batch of the results.
        public let nextToken: String?
        /// A non-negative integer used to limit the number of returned results.
        public let maxResults: Int32?

        public init(afterCommitSpecifier: String, repositoryName: String, beforeCommitSpecifier: String? = nil, beforePath: String? = nil, afterPath: String? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.afterCommitSpecifier = afterCommitSpecifier
            self.repositoryName = repositoryName
            self.beforeCommitSpecifier = beforeCommitSpecifier
            self.beforePath = beforePath
            self.afterPath = afterPath
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case afterCommitSpecifier = "afterCommitSpecifier"
            case repositoryName = "repositoryName"
            case beforeCommitSpecifier = "beforeCommitSpecifier"
            case beforePath = "beforePath"
            case afterPath = "afterPath"
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
        }
    }

    public struct CreateBranchInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "branchName", required: true, type: .string), 
            AWSShapeMember(label: "commitId", required: true, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The name of the new branch to create.
        public let branchName: String
        /// The ID of the commit to point the new branch to.
        public let commitId: String
        /// The name of the repository in which you want to create the new branch.
        public let repositoryName: String

        public init(branchName: String, commitId: String, repositoryName: String) {
            self.branchName = branchName
            self.commitId = commitId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case commitId = "commitId"
            case repositoryName = "repositoryName"
        }
    }

    public struct DeleteRepositoryInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The name of the repository to delete.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct ListBranchesInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// An enumeration token that allows the operation to batch the results.
        public let nextToken: String?
        /// The name of the repository that contains the branches.
        public let repositoryName: String

        public init(nextToken: String? = nil, repositoryName: String) {
            self.nextToken = nextToken
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetBranchOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "branch", required: false, type: .structure)
        ]
        /// The name of the branch.
        public let branch: BranchInfo?

        public init(branch: BranchInfo? = nil) {
            self.branch = branch
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
        }
    }

    public struct GetCommitInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "commitId", required: true, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The commit ID.
        public let commitId: String
        /// The name of the repository to which the commit was made.
        public let repositoryName: String

        public init(commitId: String, repositoryName: String) {
            self.commitId = commitId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case commitId = "commitId"
            case repositoryName = "repositoryName"
        }
    }

    public struct GetRepositoryInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The name of the repository to get information about.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct GetRepositoryTriggersOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "configurationId", required: false, type: .string), 
            AWSShapeMember(label: "triggers", required: false, type: .list)
        ]
        /// The system-generated unique ID for the trigger.
        public let configurationId: String?
        /// The JSON block of configuration information for each trigger.
        public let triggers: [RepositoryTrigger]?

        public init(configurationId: String? = nil, triggers: [RepositoryTrigger]? = nil) {
            self.configurationId = configurationId
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case triggers = "triggers"
        }
    }

    public struct GetRepositoryTriggersInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The name of the repository for which the trigger is configured.
        public let repositoryName: String

        public init(repositoryName: String) {
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
        }
    }

    public struct UpdateRepositoryNameInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "oldName", required: true, type: .string), 
            AWSShapeMember(label: "newName", required: true, type: .string)
        ]
        /// The existing name of the repository.
        public let oldName: String
        /// The new name for the repository.
        public let newName: String

        public init(oldName: String, newName: String) {
            self.oldName = oldName
            self.newName = newName
        }

        private enum CodingKeys: String, CodingKey {
            case oldName = "oldName"
            case newName = "newName"
        }
    }

    public struct BatchGetRepositoriesOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositories", required: false, type: .list), 
            AWSShapeMember(label: "repositoriesNotFound", required: false, type: .list)
        ]
        /// A list of repositories returned by the batch get repositories operation.
        public let repositories: [RepositoryMetadata]?
        /// Returns a list of repository names for which information could not be found.
        public let repositoriesNotFound: [String]?

        public init(repositories: [RepositoryMetadata]? = nil, repositoriesNotFound: [String]? = nil) {
            self.repositories = repositories
            self.repositoriesNotFound = repositoriesNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case repositories = "repositories"
            case repositoriesNotFound = "repositoriesNotFound"
        }
    }

    public struct GetDifferencesOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "differences", required: false, type: .list)
        ]
        /// An enumeration token that can be used in a request to return the next batch of the results.
        public let nextToken: String?
        /// A differences data type object that contains information about the differences, including whether the difference is added, modified, or deleted (A, D, M).
        public let differences: [Difference]?

        public init(nextToken: String? = nil, differences: [Difference]? = nil) {
            self.nextToken = nextToken
            self.differences = differences
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case differences = "differences"
        }
    }

    public struct ListRepositoriesInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "sortBy", required: false, type: .enum), 
            AWSShapeMember(label: "order", required: false, type: .enum), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]
        /// The criteria used to sort the results of a list repositories operation.
        public let sortBy: SortByEnum?
        /// The order in which to sort the results of a list repositories operation.
        public let order: OrderEnum?
        /// An enumeration token that allows the operation to batch the results of the operation. Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit, another page of 1,000 records is retrieved.
        public let nextToken: String?

        public init(sortBy: SortByEnum? = nil, order: OrderEnum? = nil, nextToken: String? = nil) {
            self.sortBy = sortBy
            self.order = order
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case sortBy = "sortBy"
            case order = "order"
            case nextToken = "nextToken"
        }
    }

    public struct GetBlobOutput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "content", required: true, type: .blob)
        ]
        /// The content of the blob, usually a file.
        public let content: Data

        public init(content: Data) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct RepositoryTriggerExecutionFailure: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "failureMessage", required: false, type: .string), 
            AWSShapeMember(label: "trigger", required: false, type: .string)
        ]
        /// Additional message information about the trigger that did not run.
        public let failureMessage: String?
        /// The name of the trigger that did not run.
        public let trigger: String?

        public init(failureMessage: String? = nil, trigger: String? = nil) {
            self.failureMessage = failureMessage
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case failureMessage = "failureMessage"
            case trigger = "trigger"
        }
    }

    public struct GetBlobInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "blobId", required: true, type: .string), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The ID of the blob, which is its SHA-1 pointer.
        public let blobId: String
        /// The name of the repository that contains the blob.
        public let repositoryName: String

        public init(blobId: String, repositoryName: String) {
            self.blobId = blobId
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case blobId = "blobId"
            case repositoryName = "repositoryName"
        }
    }

    public struct CreateRepositoryInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryName", required: true, type: .string), 
            AWSShapeMember(label: "repositoryDescription", required: false, type: .string)
        ]
        /// The name of the new repository to be created.  The repository name must be unique across the calling AWS account. In addition, repository names are limited to 100 alphanumeric, dash, and underscore characters, and cannot include certain characters. For a full description of the limits on repository names, see Limits in the AWS CodeCommit User Guide. The suffix ".git" is prohibited. 
        public let repositoryName: String
        /// A comment or description about the new repository.  The description field for a repository accepts all HTML characters and all valid Unicode characters. Applications that do not HTML-encode the description and display it in a web page could expose users to potentially malicious code. Make sure that you HTML-encode the description field in any application that uses this API to display the repository description on a web page. 
        public let repositoryDescription: String?

        public init(repositoryName: String, repositoryDescription: String? = nil) {
            self.repositoryName = repositoryName
            self.repositoryDescription = repositoryDescription
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryName = "repositoryName"
            case repositoryDescription = "repositoryDescription"
        }
    }

    public struct PutRepositoryTriggersInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "triggers", required: true, type: .list), 
            AWSShapeMember(label: "repositoryName", required: true, type: .string)
        ]
        /// The JSON block of configuration information for each trigger.
        public let triggers: [RepositoryTrigger]
        /// The name of the repository where you want to create or update the trigger.
        public let repositoryName: String

        public init(triggers: [RepositoryTrigger], repositoryName: String) {
            self.triggers = triggers
            self.repositoryName = repositoryName
        }

        private enum CodingKeys: String, CodingKey {
            case triggers = "triggers"
            case repositoryName = "repositoryName"
        }
    }

    public struct BatchGetRepositoriesInput: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "repositoryNames", required: true, type: .list)
        ]
        /// The names of the repositories to get information about.
        public let repositoryNames: [String]

        public init(repositoryNames: [String]) {
            self.repositoryNames = repositoryNames
        }

        private enum CodingKeys: String, CodingKey {
            case repositoryNames = "repositoryNames"
        }
    }

}