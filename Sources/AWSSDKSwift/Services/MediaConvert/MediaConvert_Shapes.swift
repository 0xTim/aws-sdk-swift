// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaConvert {

    public enum Ac3MetadataControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public struct ResourceTags: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The tags for the resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case tags = "tags"
        }
    }

    public struct ListJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .querystring(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Status", location: .querystring(locationName: "status"), required: false, type: .enum)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of jobs.
        public let nextToken: String?
        /// Provide a queue name to get back only jobs from that queue.
        public let queue: String?
        public let order: Order?
        /// Optional. Number of jobs, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        public let status: JobStatus?

        public init(nextToken: String? = nil, queue: String? = nil, order: Order? = nil, maxResults: Int32? = nil, status: JobStatus? = nil) {
            self.nextToken = nextToken
            self.queue = queue
            self.order = order
            self.maxResults = maxResults
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queue = "queue"
            case order = "order"
            case maxResults = "maxResults"
            case status = "status"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .uri(locationName: "arn"), required: true, type: .string)
        ]
        /// The Amazon Resource Name (ARN) of the resource that you want to list tags for. To get the ARN, send a GET request with the resource name.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public enum DeinterlaceAlgorithm: String, CustomStringConvertible, Codable {
        case interpolate = "INTERPOLATE"
        case interpolateTicker = "INTERPOLATE_TICKER"
        case blend = "BLEND"
        case blendTicker = "BLEND_TICKER"
        public var description: String { return self.rawValue }
    }

    public enum ProresFramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public struct OutputDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DurationInMs", location: .body(locationName: "durationInMs"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoDetails", location: .body(locationName: "videoDetails"), required: false, type: .structure)
        ]
        /// Duration in milliseconds
        public let durationInMs: Int32?
        public let videoDetails: VideoDetail?

        public init(durationInMs: Int32? = nil, videoDetails: VideoDetail? = nil) {
            self.durationInMs = durationInMs
            self.videoDetails = videoDetails
        }

        private enum CodingKeys: String, CodingKey {
            case durationInMs = "durationInMs"
            case videoDetails = "videoDetails"
        }
    }

    public struct CancelJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        /// The Job ID of the job to be cancelled.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct Eac3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LtRtSurroundMixLevel", location: .body(locationName: "ltRtSurroundMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "PhaseControl", location: .body(locationName: "phaseControl"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicRangeCompressionLine", location: .body(locationName: "dynamicRangeCompressionLine"), required: false, type: .enum), 
            AWSShapeMember(label: "StereoDownmix", location: .body(locationName: "stereoDownmix"), required: false, type: .enum), 
            AWSShapeMember(label: "LoRoCenterMixLevel", location: .body(locationName: "loRoCenterMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "Dialnorm", location: .body(locationName: "dialnorm"), required: false, type: .integer), 
            AWSShapeMember(label: "SurroundMode", location: .body(locationName: "surroundMode"), required: false, type: .enum), 
            AWSShapeMember(label: "AttenuationControl", location: .body(locationName: "attenuationControl"), required: false, type: .enum), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeFilter", location: .body(locationName: "lfeFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "PassthroughControl", location: .body(locationName: "passthroughControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LfeControl", location: .body(locationName: "lfeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "DynamicRangeCompressionRf", location: .body(locationName: "dynamicRangeCompressionRf"), required: false, type: .enum), 
            AWSShapeMember(label: "BitstreamMode", location: .body(locationName: "bitstreamMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SurroundExMode", location: .body(locationName: "surroundExMode"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "DcFilter", location: .body(locationName: "dcFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "LoRoSurroundMixLevel", location: .body(locationName: "loRoSurroundMixLevel"), required: false, type: .double), 
            AWSShapeMember(label: "MetadataControl", location: .body(locationName: "metadataControl"), required: false, type: .enum), 
            AWSShapeMember(label: "LtRtCenterMixLevel", location: .body(locationName: "ltRtCenterMixLevel"), required: false, type: .double)
        ]
        /// Left total/Right total surround mix level. Only used for 3/2 coding mode.
        /// Valid values: -1.5 -3.0 -4.5 -6.0 -60
        public let ltRtSurroundMixLevel: Double?
        public let phaseControl: Eac3PhaseControl?
        public let dynamicRangeCompressionLine: Eac3DynamicRangeCompressionLine?
        public let stereoDownmix: Eac3StereoDownmix?
        /// Left only/Right only center mix level. Only used for 3/2 coding mode.
        /// Valid values: 3.0, 1.5, 0.0, -1.5 -3.0 -4.5 -6.0 -60
        public let loRoCenterMixLevel: Double?
        /// Sets the dialnorm for the output. If blank and input audio is Dolby Digital Plus, dialnorm will be passed through.
        public let dialnorm: Int32?
        public let surroundMode: Eac3SurroundMode?
        public let attenuationControl: Eac3AttenuationControl?
        public let codingMode: Eac3CodingMode?
        public let lfeFilter: Eac3LfeFilter?
        public let passthroughControl: Eac3PassthroughControl?
        public let lfeControl: Eac3LfeControl?
        public let dynamicRangeCompressionRf: Eac3DynamicRangeCompressionRf?
        public let bitstreamMode: Eac3BitstreamMode?
        public let surroundExMode: Eac3SurroundExMode?
        /// Sample rate in hz. Sample rate is always 48000.
        public let sampleRate: Int32?
        /// Average bitrate in bits/second. Valid bitrates depend on the coding mode.
        public let bitrate: Int32?
        public let dcFilter: Eac3DcFilter?
        /// Left only/Right only surround mix level. Only used for 3/2 coding mode.
        /// Valid values: -1.5 -3.0 -4.5 -6.0 -60
        public let loRoSurroundMixLevel: Double?
        public let metadataControl: Eac3MetadataControl?
        /// Left total/Right total center mix level. Only used for 3/2 coding mode.
        /// Valid values: 3.0, 1.5, 0.0, -1.5 -3.0 -4.5 -6.0 -60
        public let ltRtCenterMixLevel: Double?

        public init(ltRtSurroundMixLevel: Double? = nil, phaseControl: Eac3PhaseControl? = nil, dynamicRangeCompressionLine: Eac3DynamicRangeCompressionLine? = nil, stereoDownmix: Eac3StereoDownmix? = nil, loRoCenterMixLevel: Double? = nil, dialnorm: Int32? = nil, surroundMode: Eac3SurroundMode? = nil, attenuationControl: Eac3AttenuationControl? = nil, codingMode: Eac3CodingMode? = nil, lfeFilter: Eac3LfeFilter? = nil, passthroughControl: Eac3PassthroughControl? = nil, lfeControl: Eac3LfeControl? = nil, dynamicRangeCompressionRf: Eac3DynamicRangeCompressionRf? = nil, bitstreamMode: Eac3BitstreamMode? = nil, surroundExMode: Eac3SurroundExMode? = nil, sampleRate: Int32? = nil, bitrate: Int32? = nil, dcFilter: Eac3DcFilter? = nil, loRoSurroundMixLevel: Double? = nil, metadataControl: Eac3MetadataControl? = nil, ltRtCenterMixLevel: Double? = nil) {
            self.ltRtSurroundMixLevel = ltRtSurroundMixLevel
            self.phaseControl = phaseControl
            self.dynamicRangeCompressionLine = dynamicRangeCompressionLine
            self.stereoDownmix = stereoDownmix
            self.loRoCenterMixLevel = loRoCenterMixLevel
            self.dialnorm = dialnorm
            self.surroundMode = surroundMode
            self.attenuationControl = attenuationControl
            self.codingMode = codingMode
            self.lfeFilter = lfeFilter
            self.passthroughControl = passthroughControl
            self.lfeControl = lfeControl
            self.dynamicRangeCompressionRf = dynamicRangeCompressionRf
            self.bitstreamMode = bitstreamMode
            self.surroundExMode = surroundExMode
            self.sampleRate = sampleRate
            self.bitrate = bitrate
            self.dcFilter = dcFilter
            self.loRoSurroundMixLevel = loRoSurroundMixLevel
            self.metadataControl = metadataControl
            self.ltRtCenterMixLevel = ltRtCenterMixLevel
        }

        private enum CodingKeys: String, CodingKey {
            case ltRtSurroundMixLevel = "ltRtSurroundMixLevel"
            case phaseControl = "phaseControl"
            case dynamicRangeCompressionLine = "dynamicRangeCompressionLine"
            case stereoDownmix = "stereoDownmix"
            case loRoCenterMixLevel = "loRoCenterMixLevel"
            case dialnorm = "dialnorm"
            case surroundMode = "surroundMode"
            case attenuationControl = "attenuationControl"
            case codingMode = "codingMode"
            case lfeFilter = "lfeFilter"
            case passthroughControl = "passthroughControl"
            case lfeControl = "lfeControl"
            case dynamicRangeCompressionRf = "dynamicRangeCompressionRf"
            case bitstreamMode = "bitstreamMode"
            case surroundExMode = "surroundExMode"
            case sampleRate = "sampleRate"
            case bitrate = "bitrate"
            case dcFilter = "dcFilter"
            case loRoSurroundMixLevel = "loRoSurroundMixLevel"
            case metadataControl = "metadataControl"
            case ltRtCenterMixLevel = "ltRtCenterMixLevel"
        }
    }

    public enum Eac3DynamicRangeCompressionLine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case filmStandard = "FILM_STANDARD"
        case filmLight = "FILM_LIGHT"
        case musicStandard = "MUSIC_STANDARD"
        case musicLight = "MUSIC_LIGHT"
        case speech = "SPEECH"
        public var description: String { return self.rawValue }
    }

    public struct FileGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string)
        ]
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?

        public init(destination: String? = nil) {
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
        }
    }

    public struct JobTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// An optional category you create to organize your job templates.
        public let category: String?
        /// The timestamp in epoch seconds for Job template creation.
        public let createdAt: TimeStamp?
        public let settings: JobTemplateSettings
        /// A job template can be of two types: system or custom. System or built-in job templates can't be modified or deleted by the user.
        public let `type`: `Type`?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
        public let queue: String?
        /// The timestamp in epoch seconds when the Job template was last updated.
        public let lastUpdated: TimeStamp?
        /// A name you create for each job template. Each name must be unique within your account.
        public let name: String
        /// An optional description you create for each job template.
        public let description: String?

        public init(category: String? = nil, createdAt: TimeStamp? = nil, settings: JobTemplateSettings, type: `Type`? = nil, arn: String? = nil, queue: String? = nil, lastUpdated: TimeStamp? = nil, name: String, description: String? = nil) {
            self.category = category
            self.createdAt = createdAt
            self.settings = settings
            self.`type` = `type`
            self.arn = arn
            self.queue = queue
            self.lastUpdated = lastUpdated
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case createdAt = "createdAt"
            case settings = "settings"
            case `type` = "type"
            case arn = "arn"
            case queue = "queue"
            case lastUpdated = "lastUpdated"
            case name = "name"
            case description = "description"
        }
    }

    public enum Eac3PhaseControl: String, CustomStringConvertible, Codable {
        case shift90Degrees = "SHIFT_90_DEGREES"
        case noShift = "NO_SHIFT"
        public var description: String { return self.rawValue }
    }

    public enum HlsAdMarkers: String, CustomStringConvertible, Codable {
        case elemental = "ELEMENTAL"
        case elementalScte35 = "ELEMENTAL_SCTE35"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationLoudnessLogging: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case dontLog = "DONT_LOG"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .body(locationName: "maxResults"), required: false, type: .integer)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of endpoints.
        public let nextToken: String?
        /// Optional. Max number of endpoints, up to twenty, that will be returned at one time.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case maxResults = "maxResults"
        }
    }

    public struct FrameCaptureSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxCaptures", location: .body(locationName: "maxCaptures"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "Quality", location: .body(locationName: "quality"), required: false, type: .integer)
        ]
        /// Frame capture will encode the first frame of the output stream, then one frame every framerateDenominator/framerateNumerator seconds. For example, settings of framerateNumerator = 1 and framerateDenominator = 3 (a rate of 1/3 frame per second) will capture the first frame, then 1 frame every 3s. Files will be named as filename.n.jpg where n is the 0-based sequence number of each Capture.
        public let framerateDenominator: Int32?
        /// Maximum number of captures (encoded jpg output files).
        public let maxCaptures: Int32?
        /// Frame capture will encode the first frame of the output stream, then one frame every framerateDenominator/framerateNumerator seconds. For example, settings of framerateNumerator = 1 and framerateDenominator = 3 (a rate of 1/3 frame per second) will capture the first frame, then 1 frame every 3s. Files will be named as filename.NNNNNNN.jpg where N is the 0-based frame sequence number zero padded to 7 decimal places.
        public let framerateNumerator: Int32?
        /// JPEG Quality - a higher value equals higher quality.
        public let quality: Int32?

        public init(framerateDenominator: Int32? = nil, maxCaptures: Int32? = nil, framerateNumerator: Int32? = nil, quality: Int32? = nil) {
            self.framerateDenominator = framerateDenominator
            self.maxCaptures = maxCaptures
            self.framerateNumerator = framerateNumerator
            self.quality = quality
        }

        private enum CodingKeys: String, CodingKey {
            case framerateDenominator = "framerateDenominator"
            case maxCaptures = "maxCaptures"
            case framerateNumerator = "framerateNumerator"
            case quality = "quality"
        }
    }

    public enum H264InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum H265GopBReference: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct TeletextSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageNumber", location: .body(locationName: "pageNumber"), required: false, type: .string)
        ]
        /// Use Page Number (PageNumber) to specify the three-digit hexadecimal page number that will be used for Teletext captions. Do not use this setting if you are passing through teletext from the input source to output.
        public let pageNumber: String?

        public init(pageNumber: String? = nil) {
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "pageNumber"
        }
    }

    public enum NoiseReducerFilter: String, CustomStringConvertible, Codable {
        case bilateral = "BILATERAL"
        case mean = "MEAN"
        case gaussian = "GAUSSIAN"
        case lanczos = "LANCZOS"
        case sharpen = "SHARPEN"
        case conserve = "CONSERVE"
        case spatial = "SPATIAL"
        public var description: String { return self.rawValue }
    }

    public enum Eac3StereoDownmix: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case loRo = "LO_RO"
        case ltRt = "LT_RT"
        case dpl2 = "DPL2"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleFontColor: String, CustomStringConvertible, Codable {
        case white = "WHITE"
        case black = "BLACK"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum HlsTimedMetadataId3Frame: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case priv = "PRIV"
        case tdrl = "TDRL"
        public var description: String { return self.rawValue }
    }

    public struct Preset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// An optional category you create to organize your presets.
        public let category: String?
        /// The timestamp in epoch seconds for preset creation.
        public let createdAt: TimeStamp?
        public let settings: PresetSettings
        /// A preset can be of two types: system or custom. System or built-in preset can't be modified or deleted by the user.
        public let `type`: `Type`?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// The timestamp in epoch seconds when the preset was last updated.
        public let lastUpdated: TimeStamp?
        /// A name you create for each preset. Each name must be unique within your account.
        public let name: String
        /// An optional description you create for each preset.
        public let description: String?

        public init(category: String? = nil, createdAt: TimeStamp? = nil, settings: PresetSettings, type: `Type`? = nil, arn: String? = nil, lastUpdated: TimeStamp? = nil, name: String, description: String? = nil) {
            self.category = category
            self.createdAt = createdAt
            self.settings = settings
            self.`type` = `type`
            self.arn = arn
            self.lastUpdated = lastUpdated
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case createdAt = "createdAt"
            case settings = "settings"
            case `type` = "type"
            case arn = "arn"
            case lastUpdated = "lastUpdated"
            case name = "name"
            case description = "description"
        }
    }

    public enum BurninSubtitleBackgroundColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public struct DvbSubDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ShadowOpacity", location: .body(locationName: "shadowOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "YPosition", location: .body(locationName: "yPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "BackgroundColor", location: .body(locationName: "backgroundColor"), required: false, type: .enum), 
            AWSShapeMember(label: "XPosition", location: .body(locationName: "xPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "Alignment", location: .body(locationName: "alignment"), required: true, type: .enum), 
            AWSShapeMember(label: "OutlineSize", location: .body(locationName: "outlineSize"), required: true, type: .integer), 
            AWSShapeMember(label: "OutlineColor", location: .body(locationName: "outlineColor"), required: true, type: .enum), 
            AWSShapeMember(label: "ShadowColor", location: .body(locationName: "shadowColor"), required: false, type: .enum), 
            AWSShapeMember(label: "ShadowYOffset", location: .body(locationName: "shadowYOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "FontResolution", location: .body(locationName: "fontResolution"), required: false, type: .integer), 
            AWSShapeMember(label: "TeletextSpacing", location: .body(locationName: "teletextSpacing"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundOpacity", location: .body(locationName: "backgroundOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowXOffset", location: .body(locationName: "shadowXOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "FontColor", location: .body(locationName: "fontColor"), required: false, type: .enum), 
            AWSShapeMember(label: "FontOpacity", location: .body(locationName: "fontOpacity"), required: true, type: .integer)
        ]
        /// Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let shadowOpacity: Int32?
        /// A positive integer indicates the exact font size in points. Set to 0 for automatic font size selection. All burn-in and DVB-Sub font settings must match.
        public let fontSize: Int32?
        /// Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit y_position is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let yPosition: Int32?
        public let backgroundColor: DvbSubtitleBackgroundColor?
        /// Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit x_position is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let xPosition: Int32?
        public let alignment: DvbSubtitleAlignment
        /// Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let outlineSize: Int32
        public let outlineColor: DvbSubtitleOutlineColor
        public let shadowColor: DvbSubtitleShadowColor?
        /// Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        public let shadowYOffset: Int32?
        /// Font resolution in DPI (dots per inch); default is 96 dpi.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontResolution: Int32?
        public let teletextSpacing: DvbSubtitleTeletextSpacing?
        /// Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let backgroundOpacity: Int32?
        /// Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        public let shadowXOffset: Int32?
        public let fontColor: DvbSubtitleFontColor?
        /// Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontOpacity: Int32

        public init(shadowOpacity: Int32? = nil, fontSize: Int32? = nil, yPosition: Int32? = nil, backgroundColor: DvbSubtitleBackgroundColor? = nil, xPosition: Int32? = nil, alignment: DvbSubtitleAlignment, outlineSize: Int32, outlineColor: DvbSubtitleOutlineColor, shadowColor: DvbSubtitleShadowColor? = nil, shadowYOffset: Int32? = nil, fontResolution: Int32? = nil, teletextSpacing: DvbSubtitleTeletextSpacing? = nil, backgroundOpacity: Int32? = nil, shadowXOffset: Int32? = nil, fontColor: DvbSubtitleFontColor? = nil, fontOpacity: Int32) {
            self.shadowOpacity = shadowOpacity
            self.fontSize = fontSize
            self.yPosition = yPosition
            self.backgroundColor = backgroundColor
            self.xPosition = xPosition
            self.alignment = alignment
            self.outlineSize = outlineSize
            self.outlineColor = outlineColor
            self.shadowColor = shadowColor
            self.shadowYOffset = shadowYOffset
            self.fontResolution = fontResolution
            self.teletextSpacing = teletextSpacing
            self.backgroundOpacity = backgroundOpacity
            self.shadowXOffset = shadowXOffset
            self.fontColor = fontColor
            self.fontOpacity = fontOpacity
        }

        private enum CodingKeys: String, CodingKey {
            case shadowOpacity = "shadowOpacity"
            case fontSize = "fontSize"
            case yPosition = "yPosition"
            case backgroundColor = "backgroundColor"
            case xPosition = "xPosition"
            case alignment = "alignment"
            case outlineSize = "outlineSize"
            case outlineColor = "outlineColor"
            case shadowColor = "shadowColor"
            case shadowYOffset = "shadowYOffset"
            case fontResolution = "fontResolution"
            case teletextSpacing = "teletextSpacing"
            case backgroundOpacity = "backgroundOpacity"
            case shadowXOffset = "shadowXOffset"
            case fontColor = "fontColor"
            case fontOpacity = "fontOpacity"
        }
    }

    public enum AacRawFormat: String, CustomStringConvertible, Codable {
        case latmLoas = "LATM_LOAS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct H265Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberReferenceFrames", location: .body(locationName: "numberReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "WriteMp4PackagingType", location: .body(locationName: "writeMp4PackagingType"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "Tiles", location: .body(locationName: "tiles"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "FlickerAdaptiveQuantization", location: .body(locationName: "flickerAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "GopBReference", location: .body(locationName: "gopBReference"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "Slices", location: .body(locationName: "slices"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "AlternateTransferFunctionSei", location: .body(locationName: "alternateTransferFunctionSei"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalIds", location: .body(locationName: "temporalIds"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "UnregisteredSeiTimecode", location: .body(locationName: "unregisteredSeiTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleAdaptiveOffsetFilterMode", location: .body(locationName: "sampleAdaptiveOffsetFilterMode"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer)
        ]
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        public let framerateConversionAlgorithm: H265FramerateConversionAlgorithm?
        /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
        public let numberReferenceFrames: Int32?
        public let rateControlMode: H265RateControlMode?
        /// Maximum bitrate in bits/second.
        public let maxBitrate: Int32?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        public let writeMp4PackagingType: H265WriteMp4PackagingType?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let gopSizeUnits: H265GopSizeUnits?
        public let parControl: H265ParControl?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        public let adaptiveQuantization: H265AdaptiveQuantization?
        public let tiles: H265Tiles?
        public let interlaceMode: H265InterlaceMode?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        public let flickerAdaptiveQuantization: H265FlickerAdaptiveQuantization?
        public let slowPal: H265SlowPal?
        public let telecine: H265Telecine?
        public let gopBReference: H265GopBReference?
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures.
        public let slices: Int32?
        public let codecLevel: H265CodecLevel?
        /// Average bitrate in bits/second. Required for VBR and CBR. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let framerateControl: H265FramerateControl?
        public let alternateTransferFunctionSei: H265AlternateTransferFunctionSei?
        public let qualityTuningLevel: H265QualityTuningLevel?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        public let spatialAdaptiveQuantization: H265SpatialAdaptiveQuantization?
        public let sceneChangeDetect: H265SceneChangeDetect?
        public let codecProfile: H265CodecProfile?
        public let temporalIds: H265TemporalIds?
        /// Size of buffer (HRD buffer model) in bits. For example, enter five megabits as 5000000.
        public let hrdBufferSize: Int32?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let unregisteredSeiTimecode: H265UnregisteredSeiTimecode?
        public let sampleAdaptiveOffsetFilterMode: H265SampleAdaptiveOffsetFilterMode?
        public let temporalAdaptiveQuantization: H265TemporalAdaptiveQuantization?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?

        public init(framerateNumerator: Int32? = nil, framerateConversionAlgorithm: H265FramerateConversionAlgorithm? = nil, numberReferenceFrames: Int32? = nil, rateControlMode: H265RateControlMode? = nil, maxBitrate: Int32? = nil, gopSize: Double? = nil, writeMp4PackagingType: H265WriteMp4PackagingType? = nil, framerateDenominator: Int32? = nil, gopSizeUnits: H265GopSizeUnits? = nil, parControl: H265ParControl? = nil, gopClosedCadence: Int32? = nil, adaptiveQuantization: H265AdaptiveQuantization? = nil, tiles: H265Tiles? = nil, interlaceMode: H265InterlaceMode? = nil, parDenominator: Int32? = nil, flickerAdaptiveQuantization: H265FlickerAdaptiveQuantization? = nil, slowPal: H265SlowPal? = nil, telecine: H265Telecine? = nil, gopBReference: H265GopBReference? = nil, numberBFramesBetweenReferenceFrames: Int32? = nil, slices: Int32? = nil, codecLevel: H265CodecLevel? = nil, bitrate: Int32? = nil, framerateControl: H265FramerateControl? = nil, alternateTransferFunctionSei: H265AlternateTransferFunctionSei? = nil, qualityTuningLevel: H265QualityTuningLevel? = nil, hrdBufferInitialFillPercentage: Int32? = nil, spatialAdaptiveQuantization: H265SpatialAdaptiveQuantization? = nil, sceneChangeDetect: H265SceneChangeDetect? = nil, codecProfile: H265CodecProfile? = nil, temporalIds: H265TemporalIds? = nil, hrdBufferSize: Int32? = nil, minIInterval: Int32? = nil, unregisteredSeiTimecode: H265UnregisteredSeiTimecode? = nil, sampleAdaptiveOffsetFilterMode: H265SampleAdaptiveOffsetFilterMode? = nil, temporalAdaptiveQuantization: H265TemporalAdaptiveQuantization? = nil, parNumerator: Int32? = nil) {
            self.framerateNumerator = framerateNumerator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.numberReferenceFrames = numberReferenceFrames
            self.rateControlMode = rateControlMode
            self.maxBitrate = maxBitrate
            self.gopSize = gopSize
            self.writeMp4PackagingType = writeMp4PackagingType
            self.framerateDenominator = framerateDenominator
            self.gopSizeUnits = gopSizeUnits
            self.parControl = parControl
            self.gopClosedCadence = gopClosedCadence
            self.adaptiveQuantization = adaptiveQuantization
            self.tiles = tiles
            self.interlaceMode = interlaceMode
            self.parDenominator = parDenominator
            self.flickerAdaptiveQuantization = flickerAdaptiveQuantization
            self.slowPal = slowPal
            self.telecine = telecine
            self.gopBReference = gopBReference
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.slices = slices
            self.codecLevel = codecLevel
            self.bitrate = bitrate
            self.framerateControl = framerateControl
            self.alternateTransferFunctionSei = alternateTransferFunctionSei
            self.qualityTuningLevel = qualityTuningLevel
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.sceneChangeDetect = sceneChangeDetect
            self.codecProfile = codecProfile
            self.temporalIds = temporalIds
            self.hrdBufferSize = hrdBufferSize
            self.minIInterval = minIInterval
            self.unregisteredSeiTimecode = unregisteredSeiTimecode
            self.sampleAdaptiveOffsetFilterMode = sampleAdaptiveOffsetFilterMode
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.parNumerator = parNumerator
        }

        private enum CodingKeys: String, CodingKey {
            case framerateNumerator = "framerateNumerator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case numberReferenceFrames = "numberReferenceFrames"
            case rateControlMode = "rateControlMode"
            case maxBitrate = "maxBitrate"
            case gopSize = "gopSize"
            case writeMp4PackagingType = "writeMp4PackagingType"
            case framerateDenominator = "framerateDenominator"
            case gopSizeUnits = "gopSizeUnits"
            case parControl = "parControl"
            case gopClosedCadence = "gopClosedCadence"
            case adaptiveQuantization = "adaptiveQuantization"
            case tiles = "tiles"
            case interlaceMode = "interlaceMode"
            case parDenominator = "parDenominator"
            case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
            case slowPal = "slowPal"
            case telecine = "telecine"
            case gopBReference = "gopBReference"
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case slices = "slices"
            case codecLevel = "codecLevel"
            case bitrate = "bitrate"
            case framerateControl = "framerateControl"
            case alternateTransferFunctionSei = "alternateTransferFunctionSei"
            case qualityTuningLevel = "qualityTuningLevel"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case sceneChangeDetect = "sceneChangeDetect"
            case codecProfile = "codecProfile"
            case temporalIds = "temporalIds"
            case hrdBufferSize = "hrdBufferSize"
            case minIInterval = "minIInterval"
            case unregisteredSeiTimecode = "unregisteredSeiTimecode"
            case sampleAdaptiveOffsetFilterMode = "sampleAdaptiveOffsetFilterMode"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case parNumerator = "parNumerator"
        }
    }

    public enum Mpeg2AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public struct AudioCodecSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Ac3Settings", location: .body(locationName: "ac3Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "AiffSettings", location: .body(locationName: "aiffSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Eac3Settings", location: .body(locationName: "eac3Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Mp2Settings", location: .body(locationName: "mp2Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "WavSettings", location: .body(locationName: "wavSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Codec", location: .body(locationName: "codec"), required: true, type: .enum), 
            AWSShapeMember(label: "AacSettings", location: .body(locationName: "aacSettings"), required: false, type: .structure)
        ]
        public let ac3Settings: Ac3Settings?
        public let aiffSettings: AiffSettings?
        public let eac3Settings: Eac3Settings?
        public let mp2Settings: Mp2Settings?
        public let wavSettings: WavSettings?
        public let codec: AudioCodec
        public let aacSettings: AacSettings?

        public init(ac3Settings: Ac3Settings? = nil, aiffSettings: AiffSettings? = nil, eac3Settings: Eac3Settings? = nil, mp2Settings: Mp2Settings? = nil, wavSettings: WavSettings? = nil, codec: AudioCodec, aacSettings: AacSettings? = nil) {
            self.ac3Settings = ac3Settings
            self.aiffSettings = aiffSettings
            self.eac3Settings = eac3Settings
            self.mp2Settings = mp2Settings
            self.wavSettings = wavSettings
            self.codec = codec
            self.aacSettings = aacSettings
        }

        private enum CodingKeys: String, CodingKey {
            case ac3Settings = "ac3Settings"
            case aiffSettings = "aiffSettings"
            case eac3Settings = "eac3Settings"
            case mp2Settings = "mp2Settings"
            case wavSettings = "wavSettings"
            case codec = "codec"
            case aacSettings = "aacSettings"
        }
    }

    public enum M2tsRateMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum AacSpecification: String, CustomStringConvertible, Codable {
        case mpeg2 = "MPEG2"
        case mpeg4 = "MPEG4"
        public var description: String { return self.rawValue }
    }

    public struct AacSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "VbrQuality", location: .body(locationName: "vbrQuality"), required: false, type: .enum), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: true, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "RawFormat", location: .body(locationName: "rawFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "Specification", location: .body(locationName: "specification"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: true, type: .integer), 
            AWSShapeMember(label: "AudioDescriptionBroadcasterMix", location: .body(locationName: "audioDescriptionBroadcasterMix"), required: false, type: .enum)
        ]
        /// Average bitrate in bits/second. Defaults and valid values depend on rate control mode and profile.
        public let bitrate: Int32?
        public let vbrQuality: AacVbrQuality?
        public let codingMode: AacCodingMode
        public let codecProfile: AacCodecProfile?
        public let rateControlMode: AacRateControlMode?
        public let rawFormat: AacRawFormat?
        public let specification: AacSpecification?
        /// Sample rate in Hz. Valid values depend on rate control mode and profile.
        public let sampleRate: Int32
        public let audioDescriptionBroadcasterMix: AacAudioDescriptionBroadcasterMix?

        public init(bitrate: Int32? = nil, vbrQuality: AacVbrQuality? = nil, codingMode: AacCodingMode, codecProfile: AacCodecProfile? = nil, rateControlMode: AacRateControlMode? = nil, rawFormat: AacRawFormat? = nil, specification: AacSpecification? = nil, sampleRate: Int32, audioDescriptionBroadcasterMix: AacAudioDescriptionBroadcasterMix? = nil) {
            self.bitrate = bitrate
            self.vbrQuality = vbrQuality
            self.codingMode = codingMode
            self.codecProfile = codecProfile
            self.rateControlMode = rateControlMode
            self.rawFormat = rawFormat
            self.specification = specification
            self.sampleRate = sampleRate
            self.audioDescriptionBroadcasterMix = audioDescriptionBroadcasterMix
        }

        private enum CodingKeys: String, CodingKey {
            case bitrate = "bitrate"
            case vbrQuality = "vbrQuality"
            case codingMode = "codingMode"
            case codecProfile = "codecProfile"
            case rateControlMode = "rateControlMode"
            case rawFormat = "rawFormat"
            case specification = "specification"
            case sampleRate = "sampleRate"
            case audioDescriptionBroadcasterMix = "audioDescriptionBroadcasterMix"
        }
    }

    public struct OutputGroupDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputDetails", location: .body(locationName: "outputDetails"), required: false, type: .list)
        ]
        /// Details about the output
        public let outputDetails: [OutputDetail]?

        public init(outputDetails: [OutputDetail]? = nil) {
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case outputDetails = "outputDetails"
        }
    }

    public enum H265FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum Eac3LfeControl: String, CustomStringConvertible, Codable {
        case lfe = "LFE"
        case noLfe = "NO_LFE"
        public var description: String { return self.rawValue }
    }

    public enum ProresTelecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum H264RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum InputFilterEnable: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case disable = "DISABLE"
        case force = "FORCE"
        public var description: String { return self.rawValue }
    }

    public enum H264ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct PresetSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CaptionDescriptions", location: .body(locationName: "captionDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "VideoDescription", location: .body(locationName: "videoDescription"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioDescriptions", location: .body(locationName: "audioDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "ContainerSettings", location: .body(locationName: "containerSettings"), required: false, type: .structure)
        ]
        /// Caption settings for this preset. There can be multiple caption settings in a single output.
        public let captionDescriptions: [CaptionDescriptionPreset]?
        /// (VideoDescription) contains a group of video encoding settings. The specific video settings depend on the video codec you choose when you specify a value for Video codec (codec). Include one instance of (VideoDescription) per output.
        public let videoDescription: VideoDescription?
        /// (AudioDescriptions) contains groups of audio encoding settings organized by audio codec. Include one instance of (AudioDescriptions) per output. (AudioDescriptions) can contain multiple groups of encoding settings.
        public let audioDescriptions: [AudioDescription]?
        public let containerSettings: ContainerSettings?

        public init(captionDescriptions: [CaptionDescriptionPreset]? = nil, videoDescription: VideoDescription? = nil, audioDescriptions: [AudioDescription]? = nil, containerSettings: ContainerSettings? = nil) {
            self.captionDescriptions = captionDescriptions
            self.videoDescription = videoDescription
            self.audioDescriptions = audioDescriptions
            self.containerSettings = containerSettings
        }

        private enum CodingKeys: String, CodingKey {
            case captionDescriptions = "captionDescriptions"
            case videoDescription = "videoDescription"
            case audioDescriptions = "audioDescriptions"
            case containerSettings = "containerSettings"
        }
    }

    public enum F4vMoovPlacement: String, CustomStringConvertible, Codable {
        case progressiveDownload = "PROGRESSIVE_DOWNLOAD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum H265WriteMp4PackagingType: String, CustomStringConvertible, Codable {
        case hvc1 = "HVC1"
        case hev1 = "HEV1"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case singlePassHq = "SINGLE_PASS_HQ"
        case multiPassHq = "MULTI_PASS_HQ"
        public var description: String { return self.rawValue }
    }

    public struct DvbNitSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NetworkName", location: .body(locationName: "networkName"), required: true, type: .string), 
            AWSShapeMember(label: "NetworkId", location: .body(locationName: "networkId"), required: true, type: .integer), 
            AWSShapeMember(label: "NitInterval", location: .body(locationName: "nitInterval"), required: true, type: .integer)
        ]
        /// The network name text placed in the network_name_descriptor inside the Network Information Table. Maximum length is 256 characters.
        public let networkName: String
        /// The numeric value placed in the Network Information Table (NIT).
        public let networkId: Int32
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let nitInterval: Int32

        public init(networkName: String, networkId: Int32, nitInterval: Int32) {
            self.networkName = networkName
            self.networkId = networkId
            self.nitInterval = nitInterval
        }

        private enum CodingKeys: String, CodingKey {
            case networkName = "networkName"
            case networkId = "networkId"
            case nitInterval = "nitInterval"
        }
    }

    public struct ListJobTemplatesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplates", location: .body(locationName: "jobTemplates"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of job templates.
        public let nextToken: String?
        /// List of Job templates.
        public let jobTemplates: [JobTemplate]?

        public init(nextToken: String? = nil, jobTemplates: [JobTemplate]? = nil) {
            self.nextToken = nextToken
            self.jobTemplates = jobTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case jobTemplates = "jobTemplates"
        }
    }

    public enum AntiAlias: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionSelectorName", location: .body(locationName: "captionSelectorName"), required: true, type: .string), 
            AWSShapeMember(label: "DestinationSettings", location: .body(locationName: "destinationSettings"), required: true, type: .structure)
        ]
        /// Human readable information to indicate captions available for players (eg. English, or Spanish). Alphanumeric characters, spaces, and underscore are legal.
        public let languageDescription: String?
        /// Indicates the language of the caption output track, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        /// Indicates the language of the caption output track.
        public let languageCode: LanguageCode?
        /// Specifies which "Caption Selector":#inputs-caption_selector to use from each input when generating captions. The name should be of the format "Caption Selector ", which denotes that the Nth Caption Selector will be used from each input.
        public let captionSelectorName: String
        public let destinationSettings: CaptionDestinationSettings

        public init(languageDescription: String? = nil, customLanguageCode: String? = nil, languageCode: LanguageCode? = nil, captionSelectorName: String, destinationSettings: CaptionDestinationSettings) {
            self.languageDescription = languageDescription
            self.customLanguageCode = customLanguageCode
            self.languageCode = languageCode
            self.captionSelectorName = captionSelectorName
            self.destinationSettings = destinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case languageDescription = "languageDescription"
            case customLanguageCode = "customLanguageCode"
            case languageCode = "languageCode"
            case captionSelectorName = "captionSelectorName"
            case destinationSettings = "destinationSettings"
        }
    }

    public enum HlsCaptionLanguageSetting: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case omit = "OMIT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum LanguageCode: String, CustomStringConvertible, Codable {
        case eng = "ENG"
        case spa = "SPA"
        case fra = "FRA"
        case deu = "DEU"
        case ger = "GER"
        case zho = "ZHO"
        case ara = "ARA"
        case hin = "HIN"
        case jpn = "JPN"
        case rus = "RUS"
        case por = "POR"
        case ita = "ITA"
        case urd = "URD"
        case vie = "VIE"
        case kor = "KOR"
        case pan = "PAN"
        case abk = "ABK"
        case aar = "AAR"
        case afr = "AFR"
        case aka = "AKA"
        case sqi = "SQI"
        case amh = "AMH"
        case arg = "ARG"
        case hye = "HYE"
        case asm = "ASM"
        case ava = "AVA"
        case ave = "AVE"
        case aym = "AYM"
        case aze = "AZE"
        case bam = "BAM"
        case bak = "BAK"
        case eus = "EUS"
        case bel = "BEL"
        case ben = "BEN"
        case bih = "BIH"
        case bis = "BIS"
        case bos = "BOS"
        case bre = "BRE"
        case bul = "BUL"
        case mya = "MYA"
        case cat = "CAT"
        case khm = "KHM"
        case cha = "CHA"
        case che = "CHE"
        case nya = "NYA"
        case chu = "CHU"
        case chv = "CHV"
        case cor = "COR"
        case cos = "COS"
        case cre = "CRE"
        case hrv = "HRV"
        case ces = "CES"
        case dan = "DAN"
        case div = "DIV"
        case nld = "NLD"
        case dzo = "DZO"
        case enm = "ENM"
        case epo = "EPO"
        case est = "EST"
        case ewe = "EWE"
        case fao = "FAO"
        case fij = "FIJ"
        case fin = "FIN"
        case frm = "FRM"
        case ful = "FUL"
        case gla = "GLA"
        case glg = "GLG"
        case lug = "LUG"
        case kat = "KAT"
        case ell = "ELL"
        case grn = "GRN"
        case guj = "GUJ"
        case hat = "HAT"
        case hau = "HAU"
        case heb = "HEB"
        case her = "HER"
        case hmo = "HMO"
        case hun = "HUN"
        case isl = "ISL"
        case ido = "IDO"
        case ibo = "IBO"
        case ind = "IND"
        case ina = "INA"
        case ile = "ILE"
        case iku = "IKU"
        case ipk = "IPK"
        case gle = "GLE"
        case jav = "JAV"
        case kal = "KAL"
        case kan = "KAN"
        case kau = "KAU"
        case kas = "KAS"
        case kaz = "KAZ"
        case kik = "KIK"
        case kin = "KIN"
        case kir = "KIR"
        case kom = "KOM"
        case kon = "KON"
        case kua = "KUA"
        case kur = "KUR"
        case lao = "LAO"
        case lat = "LAT"
        case lav = "LAV"
        case lim = "LIM"
        case lin = "LIN"
        case lit = "LIT"
        case lub = "LUB"
        case ltz = "LTZ"
        case mkd = "MKD"
        case mlg = "MLG"
        case msa = "MSA"
        case mal = "MAL"
        case mlt = "MLT"
        case glv = "GLV"
        case mri = "MRI"
        case mar = "MAR"
        case mah = "MAH"
        case mon = "MON"
        case nau = "NAU"
        case nav = "NAV"
        case nde = "NDE"
        case nbl = "NBL"
        case ndo = "NDO"
        case nep = "NEP"
        case sme = "SME"
        case nor = "NOR"
        case nob = "NOB"
        case nno = "NNO"
        case oci = "OCI"
        case oji = "OJI"
        case ori = "ORI"
        case orm = "ORM"
        case oss = "OSS"
        case pli = "PLI"
        case fas = "FAS"
        case pol = "POL"
        case pus = "PUS"
        case que = "QUE"
        case qaa = "QAA"
        case ron = "RON"
        case roh = "ROH"
        case run = "RUN"
        case smo = "SMO"
        case sag = "SAG"
        case san = "SAN"
        case srd = "SRD"
        case srb = "SRB"
        case sna = "SNA"
        case iii = "III"
        case snd = "SND"
        case sin = "SIN"
        case slk = "SLK"
        case slv = "SLV"
        case som = "SOM"
        case sot = "SOT"
        case sun = "SUN"
        case swa = "SWA"
        case ssw = "SSW"
        case swe = "SWE"
        case tgl = "TGL"
        case tah = "TAH"
        case tgk = "TGK"
        case tam = "TAM"
        case tat = "TAT"
        case tel = "TEL"
        case tha = "THA"
        case bod = "BOD"
        case tir = "TIR"
        case ton = "TON"
        case tso = "TSO"
        case tsn = "TSN"
        case tur = "TUR"
        case tuk = "TUK"
        case twi = "TWI"
        case uig = "UIG"
        case ukr = "UKR"
        case uzb = "UZB"
        case ven = "VEN"
        case vol = "VOL"
        case wln = "WLN"
        case cym = "CYM"
        case fry = "FRY"
        case wol = "WOL"
        case xho = "XHO"
        case yid = "YID"
        case yor = "YOR"
        case zha = "ZHA"
        case zul = "ZUL"
        case orj = "ORJ"
        case qpc = "QPC"
        case tng = "TNG"
        public var description: String { return self.rawValue }
    }

    public enum DropFrameTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H264EntropyEncoding: String, CustomStringConvertible, Codable {
        case cabac = "CABAC"
        case cavlc = "CAVLC"
        public var description: String { return self.rawValue }
    }

    public struct CreateQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// Optional. A description of the queue you are creating.
        public let description: String?
        /// The name of the queue you are creating.
        public let name: String
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public enum HlsClientCache: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct InputTemplate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputClippings", location: .body(locationName: "inputClippings"), required: false, type: .list), 
            AWSShapeMember(label: "PsiControl", location: .body(locationName: "psiControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FilterStrength", location: .body(locationName: "filterStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "DeblockFilter", location: .body(locationName: "deblockFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "VideoSelector", location: .body(locationName: "videoSelector"), required: false, type: .structure), 
            AWSShapeMember(label: "DenoiseFilter", location: .body(locationName: "denoiseFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "TimecodeSource", location: .body(locationName: "timecodeSource"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionSelectors", location: .body(locationName: "captionSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "AudioSelectorGroups", location: .body(locationName: "audioSelectorGroups"), required: false, type: .map), 
            AWSShapeMember(label: "AudioSelectors", location: .body(locationName: "audioSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "FilterEnable", location: .body(locationName: "filterEnable"), required: false, type: .enum)
        ]
        /// (InputClippings) contains sets of start and end times that together specify a portion of the input to be used in the outputs. If you provide only a start time, the clip will be the entire input from that point to the end. If you provide only an end time, it will be the entire input up to that point. When you specify more than one input clip, the transcoding service creates the job outputs by stringing the clips together in the order you specify them.
        public let inputClippings: [InputClipping]?
        public let psiControl: InputPsiControl?
        /// Use Filter strength (FilterStrength) to adjust the magnitude the input filter settings (Deblock and Denoise). The range is -5 to 5. Default is 0.
        public let filterStrength: Int32?
        /// Use Program (programNumber) to select a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported. Default is the first program within the transport stream. If the program you specify doesn't exist, the transcoding service will use this default.
        public let programNumber: Int32?
        public let deblockFilter: InputDeblockFilter?
        public let videoSelector: VideoSelector?
        public let denoiseFilter: InputDenoiseFilter?
        public let timecodeSource: InputTimecodeSource?
        /// Use Captions selectors (CaptionSelectors) to specify the captions data from the input that you will use in your outputs. You can use mutiple captions selectors per input.
        public let captionSelectors: [String: CaptionSelector]?
        /// Specifies set of audio selectors within an input to combine. An input may have multiple audio selector groups. See "Audio Selector Group":#inputs-audio_selector_group for more information.
        public let audioSelectorGroups: [String: AudioSelectorGroup]?
        /// Use Audio selectors (AudioSelectors) to specify a track or set of tracks from the input that you will use in your outputs. You can use mutiple Audio selectors per input.
        public let audioSelectors: [String: AudioSelector]?
        public let filterEnable: InputFilterEnable?

        public init(inputClippings: [InputClipping]? = nil, psiControl: InputPsiControl? = nil, filterStrength: Int32? = nil, programNumber: Int32? = nil, deblockFilter: InputDeblockFilter? = nil, videoSelector: VideoSelector? = nil, denoiseFilter: InputDenoiseFilter? = nil, timecodeSource: InputTimecodeSource? = nil, captionSelectors: [String: CaptionSelector]? = nil, audioSelectorGroups: [String: AudioSelectorGroup]? = nil, audioSelectors: [String: AudioSelector]? = nil, filterEnable: InputFilterEnable? = nil) {
            self.inputClippings = inputClippings
            self.psiControl = psiControl
            self.filterStrength = filterStrength
            self.programNumber = programNumber
            self.deblockFilter = deblockFilter
            self.videoSelector = videoSelector
            self.denoiseFilter = denoiseFilter
            self.timecodeSource = timecodeSource
            self.captionSelectors = captionSelectors
            self.audioSelectorGroups = audioSelectorGroups
            self.audioSelectors = audioSelectors
            self.filterEnable = filterEnable
        }

        private enum CodingKeys: String, CodingKey {
            case inputClippings = "inputClippings"
            case psiControl = "psiControl"
            case filterStrength = "filterStrength"
            case programNumber = "programNumber"
            case deblockFilter = "deblockFilter"
            case videoSelector = "videoSelector"
            case denoiseFilter = "denoiseFilter"
            case timecodeSource = "timecodeSource"
            case captionSelectors = "captionSelectors"
            case audioSelectorGroups = "audioSelectorGroups"
            case audioSelectors = "audioSelectors"
            case filterEnable = "filterEnable"
        }
    }

    public enum H264SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure)
        ]
        /// The name of the job template you are creating.
        public let name: String
        /// Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
        public let queue: String?
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]?
        /// Optional. A category for the job template you are creating
        public let category: String?
        /// Optional. A description of the job template you are creating.
        public let description: String?
        public let settings: JobTemplateSettings

        public init(name: String, queue: String? = nil, tags: [String: String]? = nil, category: String? = nil, description: String? = nil, settings: JobTemplateSettings) {
            self.name = name
            self.queue = queue
            self.tags = tags
            self.category = category
            self.description = description
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case queue = "queue"
            case tags = "tags"
            case category = "category"
            case description = "description"
            case settings = "settings"
        }
    }

    public enum H265AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case higher = "HIGHER"
        case max = "MAX"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public enum Eac3PassthroughControl: String, CustomStringConvertible, Codable {
        case whenPossible = "WHEN_POSSIBLE"
        case noPassthrough = "NO_PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum EmbeddedConvert608To708: String, CustomStringConvertible, Codable {
        case upconvert = "UPCONVERT"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", location: .body(locationName: "job"), required: false, type: .structure)
        ]
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public enum Mpeg2InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public struct Rectangle: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "X", location: .body(locationName: "x"), required: true, type: .integer), 
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: true, type: .integer), 
            AWSShapeMember(label: "Y", location: .body(locationName: "y"), required: true, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: true, type: .integer)
        ]
        /// The distance, in pixels, between the rectangle and the left edge of the video frame.
        public let x: Int32
        /// Height of rectangle in pixels.
        public let height: Int32
        /// The distance, in pixels, between the rectangle and the top edge of the video frame.
        public let y: Int32
        /// Width of rectangle in pixels.
        public let width: Int32

        public init(x: Int32, height: Int32, y: Int32, width: Int32) {
            self.x = x
            self.height = height
            self.y = y
            self.width = width
        }

        private enum CodingKeys: String, CodingKey {
            case x = "x"
            case height = "height"
            case y = "y"
            case width = "width"
        }
    }

    public struct ListPresetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Presets", location: .body(locationName: "presets"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of presets.
        public let nextToken: String?
        /// List of presets
        public let presets: [Preset]?

        public init(nextToken: String? = nil, presets: [Preset]? = nil) {
            self.nextToken = nextToken
            self.presets = presets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case presets = "presets"
        }
    }

    public enum HlsEncryptionType: String, CustomStringConvertible, Codable {
        case aes128 = "AES128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public struct CreatePresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public struct VideoSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Hdr10Metadata", location: .body(locationName: "hdr10Metadata"), required: false, type: .structure), 
            AWSShapeMember(label: "ColorSpaceUsage", location: .body(locationName: "colorSpaceUsage"), required: false, type: .enum), 
            AWSShapeMember(label: "ColorSpace", location: .body(locationName: "colorSpace"), required: false, type: .enum), 
            AWSShapeMember(label: "Pid", location: .body(locationName: "pid"), required: false, type: .integer)
        ]
        /// Selects a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported.
        public let programNumber: Int32?
        public let hdr10Metadata: Hdr10Metadata?
        public let colorSpaceUsage: ColorSpaceUsage?
        public let colorSpace: ColorSpace?
        /// Use PID (Pid) to select specific video data from an input file. Specify this value as an integer; the system automatically converts it to the hexidecimal value. For example, 257 selects PID 0x101. A PID, or packet identifier, is an identifier for a set of data in an MPEG-2 transport stream container.
        public let pid: Int32?

        public init(programNumber: Int32? = nil, hdr10Metadata: Hdr10Metadata? = nil, colorSpaceUsage: ColorSpaceUsage? = nil, colorSpace: ColorSpace? = nil, pid: Int32? = nil) {
            self.programNumber = programNumber
            self.hdr10Metadata = hdr10Metadata
            self.colorSpaceUsage = colorSpaceUsage
            self.colorSpace = colorSpace
            self.pid = pid
        }

        private enum CodingKeys: String, CodingKey {
            case programNumber = "programNumber"
            case hdr10Metadata = "hdr10Metadata"
            case colorSpaceUsage = "colorSpaceUsage"
            case colorSpace = "colorSpace"
            case pid = "pid"
        }
    }

    public struct ListJobTemplatesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Category", location: .querystring(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of job templates.
        public let nextToken: String?
        public let order: Order?
        /// Optional. Number of job templates, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        /// Optionally, specify a job template category to limit responses to only job templates from that category.
        public let category: String?
        public let listBy: JobTemplateListBy?

        public init(nextToken: String? = nil, order: Order? = nil, maxResults: Int32? = nil, category: String? = nil, listBy: JobTemplateListBy? = nil) {
            self.nextToken = nextToken
            self.order = order
            self.maxResults = maxResults
            self.category = category
            self.listBy = listBy
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case order = "order"
            case maxResults = "maxResults"
            case category = "category"
            case listBy = "listBy"
        }
    }

    public enum CmafEncryptionType: String, CustomStringConvertible, Codable {
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum H265AlternateTransferFunctionSei: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DashIsoSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public enum MsSmoothAudioDeduplication: String, CustomStringConvertible, Codable {
        case combineDuplicateStreams = "COMBINE_DUPLICATE_STREAMS"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case low = "LOW"
        case main = "MAIN"
        case high1440 = "HIGH1440"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public struct VideoCodecSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FrameCaptureSettings", location: .body(locationName: "frameCaptureSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Mpeg2Settings", location: .body(locationName: "mpeg2Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "H265Settings", location: .body(locationName: "h265Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "ProresSettings", location: .body(locationName: "proresSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "H264Settings", location: .body(locationName: "h264Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Codec", location: .body(locationName: "codec"), required: true, type: .enum)
        ]
        public let frameCaptureSettings: FrameCaptureSettings?
        public let mpeg2Settings: Mpeg2Settings?
        public let h265Settings: H265Settings?
        public let proresSettings: ProresSettings?
        public let h264Settings: H264Settings?
        public let codec: VideoCodec

        public init(frameCaptureSettings: FrameCaptureSettings? = nil, mpeg2Settings: Mpeg2Settings? = nil, h265Settings: H265Settings? = nil, proresSettings: ProresSettings? = nil, h264Settings: H264Settings? = nil, codec: VideoCodec) {
            self.frameCaptureSettings = frameCaptureSettings
            self.mpeg2Settings = mpeg2Settings
            self.h265Settings = h265Settings
            self.proresSettings = proresSettings
            self.h264Settings = h264Settings
            self.codec = codec
        }

        private enum CodingKeys: String, CodingKey {
            case frameCaptureSettings = "frameCaptureSettings"
            case mpeg2Settings = "mpeg2Settings"
            case h265Settings = "h265Settings"
            case proresSettings = "proresSettings"
            case h264Settings = "h264Settings"
            case codec = "codec"
        }
    }

    public enum Order: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationPeakCalculation: String, CustomStringConvertible, Codable {
        case truePeak = "TRUE_PEAK"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Eac3SurroundExMode: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265InterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum H265RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct VideoDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DropFrameTimecode", location: .body(locationName: "dropFrameTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "FixedAfd", location: .body(locationName: "fixedAfd"), required: false, type: .integer), 
            AWSShapeMember(label: "Sharpness", location: .body(locationName: "sharpness"), required: false, type: .integer), 
            AWSShapeMember(label: "AfdSignaling", location: .body(locationName: "afdSignaling"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecSettings", location: .body(locationName: "codecSettings"), required: true, type: .structure), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "Crop", location: .body(locationName: "crop"), required: false, type: .structure), 
            AWSShapeMember(label: "VideoPreprocessors", location: .body(locationName: "videoPreprocessors"), required: false, type: .structure), 
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "AntiAlias", location: .body(locationName: "antiAlias"), required: false, type: .enum), 
            AWSShapeMember(label: "ScalingBehavior", location: .body(locationName: "scalingBehavior"), required: false, type: .enum), 
            AWSShapeMember(label: "TimecodeInsertion", location: .body(locationName: "timecodeInsertion"), required: false, type: .enum), 
            AWSShapeMember(label: "RespondToAfd", location: .body(locationName: "respondToAfd"), required: false, type: .enum), 
            AWSShapeMember(label: "ColorMetadata", location: .body(locationName: "colorMetadata"), required: false, type: .enum), 
            AWSShapeMember(label: "Position", location: .body(locationName: "position"), required: false, type: .structure)
        ]
        public let dropFrameTimecode: DropFrameTimecode?
        /// Applies only if you set AFD Signaling(AfdSignaling) to Fixed (FIXED). Use Fixed (FixedAfd) to specify a four-bit AFD value which the service will write on all  frames of this video output.
        public let fixedAfd: Int32?
        /// Use Sharpness (Sharpness)setting to specify the strength of anti-aliasing. This setting changes the width of the anti-alias filter kernel used for scaling. Sharpness only applies if your output resolution is different from your input resolution, and if you set Anti-alias (AntiAlias) to ENABLED. 0 is the softest setting, 100 the sharpest, and 50 recommended for most content.
        public let sharpness: Int32?
        public let afdSignaling: AfdSignaling?
        public let codecSettings: VideoCodecSettings
        /// Use Width (Width) to define the video resolution width, in pixels, for this output. If you don't provide a value here, the service will use the input width.
        public let width: Int32?
        /// Applies only if your input aspect ratio is different from your output aspect ratio. Use Input cropping rectangle (Crop) to specify the  video area the service will include in the output. This will crop the input source, causing video pixels to be removed on encode. Do not use this setting if you have enabled Stretch to output (stretchToOutput) in your output settings.
        public let crop: Rectangle?
        /// Find additional transcoding features under Preprocessors (VideoPreprocessors). Enable the features at each output individually. These features are disabled by default.
        public let videoPreprocessors: VideoPreprocessor?
        /// Use the Height (Height) setting to define the video resolution height for this output. Specify in pixels. If you don't provide a value here, the service will use the input height.
        public let height: Int32?
        public let antiAlias: AntiAlias?
        public let scalingBehavior: ScalingBehavior?
        public let timecodeInsertion: VideoTimecodeInsertion?
        public let respondToAfd: RespondToAfd?
        public let colorMetadata: ColorMetadata?
        /// Use Position (Position) to point to a rectangle object to define your position. This setting overrides any other aspect ratio.
        public let position: Rectangle?

        public init(dropFrameTimecode: DropFrameTimecode? = nil, fixedAfd: Int32? = nil, sharpness: Int32? = nil, afdSignaling: AfdSignaling? = nil, codecSettings: VideoCodecSettings, width: Int32? = nil, crop: Rectangle? = nil, videoPreprocessors: VideoPreprocessor? = nil, height: Int32? = nil, antiAlias: AntiAlias? = nil, scalingBehavior: ScalingBehavior? = nil, timecodeInsertion: VideoTimecodeInsertion? = nil, respondToAfd: RespondToAfd? = nil, colorMetadata: ColorMetadata? = nil, position: Rectangle? = nil) {
            self.dropFrameTimecode = dropFrameTimecode
            self.fixedAfd = fixedAfd
            self.sharpness = sharpness
            self.afdSignaling = afdSignaling
            self.codecSettings = codecSettings
            self.width = width
            self.crop = crop
            self.videoPreprocessors = videoPreprocessors
            self.height = height
            self.antiAlias = antiAlias
            self.scalingBehavior = scalingBehavior
            self.timecodeInsertion = timecodeInsertion
            self.respondToAfd = respondToAfd
            self.colorMetadata = colorMetadata
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case dropFrameTimecode = "dropFrameTimecode"
            case fixedAfd = "fixedAfd"
            case sharpness = "sharpness"
            case afdSignaling = "afdSignaling"
            case codecSettings = "codecSettings"
            case width = "width"
            case crop = "crop"
            case videoPreprocessors = "videoPreprocessors"
            case height = "height"
            case antiAlias = "antiAlias"
            case scalingBehavior = "scalingBehavior"
            case timecodeInsertion = "timecodeInsertion"
            case respondToAfd = "respondToAfd"
            case colorMetadata = "colorMetadata"
            case position = "position"
        }
    }

    public enum H264Syntax: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case rp2027 = "RP2027"
        public var description: String { return self.rawValue }
    }

    public enum HlsProgramDateTime: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum InputPsiControl: String, CustomStringConvertible, Codable {
        case ignorePsi = "IGNORE_PSI"
        case usePsi = "USE_PSI"
        public var description: String { return self.rawValue }
    }

    public enum M2tsEsRateInPes: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum CmafManifestDurationFormat: String, CustomStringConvertible, Codable {
        case floatingPoint = "FLOATING_POINT"
        case integer = "INTEGER"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleOutlineColor: String, CustomStringConvertible, Codable {
        case black = "BLACK"
        case white = "WHITE"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum Eac3BitstreamMode: String, CustomStringConvertible, Codable {
        case completeMain = "COMPLETE_MAIN"
        case commentary = "COMMENTARY"
        case emergency = "EMERGENCY"
        case hearingImpaired = "HEARING_IMPAIRED"
        case visuallyImpaired = "VISUALLY_IMPAIRED"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2IntraDcPrecision: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case intraDcPrecision8 = "INTRA_DC_PRECISION_8"
        case intraDcPrecision9 = "INTRA_DC_PRECISION_9"
        case intraDcPrecision10 = "INTRA_DC_PRECISION_10"
        case intraDcPrecision11 = "INTRA_DC_PRECISION_11"
        public var description: String { return self.rawValue }
    }

    public enum M3u8NielsenId3: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct GetPresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public enum AacCodingMode: String, CustomStringConvertible, Codable {
        case adReceiverMix = "AD_RECEIVER_MIX"
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode11 = "CODING_MODE_1_1"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode51 = "CODING_MODE_5_1"
        public var description: String { return self.rawValue }
    }

    public enum AudioLanguageCodeControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public struct M2tsSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioPids", location: .body(locationName: "audioPids"), required: false, type: .list), 
            AWSShapeMember(label: "Scte35Pid", location: .body(locationName: "scte35Pid"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioBufferModel", location: .body(locationName: "audioBufferModel"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentationMarkers", location: .body(locationName: "segmentationMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "BufferModel", location: .body(locationName: "bufferModel"), required: false, type: .enum), 
            AWSShapeMember(label: "FragmentTime", location: .body(locationName: "fragmentTime"), required: false, type: .double), 
            AWSShapeMember(label: "TransportStreamId", location: .body(locationName: "transportStreamId"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbTeletextPid", location: .body(locationName: "dvbTeletextPid"), required: false, type: .integer), 
            AWSShapeMember(label: "EsRateInPes", location: .body(locationName: "esRateInPes"), required: false, type: .enum), 
            AWSShapeMember(label: "NielsenId3", location: .body(locationName: "nielsenId3"), required: false, type: .enum), 
            AWSShapeMember(label: "AudioFramesPerPes", location: .body(locationName: "audioFramesPerPes"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Source", location: .body(locationName: "scte35Source"), required: false, type: .enum), 
            AWSShapeMember(label: "PmtPid", location: .body(locationName: "pmtPid"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbSubPids", location: .body(locationName: "dvbSubPids"), required: false, type: .list), 
            AWSShapeMember(label: "PcrPid", location: .body(locationName: "pcrPid"), required: false, type: .integer), 
            AWSShapeMember(label: "EbpAudioInterval", location: .body(locationName: "ebpAudioInterval"), required: false, type: .enum), 
            AWSShapeMember(label: "RateMode", location: .body(locationName: "rateMode"), required: false, type: .enum), 
            AWSShapeMember(label: "DvbTdtSettings", location: .body(locationName: "dvbTdtSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TimedMetadataPid", location: .body(locationName: "timedMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "DvbSdtSettings", location: .body(locationName: "dvbSdtSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DvbNitSettings", location: .body(locationName: "dvbNitSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "NullPacketBitrate", location: .body(locationName: "nullPacketBitrate"), required: false, type: .double), 
            AWSShapeMember(label: "SegmentationStyle", location: .body(locationName: "segmentationStyle"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentationTime", location: .body(locationName: "segmentationTime"), required: false, type: .double), 
            AWSShapeMember(label: "MinEbpInterval", location: .body(locationName: "minEbpInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtInterval", location: .body(locationName: "pmtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxPcrInterval", location: .body(locationName: "maxPcrInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "PrivateMetadataPid", location: .body(locationName: "privateMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "VideoPid", location: .body(locationName: "videoPid"), required: false, type: .integer), 
            AWSShapeMember(label: "EbpPlacement", location: .body(locationName: "ebpPlacement"), required: false, type: .enum), 
            AWSShapeMember(label: "PatInterval", location: .body(locationName: "patInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrControl", location: .body(locationName: "pcrControl"), required: false, type: .enum)
        ]
        /// Packet Identifier (PID) of the elementary audio stream(s) in the transport stream. Multiple values are accepted, and can be entered in ranges and/or by comma separation.
        public let audioPids: [Int32]?
        /// Packet Identifier (PID) of the SCTE-35 stream in the transport stream.
        public let scte35Pid: Int32?
        public let audioBufferModel: M2tsAudioBufferModel?
        public let segmentationMarkers: M2tsSegmentationMarkers?
        public let bufferModel: M2tsBufferModel?
        /// The length in seconds of each fragment. Only used with EBP markers.
        public let fragmentTime: Double?
        /// The value of the transport stream ID field in the Program Map Table.
        public let transportStreamId: Int32?
        /// Packet Identifier (PID) for input source DVB Teletext data to this output.
        public let dvbTeletextPid: Int32?
        public let esRateInPes: M2tsEsRateInPes?
        public let nielsenId3: M2tsNielsenId3?
        /// The number of audio frames to insert for each PES packet.
        public let audioFramesPerPes: Int32?
        /// The value of the program number field in the Program Map Table.
        public let programNumber: Int32?
        public let scte35Source: M2tsScte35Source?
        /// Packet Identifier (PID) for the Program Map Table (PMT) in the transport stream.
        public let pmtPid: Int32?
        /// Packet Identifier (PID) for input source DVB Subtitle data to this output. Multiple values are accepted, and can be entered in ranges and/or by comma separation.
        public let dvbSubPids: [Int32]?
        /// Packet Identifier (PID) of the Program Clock Reference (PCR) in the transport stream. When no value is given, the encoder will assign the same value as the Video PID.
        public let pcrPid: Int32?
        public let ebpAudioInterval: M2tsEbpAudioInterval?
        public let rateMode: M2tsRateMode?
        public let dvbTdtSettings: DvbTdtSettings?
        /// Packet Identifier (PID) of the timed metadata stream in the transport stream.
        public let timedMetadataPid: Int32?
        public let dvbSdtSettings: DvbSdtSettings?
        public let dvbNitSettings: DvbNitSettings?
        /// The output bitrate of the transport stream in bits per second. Setting to 0 lets the muxer automatically determine the appropriate bitrate. Other common values are 3750000, 7500000, and 15000000.
        public let bitrate: Int32?
        /// Value in bits per second of extra null packets to insert into the transport stream. This can be used if a downstream encryption system requires periodic null packets.
        public let nullPacketBitrate: Double?
        public let segmentationStyle: M2tsSegmentationStyle?
        /// The length in seconds of each segment. Required unless markers is set to _none_.
        public let segmentationTime: Double?
        /// When set, enforces that Encoder Boundary Points do not come within the specified time interval of each other by looking ahead at input video. If another EBP is going to come in within the specified time interval, the current EBP is not emitted, and the segment is "stretched" to the next marker. The lookahead value does not add latency to the system. The Live Event must be configured elsewhere to create sufficient latency to make the lookahead accurate.
        public let minEbpInterval: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let pmtInterval: Int32?
        /// Maximum time in milliseconds between Program Clock References (PCRs) inserted into the transport stream.
        public let maxPcrInterval: Int32?
        /// Packet Identifier (PID) of the private metadata stream in the transport stream.
        public let privateMetadataPid: Int32?
        /// Packet Identifier (PID) of the elementary video stream in the transport stream.
        public let videoPid: Int32?
        public let ebpPlacement: M2tsEbpPlacement?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let patInterval: Int32?
        public let pcrControl: M2tsPcrControl?

        public init(audioPids: [Int32]? = nil, scte35Pid: Int32? = nil, audioBufferModel: M2tsAudioBufferModel? = nil, segmentationMarkers: M2tsSegmentationMarkers? = nil, bufferModel: M2tsBufferModel? = nil, fragmentTime: Double? = nil, transportStreamId: Int32? = nil, dvbTeletextPid: Int32? = nil, esRateInPes: M2tsEsRateInPes? = nil, nielsenId3: M2tsNielsenId3? = nil, audioFramesPerPes: Int32? = nil, programNumber: Int32? = nil, scte35Source: M2tsScte35Source? = nil, pmtPid: Int32? = nil, dvbSubPids: [Int32]? = nil, pcrPid: Int32? = nil, ebpAudioInterval: M2tsEbpAudioInterval? = nil, rateMode: M2tsRateMode? = nil, dvbTdtSettings: DvbTdtSettings? = nil, timedMetadataPid: Int32? = nil, dvbSdtSettings: DvbSdtSettings? = nil, dvbNitSettings: DvbNitSettings? = nil, bitrate: Int32? = nil, nullPacketBitrate: Double? = nil, segmentationStyle: M2tsSegmentationStyle? = nil, segmentationTime: Double? = nil, minEbpInterval: Int32? = nil, pmtInterval: Int32? = nil, maxPcrInterval: Int32? = nil, privateMetadataPid: Int32? = nil, videoPid: Int32? = nil, ebpPlacement: M2tsEbpPlacement? = nil, patInterval: Int32? = nil, pcrControl: M2tsPcrControl? = nil) {
            self.audioPids = audioPids
            self.scte35Pid = scte35Pid
            self.audioBufferModel = audioBufferModel
            self.segmentationMarkers = segmentationMarkers
            self.bufferModel = bufferModel
            self.fragmentTime = fragmentTime
            self.transportStreamId = transportStreamId
            self.dvbTeletextPid = dvbTeletextPid
            self.esRateInPes = esRateInPes
            self.nielsenId3 = nielsenId3
            self.audioFramesPerPes = audioFramesPerPes
            self.programNumber = programNumber
            self.scte35Source = scte35Source
            self.pmtPid = pmtPid
            self.dvbSubPids = dvbSubPids
            self.pcrPid = pcrPid
            self.ebpAudioInterval = ebpAudioInterval
            self.rateMode = rateMode
            self.dvbTdtSettings = dvbTdtSettings
            self.timedMetadataPid = timedMetadataPid
            self.dvbSdtSettings = dvbSdtSettings
            self.dvbNitSettings = dvbNitSettings
            self.bitrate = bitrate
            self.nullPacketBitrate = nullPacketBitrate
            self.segmentationStyle = segmentationStyle
            self.segmentationTime = segmentationTime
            self.minEbpInterval = minEbpInterval
            self.pmtInterval = pmtInterval
            self.maxPcrInterval = maxPcrInterval
            self.privateMetadataPid = privateMetadataPid
            self.videoPid = videoPid
            self.ebpPlacement = ebpPlacement
            self.patInterval = patInterval
            self.pcrControl = pcrControl
        }

        private enum CodingKeys: String, CodingKey {
            case audioPids = "audioPids"
            case scte35Pid = "scte35Pid"
            case audioBufferModel = "audioBufferModel"
            case segmentationMarkers = "segmentationMarkers"
            case bufferModel = "bufferModel"
            case fragmentTime = "fragmentTime"
            case transportStreamId = "transportStreamId"
            case dvbTeletextPid = "dvbTeletextPid"
            case esRateInPes = "esRateInPes"
            case nielsenId3 = "nielsenId3"
            case audioFramesPerPes = "audioFramesPerPes"
            case programNumber = "programNumber"
            case scte35Source = "scte35Source"
            case pmtPid = "pmtPid"
            case dvbSubPids = "dvbSubPids"
            case pcrPid = "pcrPid"
            case ebpAudioInterval = "ebpAudioInterval"
            case rateMode = "rateMode"
            case dvbTdtSettings = "dvbTdtSettings"
            case timedMetadataPid = "timedMetadataPid"
            case dvbSdtSettings = "dvbSdtSettings"
            case dvbNitSettings = "dvbNitSettings"
            case bitrate = "bitrate"
            case nullPacketBitrate = "nullPacketBitrate"
            case segmentationStyle = "segmentationStyle"
            case segmentationTime = "segmentationTime"
            case minEbpInterval = "minEbpInterval"
            case pmtInterval = "pmtInterval"
            case maxPcrInterval = "maxPcrInterval"
            case privateMetadataPid = "privateMetadataPid"
            case videoPid = "videoPid"
            case ebpPlacement = "ebpPlacement"
            case patInterval = "patInterval"
            case pcrControl = "pcrControl"
        }
    }

    public enum ProresParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct AudioNormalizationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CorrectionGateLevel", location: .body(locationName: "correctionGateLevel"), required: false, type: .integer), 
            AWSShapeMember(label: "Algorithm", location: .body(locationName: "algorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "AlgorithmControl", location: .body(locationName: "algorithmControl"), required: false, type: .enum), 
            AWSShapeMember(label: "PeakCalculation", location: .body(locationName: "peakCalculation"), required: false, type: .enum), 
            AWSShapeMember(label: "LoudnessLogging", location: .body(locationName: "loudnessLogging"), required: false, type: .enum), 
            AWSShapeMember(label: "TargetLkfs", location: .body(locationName: "targetLkfs"), required: false, type: .double)
        ]
        /// Content measuring above this level will be corrected to the target level. Content measuring below this level will not be corrected. Gating only applies when not using real_time_correction.
        public let correctionGateLevel: Int32?
        public let algorithm: AudioNormalizationAlgorithm?
        public let algorithmControl: AudioNormalizationAlgorithmControl?
        public let peakCalculation: AudioNormalizationPeakCalculation?
        public let loudnessLogging: AudioNormalizationLoudnessLogging?
        /// Target LKFS(loudness) to adjust volume to. If no value is entered, a default value will be used according to the chosen algorithm. The CALM Act (1770-1) recommends a target of -24 LKFS. The EBU R-128 specification (1770-2) recommends a target of -23 LKFS.
        public let targetLkfs: Double?

        public init(correctionGateLevel: Int32? = nil, algorithm: AudioNormalizationAlgorithm? = nil, algorithmControl: AudioNormalizationAlgorithmControl? = nil, peakCalculation: AudioNormalizationPeakCalculation? = nil, loudnessLogging: AudioNormalizationLoudnessLogging? = nil, targetLkfs: Double? = nil) {
            self.correctionGateLevel = correctionGateLevel
            self.algorithm = algorithm
            self.algorithmControl = algorithmControl
            self.peakCalculation = peakCalculation
            self.loudnessLogging = loudnessLogging
            self.targetLkfs = targetLkfs
        }

        private enum CodingKeys: String, CodingKey {
            case correctionGateLevel = "correctionGateLevel"
            case algorithm = "algorithm"
            case algorithmControl = "algorithmControl"
            case peakCalculation = "peakCalculation"
            case loudnessLogging = "loudnessLogging"
            case targetLkfs = "targetLkfs"
        }
    }

    public struct NoiseReducer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filter", location: .body(locationName: "filter"), required: true, type: .enum), 
            AWSShapeMember(label: "SpatialFilterSettings", location: .body(locationName: "spatialFilterSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "FilterSettings", location: .body(locationName: "filterSettings"), required: false, type: .structure)
        ]
        public let filter: NoiseReducerFilter
        public let spatialFilterSettings: NoiseReducerSpatialFilterSettings?
        public let filterSettings: NoiseReducerFilterSettings?

        public init(filter: NoiseReducerFilter, spatialFilterSettings: NoiseReducerSpatialFilterSettings? = nil, filterSettings: NoiseReducerFilterSettings? = nil) {
            self.filter = filter
            self.spatialFilterSettings = spatialFilterSettings
            self.filterSettings = filterSettings
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case spatialFilterSettings = "spatialFilterSettings"
            case filterSettings = "filterSettings"
        }
    }

    public enum Ac3BitstreamMode: String, CustomStringConvertible, Codable {
        case completeMain = "COMPLETE_MAIN"
        case commentary = "COMMENTARY"
        case dialogue = "DIALOGUE"
        case emergency = "EMERGENCY"
        case hearingImpaired = "HEARING_IMPAIRED"
        case musicAndEffects = "MUSIC_AND_EFFECTS"
        case visuallyImpaired = "VISUALLY_IMPAIRED"
        case voiceOver = "VOICE_OVER"
        public var description: String { return self.rawValue }
    }

    public enum ScalingBehavior: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case stretchToOutput = "STRETCH_TO_OUTPUT"
        public var description: String { return self.rawValue }
    }

    public struct HlsCaptionLanguageMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "CaptionChannel", location: .body(locationName: "captionChannel"), required: false, type: .integer), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum)
        ]
        /// Caption language description.
        public let languageDescription: String?
        /// Specify the language for this caption channel, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        /// Caption channel.
        public let captionChannel: Int32?
        public let languageCode: LanguageCode?

        public init(languageDescription: String? = nil, customLanguageCode: String? = nil, captionChannel: Int32? = nil, languageCode: LanguageCode? = nil) {
            self.languageDescription = languageDescription
            self.customLanguageCode = customLanguageCode
            self.captionChannel = captionChannel
            self.languageCode = languageCode
        }

        private enum CodingKeys: String, CodingKey {
            case languageDescription = "languageDescription"
            case customLanguageCode = "customLanguageCode"
            case captionChannel = "captionChannel"
            case languageCode = "languageCode"
        }
    }

    public struct CmafEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConstantInitializationVector", location: .body(locationName: "constantInitializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "InitializationVectorInManifest", location: .body(locationName: "initializationVectorInManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: true, type: .enum), 
            AWSShapeMember(label: "StaticKeyProvider", location: .body(locationName: "staticKeyProvider"), required: false, type: .structure)
        ]
        /// This is a 128-bit, 16-byte hex value represented by a 32-character text string. If this parameter is not set then the Initialization Vector will follow the segment number by default.
        public let constantInitializationVector: String?
        public let encryptionMethod: CmafEncryptionType?
        public let initializationVectorInManifest: CmafInitializationVectorInManifest?
        public let `type`: CmafKeyProviderType
        public let staticKeyProvider: StaticKeyProvider?

        public init(constantInitializationVector: String? = nil, encryptionMethod: CmafEncryptionType? = nil, initializationVectorInManifest: CmafInitializationVectorInManifest? = nil, type: CmafKeyProviderType, staticKeyProvider: StaticKeyProvider? = nil) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.initializationVectorInManifest = initializationVectorInManifest
            self.`type` = `type`
            self.staticKeyProvider = staticKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case initializationVectorInManifest = "initializationVectorInManifest"
            case `type` = "type"
            case staticKeyProvider = "staticKeyProvider"
        }
    }

    public struct TagResourceResponse: AWSShape {

    }

    public struct InputClipping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartTimecode", location: .body(locationName: "startTimecode"), required: false, type: .string), 
            AWSShapeMember(label: "EndTimecode", location: .body(locationName: "endTimecode"), required: false, type: .string)
        ]
        /// Set Start timecode (StartTimecode) to the beginning of the portion of the input you are clipping. The frame corresponding to the Start timecode value is included in the clip. Start timecode or End timecode may be left blank, but not both. Use the format HH:MM:SS:FF or HH:MM:SS;FF, where HH is the hour, MM is the minute, SS is the second, and FF is the frame number. When choosing this value, take into account your setting for Input timecode source. For example, if you have embedded timecodes that start at 01:00:00:00 and you want your clip to begin five minutes into the video, use 01:05:00:00.
        public let startTimecode: String?
        /// Set End timecode (EndTimecode) to the end of the portion of the input you are clipping. The frame corresponding to the End timecode value is included in the clip. Start timecode or End timecode may be left blank, but not both. Use the format HH:MM:SS:FF or HH:MM:SS;FF, where HH is the hour, MM is the minute, SS is the second, and FF is the frame number. When choosing this value, take into account your setting for timecode source under input settings (InputTimecodeSource). For example, if you have embedded timecodes that start at 01:00:00:00 and you want your clip to end six minutes into the video, use 01:06:00:00.
        public let endTimecode: String?

        public init(startTimecode: String? = nil, endTimecode: String? = nil) {
            self.startTimecode = startTimecode
            self.endTimecode = endTimecode
        }

        private enum CodingKeys: String, CodingKey {
            case startTimecode = "startTimecode"
            case endTimecode = "endTimecode"
        }
    }

    public enum TimecodeBurninPosition: String, CustomStringConvertible, Codable {
        case topCenter = "TOP_CENTER"
        case topLeft = "TOP_LEFT"
        case topRight = "TOP_RIGHT"
        case middleLeft = "MIDDLE_LEFT"
        case middleCenter = "MIDDLE_CENTER"
        case middleRight = "MIDDLE_RIGHT"
        case bottomLeft = "BOTTOM_LEFT"
        case bottomCenter = "BOTTOM_CENTER"
        case bottomRight = "BOTTOM_RIGHT"
        public var description: String { return self.rawValue }
    }

    public struct DvbSdtSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SdtInterval", location: .body(locationName: "sdtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "ServiceName", location: .body(locationName: "serviceName"), required: false, type: .string), 
            AWSShapeMember(label: "OutputSdt", location: .body(locationName: "outputSdt"), required: false, type: .enum), 
            AWSShapeMember(label: "ServiceProviderName", location: .body(locationName: "serviceProviderName"), required: false, type: .string)
        ]
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let sdtInterval: Int32?
        /// The service name placed in the service_descriptor in the Service Description Table. Maximum length is 256 characters.
        public let serviceName: String?
        public let outputSdt: OutputSdt?
        /// The service provider name placed in the service_descriptor in the Service Description Table. Maximum length is 256 characters.
        public let serviceProviderName: String?

        public init(sdtInterval: Int32? = nil, serviceName: String? = nil, outputSdt: OutputSdt? = nil, serviceProviderName: String? = nil) {
            self.sdtInterval = sdtInterval
            self.serviceName = serviceName
            self.outputSdt = outputSdt
            self.serviceProviderName = serviceProviderName
        }

        private enum CodingKeys: String, CodingKey {
            case sdtInterval = "sdtInterval"
            case serviceName = "serviceName"
            case outputSdt = "outputSdt"
            case serviceProviderName = "serviceProviderName"
        }
    }

    public struct RemixSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelsIn", location: .body(locationName: "channelsIn"), required: true, type: .integer), 
            AWSShapeMember(label: "ChannelMapping", location: .body(locationName: "channelMapping"), required: true, type: .structure), 
            AWSShapeMember(label: "ChannelsOut", location: .body(locationName: "channelsOut"), required: true, type: .integer)
        ]
        /// Specify the number of audio channels from your input that you want to use in your output. With remixing, you might combine or split the data in these channels, so the number of channels in your final output might be different.
        public let channelsIn: Int32
        public let channelMapping: ChannelMapping
        /// Specify the number of channels in this output after remixing. Valid values: 1, 2, 4, 6, 8
        public let channelsOut: Int32

        public init(channelsIn: Int32, channelMapping: ChannelMapping, channelsOut: Int32) {
            self.channelsIn = channelsIn
            self.channelMapping = channelMapping
            self.channelsOut = channelsOut
        }

        private enum CodingKeys: String, CodingKey {
            case channelsIn = "channelsIn"
            case channelMapping = "channelMapping"
            case channelsOut = "channelsOut"
        }
    }

    public enum HlsInitializationVectorInManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleBackgroundColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum H265SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct HlsGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamInfResolution", location: .body(locationName: "streamInfResolution"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestDurationFormat", location: .body(locationName: "manifestDurationFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgramDateTimePeriod", location: .body(locationName: "programDateTimePeriod"), required: false, type: .integer), 
            AWSShapeMember(label: "OutputSelection", location: .body(locationName: "outputSelection"), required: false, type: .enum), 
            AWSShapeMember(label: "DirectoryStructure", location: .body(locationName: "directoryStructure"), required: false, type: .enum), 
            AWSShapeMember(label: "TimestampDeltaMilliseconds", location: .body(locationName: "timestampDeltaMilliseconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "CodecSpecification", location: .body(locationName: "codecSpecification"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionLanguageSetting", location: .body(locationName: "captionLanguageSetting"), required: false, type: .enum), 
            AWSShapeMember(label: "MinSegmentLength", location: .body(locationName: "minSegmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ManifestCompression", location: .body(locationName: "manifestCompression"), required: false, type: .enum), 
            AWSShapeMember(label: "CaptionLanguageMappings", location: .body(locationName: "captionLanguageMappings"), required: false, type: .list), 
            AWSShapeMember(label: "ProgramDateTime", location: .body(locationName: "programDateTime"), required: false, type: .enum), 
            AWSShapeMember(label: "TimedMetadataId3Frame", location: .body(locationName: "timedMetadataId3Frame"), required: false, type: .enum), 
            AWSShapeMember(label: "ClientCache", location: .body(locationName: "clientCache"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .list), 
            AWSShapeMember(label: "TimedMetadataId3Period", location: .body(locationName: "timedMetadataId3Period"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsPerSubdirectory", location: .body(locationName: "segmentsPerSubdirectory"), required: false, type: .integer)
        ]
        public let streamInfResolution: HlsStreamInfResolution?
        public let manifestDurationFormat: HlsManifestDurationFormat?
        /// Period of insertion of EXT-X-PROGRAM-DATE-TIME entry, in seconds.
        public let programDateTimePeriod: Int32?
        public let outputSelection: HlsOutputSelection?
        public let directoryStructure: HlsDirectoryStructure?
        /// Provides an extra millisecond delta offset to fine tune the timestamps.
        public let timestampDeltaMilliseconds: Int32?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        public let codecSpecification: HlsCodecSpecification?
        public let captionLanguageSetting: HlsCaptionLanguageSetting?
        /// When set, Minimum Segment Size is enforced by looking ahead and back within the specified range for a nearby avail and extending the segment size if needed.
        public let minSegmentLength: Int32
        /// A partial URI prefix that will be prepended to each output in the media .m3u8 file. Can be used if base manifest is delivered from a different URL than the main .m3u8 file.
        public let baseUrl: String?
        public let manifestCompression: HlsManifestCompression?
        /// Language to be used on Caption outputs
        public let captionLanguageMappings: [HlsCaptionLanguageMapping]?
        public let programDateTime: HlsProgramDateTime?
        public let timedMetadataId3Frame: HlsTimedMetadataId3Frame?
        public let clientCache: HlsClientCache?
        /// Length of MPEG-2 Transport Stream segments to create (in seconds). Note that segments will end on the next keyframe after this number of seconds, so actual segment length may be longer.
        public let segmentLength: Int32
        public let segmentControl: HlsSegmentControl?
        /// DRM settings.
        public let encryption: HlsEncryptionSettings?
        /// Choose one or more ad marker types to pass SCTE35 signals through to this group of Apple HLS outputs.
        public let adMarkers: [HlsAdMarkers]?
        /// Timed Metadata interval in seconds.
        public let timedMetadataId3Period: Int32?
        /// Number of segments to write to a subdirectory before starting a new one. directoryStructure must be SINGLE_DIRECTORY for this setting to have an effect.
        public let segmentsPerSubdirectory: Int32?

        public init(streamInfResolution: HlsStreamInfResolution? = nil, manifestDurationFormat: HlsManifestDurationFormat? = nil, programDateTimePeriod: Int32? = nil, outputSelection: HlsOutputSelection? = nil, directoryStructure: HlsDirectoryStructure? = nil, timestampDeltaMilliseconds: Int32? = nil, destination: String? = nil, codecSpecification: HlsCodecSpecification? = nil, captionLanguageSetting: HlsCaptionLanguageSetting? = nil, minSegmentLength: Int32, baseUrl: String? = nil, manifestCompression: HlsManifestCompression? = nil, captionLanguageMappings: [HlsCaptionLanguageMapping]? = nil, programDateTime: HlsProgramDateTime? = nil, timedMetadataId3Frame: HlsTimedMetadataId3Frame? = nil, clientCache: HlsClientCache? = nil, segmentLength: Int32, segmentControl: HlsSegmentControl? = nil, encryption: HlsEncryptionSettings? = nil, adMarkers: [HlsAdMarkers]? = nil, timedMetadataId3Period: Int32? = nil, segmentsPerSubdirectory: Int32? = nil) {
            self.streamInfResolution = streamInfResolution
            self.manifestDurationFormat = manifestDurationFormat
            self.programDateTimePeriod = programDateTimePeriod
            self.outputSelection = outputSelection
            self.directoryStructure = directoryStructure
            self.timestampDeltaMilliseconds = timestampDeltaMilliseconds
            self.destination = destination
            self.codecSpecification = codecSpecification
            self.captionLanguageSetting = captionLanguageSetting
            self.minSegmentLength = minSegmentLength
            self.baseUrl = baseUrl
            self.manifestCompression = manifestCompression
            self.captionLanguageMappings = captionLanguageMappings
            self.programDateTime = programDateTime
            self.timedMetadataId3Frame = timedMetadataId3Frame
            self.clientCache = clientCache
            self.segmentLength = segmentLength
            self.segmentControl = segmentControl
            self.encryption = encryption
            self.adMarkers = adMarkers
            self.timedMetadataId3Period = timedMetadataId3Period
            self.segmentsPerSubdirectory = segmentsPerSubdirectory
        }

        private enum CodingKeys: String, CodingKey {
            case streamInfResolution = "streamInfResolution"
            case manifestDurationFormat = "manifestDurationFormat"
            case programDateTimePeriod = "programDateTimePeriod"
            case outputSelection = "outputSelection"
            case directoryStructure = "directoryStructure"
            case timestampDeltaMilliseconds = "timestampDeltaMilliseconds"
            case destination = "destination"
            case codecSpecification = "codecSpecification"
            case captionLanguageSetting = "captionLanguageSetting"
            case minSegmentLength = "minSegmentLength"
            case baseUrl = "baseUrl"
            case manifestCompression = "manifestCompression"
            case captionLanguageMappings = "captionLanguageMappings"
            case programDateTime = "programDateTime"
            case timedMetadataId3Frame = "timedMetadataId3Frame"
            case clientCache = "clientCache"
            case segmentLength = "segmentLength"
            case segmentControl = "segmentControl"
            case encryption = "encryption"
            case adMarkers = "adMarkers"
            case timedMetadataId3Period = "timedMetadataId3Period"
            case segmentsPerSubdirectory = "segmentsPerSubdirectory"
        }
    }

    public enum MovCslgAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct Hdr10Metadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MinLuminance", location: .body(locationName: "minLuminance"), required: false, type: .integer), 
            AWSShapeMember(label: "RedPrimaryX", location: .body(locationName: "redPrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "BluePrimaryX", location: .body(locationName: "bluePrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "WhitePointX", location: .body(locationName: "whitePointX"), required: false, type: .integer), 
            AWSShapeMember(label: "GreenPrimaryY", location: .body(locationName: "greenPrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "MaxContentLightLevel", location: .body(locationName: "maxContentLightLevel"), required: true, type: .integer), 
            AWSShapeMember(label: "MaxFrameAverageLightLevel", location: .body(locationName: "maxFrameAverageLightLevel"), required: true, type: .integer), 
            AWSShapeMember(label: "MaxLuminance", location: .body(locationName: "maxLuminance"), required: false, type: .integer), 
            AWSShapeMember(label: "WhitePointY", location: .body(locationName: "whitePointY"), required: false, type: .integer), 
            AWSShapeMember(label: "GreenPrimaryX", location: .body(locationName: "greenPrimaryX"), required: false, type: .integer), 
            AWSShapeMember(label: "RedPrimaryY", location: .body(locationName: "redPrimaryY"), required: false, type: .integer), 
            AWSShapeMember(label: "BluePrimaryY", location: .body(locationName: "bluePrimaryY"), required: false, type: .integer)
        ]
        /// Nominal minimum mastering display luminance in units of of 0.0001 candelas per square meter
        public let minLuminance: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let redPrimaryX: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let bluePrimaryX: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let whitePointX: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let greenPrimaryY: Int32?
        /// Maximum light level among all samples in the coded video sequence, in units of candelas per square meter.
        public let maxContentLightLevel: Int32
        /// Maximum average light level of any frame in the coded video sequence, in units of candelas per square meter.
        public let maxFrameAverageLightLevel: Int32
        /// Nominal maximum mastering display luminance in units of of 0.0001 candelas per square meter.
        public let maxLuminance: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let whitePointY: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let greenPrimaryX: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let redPrimaryY: Int32?
        /// HDR Master Display Information must be provided by a color grader, using color grading tools. Range is 0 to 50,000, each increment represents 0.00002 in CIE1931 color coordinate. Note that this setting is not for color correction.
        public let bluePrimaryY: Int32?

        public init(minLuminance: Int32? = nil, redPrimaryX: Int32? = nil, bluePrimaryX: Int32? = nil, whitePointX: Int32? = nil, greenPrimaryY: Int32? = nil, maxContentLightLevel: Int32, maxFrameAverageLightLevel: Int32, maxLuminance: Int32? = nil, whitePointY: Int32? = nil, greenPrimaryX: Int32? = nil, redPrimaryY: Int32? = nil, bluePrimaryY: Int32? = nil) {
            self.minLuminance = minLuminance
            self.redPrimaryX = redPrimaryX
            self.bluePrimaryX = bluePrimaryX
            self.whitePointX = whitePointX
            self.greenPrimaryY = greenPrimaryY
            self.maxContentLightLevel = maxContentLightLevel
            self.maxFrameAverageLightLevel = maxFrameAverageLightLevel
            self.maxLuminance = maxLuminance
            self.whitePointY = whitePointY
            self.greenPrimaryX = greenPrimaryX
            self.redPrimaryY = redPrimaryY
            self.bluePrimaryY = bluePrimaryY
        }

        private enum CodingKeys: String, CodingKey {
            case minLuminance = "minLuminance"
            case redPrimaryX = "redPrimaryX"
            case bluePrimaryX = "bluePrimaryX"
            case whitePointX = "whitePointX"
            case greenPrimaryY = "greenPrimaryY"
            case maxContentLightLevel = "maxContentLightLevel"
            case maxFrameAverageLightLevel = "maxFrameAverageLightLevel"
            case maxLuminance = "maxLuminance"
            case whitePointY = "whitePointY"
            case greenPrimaryX = "greenPrimaryX"
            case redPrimaryY = "redPrimaryY"
            case bluePrimaryY = "bluePrimaryY"
        }
    }

    public struct CancelJobResponse: AWSShape {

    }

    public struct TimecodeConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Source", location: .body(locationName: "source"), required: false, type: .enum), 
            AWSShapeMember(label: "TimestampOffset", location: .body(locationName: "timestampOffset"), required: false, type: .string), 
            AWSShapeMember(label: "Anchor", location: .body(locationName: "anchor"), required: false, type: .string), 
            AWSShapeMember(label: "Start", location: .body(locationName: "start"), required: false, type: .string)
        ]
        public let source: TimecodeSource?
        /// Only applies to outputs that support program-date-time stamp. Use Timestamp offset (TimestampOffset) to overwrite the timecode date without affecting the time and frame number. Provide the new date as a string in the format "yyyy-mm-dd".  To use Time stamp offset, you must also enable Insert program-date-time (InsertProgramDateTime) in the output settings. For example, if the date part of your timecodes is 2002-1-25 and you want to change it to one year later, set Timestamp offset (TimestampOffset) to 2003-1-25.
        public let timestampOffset: String?
        /// If you use an editing platform that relies on an anchor timecode, use Anchor Timecode (Anchor) to specify a timecode that will match the input video frame to the output video frame. Use 24-hour format with frame number, (HH:MM:SS:FF) or (HH:MM:SS;FF). This setting ignores framerate conversion. System behavior for Anchor Timecode varies depending on your setting for Source (TimecodeSource). * If Source (TimecodeSource) is set to Specified Start (SPECIFIEDSTART), the first input frame is the specified value in Start Timecode (Start). Anchor Timecode (Anchor) and Start Timecode (Start) are used calculate output timecode. * If Source (TimecodeSource) is set to Start at 0 (ZEROBASED)  the  first frame is 00:00:00:00. * If Source (TimecodeSource) is set to Embedded (EMBEDDED), the  first frame is the timecode value on the first input frame of the input.
        public let anchor: String?
        /// Only use when you set Source (TimecodeSource) to Specified start (SPECIFIEDSTART). Use Start timecode (Start) to specify the timecode for the initial frame. Use 24-hour format with frame number, (HH:MM:SS:FF) or (HH:MM:SS;FF).
        public let start: String?

        public init(source: TimecodeSource? = nil, timestampOffset: String? = nil, anchor: String? = nil, start: String? = nil) {
            self.source = source
            self.timestampOffset = timestampOffset
            self.anchor = anchor
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case timestampOffset = "timestampOffset"
            case anchor = "anchor"
            case start = "start"
        }
    }

    public enum DvbSubtitleAlignment: String, CustomStringConvertible, Codable {
        case centered = "CENTERED"
        case left = "LEFT"
        public var description: String { return self.rawValue }
    }

    public struct DeletePresetResponse: AWSShape {

    }

    public struct ListJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Jobs", location: .body(locationName: "jobs"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of jobs.
        public let nextToken: String?
        /// List of jobs
        public let jobs: [Job]?

        public init(nextToken: String? = nil, jobs: [Job]? = nil) {
            self.nextToken = nextToken
            self.jobs = jobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case jobs = "jobs"
        }
    }

    public struct Timing: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubmitTime", location: .body(locationName: "submitTime"), required: false, type: .timestamp), 
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .timestamp), 
            AWSShapeMember(label: "FinishTime", location: .body(locationName: "finishTime"), required: false, type: .timestamp)
        ]
        /// The time, in Unix epoch format, that you submitted the job.
        public let submitTime: TimeStamp?
        /// The time, in Unix epoch format, that transcoding for the job began.
        public let startTime: TimeStamp?
        /// The time, in Unix epoch format, that the transcoding job finished
        public let finishTime: TimeStamp?

        public init(submitTime: TimeStamp? = nil, startTime: TimeStamp? = nil, finishTime: TimeStamp? = nil) {
            self.submitTime = submitTime
            self.startTime = startTime
            self.finishTime = finishTime
        }

        private enum CodingKeys: String, CodingKey {
            case submitTime = "submitTime"
            case startTime = "startTime"
            case finishTime = "finishTime"
        }
    }

    public enum H264SpatialAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct DvbSubSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Pid", location: .body(locationName: "pid"), required: false, type: .integer)
        ]
        /// When using DVB-Sub with Burn-In or SMPTE-TT, use this PID for the source content. Unused for DVB-Sub passthrough. All DVB-Sub content is passed through, regardless of selectors.
        public let pid: Int32?

        public init(pid: Int32? = nil) {
            self.pid = pid
        }

        private enum CodingKeys: String, CodingKey {
            case pid = "pid"
        }
    }

    public enum H264UnregisteredSeiTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationAlgorithm: String, CustomStringConvertible, Codable {
        case ituBs17701 = "ITU_BS_1770_1"
        case ituBs17702 = "ITU_BS_1770_2"
        public var description: String { return self.rawValue }
    }

    public struct GetJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the job template.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum M3u8Scte35Source: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H265SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct WavSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Format", location: .body(locationName: "format"), required: false, type: .enum), 
            AWSShapeMember(label: "BitDepth", location: .body(locationName: "bitDepth"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer)
        ]
        public let format: WavFormat?
        /// Specify Bit depth (BitDepth), in bits per sample, to choose the encoding quality for this audio track.
        public let bitDepth: Int32?
        /// Set Channels to specify the number of channels in this output audio track. With WAV, valid values 1, 2, 4, and 8. In the console, these values are Mono, Stereo, 4-Channel, and 8-Channel, respectively.
        public let channels: Int32?
        /// Sample rate in Hz.
        public let sampleRate: Int32?

        public init(format: WavFormat? = nil, bitDepth: Int32? = nil, channels: Int32? = nil, sampleRate: Int32? = nil) {
            self.format = format
            self.bitDepth = bitDepth
            self.channels = channels
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case bitDepth = "bitDepth"
            case channels = "channels"
            case sampleRate = "sampleRate"
        }
    }

    public enum Mpeg2FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum H264FieldEncoding: String, CustomStringConvertible, Codable {
        case paff = "PAFF"
        case forceField = "FORCE_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum HlsStreamInfResolution: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum Eac3DynamicRangeCompressionRf: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case filmStandard = "FILM_STANDARD"
        case filmLight = "FILM_LIGHT"
        case musicStandard = "MUSIC_STANDARD"
        case musicLight = "MUSIC_LIGHT"
        case speech = "SPEECH"
        public var description: String { return self.rawValue }
    }

    public enum AudioCodec: String, CustomStringConvertible, Codable {
        case aac = "AAC"
        case mp2 = "MP2"
        case wav = "WAV"
        case aiff = "AIFF"
        case ac3 = "AC3"
        case eac3 = "EAC3"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public struct TimecodeBurnin: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Prefix", location: .body(locationName: "prefix"), required: false, type: .string), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "Position", location: .body(locationName: "position"), required: false, type: .enum)
        ]
        /// Use Prefix (Prefix) to place ASCII characters before any burned-in timecode. For example, a prefix of "EZ-" will result in the timecode "EZ-00:00:00:00". Provide either the characters themselves or the ASCII code equivalents. The supported range of characters is 0x20 through 0x7e. This includes letters, numbers, and all special characters represented on a standard English keyboard.
        public let prefix: String?
        /// Use Font Size (FontSize) to set the font size of any burned-in timecode. Valid values are 10, 16, 32, 48.
        public let fontSize: Int32?
        public let position: TimecodeBurninPosition?

        public init(prefix: String? = nil, fontSize: Int32? = nil, position: TimecodeBurninPosition? = nil) {
            self.prefix = prefix
            self.fontSize = fontSize
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "prefix"
            case fontSize = "fontSize"
            case position = "position"
        }
    }

    public enum HlsCodecSpecification: String, CustomStringConvertible, Codable {
        case rfc6381 = "RFC_6381"
        case rfc4281 = "RFC_4281"
        public var description: String { return self.rawValue }
    }

    public struct UntagResourceResponse: AWSShape {

    }

    public struct CreatePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The name of the preset you are creating.
        public let name: String
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]?
        /// Optional. A category for the preset you are creating.
        public let category: String?
        public let settings: PresetSettings
        /// Optional. A description of the preset you are creating.
        public let description: String?

        public init(name: String, tags: [String: String]? = nil, category: String? = nil, settings: PresetSettings, description: String? = nil) {
            self.name = name
            self.tags = tags
            self.category = category
            self.settings = settings
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
            case category = "category"
            case settings = "settings"
            case description = "description"
        }
    }

    public enum M2tsEbpAudioInterval: String, CustomStringConvertible, Codable {
        case videoAndFixedIntervals = "VIDEO_AND_FIXED_INTERVALS"
        case videoInterval = "VIDEO_INTERVAL"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum H265CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case level1 = "LEVEL_1"
        case level2 = "LEVEL_2"
        case level21 = "LEVEL_2_1"
        case level3 = "LEVEL_3"
        case level31 = "LEVEL_3_1"
        case level4 = "LEVEL_4"
        case level41 = "LEVEL_4_1"
        case level5 = "LEVEL_5"
        case level51 = "LEVEL_5_1"
        case level52 = "LEVEL_5_2"
        case level6 = "LEVEL_6"
        case level61 = "LEVEL_6_1"
        case level62 = "LEVEL_6_2"
        public var description: String { return self.rawValue }
    }

    public struct Endpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string)
        ]
        /// URL of endpoint
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "url"
        }
    }

    public enum AfdSignaling: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case auto = "AUTO"
        case fixed = "FIXED"
        public var description: String { return self.rawValue }
    }

    public struct HlsEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConstantInitializationVector", location: .body(locationName: "constantInitializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "InitializationVectorInManifest", location: .body(locationName: "initializationVectorInManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "StaticKeyProvider", location: .body(locationName: "staticKeyProvider"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: true, type: .enum)
        ]
        /// This is a 128-bit, 16-byte hex value represented by a 32-character text string. If this parameter is not set then the Initialization Vector will follow the segment number by default.
        public let constantInitializationVector: String?
        public let encryptionMethod: HlsEncryptionType?
        public let initializationVectorInManifest: HlsInitializationVectorInManifest?
        public let spekeKeyProvider: SpekeKeyProvider?
        public let staticKeyProvider: StaticKeyProvider?
        public let `type`: HlsKeyProviderType

        public init(constantInitializationVector: String? = nil, encryptionMethod: HlsEncryptionType? = nil, initializationVectorInManifest: HlsInitializationVectorInManifest? = nil, spekeKeyProvider: SpekeKeyProvider? = nil, staticKeyProvider: StaticKeyProvider? = nil, type: HlsKeyProviderType) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.initializationVectorInManifest = initializationVectorInManifest
            self.spekeKeyProvider = spekeKeyProvider
            self.staticKeyProvider = staticKeyProvider
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case initializationVectorInManifest = "initializationVectorInManifest"
            case spekeKeyProvider = "spekeKeyProvider"
            case staticKeyProvider = "staticKeyProvider"
            case `type` = "type"
        }
    }

    public struct MovSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClapAtom", location: .body(locationName: "clapAtom"), required: false, type: .enum), 
            AWSShapeMember(label: "Mpeg2FourCCControl", location: .body(locationName: "mpeg2FourCCControl"), required: false, type: .enum), 
            AWSShapeMember(label: "PaddingControl", location: .body(locationName: "paddingControl"), required: false, type: .enum), 
            AWSShapeMember(label: "Reference", location: .body(locationName: "reference"), required: false, type: .enum), 
            AWSShapeMember(label: "CslgAtom", location: .body(locationName: "cslgAtom"), required: false, type: .enum)
        ]
        public let clapAtom: MovClapAtom?
        public let mpeg2FourCCControl: MovMpeg2FourCCControl?
        public let paddingControl: MovPaddingControl?
        public let reference: MovReference?
        public let cslgAtom: MovCslgAtom?

        public init(clapAtom: MovClapAtom? = nil, mpeg2FourCCControl: MovMpeg2FourCCControl? = nil, paddingControl: MovPaddingControl? = nil, reference: MovReference? = nil, cslgAtom: MovCslgAtom? = nil) {
            self.clapAtom = clapAtom
            self.mpeg2FourCCControl = mpeg2FourCCControl
            self.paddingControl = paddingControl
            self.reference = reference
            self.cslgAtom = cslgAtom
        }

        private enum CodingKeys: String, CodingKey {
            case clapAtom = "clapAtom"
            case mpeg2FourCCControl = "mpeg2FourCCControl"
            case paddingControl = "paddingControl"
            case reference = "reference"
            case cslgAtom = "cslgAtom"
        }
    }

    public enum Mp4CslgAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct H264Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberReferenceFrames", location: .body(locationName: "numberReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "RepeatPps", location: .body(locationName: "repeatPps"), required: false, type: .enum), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "EntropyEncoding", location: .body(locationName: "entropyEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "FlickerAdaptiveQuantization", location: .body(locationName: "flickerAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "GopBReference", location: .body(locationName: "gopBReference"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "Slices", location: .body(locationName: "slices"), required: false, type: .integer), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "Softness", location: .body(locationName: "softness"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "FieldEncoding", location: .body(locationName: "fieldEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "Syntax", location: .body(locationName: "syntax"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "UnregisteredSeiTimecode", location: .body(locationName: "unregisteredSeiTimecode"), required: false, type: .enum), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer)
        ]
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        public let framerateConversionAlgorithm: H264FramerateConversionAlgorithm?
        /// Number of reference frames to use. The encoder may use more than requested if using B-frames and/or interlaced encoding.
        public let numberReferenceFrames: Int32?
        public let rateControlMode: H264RateControlMode?
        /// Maximum bitrate in bits/second. For example, enter five megabits per second as 5000000.
        public let maxBitrate: Int32?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        /// When you use the API for transcode jobs that use framerate conversion, specify the framerate as a fraction. For example,  24000 / 1001 = 23.976 fps. Use FramerateDenominator to specify the denominator of this fraction. In this example, use 1001 for the value of FramerateDenominator. When you use the console for transcode jobs that use framerate conversion, provide the value as a decimal number for Framerate. In this example, specify 23.976.
        public let framerateDenominator: Int32?
        public let gopSizeUnits: H264GopSizeUnits?
        public let parControl: H264ParControl?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        public let repeatPps: H264RepeatPps?
        public let adaptiveQuantization: H264AdaptiveQuantization?
        public let interlaceMode: H264InterlaceMode?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        public let entropyEncoding: H264EntropyEncoding?
        public let flickerAdaptiveQuantization: H264FlickerAdaptiveQuantization?
        public let slowPal: H264SlowPal?
        public let telecine: H264Telecine?
        public let gopBReference: H264GopBReference?
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        /// Number of slices per picture. Must be less than or equal to the number of macroblock rows for progressive pictures, and less than or equal to half the number of macroblock rows for interlaced pictures.
        public let slices: Int32?
        public let codecLevel: H264CodecLevel?
        /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image.
        public let softness: Int32?
        /// Average bitrate in bits/second. Required for VBR and CBR. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let fieldEncoding: H264FieldEncoding?
        public let framerateControl: H264FramerateControl?
        public let qualityTuningLevel: H264QualityTuningLevel?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        public let spatialAdaptiveQuantization: H264SpatialAdaptiveQuantization?
        public let sceneChangeDetect: H264SceneChangeDetect?
        public let syntax: H264Syntax?
        public let codecProfile: H264CodecProfile?
        /// Size of buffer (HRD buffer model) in bits. For example, enter five megabits as 5000000.
        public let hrdBufferSize: Int32?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        public let unregisteredSeiTimecode: H264UnregisteredSeiTimecode?
        public let temporalAdaptiveQuantization: H264TemporalAdaptiveQuantization?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?

        public init(framerateNumerator: Int32? = nil, framerateConversionAlgorithm: H264FramerateConversionAlgorithm? = nil, numberReferenceFrames: Int32? = nil, rateControlMode: H264RateControlMode? = nil, maxBitrate: Int32? = nil, gopSize: Double? = nil, framerateDenominator: Int32? = nil, gopSizeUnits: H264GopSizeUnits? = nil, parControl: H264ParControl? = nil, gopClosedCadence: Int32? = nil, repeatPps: H264RepeatPps? = nil, adaptiveQuantization: H264AdaptiveQuantization? = nil, interlaceMode: H264InterlaceMode? = nil, parDenominator: Int32? = nil, entropyEncoding: H264EntropyEncoding? = nil, flickerAdaptiveQuantization: H264FlickerAdaptiveQuantization? = nil, slowPal: H264SlowPal? = nil, telecine: H264Telecine? = nil, gopBReference: H264GopBReference? = nil, numberBFramesBetweenReferenceFrames: Int32? = nil, slices: Int32? = nil, codecLevel: H264CodecLevel? = nil, softness: Int32? = nil, bitrate: Int32? = nil, fieldEncoding: H264FieldEncoding? = nil, framerateControl: H264FramerateControl? = nil, qualityTuningLevel: H264QualityTuningLevel? = nil, hrdBufferInitialFillPercentage: Int32? = nil, spatialAdaptiveQuantization: H264SpatialAdaptiveQuantization? = nil, sceneChangeDetect: H264SceneChangeDetect? = nil, syntax: H264Syntax? = nil, codecProfile: H264CodecProfile? = nil, hrdBufferSize: Int32? = nil, minIInterval: Int32? = nil, unregisteredSeiTimecode: H264UnregisteredSeiTimecode? = nil, temporalAdaptiveQuantization: H264TemporalAdaptiveQuantization? = nil, parNumerator: Int32? = nil) {
            self.framerateNumerator = framerateNumerator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.numberReferenceFrames = numberReferenceFrames
            self.rateControlMode = rateControlMode
            self.maxBitrate = maxBitrate
            self.gopSize = gopSize
            self.framerateDenominator = framerateDenominator
            self.gopSizeUnits = gopSizeUnits
            self.parControl = parControl
            self.gopClosedCadence = gopClosedCadence
            self.repeatPps = repeatPps
            self.adaptiveQuantization = adaptiveQuantization
            self.interlaceMode = interlaceMode
            self.parDenominator = parDenominator
            self.entropyEncoding = entropyEncoding
            self.flickerAdaptiveQuantization = flickerAdaptiveQuantization
            self.slowPal = slowPal
            self.telecine = telecine
            self.gopBReference = gopBReference
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.slices = slices
            self.codecLevel = codecLevel
            self.softness = softness
            self.bitrate = bitrate
            self.fieldEncoding = fieldEncoding
            self.framerateControl = framerateControl
            self.qualityTuningLevel = qualityTuningLevel
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.sceneChangeDetect = sceneChangeDetect
            self.syntax = syntax
            self.codecProfile = codecProfile
            self.hrdBufferSize = hrdBufferSize
            self.minIInterval = minIInterval
            self.unregisteredSeiTimecode = unregisteredSeiTimecode
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.parNumerator = parNumerator
        }

        private enum CodingKeys: String, CodingKey {
            case framerateNumerator = "framerateNumerator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case numberReferenceFrames = "numberReferenceFrames"
            case rateControlMode = "rateControlMode"
            case maxBitrate = "maxBitrate"
            case gopSize = "gopSize"
            case framerateDenominator = "framerateDenominator"
            case gopSizeUnits = "gopSizeUnits"
            case parControl = "parControl"
            case gopClosedCadence = "gopClosedCadence"
            case repeatPps = "repeatPps"
            case adaptiveQuantization = "adaptiveQuantization"
            case interlaceMode = "interlaceMode"
            case parDenominator = "parDenominator"
            case entropyEncoding = "entropyEncoding"
            case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
            case slowPal = "slowPal"
            case telecine = "telecine"
            case gopBReference = "gopBReference"
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case slices = "slices"
            case codecLevel = "codecLevel"
            case softness = "softness"
            case bitrate = "bitrate"
            case fieldEncoding = "fieldEncoding"
            case framerateControl = "framerateControl"
            case qualityTuningLevel = "qualityTuningLevel"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case sceneChangeDetect = "sceneChangeDetect"
            case syntax = "syntax"
            case codecProfile = "codecProfile"
            case hrdBufferSize = "hrdBufferSize"
            case minIInterval = "minIInterval"
            case unregisteredSeiTimecode = "unregisteredSeiTimecode"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case parNumerator = "parNumerator"
        }
    }

    public struct GetJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Job", location: .body(locationName: "job"), required: false, type: .structure)
        ]
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct VideoDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WidthInPx", location: .body(locationName: "widthInPx"), required: false, type: .integer), 
            AWSShapeMember(label: "HeightInPx", location: .body(locationName: "heightInPx"), required: false, type: .integer)
        ]
        /// Width in pixels for the output
        public let widthInPx: Int32?
        /// Height in pixels for the output
        public let heightInPx: Int32?

        public init(widthInPx: Int32? = nil, heightInPx: Int32? = nil) {
            self.widthInPx = widthInPx
            self.heightInPx = heightInPx
        }

        private enum CodingKeys: String, CodingKey {
            case widthInPx = "widthInPx"
            case heightInPx = "heightInPx"
        }
    }

    public enum HlsAudioTrackType: String, CustomStringConvertible, Codable {
        case alternateAudioAutoSelectDefault = "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT"
        case alternateAudioAutoSelect = "ALTERNATE_AUDIO_AUTO_SELECT"
        case alternateAudioNotAutoSelect = "ALTERNATE_AUDIO_NOT_AUTO_SELECT"
        case audioOnlyVariantStream = "AUDIO_ONLY_VARIANT_STREAM"
        public var description: String { return self.rawValue }
    }

    public struct TeletextDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PageNumber", location: .body(locationName: "pageNumber"), required: false, type: .string)
        ]
        /// Set pageNumber to the Teletext page number for the destination captions for this output. This value must be a three-digit hexadecimal string; strings ending in -FF are invalid. If you are passing through the entire set of Teletext data, do not use this field.
        public let pageNumber: String?

        public init(pageNumber: String? = nil) {
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case pageNumber = "pageNumber"
        }
    }

    public enum M3u8PcrControl: String, CustomStringConvertible, Codable {
        case pcrEveryPesPacket = "PCR_EVERY_PES_PACKET"
        case configuredPcrPeriod = "CONFIGURED_PCR_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum H264Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public enum Eac3LfeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleShadowColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum H265CodecProfile: String, CustomStringConvertible, Codable {
        case mainMain = "MAIN_MAIN"
        case mainHigh = "MAIN_HIGH"
        case main10Main = "MAIN10_MAIN"
        case main10High = "MAIN10_HIGH"
        case main4228BitMain = "MAIN_422_8BIT_MAIN"
        case main4228BitHigh = "MAIN_422_8BIT_HIGH"
        case main42210BitMain = "MAIN_422_10BIT_MAIN"
        case main42210BitHigh = "MAIN_422_10BIT_HIGH"
        public var description: String { return self.rawValue }
    }

    public struct GetJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public struct DashIsoGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "MinBufferTime", location: .body(locationName: "minBufferTime"), required: false, type: .integer), 
            AWSShapeMember(label: "HbbtvCompliance", location: .body(locationName: "hbbtvCompliance"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure)
        ]
        /// Length of fragments to generate (in seconds). Fragment length must be compatible with GOP size and Framerate. Note that fragments will end on the next keyframe after this number of seconds, so actual fragment length may be longer. When Emit Single File is checked, the fragmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let fragmentLength: Int32
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        public let segmentControl: DashIsoSegmentControl?
        /// A partial URI prefix that will be put in the manifest (.mpd) file at the top level BaseURL element. Can be used if streams are delivered from a different URL than the manifest file.
        public let baseUrl: String?
        /// Length of mpd segments to create (in seconds). Note that segments will end on the next keyframe after this number of seconds, so actual segment length may be longer. When Emit Single File is checked, the segmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let segmentLength: Int32
        /// Minimum time of initially buffered media that is needed to ensure smooth playout.
        public let minBufferTime: Int32?
        public let hbbtvCompliance: DashIsoHbbtvCompliance?
        /// DRM settings.
        public let encryption: DashIsoEncryptionSettings?

        public init(fragmentLength: Int32, destination: String? = nil, segmentControl: DashIsoSegmentControl? = nil, baseUrl: String? = nil, segmentLength: Int32, minBufferTime: Int32? = nil, hbbtvCompliance: DashIsoHbbtvCompliance? = nil, encryption: DashIsoEncryptionSettings? = nil) {
            self.fragmentLength = fragmentLength
            self.destination = destination
            self.segmentControl = segmentControl
            self.baseUrl = baseUrl
            self.segmentLength = segmentLength
            self.minBufferTime = minBufferTime
            self.hbbtvCompliance = hbbtvCompliance
            self.encryption = encryption
        }

        private enum CodingKeys: String, CodingKey {
            case fragmentLength = "fragmentLength"
            case destination = "destination"
            case segmentControl = "segmentControl"
            case baseUrl = "baseUrl"
            case segmentLength = "segmentLength"
            case minBufferTime = "minBufferTime"
            case hbbtvCompliance = "hbbtvCompliance"
            case encryption = "encryption"
        }
    }

    public struct CaptionSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceType", location: .body(locationName: "sourceType"), required: true, type: .enum), 
            AWSShapeMember(label: "AncillarySourceSettings", location: .body(locationName: "ancillarySourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "FileSourceSettings", location: .body(locationName: "fileSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DvbSubSourceSettings", location: .body(locationName: "dvbSubSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TeletextSourceSettings", location: .body(locationName: "teletextSourceSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "EmbeddedSourceSettings", location: .body(locationName: "embeddedSourceSettings"), required: false, type: .structure)
        ]
        public let sourceType: CaptionSourceType
        public let ancillarySourceSettings: AncillarySourceSettings?
        public let fileSourceSettings: FileSourceSettings?
        public let dvbSubSourceSettings: DvbSubSourceSettings?
        public let teletextSourceSettings: TeletextSourceSettings?
        public let embeddedSourceSettings: EmbeddedSourceSettings?

        public init(sourceType: CaptionSourceType, ancillarySourceSettings: AncillarySourceSettings? = nil, fileSourceSettings: FileSourceSettings? = nil, dvbSubSourceSettings: DvbSubSourceSettings? = nil, teletextSourceSettings: TeletextSourceSettings? = nil, embeddedSourceSettings: EmbeddedSourceSettings? = nil) {
            self.sourceType = sourceType
            self.ancillarySourceSettings = ancillarySourceSettings
            self.fileSourceSettings = fileSourceSettings
            self.dvbSubSourceSettings = dvbSubSourceSettings
            self.teletextSourceSettings = teletextSourceSettings
            self.embeddedSourceSettings = embeddedSourceSettings
        }

        private enum CodingKeys: String, CodingKey {
            case sourceType = "sourceType"
            case ancillarySourceSettings = "ancillarySourceSettings"
            case fileSourceSettings = "fileSourceSettings"
            case dvbSubSourceSettings = "dvbSubSourceSettings"
            case teletextSourceSettings = "teletextSourceSettings"
            case embeddedSourceSettings = "embeddedSourceSettings"
        }
    }

    public struct CmafGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ManifestDurationFormat", location: .body(locationName: "manifestDurationFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "MinBufferTime", location: .body(locationName: "minBufferTime"), required: false, type: .integer), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string), 
            AWSShapeMember(label: "CodecSpecification", location: .body(locationName: "codecSpecification"), required: false, type: .enum), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "WriteDashManifest", location: .body(locationName: "writeDashManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "BaseUrl", location: .body(locationName: "baseUrl"), required: false, type: .string), 
            AWSShapeMember(label: "ClientCache", location: .body(locationName: "clientCache"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestCompression", location: .body(locationName: "manifestCompression"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentControl", location: .body(locationName: "segmentControl"), required: false, type: .enum), 
            AWSShapeMember(label: "WriteHlsManifest", location: .body(locationName: "writeHlsManifest"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentLength", location: .body(locationName: "segmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "StreamInfResolution", location: .body(locationName: "streamInfResolution"), required: false, type: .enum)
        ]
        public let manifestDurationFormat: CmafManifestDurationFormat?
        /// Minimum time of initially buffered media that is needed to ensure smooth playout.
        public let minBufferTime: Int32?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?
        public let codecSpecification: CmafCodecSpecification?
        /// Length of fragments to generate (in seconds). Fragment length must be compatible with GOP size and Framerate. Note that fragments will end on the next keyframe after this number of seconds, so actual fragment length may be longer. When Emit Single File is checked, the fragmentation is internal to a single output file and it does not cause the creation of many output files as in other output types.
        public let fragmentLength: Int32
        public let writeDashManifest: CmafWriteDASHManifest?
        /// A partial URI prefix that will be put in the manifest file at the top level BaseURL element. Can be used if streams are delivered from a different URL than the manifest file.
        public let baseUrl: String?
        public let clientCache: CmafClientCache?
        public let manifestCompression: CmafManifestCompression?
        public let segmentControl: CmafSegmentControl?
        public let writeHlsManifest: CmafWriteHLSManifest?
        /// Use this setting to specify the length, in seconds, of each individual CMAF segment. This value applies to the whole package; that is, to every output in the output group. Note that segments end on the first keyframe after this number of seconds, so the actual segment length might be slightly longer. If you set Segment control (CmafSegmentControl) to single file, the service puts the content of each output in a single file that has metadata that marks these segments. If you set it to segmented files, the service creates multiple files for each output, each with the content of one segment.
        public let segmentLength: Int32
        /// DRM settings.
        public let encryption: CmafEncryptionSettings?
        public let streamInfResolution: CmafStreamInfResolution?

        public init(manifestDurationFormat: CmafManifestDurationFormat? = nil, minBufferTime: Int32? = nil, destination: String? = nil, codecSpecification: CmafCodecSpecification? = nil, fragmentLength: Int32, writeDashManifest: CmafWriteDASHManifest? = nil, baseUrl: String? = nil, clientCache: CmafClientCache? = nil, manifestCompression: CmafManifestCompression? = nil, segmentControl: CmafSegmentControl? = nil, writeHlsManifest: CmafWriteHLSManifest? = nil, segmentLength: Int32, encryption: CmafEncryptionSettings? = nil, streamInfResolution: CmafStreamInfResolution? = nil) {
            self.manifestDurationFormat = manifestDurationFormat
            self.minBufferTime = minBufferTime
            self.destination = destination
            self.codecSpecification = codecSpecification
            self.fragmentLength = fragmentLength
            self.writeDashManifest = writeDashManifest
            self.baseUrl = baseUrl
            self.clientCache = clientCache
            self.manifestCompression = manifestCompression
            self.segmentControl = segmentControl
            self.writeHlsManifest = writeHlsManifest
            self.segmentLength = segmentLength
            self.encryption = encryption
            self.streamInfResolution = streamInfResolution
        }

        private enum CodingKeys: String, CodingKey {
            case manifestDurationFormat = "manifestDurationFormat"
            case minBufferTime = "minBufferTime"
            case destination = "destination"
            case codecSpecification = "codecSpecification"
            case fragmentLength = "fragmentLength"
            case writeDashManifest = "writeDashManifest"
            case baseUrl = "baseUrl"
            case clientCache = "clientCache"
            case manifestCompression = "manifestCompression"
            case segmentControl = "segmentControl"
            case writeHlsManifest = "writeHlsManifest"
            case segmentLength = "segmentLength"
            case encryption = "encryption"
            case streamInfResolution = "streamInfResolution"
        }
    }

    public enum PresetListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum M2tsEbpPlacement: String, CustomStringConvertible, Codable {
        case videoAndAudioPids = "VIDEO_AND_AUDIO_PIDS"
        case videoPid = "VIDEO_PID"
        public var description: String { return self.rawValue }
    }

    public struct AncillarySourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceAncillaryChannelNumber", location: .body(locationName: "sourceAncillaryChannelNumber"), required: false, type: .integer)
        ]
        /// Specifies the 608 channel number in the ancillary data track from which to extract captions. Unused for passthrough.
        public let sourceAncillaryChannelNumber: Int32?

        public init(sourceAncillaryChannelNumber: Int32? = nil) {
            self.sourceAncillaryChannelNumber = sourceAncillaryChannelNumber
        }

        private enum CodingKeys: String, CodingKey {
            case sourceAncillaryChannelNumber = "sourceAncillaryChannelNumber"
        }
    }

    public enum AudioSelectorType: String, CustomStringConvertible, Codable {
        case pid = "PID"
        case track = "TRACK"
        case languageCode = "LANGUAGE_CODE"
        public var description: String { return self.rawValue }
    }

    public struct DashIsoEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public enum JobTemplateListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum ProresCodecProfile: String, CustomStringConvertible, Codable {
        case appleProres422 = "APPLE_PRORES_422"
        case appleProres422Hq = "APPLE_PRORES_422_HQ"
        case appleProres422Lt = "APPLE_PRORES_422_LT"
        case appleProres422Proxy = "APPLE_PRORES_422_PROXY"
        public var description: String { return self.rawValue }
    }

    public struct JobTemplateSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdAvailOffset", location: .body(locationName: "adAvailOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "AvailBlanking", location: .body(locationName: "availBlanking"), required: false, type: .structure), 
            AWSShapeMember(label: "TimedMetadataInsertion", location: .body(locationName: "timedMetadataInsertion"), required: false, type: .structure), 
            AWSShapeMember(label: "Inputs", location: .body(locationName: "inputs"), required: false, type: .list), 
            AWSShapeMember(label: "TimecodeConfig", location: .body(locationName: "timecodeConfig"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputGroups", location: .body(locationName: "outputGroups"), required: true, type: .list), 
            AWSShapeMember(label: "NielsenConfiguration", location: .body(locationName: "nielsenConfiguration"), required: false, type: .structure)
        ]
        /// When specified, this offset (in milliseconds) is added to the input Ad Avail PTS time.
        public let adAvailOffset: Int32?
        /// Settings for ad avail blanking.  Video can be blanked or overlaid with an image, and audio muted during SCTE-35 triggered ad avails.
        public let availBlanking: AvailBlanking?
        public let timedMetadataInsertion: TimedMetadataInsertion?
        /// Use Inputs (inputs) to define the source file used in the transcode job. There can only be one input in a job template.  Using the API, you can include multiple inputs when referencing a job template.
        public let inputs: [InputTemplate]?
        /// Contains settings used to acquire and adjust timecode information from inputs.
        public let timecodeConfig: TimecodeConfig?
        /// (OutputGroups) contains one group of settings for each set of outputs that share a common package type. All unpackaged files (MPEG-4, MPEG-2 TS, Quicktime, MXF, and no container) are grouped in a single output group as well. Required in (OutputGroups) is a group of settings that apply to the whole group. This required object depends on the value you set for (Type) under (OutputGroups)>(OutputGroupSettings). Type, settings object pairs are as follows. * FILE_GROUP_SETTINGS, FileGroupSettings * HLS_GROUP_SETTINGS, HlsGroupSettings * DASH_ISO_GROUP_SETTINGS, DashIsoGroupSettings * MS_SMOOTH_GROUP_SETTINGS, MsSmoothGroupSettings * CMAF_GROUP_SETTINGS, CmafGroupSettings
        public let outputGroups: [OutputGroup]
        public let nielsenConfiguration: NielsenConfiguration?

        public init(adAvailOffset: Int32? = nil, availBlanking: AvailBlanking? = nil, timedMetadataInsertion: TimedMetadataInsertion? = nil, inputs: [InputTemplate]? = nil, timecodeConfig: TimecodeConfig? = nil, outputGroups: [OutputGroup], nielsenConfiguration: NielsenConfiguration? = nil) {
            self.adAvailOffset = adAvailOffset
            self.availBlanking = availBlanking
            self.timedMetadataInsertion = timedMetadataInsertion
            self.inputs = inputs
            self.timecodeConfig = timecodeConfig
            self.outputGroups = outputGroups
            self.nielsenConfiguration = nielsenConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case adAvailOffset = "adAvailOffset"
            case availBlanking = "availBlanking"
            case timedMetadataInsertion = "timedMetadataInsertion"
            case inputs = "inputs"
            case timecodeConfig = "timecodeConfig"
            case outputGroups = "outputGroups"
            case nielsenConfiguration = "nielsenConfiguration"
        }
    }

    public enum MsSmoothManifestEncoding: String, CustomStringConvertible, Codable {
        case utf8 = "UTF8"
        case utf16 = "UTF16"
        public var description: String { return self.rawValue }
    }

    public struct Mp2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer)
        ]
        /// Average bitrate in bits/second.
        public let bitrate: Int32?
        /// Set Channels to specify the number of channels in this output audio track. Choosing Mono in the console will give you 1 output channel; choosing Stereo will give you 2. In the API, valid values are 1 and 2.
        public let channels: Int32?
        /// Sample rate in hz.
        public let sampleRate: Int32?

        public init(bitrate: Int32? = nil, channels: Int32? = nil, sampleRate: Int32? = nil) {
            self.bitrate = bitrate
            self.channels = channels
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case bitrate = "bitrate"
            case channels = "channels"
            case sampleRate = "sampleRate"
        }
    }

    public struct MsSmoothEncryptionSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public enum M2tsSegmentationMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case raiSegstart = "RAI_SEGSTART"
        case raiAdapt = "RAI_ADAPT"
        case psiSegstart = "PSI_SEGSTART"
        case ebp = "EBP"
        case ebpLegacy = "EBP_LEGACY"
        public var description: String { return self.rawValue }
    }

    public struct OutputChannelMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InputChannels", location: .body(locationName: "inputChannels"), required: true, type: .list)
        ]
        /// List of input channels
        public let inputChannels: [Int32]

        public init(inputChannels: [Int32]) {
            self.inputChannels = inputChannels
        }

        private enum CodingKeys: String, CodingKey {
            case inputChannels = "inputChannels"
        }
    }

    public struct DeleteQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the queue to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DescribeEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Endpoints", location: .body(locationName: "endpoints"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of endpoints.
        public let nextToken: String?
        /// List of endpoints
        public let endpoints: [Endpoint]?

        public init(nextToken: String? = nil, endpoints: [Endpoint]? = nil) {
            self.nextToken = nextToken
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case endpoints = "endpoints"
        }
    }

    public struct F4vSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MoovPlacement", location: .body(locationName: "moovPlacement"), required: false, type: .enum)
        ]
        public let moovPlacement: F4vMoovPlacement?

        public init(moovPlacement: F4vMoovPlacement? = nil) {
            self.moovPlacement = moovPlacement
        }

        private enum CodingKeys: String, CodingKey {
            case moovPlacement = "moovPlacement"
        }
    }

    public enum HlsManifestCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct NoiseReducerSpatialFilterSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PostFilterSharpenStrength", location: .body(locationName: "postFilterSharpenStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "Speed", location: .body(locationName: "speed"), required: false, type: .integer), 
            AWSShapeMember(label: "Strength", location: .body(locationName: "strength"), required: false, type: .integer)
        ]
        /// Specify strength of post noise reduction sharpening filter, with 0 disabling the filter and 3 enabling it at maximum strength.
        public let postFilterSharpenStrength: Int32?
        /// The speed of the filter, from -2 (lower speed) to 3 (higher speed), with 0 being the nominal value.
        public let speed: Int32?
        /// Relative strength of noise reducing filter. Higher values produce stronger filtering.
        public let strength: Int32?

        public init(postFilterSharpenStrength: Int32? = nil, speed: Int32? = nil, strength: Int32? = nil) {
            self.postFilterSharpenStrength = postFilterSharpenStrength
            self.speed = speed
            self.strength = strength
        }

        private enum CodingKeys: String, CodingKey {
            case postFilterSharpenStrength = "postFilterSharpenStrength"
            case speed = "speed"
            case strength = "strength"
        }
    }

    public struct CaptionSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceSettings", location: .body(locationName: "sourceSettings"), required: true, type: .structure), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string)
        ]
        public let sourceSettings: CaptionSourceSettings
        /// The specific language to extract from source. If input is SCTE-27, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub and output is Burn-in or SMPTE-TT, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub that is being passed through, omit this field (and PID field); there is no way to extract a specific language with pass-through captions.
        public let languageCode: LanguageCode?
        /// The specific language to extract from source, using the ISO 639-2 or ISO 639-3 three-letter language code. If input is SCTE-27, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub and output is Burn-in or SMPTE-TT, complete this field and/or PID to select the caption language to extract. If input is DVB-Sub that is being passed through, omit this field (and PID field); there is no way to extract a specific language with pass-through captions.
        public let customLanguageCode: String?

        public init(sourceSettings: CaptionSourceSettings, languageCode: LanguageCode? = nil, customLanguageCode: String? = nil) {
            self.sourceSettings = sourceSettings
            self.languageCode = languageCode
            self.customLanguageCode = customLanguageCode
        }

        private enum CodingKeys: String, CodingKey {
            case sourceSettings = "sourceSettings"
            case languageCode = "languageCode"
            case customLanguageCode = "customLanguageCode"
        }
    }

    public enum H264CodecProfile: String, CustomStringConvertible, Codable {
        case baseline = "BASELINE"
        case high = "HIGH"
        case high10Bit = "HIGH_10BIT"
        case high422 = "HIGH_422"
        case high42210Bit = "HIGH_422_10BIT"
        case main = "MAIN"
        public var description: String { return self.rawValue }
    }

    public struct UpdateJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public enum H264CodecLevel: String, CustomStringConvertible, Codable {
        case auto = "AUTO"
        case level1 = "LEVEL_1"
        case level11 = "LEVEL_1_1"
        case level12 = "LEVEL_1_2"
        case level13 = "LEVEL_1_3"
        case level2 = "LEVEL_2"
        case level21 = "LEVEL_2_1"
        case level22 = "LEVEL_2_2"
        case level3 = "LEVEL_3"
        case level31 = "LEVEL_3_1"
        case level32 = "LEVEL_3_2"
        case level4 = "LEVEL_4"
        case level41 = "LEVEL_4_1"
        case level42 = "LEVEL_4_2"
        case level5 = "LEVEL_5"
        case level51 = "LEVEL_5_1"
        case level52 = "LEVEL_5_2"
        public var description: String { return self.rawValue }
    }

    public enum FileSourceConvert608To708: String, CustomStringConvertible, Codable {
        case upconvert = "UPCONVERT"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct DeleteJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the job template to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum VideoCodec: String, CustomStringConvertible, Codable {
        case frameCapture = "FRAME_CAPTURE"
        case h264 = "H_264"
        case h265 = "H_265"
        case mpeg2 = "MPEG2"
        case prores = "PRORES"
        public var description: String { return self.rawValue }
    }

    public enum Mp4MoovPlacement: String, CustomStringConvertible, Codable {
        case progressiveDownload = "PROGRESSIVE_DOWNLOAD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public struct AudioDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StreamName", location: .body(locationName: "streamName"), required: false, type: .string), 
            AWSShapeMember(label: "AudioSourceName", location: .body(locationName: "audioSourceName"), required: false, type: .string), 
            AWSShapeMember(label: "AudioType", location: .body(locationName: "audioType"), required: false, type: .integer), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "RemixSettings", location: .body(locationName: "remixSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCodeControl", location: .body(locationName: "languageCodeControl"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecSettings", location: .body(locationName: "codecSettings"), required: true, type: .structure), 
            AWSShapeMember(label: "AudioNormalizationSettings", location: .body(locationName: "audioNormalizationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioTypeControl", location: .body(locationName: "audioTypeControl"), required: false, type: .enum)
        ]
        /// Used for MS Smooth and Apple HLS outputs. Indicates the name displayed by the player (eg. English, or Director Commentary). Alphanumeric characters, spaces, and underscore are legal.
        public let streamName: String?
        /// Specifies which audio data to use from each input. In the simplest case, specify an "Audio Selector":#inputs-audio_selector by name based on its order within each input. For example if you specify "Audio Selector 3", then the third audio selector will be used from each input. If an input does not have an "Audio Selector 3", then the audio selector marked as "default" in that input will be used. If there is no audio selector marked as "default", silence will be inserted for the duration of that input. Alternatively, an "Audio Selector Group":#inputs-audio_selector_group name may be specified, with similar default/silence behavior. If no audio_source_name is specified, then "Audio Selector 1" will be chosen automatically.
        public let audioSourceName: String?
        /// Applies only if Follow Input Audio Type is unchecked (false). A number between 0 and 255. The following are defined in ISO-IEC 13818-1: 0 = Undefined, 1 = Clean Effects, 2 = Hearing Impaired, 3 = Visually Impaired Commentary, 4-255 = Reserved.
        public let audioType: Int32?
        /// Indicates the language of the audio output track. The ISO 639 language specified in the 'Language Code' drop down will be used when 'Follow Input Language Code' is not selected or when 'Follow Input Language Code' is selected but there is no ISO 639 language code specified by the input.
        public let languageCode: LanguageCode?
        /// Advanced audio remixing settings.
        public let remixSettings: RemixSettings?
        /// Specify the language for this audio output track, using the ISO 639-2 or ISO 639-3 three-letter language code. The language specified will be used when 'Follow Input Language Code' is not selected or when 'Follow Input Language Code' is selected but there is no ISO 639 language code specified by the input.
        public let customLanguageCode: String?
        public let languageCodeControl: AudioLanguageCodeControl?
        public let codecSettings: AudioCodecSettings
        public let audioNormalizationSettings: AudioNormalizationSettings?
        public let audioTypeControl: AudioTypeControl?

        public init(streamName: String? = nil, audioSourceName: String? = nil, audioType: Int32? = nil, languageCode: LanguageCode? = nil, remixSettings: RemixSettings? = nil, customLanguageCode: String? = nil, languageCodeControl: AudioLanguageCodeControl? = nil, codecSettings: AudioCodecSettings, audioNormalizationSettings: AudioNormalizationSettings? = nil, audioTypeControl: AudioTypeControl? = nil) {
            self.streamName = streamName
            self.audioSourceName = audioSourceName
            self.audioType = audioType
            self.languageCode = languageCode
            self.remixSettings = remixSettings
            self.customLanguageCode = customLanguageCode
            self.languageCodeControl = languageCodeControl
            self.codecSettings = codecSettings
            self.audioNormalizationSettings = audioNormalizationSettings
            self.audioTypeControl = audioTypeControl
        }

        private enum CodingKeys: String, CodingKey {
            case streamName = "streamName"
            case audioSourceName = "audioSourceName"
            case audioType = "audioType"
            case languageCode = "languageCode"
            case remixSettings = "remixSettings"
            case customLanguageCode = "customLanguageCode"
            case languageCodeControl = "languageCodeControl"
            case codecSettings = "codecSettings"
            case audioNormalizationSettings = "audioNormalizationSettings"
            case audioTypeControl = "audioTypeControl"
        }
    }

    public enum CmafInitializationVectorInManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct StaticKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StaticKeyValue", location: .body(locationName: "staticKeyValue"), required: true, type: .string), 
            AWSShapeMember(label: "KeyFormatVersions", location: .body(locationName: "keyFormatVersions"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: true, type: .string), 
            AWSShapeMember(label: "KeyFormat", location: .body(locationName: "keyFormat"), required: false, type: .string)
        ]
        /// Relates to DRM implementation. Use a 32-character hexidecimal string to specify Key Value (StaticKeyValue).
        public let staticKeyValue: String
        /// Relates to DRM implementation. Either a single positive integer version value or a slash delimited list of version values (1/2/3).
        public let keyFormatVersions: String?
        /// Relates to DRM implementation. The location of the license server used for protecting content.
        public let url: String
        /// Relates to DRM implementation. Sets the value of the KEYFORMAT attribute. Must be 'identity' or a reverse DNS string. May be omitted to indicate an implicit value of 'identity'.
        public let keyFormat: String?

        public init(staticKeyValue: String, keyFormatVersions: String? = nil, url: String, keyFormat: String? = nil) {
            self.staticKeyValue = staticKeyValue
            self.keyFormatVersions = keyFormatVersions
            self.url = url
            self.keyFormat = keyFormat
        }

        private enum CodingKeys: String, CodingKey {
            case staticKeyValue = "staticKeyValue"
            case keyFormatVersions = "keyFormatVersions"
            case url = "url"
            case keyFormat = "keyFormat"
        }
    }

    public struct Output: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CaptionDescriptions", location: .body(locationName: "captionDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "AudioDescriptions", location: .body(locationName: "audioDescriptions"), required: false, type: .list), 
            AWSShapeMember(label: "NameModifier", location: .body(locationName: "nameModifier"), required: false, type: .string), 
            AWSShapeMember(label: "OutputSettings", location: .body(locationName: "outputSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "VideoDescription", location: .body(locationName: "videoDescription"), required: false, type: .structure), 
            AWSShapeMember(label: "ContainerSettings", location: .body(locationName: "containerSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Extension", location: .body(locationName: "extension"), required: false, type: .string), 
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .string)
        ]
        /// (CaptionDescriptions) contains groups of captions settings. For each output that has captions, include one instance of (CaptionDescriptions). (CaptionDescriptions) can contain multiple groups of captions settings.
        public let captionDescriptions: [CaptionDescription]?
        /// (AudioDescriptions) contains groups of audio encoding settings organized by audio codec. Include one instance of (AudioDescriptions) per output. (AudioDescriptions) can contain multiple groups of encoding settings.
        public let audioDescriptions: [AudioDescription]?
        /// Use Name modifier (NameModifier) to have the service add a string to the end of each output filename. You specify the base filename as part of your destination URI. When you create multiple outputs in the same output group, Name modifier (NameModifier) is required. Name modifier also accepts format identifiers. For DASH ISO outputs, if you use the format identifiers $Number$ or $Time$ in one output, you must use them in the same way in all outputs of the output group.
        public let nameModifier: String?
        public let outputSettings: OutputSettings?
        /// (VideoDescription) contains a group of video encoding settings. The specific video settings depend on the video codec you choose when you specify a value for Video codec (codec). Include one instance of (VideoDescription) per output.
        public let videoDescription: VideoDescription?
        public let containerSettings: ContainerSettings?
        /// Use Extension (Extension) to specify the file extension for outputs in File output groups. If you do not specify a value, the service will use default extensions by container type as follows * MPEG-2 transport stream, m2ts * Quicktime, mov * MXF container, mxf * MPEG-4 container, mp4 * No Container, the service will use codec extensions (e.g. AAC, H265, H265, AC3)
        public let `extension`: String?
        /// Use Preset (Preset) to specifiy a preset for your transcoding settings. Provide the system or custom preset name. You can specify either Preset (Preset) or Container settings (ContainerSettings), but not both.
        public let preset: String?

        public init(captionDescriptions: [CaptionDescription]? = nil, audioDescriptions: [AudioDescription]? = nil, nameModifier: String? = nil, outputSettings: OutputSettings? = nil, videoDescription: VideoDescription? = nil, containerSettings: ContainerSettings? = nil, extension: String? = nil, preset: String? = nil) {
            self.captionDescriptions = captionDescriptions
            self.audioDescriptions = audioDescriptions
            self.nameModifier = nameModifier
            self.outputSettings = outputSettings
            self.videoDescription = videoDescription
            self.containerSettings = containerSettings
            self.`extension` = `extension`
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case captionDescriptions = "captionDescriptions"
            case audioDescriptions = "audioDescriptions"
            case nameModifier = "nameModifier"
            case outputSettings = "outputSettings"
            case videoDescription = "videoDescription"
            case containerSettings = "containerSettings"
            case `extension` = "extension"
            case preset = "preset"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceTags", location: .body(locationName: "resourceTags"), required: false, type: .structure)
        ]
        public let resourceTags: ResourceTags?

        public init(resourceTags: ResourceTags? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "resourceTags"
        }
    }

    public struct UpdateJobTemplateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure)
        ]
        /// The name of the job template you are modifying
        public let name: String
        /// The new queue for the job template, if you are changing it.
        public let queue: String?
        /// The new category for the job template, if you are changing it.
        public let category: String?
        /// The new description for the job template, if you are changing it.
        public let description: String?
        public let settings: JobTemplateSettings?

        public init(name: String, queue: String? = nil, category: String? = nil, description: String? = nil, settings: JobTemplateSettings? = nil) {
            self.name = name
            self.queue = queue
            self.category = category
            self.description = description
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case queue = "queue"
            case category = "category"
            case description = "description"
            case settings = "settings"
        }
    }

    public enum H264RepeatPps: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AudioNormalizationAlgorithmControl: String, CustomStringConvertible, Codable {
        case correctAudio = "CORRECT_AUDIO"
        case measureOnly = "MEASURE_ONLY"
        public var description: String { return self.rawValue }
    }

    public struct ContainerSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MovSettings", location: .body(locationName: "movSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "M3u8Settings", location: .body(locationName: "m3u8Settings"), required: false, type: .structure), 
            AWSShapeMember(label: "F4vSettings", location: .body(locationName: "f4vSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "M2tsSettings", location: .body(locationName: "m2tsSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Container", location: .body(locationName: "container"), required: true, type: .enum), 
            AWSShapeMember(label: "Mp4Settings", location: .body(locationName: "mp4Settings"), required: false, type: .structure)
        ]
        public let movSettings: MovSettings?
        public let m3u8Settings: M3u8Settings?
        public let f4vSettings: F4vSettings?
        public let m2tsSettings: M2tsSettings?
        public let container: ContainerType
        public let mp4Settings: Mp4Settings?

        public init(movSettings: MovSettings? = nil, m3u8Settings: M3u8Settings? = nil, f4vSettings: F4vSettings? = nil, m2tsSettings: M2tsSettings? = nil, container: ContainerType, mp4Settings: Mp4Settings? = nil) {
            self.movSettings = movSettings
            self.m3u8Settings = m3u8Settings
            self.f4vSettings = f4vSettings
            self.m2tsSettings = m2tsSettings
            self.container = container
            self.mp4Settings = mp4Settings
        }

        private enum CodingKeys: String, CodingKey {
            case movSettings = "movSettings"
            case m3u8Settings = "m3u8Settings"
            case f4vSettings = "f4vSettings"
            case m2tsSettings = "m2tsSettings"
            case container = "container"
            case mp4Settings = "mp4Settings"
        }
    }

    public struct ImageInserter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsertableImages", location: .body(locationName: "insertableImages"), required: true, type: .list)
        ]
        /// Image to insert. Must be 32 bit windows BMP, PNG, or TGA file. Must not be  larger than the output frames.
        public let insertableImages: [InsertableImage]

        public init(insertableImages: [InsertableImage]) {
            self.insertableImages = insertableImages
        }

        private enum CodingKeys: String, CodingKey {
            case insertableImages = "insertableImages"
        }
    }

    public struct CreateJobTemplateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .structure)
        ]
        public let jobTemplate: JobTemplate?

        public init(jobTemplate: JobTemplate? = nil) {
            self.jobTemplate = jobTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case jobTemplate = "jobTemplate"
        }
    }

    public enum Mpeg2QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case multiPass = "MULTI_PASS"
        public var description: String { return self.rawValue }
    }

    public enum Eac3CodingMode: String, CustomStringConvertible, Codable {
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode32 = "CODING_MODE_3_2"
        public var description: String { return self.rawValue }
    }

    public struct VideoPreprocessor: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ColorCorrector", location: .body(locationName: "colorCorrector"), required: false, type: .structure), 
            AWSShapeMember(label: "NoiseReducer", location: .body(locationName: "noiseReducer"), required: false, type: .structure), 
            AWSShapeMember(label: "ImageInserter", location: .body(locationName: "imageInserter"), required: false, type: .structure), 
            AWSShapeMember(label: "TimecodeBurnin", location: .body(locationName: "timecodeBurnin"), required: false, type: .structure), 
            AWSShapeMember(label: "Deinterlacer", location: .body(locationName: "deinterlacer"), required: false, type: .structure)
        ]
        /// Enable the Color corrector (ColorCorrector) feature if necessary. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let colorCorrector: ColorCorrector?
        /// Enable the Noise reducer (NoiseReducer) feature to remove noise from your video output if necessary. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let noiseReducer: NoiseReducer?
        /// Enable the Image inserter (ImageInserter) feature to include a graphic overlay on your video. Enable or disable this feature for each output individually. This setting is disabled by default.
        public let imageInserter: ImageInserter?
        /// Timecode burn-in (TimecodeBurnIn)--Burns the output timecode and specified prefix into the output.
        public let timecodeBurnin: TimecodeBurnin?
        /// Use Deinterlacer (Deinterlacer) to produce smoother motion and a clearer picture.
        public let deinterlacer: Deinterlacer?

        public init(colorCorrector: ColorCorrector? = nil, noiseReducer: NoiseReducer? = nil, imageInserter: ImageInserter? = nil, timecodeBurnin: TimecodeBurnin? = nil, deinterlacer: Deinterlacer? = nil) {
            self.colorCorrector = colorCorrector
            self.noiseReducer = noiseReducer
            self.imageInserter = imageInserter
            self.timecodeBurnin = timecodeBurnin
            self.deinterlacer = deinterlacer
        }

        private enum CodingKeys: String, CodingKey {
            case colorCorrector = "colorCorrector"
            case noiseReducer = "noiseReducer"
            case imageInserter = "imageInserter"
            case timecodeBurnin = "timecodeBurnin"
            case deinterlacer = "deinterlacer"
        }
    }

    public enum BurninSubtitleTeletextSpacing: String, CustomStringConvertible, Codable {
        case fixedGrid = "FIXED_GRID"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2ParControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct Mpeg2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "RateControlMode", location: .body(locationName: "rateControlMode"), required: false, type: .enum), 
            AWSShapeMember(label: "GopSize", location: .body(locationName: "gopSize"), required: false, type: .double), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "GopSizeUnits", location: .body(locationName: "gopSizeUnits"), required: false, type: .enum), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "GopClosedCadence", location: .body(locationName: "gopClosedCadence"), required: false, type: .integer), 
            AWSShapeMember(label: "AdaptiveQuantization", location: .body(locationName: "adaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "NumberBFramesBetweenReferenceFrames", location: .body(locationName: "numberBFramesBetweenReferenceFrames"), required: false, type: .integer), 
            AWSShapeMember(label: "IntraDcPrecision", location: .body(locationName: "intraDcPrecision"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecLevel", location: .body(locationName: "codecLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "Softness", location: .body(locationName: "softness"), required: false, type: .integer), 
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "QualityTuningLevel", location: .body(locationName: "qualityTuningLevel"), required: false, type: .enum), 
            AWSShapeMember(label: "HrdBufferInitialFillPercentage", location: .body(locationName: "hrdBufferInitialFillPercentage"), required: false, type: .integer), 
            AWSShapeMember(label: "SpatialAdaptiveQuantization", location: .body(locationName: "spatialAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "SceneChangeDetect", location: .body(locationName: "sceneChangeDetect"), required: false, type: .enum), 
            AWSShapeMember(label: "Syntax", location: .body(locationName: "syntax"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "MinIInterval", location: .body(locationName: "minIInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "HrdBufferSize", location: .body(locationName: "hrdBufferSize"), required: false, type: .integer), 
            AWSShapeMember(label: "TemporalAdaptiveQuantization", location: .body(locationName: "temporalAdaptiveQuantization"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxBitrate", location: .body(locationName: "maxBitrate"), required: false, type: .integer)
        ]
        /// Framerate numerator - framerate is a fraction, e.g. 24000 / 1001 = 23.976 fps.
        public let framerateNumerator: Int32?
        public let framerateConversionAlgorithm: Mpeg2FramerateConversionAlgorithm?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        public let rateControlMode: Mpeg2RateControlMode?
        /// GOP Length (keyframe interval) in frames or seconds. Must be greater than zero.
        public let gopSize: Double?
        /// Framerate denominator.
        public let framerateDenominator: Int32?
        public let gopSizeUnits: Mpeg2GopSizeUnits?
        public let parControl: Mpeg2ParControl?
        /// Frequency of closed GOPs. In streaming applications, it is recommended that this be set to 1 so a decoder joining mid-stream will receive an IDR frame as quickly as possible. Setting this value to 0 will break output segmenting.
        public let gopClosedCadence: Int32?
        public let adaptiveQuantization: Mpeg2AdaptiveQuantization?
        public let interlaceMode: Mpeg2InterlaceMode?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        public let slowPal: Mpeg2SlowPal?
        public let telecine: Mpeg2Telecine?
        /// Number of B-frames between reference frames.
        public let numberBFramesBetweenReferenceFrames: Int32?
        public let intraDcPrecision: Mpeg2IntraDcPrecision?
        public let codecLevel: Mpeg2CodecLevel?
        /// Softness. Selects quantizer matrix, larger values reduce high-frequency content in the encoded image.
        public let softness: Int32?
        /// Average bitrate in bits/second. Required for VBR and CBR. For MS Smooth outputs, bitrates must be unique when rounded down to the nearest multiple of 1000.
        public let bitrate: Int32?
        public let framerateControl: Mpeg2FramerateControl?
        public let qualityTuningLevel: Mpeg2QualityTuningLevel?
        /// Percentage of the buffer that should initially be filled (HRD buffer model).
        public let hrdBufferInitialFillPercentage: Int32?
        public let spatialAdaptiveQuantization: Mpeg2SpatialAdaptiveQuantization?
        public let sceneChangeDetect: Mpeg2SceneChangeDetect?
        public let syntax: Mpeg2Syntax?
        public let codecProfile: Mpeg2CodecProfile?
        /// Enforces separation between repeated (cadence) I-frames and I-frames inserted by Scene Change Detection. If a scene change I-frame is within I-interval frames of a cadence I-frame, the GOP is shrunk and/or stretched to the scene change I-frame. GOP stretch requires enabling lookahead as well as setting I-interval. The normal cadence resumes for the next GOP. This setting is only used when Scene Change Detect is enabled. Note: Maximum GOP stretch = GOP size + Min-I-interval - 1
        public let minIInterval: Int32?
        /// Size of buffer (HRD buffer model) in bits. For example, enter five megabits as 5000000.
        public let hrdBufferSize: Int32?
        public let temporalAdaptiveQuantization: Mpeg2TemporalAdaptiveQuantization?
        /// Maximum bitrate in bits/second. For example, enter five megabits per second as 5000000.
        public let maxBitrate: Int32?

        public init(framerateNumerator: Int32? = nil, framerateConversionAlgorithm: Mpeg2FramerateConversionAlgorithm? = nil, parNumerator: Int32? = nil, rateControlMode: Mpeg2RateControlMode? = nil, gopSize: Double? = nil, framerateDenominator: Int32? = nil, gopSizeUnits: Mpeg2GopSizeUnits? = nil, parControl: Mpeg2ParControl? = nil, gopClosedCadence: Int32? = nil, adaptiveQuantization: Mpeg2AdaptiveQuantization? = nil, interlaceMode: Mpeg2InterlaceMode? = nil, parDenominator: Int32? = nil, slowPal: Mpeg2SlowPal? = nil, telecine: Mpeg2Telecine? = nil, numberBFramesBetweenReferenceFrames: Int32? = nil, intraDcPrecision: Mpeg2IntraDcPrecision? = nil, codecLevel: Mpeg2CodecLevel? = nil, softness: Int32? = nil, bitrate: Int32? = nil, framerateControl: Mpeg2FramerateControl? = nil, qualityTuningLevel: Mpeg2QualityTuningLevel? = nil, hrdBufferInitialFillPercentage: Int32? = nil, spatialAdaptiveQuantization: Mpeg2SpatialAdaptiveQuantization? = nil, sceneChangeDetect: Mpeg2SceneChangeDetect? = nil, syntax: Mpeg2Syntax? = nil, codecProfile: Mpeg2CodecProfile? = nil, minIInterval: Int32? = nil, hrdBufferSize: Int32? = nil, temporalAdaptiveQuantization: Mpeg2TemporalAdaptiveQuantization? = nil, maxBitrate: Int32? = nil) {
            self.framerateNumerator = framerateNumerator
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.parNumerator = parNumerator
            self.rateControlMode = rateControlMode
            self.gopSize = gopSize
            self.framerateDenominator = framerateDenominator
            self.gopSizeUnits = gopSizeUnits
            self.parControl = parControl
            self.gopClosedCadence = gopClosedCadence
            self.adaptiveQuantization = adaptiveQuantization
            self.interlaceMode = interlaceMode
            self.parDenominator = parDenominator
            self.slowPal = slowPal
            self.telecine = telecine
            self.numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFrames
            self.intraDcPrecision = intraDcPrecision
            self.codecLevel = codecLevel
            self.softness = softness
            self.bitrate = bitrate
            self.framerateControl = framerateControl
            self.qualityTuningLevel = qualityTuningLevel
            self.hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentage
            self.spatialAdaptiveQuantization = spatialAdaptiveQuantization
            self.sceneChangeDetect = sceneChangeDetect
            self.syntax = syntax
            self.codecProfile = codecProfile
            self.minIInterval = minIInterval
            self.hrdBufferSize = hrdBufferSize
            self.temporalAdaptiveQuantization = temporalAdaptiveQuantization
            self.maxBitrate = maxBitrate
        }

        private enum CodingKeys: String, CodingKey {
            case framerateNumerator = "framerateNumerator"
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case parNumerator = "parNumerator"
            case rateControlMode = "rateControlMode"
            case gopSize = "gopSize"
            case framerateDenominator = "framerateDenominator"
            case gopSizeUnits = "gopSizeUnits"
            case parControl = "parControl"
            case gopClosedCadence = "gopClosedCadence"
            case adaptiveQuantization = "adaptiveQuantization"
            case interlaceMode = "interlaceMode"
            case parDenominator = "parDenominator"
            case slowPal = "slowPal"
            case telecine = "telecine"
            case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
            case intraDcPrecision = "intraDcPrecision"
            case codecLevel = "codecLevel"
            case softness = "softness"
            case bitrate = "bitrate"
            case framerateControl = "framerateControl"
            case qualityTuningLevel = "qualityTuningLevel"
            case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
            case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
            case sceneChangeDetect = "sceneChangeDetect"
            case syntax = "syntax"
            case codecProfile = "codecProfile"
            case minIInterval = "minIInterval"
            case hrdBufferSize = "hrdBufferSize"
            case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
            case maxBitrate = "maxBitrate"
        }
    }

    public enum TimedMetadata: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum TtmlStylePassthrough: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum Ac3DynamicRangeCompressionProfile: String, CustomStringConvertible, Codable {
        case filmStandard = "FILM_STANDARD"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DeinterlacerMode: String, CustomStringConvertible, Codable {
        case deinterlace = "DEINTERLACE"
        case inverseTelecine = "INVERSE_TELECINE"
        case adaptive = "ADAPTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ColorSpaceConversion: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case force601 = "FORCE_601"
        case force709 = "FORCE_709"
        case forceHdr10 = "FORCE_HDR10"
        case forceHlg2020 = "FORCE_HLG_2020"
        public var description: String { return self.rawValue }
    }

    public struct MsSmoothGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioDeduplication", location: .body(locationName: "audioDeduplication"), required: false, type: .enum), 
            AWSShapeMember(label: "FragmentLength", location: .body(locationName: "fragmentLength"), required: true, type: .integer), 
            AWSShapeMember(label: "ManifestEncoding", location: .body(locationName: "manifestEncoding"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "Destination", location: .body(locationName: "destination"), required: false, type: .string)
        ]
        public let audioDeduplication: MsSmoothAudioDeduplication?
        /// Use Fragment length (FragmentLength) to specify the mp4 fragment sizes in seconds. Fragment length must be compatible with GOP size and framerate.
        public let fragmentLength: Int32
        public let manifestEncoding: MsSmoothManifestEncoding?
        public let encryption: MsSmoothEncryptionSettings?
        /// Use Destination (Destination) to specify the S3 output location and the output filename base. Destination accepts format identifiers. If you do not specify the base filename in the URI, the service will use the filename of the input file. If your job has multiple inputs, the service uses the filename of the first input file.
        public let destination: String?

        public init(audioDeduplication: MsSmoothAudioDeduplication? = nil, fragmentLength: Int32, manifestEncoding: MsSmoothManifestEncoding? = nil, encryption: MsSmoothEncryptionSettings? = nil, destination: String? = nil) {
            self.audioDeduplication = audioDeduplication
            self.fragmentLength = fragmentLength
            self.manifestEncoding = manifestEncoding
            self.encryption = encryption
            self.destination = destination
        }

        private enum CodingKeys: String, CodingKey {
            case audioDeduplication = "audioDeduplication"
            case fragmentLength = "fragmentLength"
            case manifestEncoding = "manifestEncoding"
            case encryption = "encryption"
            case destination = "destination"
        }
    }

    public enum CaptionSourceType: String, CustomStringConvertible, Codable {
        case ancillary = "ANCILLARY"
        case dvbSub = "DVB_SUB"
        case embedded = "EMBEDDED"
        case scc = "SCC"
        case ttml = "TTML"
        case stl = "STL"
        case srt = "SRT"
        case teletext = "TELETEXT"
        case nullSource = "NULL_SOURCE"
        public var description: String { return self.rawValue }
    }

    public struct DvbTdtSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TdtInterval", location: .body(locationName: "tdtInterval"), required: true, type: .integer)
        ]
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let tdtInterval: Int32

        public init(tdtInterval: Int32) {
            self.tdtInterval = tdtInterval
        }

        private enum CodingKeys: String, CodingKey {
            case tdtInterval = "tdtInterval"
        }
    }

    public enum Mp4FreeSpaceBox: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public struct NielsenConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BreakoutCode", location: .body(locationName: "breakoutCode"), required: false, type: .integer), 
            AWSShapeMember(label: "DistributorId", location: .body(locationName: "distributorId"), required: false, type: .string)
        ]
        /// Use Nielsen Configuration (NielsenConfiguration) to set the Nielsen measurement system breakout code. Supported values are 0, 3, 7, and 9.
        public let breakoutCode: Int32?
        /// Use Distributor ID (DistributorID) to specify the distributor ID that is assigned to your organization by Neilsen.
        public let distributorId: String?

        public init(breakoutCode: Int32? = nil, distributorId: String? = nil) {
            self.breakoutCode = breakoutCode
            self.distributorId = distributorId
        }

        private enum CodingKeys: String, CodingKey {
            case breakoutCode = "breakoutCode"
            case distributorId = "distributorId"
        }
    }

    public struct DeletePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the preset to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "TagKeys", location: .body(locationName: "tagKeys"), required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. To get the ARN, send a GET request with the resource name.
        public let arn: String?
        /// The keys of the tags that you want to remove from the resource.
        public let tagKeys: [String]?

        public init(arn: String? = nil, tagKeys: [String]? = nil) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case tagKeys = "tagKeys"
        }
    }

    public enum InputDeblockFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct AiffSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .integer), 
            AWSShapeMember(label: "BitDepth", location: .body(locationName: "bitDepth"), required: false, type: .integer), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer)
        ]
        /// Set Channels to specify the number of channels in this output audio track. Choosing Mono in the console will give you 1 output channel; choosing Stereo will give you 2. In the API, valid values are 1 and 2.
        public let channels: Int32?
        /// Specify Bit depth (BitDepth), in bits per sample, to choose the encoding quality for this audio track.
        public let bitDepth: Int32?
        /// Sample rate in hz.
        public let sampleRate: Int32?

        public init(channels: Int32? = nil, bitDepth: Int32? = nil, sampleRate: Int32? = nil) {
            self.channels = channels
            self.bitDepth = bitDepth
            self.sampleRate = sampleRate
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case bitDepth = "bitDepth"
            case sampleRate = "sampleRate"
        }
    }

    public struct GetQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum InputTimecodeSource: String, CustomStringConvertible, Codable {
        case embedded = "EMBEDDED"
        case zerobased = "ZEROBASED"
        case specifiedstart = "SPECIFIEDSTART"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2CodecProfile: String, CustomStringConvertible, Codable {
        case main = "MAIN"
        case profile422 = "PROFILE_422"
        public var description: String { return self.rawValue }
    }

    public struct OutputGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CustomName", location: .body(locationName: "customName"), required: false, type: .string), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: false, type: .string), 
            AWSShapeMember(label: "OutputGroupSettings", location: .body(locationName: "outputGroupSettings"), required: true, type: .structure), 
            AWSShapeMember(label: "Outputs", location: .body(locationName: "outputs"), required: true, type: .list)
        ]
        /// Use Custom Group Name (CustomName) to specify a name for the output group. This value is displayed on the console and can make your job settings JSON more human-readable. It does not affect your outputs. Use up to twelve characters that are either letters, numbers, spaces, or underscores.
        public let customName: String?
        /// Name of the output group
        public let name: String?
        public let outputGroupSettings: OutputGroupSettings
        /// This object holds groups of encoding settings, one group of settings per output.
        public let outputs: [Output]

        public init(customName: String? = nil, name: String? = nil, outputGroupSettings: OutputGroupSettings, outputs: [Output]) {
            self.customName = customName
            self.name = name
            self.outputGroupSettings = outputGroupSettings
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case customName = "customName"
            case name = "name"
            case outputGroupSettings = "outputGroupSettings"
            case outputs = "outputs"
        }
    }

    public enum Eac3DcFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct UpdateQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public struct Deinterlacer: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Control", location: .body(locationName: "control"), required: false, type: .enum), 
            AWSShapeMember(label: "Mode", location: .body(locationName: "mode"), required: false, type: .enum), 
            AWSShapeMember(label: "Algorithm", location: .body(locationName: "algorithm"), required: false, type: .enum)
        ]
        public let control: DeinterlacerControl?
        public let mode: DeinterlacerMode?
        public let algorithm: DeinterlaceAlgorithm?

        public init(control: DeinterlacerControl? = nil, mode: DeinterlacerMode? = nil, algorithm: DeinterlaceAlgorithm? = nil) {
            self.control = control
            self.mode = mode
            self.algorithm = algorithm
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
            case mode = "mode"
            case algorithm = "algorithm"
        }
    }

    public enum Eac3SurroundMode: String, CustomStringConvertible, Codable {
        case notIndicated = "NOT_INDICATED"
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDescriptionPreset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LanguageDescription", location: .body(locationName: "languageDescription"), required: false, type: .string), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "DestinationSettings", location: .body(locationName: "destinationSettings"), required: true, type: .structure)
        ]
        /// Human readable information to indicate captions available for players (eg. English, or Spanish). Alphanumeric characters, spaces, and underscore are legal.
        public let languageDescription: String?
        /// Indicates the language of the caption output track, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        /// Indicates the language of the caption output track.
        public let languageCode: LanguageCode?
        public let destinationSettings: CaptionDestinationSettings

        public init(languageDescription: String? = nil, customLanguageCode: String? = nil, languageCode: LanguageCode? = nil, destinationSettings: CaptionDestinationSettings) {
            self.languageDescription = languageDescription
            self.customLanguageCode = customLanguageCode
            self.languageCode = languageCode
            self.destinationSettings = destinationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case languageDescription = "languageDescription"
            case customLanguageCode = "customLanguageCode"
            case languageCode = "languageCode"
            case destinationSettings = "destinationSettings"
        }
    }

    public enum DvbSubtitleOutlineColor: String, CustomStringConvertible, Codable {
        case black = "BLACK"
        case white = "WHITE"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public enum HlsOutputSelection: String, CustomStringConvertible, Codable {
        case manifestsAndSegments = "MANIFESTS_AND_SEGMENTS"
        case segmentsOnly = "SEGMENTS_ONLY"
        public var description: String { return self.rawValue }
    }

    public struct ListQueuesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Queues", location: .body(locationName: "queues"), required: false, type: .list)
        ]
        /// Use this string to request the next batch of queues.
        public let nextToken: String?
        /// List of queues
        public let queues: [Queue]?

        public init(nextToken: String? = nil, queues: [Queue]? = nil) {
            self.nextToken = nextToken
            self.queues = queues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queues = "queues"
        }
    }

    public struct UpdatePresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Category", location: .body(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// The name of the preset you are modifying.
        public let name: String
        /// The new category for the preset, if you are changing it.
        public let category: String?
        public let settings: PresetSettings?
        /// The new description for the preset, if you are changing it.
        public let description: String?

        public init(name: String, category: String? = nil, settings: PresetSettings? = nil, description: String? = nil) {
            self.name = name
            self.category = category
            self.settings = settings
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case category = "category"
            case settings = "settings"
            case description = "description"
        }
    }

    public enum ContainerType: String, CustomStringConvertible, Codable {
        case f4v = "F4V"
        case ismv = "ISMV"
        case m2ts = "M2TS"
        case m3u8 = "M3U8"
        case cmfc = "CMFC"
        case mov = "MOV"
        case mp4 = "MP4"
        case mpd = "MPD"
        case mxf = "MXF"
        case raw = "RAW"
        public var description: String { return self.rawValue }
    }

    public enum AacRateControlMode: String, CustomStringConvertible, Codable {
        case cbr = "CBR"
        case vbr = "VBR"
        public var description: String { return self.rawValue }
    }

    public enum HlsIFrameOnlyManifest: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum ColorMetadata: String, CustomStringConvertible, Codable {
        case ignore = "IGNORE"
        case insert = "INSERT"
        public var description: String { return self.rawValue }
    }

    public enum H265TemporalIds: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum M2tsAudioBufferModel: String, CustomStringConvertible, Codable {
        case dvb = "DVB"
        case atsc = "ATSC"
        public var description: String { return self.rawValue }
    }

    public enum AudioTypeControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum CmafSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public enum CmafKeyProviderType: String, CustomStringConvertible, Codable {
        case staticKey = "STATIC_KEY"
        public var description: String { return self.rawValue }
    }

    public struct CreateJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Role", location: .body(locationName: "role"), required: true, type: .string), 
            AWSShapeMember(label: "ClientRequestToken", location: .body(locationName: "clientRequestToken"), required: false, type: .string), 
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .string), 
            AWSShapeMember(label: "UserMetadata", location: .body(locationName: "userMetadata"), required: false, type: .map), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure)
        ]
        /// Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html.
        public let queue: String?
        /// Required. The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html.
        public let role: String
        /// Idempotency token for CreateJob operation.
        public let clientRequestToken: String?
        /// When you create a job, you can either specify a job template or specify the transcoding settings individually
        public let jobTemplate: String?
        /// User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.
        public let userMetadata: [String: String]?
        public let settings: JobSettings

        public init(queue: String? = nil, role: String, clientRequestToken: String? = nil, jobTemplate: String? = nil, userMetadata: [String: String]? = nil, settings: JobSettings) {
            self.queue = queue
            self.role = role
            self.clientRequestToken = clientRequestToken
            self.jobTemplate = jobTemplate
            self.userMetadata = userMetadata
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
            case role = "role"
            case clientRequestToken = "clientRequestToken"
            case jobTemplate = "jobTemplate"
            case userMetadata = "userMetadata"
            case settings = "settings"
        }
    }

    public enum MovClapAtom: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum MovPaddingControl: String, CustomStringConvertible, Codable {
        case omneon = "OMNEON"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum HlsKeyProviderType: String, CustomStringConvertible, Codable {
        case speke = "SPEKE"
        case staticKey = "STATIC_KEY"
        public var description: String { return self.rawValue }
    }

    public enum DashIsoHbbtvCompliance: String, CustomStringConvertible, Codable {
        case hbbtv15 = "HBBTV_1_5"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum BurninSubtitleFontColor: String, CustomStringConvertible, Codable {
        case white = "WHITE"
        case black = "BLACK"
        case yellow = "YELLOW"
        case red = "RED"
        case green = "GREEN"
        case blue = "BLUE"
        public var description: String { return self.rawValue }
    }

    public struct Input: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterStrength", location: .body(locationName: "filterStrength"), required: false, type: .integer), 
            AWSShapeMember(label: "InputClippings", location: .body(locationName: "inputClippings"), required: false, type: .list), 
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "TimecodeSource", location: .body(locationName: "timecodeSource"), required: false, type: .enum), 
            AWSShapeMember(label: "FilterEnable", location: .body(locationName: "filterEnable"), required: false, type: .enum), 
            AWSShapeMember(label: "VideoSelector", location: .body(locationName: "videoSelector"), required: false, type: .structure), 
            AWSShapeMember(label: "AudioSelectorGroups", location: .body(locationName: "audioSelectorGroups"), required: false, type: .map), 
            AWSShapeMember(label: "DeblockFilter", location: .body(locationName: "deblockFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "DenoiseFilter", location: .body(locationName: "denoiseFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "PsiControl", location: .body(locationName: "psiControl"), required: false, type: .enum), 
            AWSShapeMember(label: "FileInput", location: .body(locationName: "fileInput"), required: true, type: .string), 
            AWSShapeMember(label: "CaptionSelectors", location: .body(locationName: "captionSelectors"), required: false, type: .map), 
            AWSShapeMember(label: "AudioSelectors", location: .body(locationName: "audioSelectors"), required: false, type: .map)
        ]
        /// Use Filter strength (FilterStrength) to adjust the magnitude the input filter settings (Deblock and Denoise). The range is -5 to 5. Default is 0.
        public let filterStrength: Int32?
        /// (InputClippings) contains sets of start and end times that together specify a portion of the input to be used in the outputs. If you provide only a start time, the clip will be the entire input from that point to the end. If you provide only an end time, it will be the entire input up to that point. When you specify more than one input clip, the transcoding service creates the job outputs by stringing the clips together in the order you specify them.
        public let inputClippings: [InputClipping]?
        /// Use Program (programNumber) to select a specific program from within a multi-program transport stream. Note that Quad 4K is not currently supported. Default is the first program within the transport stream. If the program you specify doesn't exist, the transcoding service will use this default.
        public let programNumber: Int32?
        public let timecodeSource: InputTimecodeSource?
        public let filterEnable: InputFilterEnable?
        public let videoSelector: VideoSelector?
        /// Specifies set of audio selectors within an input to combine. An input may have multiple audio selector groups. See "Audio Selector Group":#inputs-audio_selector_group for more information.
        public let audioSelectorGroups: [String: AudioSelectorGroup]?
        public let deblockFilter: InputDeblockFilter?
        public let denoiseFilter: InputDenoiseFilter?
        public let psiControl: InputPsiControl?
        /// Use Input (fileInput) to define the source file used in the transcode job. There can be multiple inputs in a job. These inputs are concantenated, in the order they are specified in the job, to create the output.
        public let fileInput: String
        /// Use Captions selectors (CaptionSelectors) to specify the captions data from the input that you will use in your outputs. You can use mutiple captions selectors per input.
        public let captionSelectors: [String: CaptionSelector]?
        /// Use Audio selectors (AudioSelectors) to specify a track or set of tracks from the input that you will use in your outputs. You can use mutiple Audio selectors per input.
        public let audioSelectors: [String: AudioSelector]?

        public init(filterStrength: Int32? = nil, inputClippings: [InputClipping]? = nil, programNumber: Int32? = nil, timecodeSource: InputTimecodeSource? = nil, filterEnable: InputFilterEnable? = nil, videoSelector: VideoSelector? = nil, audioSelectorGroups: [String: AudioSelectorGroup]? = nil, deblockFilter: InputDeblockFilter? = nil, denoiseFilter: InputDenoiseFilter? = nil, psiControl: InputPsiControl? = nil, fileInput: String, captionSelectors: [String: CaptionSelector]? = nil, audioSelectors: [String: AudioSelector]? = nil) {
            self.filterStrength = filterStrength
            self.inputClippings = inputClippings
            self.programNumber = programNumber
            self.timecodeSource = timecodeSource
            self.filterEnable = filterEnable
            self.videoSelector = videoSelector
            self.audioSelectorGroups = audioSelectorGroups
            self.deblockFilter = deblockFilter
            self.denoiseFilter = denoiseFilter
            self.psiControl = psiControl
            self.fileInput = fileInput
            self.captionSelectors = captionSelectors
            self.audioSelectors = audioSelectors
        }

        private enum CodingKeys: String, CodingKey {
            case filterStrength = "filterStrength"
            case inputClippings = "inputClippings"
            case programNumber = "programNumber"
            case timecodeSource = "timecodeSource"
            case filterEnable = "filterEnable"
            case videoSelector = "videoSelector"
            case audioSelectorGroups = "audioSelectorGroups"
            case deblockFilter = "deblockFilter"
            case denoiseFilter = "denoiseFilter"
            case psiControl = "psiControl"
            case fileInput = "fileInput"
            case captionSelectors = "captionSelectors"
            case audioSelectors = "audioSelectors"
        }
    }

    public enum H264FlickerAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265UnregisteredSeiTimecode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MovMpeg2FourCCControl: String, CustomStringConvertible, Codable {
        case xdcam = "XDCAM"
        case mpeg = "MPEG"
        public var description: String { return self.rawValue }
    }

    public struct GetPresetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the preset.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum M2tsBufferModel: String, CustomStringConvertible, Codable {
        case multiplex = "MULTIPLEX"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ProresInterlaceMode: String, CustomStringConvertible, Codable {
        case progressive = "PROGRESSIVE"
        case topField = "TOP_FIELD"
        case bottomField = "BOTTOM_FIELD"
        case followTopField = "FOLLOW_TOP_FIELD"
        case followBottomField = "FOLLOW_BOTTOM_FIELD"
        public var description: String { return self.rawValue }
    }

    public enum H265FlickerAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HlsManifestDurationFormat: String, CustomStringConvertible, Codable {
        case floatingPoint = "FLOATING_POINT"
        case integer = "INTEGER"
        public var description: String { return self.rawValue }
    }

    public struct CreateQueueResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .structure)
        ]
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public enum H265Telecine: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case soft = "SOFT"
        case hard = "HARD"
        public var description: String { return self.rawValue }
    }

    public struct Id3Insertion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id3", location: .body(locationName: "id3"), required: true, type: .string), 
            AWSShapeMember(label: "Timecode", location: .body(locationName: "timecode"), required: true, type: .string)
        ]
        /// Use ID3 tag (Id3) to provide a tag value in base64-encode format.
        public let id3: String
        /// Provide a Timecode (TimeCode) in HH:MM:SS:FF or HH:MM:SS;FF format.
        public let timecode: String

        public init(id3: String, timecode: String) {
            self.id3 = id3
            self.timecode = timecode
        }

        private enum CodingKeys: String, CodingKey {
            case id3 = "id3"
            case timecode = "timecode"
        }
    }

    public enum H264SceneChangeDetect: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H264GopBReference: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct M3u8Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ProgramNumber", location: .body(locationName: "programNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrControl", location: .body(locationName: "pcrControl"), required: false, type: .enum), 
            AWSShapeMember(label: "TimedMetadataPid", location: .body(locationName: "timedMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtInterval", location: .body(locationName: "pmtInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "Scte35Source", location: .body(locationName: "scte35Source"), required: false, type: .enum), 
            AWSShapeMember(label: "Scte35Pid", location: .body(locationName: "scte35Pid"), required: false, type: .integer), 
            AWSShapeMember(label: "TimedMetadata", location: .body(locationName: "timedMetadata"), required: false, type: .enum), 
            AWSShapeMember(label: "TransportStreamId", location: .body(locationName: "transportStreamId"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioPids", location: .body(locationName: "audioPids"), required: false, type: .list), 
            AWSShapeMember(label: "VideoPid", location: .body(locationName: "videoPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PcrPid", location: .body(locationName: "pcrPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PatInterval", location: .body(locationName: "patInterval"), required: false, type: .integer), 
            AWSShapeMember(label: "AudioFramesPerPes", location: .body(locationName: "audioFramesPerPes"), required: false, type: .integer), 
            AWSShapeMember(label: "PrivateMetadataPid", location: .body(locationName: "privateMetadataPid"), required: false, type: .integer), 
            AWSShapeMember(label: "PmtPid", location: .body(locationName: "pmtPid"), required: false, type: .integer), 
            AWSShapeMember(label: "NielsenId3", location: .body(locationName: "nielsenId3"), required: false, type: .enum)
        ]
        /// The value of the program number field in the Program Map Table.
        public let programNumber: Int32?
        public let pcrControl: M3u8PcrControl?
        /// Packet Identifier (PID) of the timed metadata stream in the transport stream.
        public let timedMetadataPid: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let pmtInterval: Int32?
        public let scte35Source: M3u8Scte35Source?
        /// Packet Identifier (PID) of the SCTE-35 stream in the transport stream.
        public let scte35Pid: Int32?
        public let timedMetadata: TimedMetadata?
        /// The value of the transport stream ID field in the Program Map Table.
        public let transportStreamId: Int32?
        /// Packet Identifier (PID) of the elementary audio stream(s) in the transport stream. Multiple values are accepted, and can be entered in ranges and/or by comma separation.
        public let audioPids: [Int32]?
        /// Packet Identifier (PID) of the elementary video stream in the transport stream.
        public let videoPid: Int32?
        /// Packet Identifier (PID) of the Program Clock Reference (PCR) in the transport stream. When no value is given, the encoder will assign the same value as the Video PID.
        public let pcrPid: Int32?
        /// The number of milliseconds between instances of this table in the output transport stream.
        public let patInterval: Int32?
        /// The number of audio frames to insert for each PES packet.
        public let audioFramesPerPes: Int32?
        /// Packet Identifier (PID) of the private metadata stream in the transport stream.
        public let privateMetadataPid: Int32?
        /// Packet Identifier (PID) for the Program Map Table (PMT) in the transport stream.
        public let pmtPid: Int32?
        public let nielsenId3: M3u8NielsenId3?

        public init(programNumber: Int32? = nil, pcrControl: M3u8PcrControl? = nil, timedMetadataPid: Int32? = nil, pmtInterval: Int32? = nil, scte35Source: M3u8Scte35Source? = nil, scte35Pid: Int32? = nil, timedMetadata: TimedMetadata? = nil, transportStreamId: Int32? = nil, audioPids: [Int32]? = nil, videoPid: Int32? = nil, pcrPid: Int32? = nil, patInterval: Int32? = nil, audioFramesPerPes: Int32? = nil, privateMetadataPid: Int32? = nil, pmtPid: Int32? = nil, nielsenId3: M3u8NielsenId3? = nil) {
            self.programNumber = programNumber
            self.pcrControl = pcrControl
            self.timedMetadataPid = timedMetadataPid
            self.pmtInterval = pmtInterval
            self.scte35Source = scte35Source
            self.scte35Pid = scte35Pid
            self.timedMetadata = timedMetadata
            self.transportStreamId = transportStreamId
            self.audioPids = audioPids
            self.videoPid = videoPid
            self.pcrPid = pcrPid
            self.patInterval = patInterval
            self.audioFramesPerPes = audioFramesPerPes
            self.privateMetadataPid = privateMetadataPid
            self.pmtPid = pmtPid
            self.nielsenId3 = nielsenId3
        }

        private enum CodingKeys: String, CodingKey {
            case programNumber = "programNumber"
            case pcrControl = "pcrControl"
            case timedMetadataPid = "timedMetadataPid"
            case pmtInterval = "pmtInterval"
            case scte35Source = "scte35Source"
            case scte35Pid = "scte35Pid"
            case timedMetadata = "timedMetadata"
            case transportStreamId = "transportStreamId"
            case audioPids = "audioPids"
            case videoPid = "videoPid"
            case pcrPid = "pcrPid"
            case patInterval = "patInterval"
            case audioFramesPerPes = "audioFramesPerPes"
            case privateMetadataPid = "privateMetadataPid"
            case pmtPid = "pmtPid"
            case nielsenId3 = "nielsenId3"
        }
    }

    public struct UpdatePresetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Preset", location: .body(locationName: "preset"), required: false, type: .structure)
        ]
        public let preset: Preset?

        public init(preset: Preset? = nil) {
            self.preset = preset
        }

        private enum CodingKeys: String, CodingKey {
            case preset = "preset"
        }
    }

    public enum BurninSubtitleAlignment: String, CustomStringConvertible, Codable {
        case centered = "CENTERED"
        case left = "LEFT"
        public var description: String { return self.rawValue }
    }

    public enum DvbSubtitleTeletextSpacing: String, CustomStringConvertible, Codable {
        case fixedGrid = "FIXED_GRID"
        case proportional = "PROPORTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum CmafCodecSpecification: String, CustomStringConvertible, Codable {
        case rfc6381 = "RFC_6381"
        case rfc4281 = "RFC_4281"
        public var description: String { return self.rawValue }
    }

    public enum InputDenoiseFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case submitted = "SUBMITTED"
        case progressing = "PROGRESSING"
        case complete = "COMPLETE"
        case canceled = "CANCELED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum SccDestinationFramerate: String, CustomStringConvertible, Codable {
        case framerate2397 = "FRAMERATE_23_97"
        case framerate24 = "FRAMERATE_24"
        case framerate2997Dropframe = "FRAMERATE_29_97_DROPFRAME"
        case framerate2997NonDropframe = "FRAMERATE_29_97_NON_DROPFRAME"
        public var description: String { return self.rawValue }
    }

    public enum DeinterlacerControl: String, CustomStringConvertible, Codable {
        case forceAllFrames = "FORCE_ALL_FRAMES"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum Mpeg2RateControlMode: String, CustomStringConvertible, Codable {
        case vbr = "VBR"
        case cbr = "CBR"
        public var description: String { return self.rawValue }
    }

    public enum AacCodecProfile: String, CustomStringConvertible, Codable {
        case lc = "LC"
        case hev1 = "HEV1"
        case hev2 = "HEV2"
        public var description: String { return self.rawValue }
    }

    public struct DeleteJobTemplateResponse: AWSShape {

    }

    public enum Ac3LfeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum AacAudioDescriptionBroadcasterMix: String, CustomStringConvertible, Codable {
        case broadcasterMixedAd = "BROADCASTER_MIXED_AD"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public struct AudioSelectorGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioSelectorNames", location: .body(locationName: "audioSelectorNames"), required: true, type: .list)
        ]
        /// Name of an Audio Selector within the same input to include in the group.  Audio selector names are standardized, based on their order within the input (e.g., "Audio Selector 1"). The audio selector name parameter can be repeated to add any number of audio selectors to the group.
        public let audioSelectorNames: [String]

        public init(audioSelectorNames: [String]) {
            self.audioSelectorNames = audioSelectorNames
        }

        private enum CodingKeys: String, CodingKey {
            case audioSelectorNames = "audioSelectorNames"
        }
    }

    public enum CaptionDestinationType: String, CustomStringConvertible, Codable {
        case burnIn = "BURN_IN"
        case dvbSub = "DVB_SUB"
        case embedded = "EMBEDDED"
        case scc = "SCC"
        case srt = "SRT"
        case teletext = "TELETEXT"
        case ttml = "TTML"
        case webvtt = "WEBVTT"
        public var description: String { return self.rawValue }
    }

    public struct JobSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdAvailOffset", location: .body(locationName: "adAvailOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "AvailBlanking", location: .body(locationName: "availBlanking"), required: false, type: .structure), 
            AWSShapeMember(label: "TimedMetadataInsertion", location: .body(locationName: "timedMetadataInsertion"), required: false, type: .structure), 
            AWSShapeMember(label: "Inputs", location: .body(locationName: "inputs"), required: true, type: .list), 
            AWSShapeMember(label: "TimecodeConfig", location: .body(locationName: "timecodeConfig"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputGroups", location: .body(locationName: "outputGroups"), required: true, type: .list), 
            AWSShapeMember(label: "NielsenConfiguration", location: .body(locationName: "nielsenConfiguration"), required: false, type: .structure)
        ]
        /// When specified, this offset (in milliseconds) is added to the input Ad Avail PTS time.
        public let adAvailOffset: Int32?
        /// Settings for ad avail blanking.  Video can be blanked or overlaid with an image, and audio muted during SCTE-35 triggered ad avails.
        public let availBlanking: AvailBlanking?
        public let timedMetadataInsertion: TimedMetadataInsertion?
        /// Use Inputs (inputs) to define source file used in the transcode job. There can be multiple inputs add in a job. These inputs will be concantenated together to create the output.
        public let inputs: [Input]
        /// Contains settings used to acquire and adjust timecode information from inputs.
        public let timecodeConfig: TimecodeConfig?
        /// (OutputGroups) contains one group of settings for each set of outputs that share a common package type. All unpackaged files (MPEG-4, MPEG-2 TS, Quicktime, MXF, and no container) are grouped in a single output group as well. Required in (OutputGroups) is a group of settings that apply to the whole group. This required object depends on the value you set for (Type) under (OutputGroups)>(OutputGroupSettings). Type, settings object pairs are as follows. * FILE_GROUP_SETTINGS, FileGroupSettings * HLS_GROUP_SETTINGS, HlsGroupSettings * DASH_ISO_GROUP_SETTINGS, DashIsoGroupSettings * MS_SMOOTH_GROUP_SETTINGS, MsSmoothGroupSettings * CMAF_GROUP_SETTINGS, CmafGroupSettings
        public let outputGroups: [OutputGroup]
        public let nielsenConfiguration: NielsenConfiguration?

        public init(adAvailOffset: Int32? = nil, availBlanking: AvailBlanking? = nil, timedMetadataInsertion: TimedMetadataInsertion? = nil, inputs: [Input], timecodeConfig: TimecodeConfig? = nil, outputGroups: [OutputGroup], nielsenConfiguration: NielsenConfiguration? = nil) {
            self.adAvailOffset = adAvailOffset
            self.availBlanking = availBlanking
            self.timedMetadataInsertion = timedMetadataInsertion
            self.inputs = inputs
            self.timecodeConfig = timecodeConfig
            self.outputGroups = outputGroups
            self.nielsenConfiguration = nielsenConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case adAvailOffset = "adAvailOffset"
            case availBlanking = "availBlanking"
            case timedMetadataInsertion = "timedMetadataInsertion"
            case inputs = "inputs"
            case timecodeConfig = "timecodeConfig"
            case outputGroups = "outputGroups"
            case nielsenConfiguration = "nielsenConfiguration"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: true, type: .map)
        ]
        /// The Amazon Resource Name (ARN) of the resource that you want to tag. To get the ARN, send a GET request with the resource name.
        public let arn: String
        /// The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
        public let tags: [String: String]

        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case tags = "tags"
        }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case system = "SYSTEM"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public struct OutputSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HlsSettings", location: .body(locationName: "hlsSettings"), required: false, type: .structure)
        ]
        public let hlsSettings: HlsSettings?

        public init(hlsSettings: HlsSettings? = nil) {
            self.hlsSettings = hlsSettings
        }

        private enum CodingKeys: String, CodingKey {
            case hlsSettings = "hlsSettings"
        }
    }

    public enum HlsSegmentControl: String, CustomStringConvertible, Codable {
        case singleFile = "SINGLE_FILE"
        case segmentedFiles = "SEGMENTED_FILES"
        public var description: String { return self.rawValue }
    }

    public enum WavFormat: String, CustomStringConvertible, Codable {
        case riff = "RIFF"
        case rf64 = "RF64"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case paused = "PAUSED"
        public var description: String { return self.rawValue }
    }

    public enum M2tsScte35Source: String, CustomStringConvertible, Codable {
        case passthrough = "PASSTHROUGH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct TimedMetadataInsertion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id3Insertions", location: .body(locationName: "id3Insertions"), required: true, type: .list)
        ]
        /// Id3Insertions contains the array of Id3Insertion instances.
        public let id3Insertions: [Id3Insertion]

        public init(id3Insertions: [Id3Insertion]) {
            self.id3Insertions = id3Insertions
        }

        private enum CodingKeys: String, CodingKey {
            case id3Insertions = "id3Insertions"
        }
    }

    public enum VideoTimecodeInsertion: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case picTimingSei = "PIC_TIMING_SEI"
        public var description: String { return self.rawValue }
    }

    public struct ListPresetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "Category", location: .querystring(locationName: "category"), required: false, type: .string), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of presets.
        public let nextToken: String?
        public let order: Order?
        /// Optional. Number of presets, up to twenty, that will be returned at one time
        public let maxResults: Int32?
        /// Optionally, specify a preset category to limit responses to only presets from that category.
        public let category: String?
        public let listBy: PresetListBy?

        public init(nextToken: String? = nil, order: Order? = nil, maxResults: Int32? = nil, category: String? = nil, listBy: PresetListBy? = nil) {
            self.nextToken = nextToken
            self.order = order
            self.maxResults = maxResults
            self.category = category
            self.listBy = listBy
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case order = "order"
            case maxResults = "maxResults"
            case category = "category"
            case listBy = "listBy"
        }
    }

    public struct ColorCorrector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ColorSpaceConversion", location: .body(locationName: "colorSpaceConversion"), required: false, type: .enum), 
            AWSShapeMember(label: "Hdr10Metadata", location: .body(locationName: "hdr10Metadata"), required: false, type: .structure), 
            AWSShapeMember(label: "Brightness", location: .body(locationName: "brightness"), required: false, type: .integer), 
            AWSShapeMember(label: "Saturation", location: .body(locationName: "saturation"), required: false, type: .integer), 
            AWSShapeMember(label: "Hue", location: .body(locationName: "hue"), required: false, type: .integer), 
            AWSShapeMember(label: "Contrast", location: .body(locationName: "contrast"), required: false, type: .integer)
        ]
        public let colorSpaceConversion: ColorSpaceConversion?
        public let hdr10Metadata: Hdr10Metadata?
        /// Brightness level.
        public let brightness: Int32?
        /// Saturation level.
        public let saturation: Int32?
        /// Hue in degrees.
        public let hue: Int32?
        /// Contrast level.
        public let contrast: Int32?

        public init(colorSpaceConversion: ColorSpaceConversion? = nil, hdr10Metadata: Hdr10Metadata? = nil, brightness: Int32? = nil, saturation: Int32? = nil, hue: Int32? = nil, contrast: Int32? = nil) {
            self.colorSpaceConversion = colorSpaceConversion
            self.hdr10Metadata = hdr10Metadata
            self.brightness = brightness
            self.saturation = saturation
            self.hue = hue
            self.contrast = contrast
        }

        private enum CodingKeys: String, CodingKey {
            case colorSpaceConversion = "colorSpaceConversion"
            case hdr10Metadata = "hdr10Metadata"
            case brightness = "brightness"
            case saturation = "saturation"
            case hue = "hue"
            case contrast = "contrast"
        }
    }

    public struct NoiseReducerFilterSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Strength", location: .body(locationName: "strength"), required: false, type: .integer)
        ]
        /// Relative strength of noise reducing filter. Higher values produce stronger filtering.
        public let strength: Int32?

        public init(strength: Int32? = nil) {
            self.strength = strength
        }

        private enum CodingKeys: String, CodingKey {
            case strength = "strength"
        }
    }

    public enum ColorSpaceUsage: String, CustomStringConvertible, Codable {
        case force = "FORCE"
        case fallback = "FALLBACK"
        public var description: String { return self.rawValue }
    }

    public enum M2tsPcrControl: String, CustomStringConvertible, Codable {
        case pcrEveryPesPacket = "PCR_EVERY_PES_PACKET"
        case configuredPcrPeriod = "CONFIGURED_PCR_PERIOD"
        public var description: String { return self.rawValue }
    }

    public enum AudioDefaultSelection: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case notDefault = "NOT_DEFAULT"
        public var description: String { return self.rawValue }
    }

    public struct ListQueuesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "Order", location: .querystring(locationName: "order"), required: false, type: .enum), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "ListBy", location: .querystring(locationName: "listBy"), required: false, type: .enum)
        ]
        /// Use this string, provided with the response to a previous request, to request the next batch of queues.
        public let nextToken: String?
        public let order: Order?
        /// Optional. Number of queues, up to twenty, that will be returned at one time.
        public let maxResults: Int32?
        public let listBy: QueueListBy?

        public init(nextToken: String? = nil, order: Order? = nil, maxResults: Int32? = nil, listBy: QueueListBy? = nil) {
            self.nextToken = nextToken
            self.order = order
            self.maxResults = maxResults
            self.listBy = listBy
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case order = "order"
            case maxResults = "maxResults"
            case listBy = "listBy"
        }
    }

    public struct TtmlDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StylePassthrough", location: .body(locationName: "stylePassthrough"), required: false, type: .enum)
        ]
        public let stylePassthrough: TtmlStylePassthrough?

        public init(stylePassthrough: TtmlStylePassthrough? = nil) {
            self.stylePassthrough = stylePassthrough
        }

        private enum CodingKeys: String, CodingKey {
            case stylePassthrough = "stylePassthrough"
        }
    }

    public enum ProresFramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct OutputGroupSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "HlsGroupSettings", location: .body(locationName: "hlsGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DashIsoGroupSettings", location: .body(locationName: "dashIsoGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: true, type: .enum), 
            AWSShapeMember(label: "FileGroupSettings", location: .body(locationName: "fileGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CmafGroupSettings", location: .body(locationName: "cmafGroupSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "MsSmoothGroupSettings", location: .body(locationName: "msSmoothGroupSettings"), required: false, type: .structure)
        ]
        public let hlsGroupSettings: HlsGroupSettings?
        public let dashIsoGroupSettings: DashIsoGroupSettings?
        public let `type`: OutputGroupType
        public let fileGroupSettings: FileGroupSettings?
        public let cmafGroupSettings: CmafGroupSettings?
        public let msSmoothGroupSettings: MsSmoothGroupSettings?

        public init(hlsGroupSettings: HlsGroupSettings? = nil, dashIsoGroupSettings: DashIsoGroupSettings? = nil, type: OutputGroupType, fileGroupSettings: FileGroupSettings? = nil, cmafGroupSettings: CmafGroupSettings? = nil, msSmoothGroupSettings: MsSmoothGroupSettings? = nil) {
            self.hlsGroupSettings = hlsGroupSettings
            self.dashIsoGroupSettings = dashIsoGroupSettings
            self.`type` = `type`
            self.fileGroupSettings = fileGroupSettings
            self.cmafGroupSettings = cmafGroupSettings
            self.msSmoothGroupSettings = msSmoothGroupSettings
        }

        private enum CodingKeys: String, CodingKey {
            case hlsGroupSettings = "hlsGroupSettings"
            case dashIsoGroupSettings = "dashIsoGroupSettings"
            case `type` = "type"
            case fileGroupSettings = "fileGroupSettings"
            case cmafGroupSettings = "cmafGroupSettings"
            case msSmoothGroupSettings = "msSmoothGroupSettings"
        }
    }

    public struct SccDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Framerate", location: .body(locationName: "framerate"), required: false, type: .enum)
        ]
        public let framerate: SccDestinationFramerate?

        public init(framerate: SccDestinationFramerate? = nil) {
            self.framerate = framerate
        }

        private enum CodingKeys: String, CodingKey {
            case framerate = "framerate"
        }
    }

    public enum Eac3MetadataControl: String, CustomStringConvertible, Codable {
        case followInput = "FOLLOW_INPUT"
        case useConfigured = "USE_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public struct BurninDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ShadowOpacity", location: .body(locationName: "shadowOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "FontSize", location: .body(locationName: "fontSize"), required: false, type: .integer), 
            AWSShapeMember(label: "YPosition", location: .body(locationName: "yPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "BackgroundColor", location: .body(locationName: "backgroundColor"), required: false, type: .enum), 
            AWSShapeMember(label: "XPosition", location: .body(locationName: "xPosition"), required: false, type: .integer), 
            AWSShapeMember(label: "Alignment", location: .body(locationName: "alignment"), required: true, type: .enum), 
            AWSShapeMember(label: "OutlineSize", location: .body(locationName: "outlineSize"), required: true, type: .integer), 
            AWSShapeMember(label: "OutlineColor", location: .body(locationName: "outlineColor"), required: true, type: .enum), 
            AWSShapeMember(label: "ShadowColor", location: .body(locationName: "shadowColor"), required: false, type: .enum), 
            AWSShapeMember(label: "ShadowYOffset", location: .body(locationName: "shadowYOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "FontResolution", location: .body(locationName: "fontResolution"), required: false, type: .integer), 
            AWSShapeMember(label: "TeletextSpacing", location: .body(locationName: "teletextSpacing"), required: false, type: .enum), 
            AWSShapeMember(label: "BackgroundOpacity", location: .body(locationName: "backgroundOpacity"), required: false, type: .integer), 
            AWSShapeMember(label: "ShadowXOffset", location: .body(locationName: "shadowXOffset"), required: false, type: .integer), 
            AWSShapeMember(label: "FontColor", location: .body(locationName: "fontColor"), required: false, type: .enum), 
            AWSShapeMember(label: "FontOpacity", location: .body(locationName: "fontOpacity"), required: true, type: .integer)
        ]
        /// Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let shadowOpacity: Int32?
        /// A positive integer indicates the exact font size in points. Set to 0 for automatic font size selection. All burn-in and DVB-Sub font settings must match.
        public let fontSize: Int32?
        /// Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit y_position is provided, the caption will be positioned towards the bottom of the output. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let yPosition: Int32?
        public let backgroundColor: BurninSubtitleBackgroundColor?
        /// Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit x_position is provided, the horizontal caption position will be determined by the alignment parameter. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let xPosition: Int32?
        public let alignment: BurninSubtitleAlignment
        /// Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match.
        public let outlineSize: Int32
        public let outlineColor: BurninSubtitleOutlineColor
        public let shadowColor: BurninSubtitleShadowColor?
        /// Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match.
        public let shadowYOffset: Int32?
        /// Font resolution in DPI (dots per inch); default is 96 dpi.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontResolution: Int32?
        public let teletextSpacing: BurninSubtitleTeletextSpacing?
        /// Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter blank is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match.
        public let backgroundOpacity: Int32?
        /// Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match.
        public let shadowXOffset: Int32?
        public let fontColor: BurninSubtitleFontColor?
        /// Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent.
        /// All burn-in and DVB-Sub font settings must match.
        public let fontOpacity: Int32

        public init(shadowOpacity: Int32? = nil, fontSize: Int32? = nil, yPosition: Int32? = nil, backgroundColor: BurninSubtitleBackgroundColor? = nil, xPosition: Int32? = nil, alignment: BurninSubtitleAlignment, outlineSize: Int32, outlineColor: BurninSubtitleOutlineColor, shadowColor: BurninSubtitleShadowColor? = nil, shadowYOffset: Int32? = nil, fontResolution: Int32? = nil, teletextSpacing: BurninSubtitleTeletextSpacing? = nil, backgroundOpacity: Int32? = nil, shadowXOffset: Int32? = nil, fontColor: BurninSubtitleFontColor? = nil, fontOpacity: Int32) {
            self.shadowOpacity = shadowOpacity
            self.fontSize = fontSize
            self.yPosition = yPosition
            self.backgroundColor = backgroundColor
            self.xPosition = xPosition
            self.alignment = alignment
            self.outlineSize = outlineSize
            self.outlineColor = outlineColor
            self.shadowColor = shadowColor
            self.shadowYOffset = shadowYOffset
            self.fontResolution = fontResolution
            self.teletextSpacing = teletextSpacing
            self.backgroundOpacity = backgroundOpacity
            self.shadowXOffset = shadowXOffset
            self.fontColor = fontColor
            self.fontOpacity = fontOpacity
        }

        private enum CodingKeys: String, CodingKey {
            case shadowOpacity = "shadowOpacity"
            case fontSize = "fontSize"
            case yPosition = "yPosition"
            case backgroundColor = "backgroundColor"
            case xPosition = "xPosition"
            case alignment = "alignment"
            case outlineSize = "outlineSize"
            case outlineColor = "outlineColor"
            case shadowColor = "shadowColor"
            case shadowYOffset = "shadowYOffset"
            case fontResolution = "fontResolution"
            case teletextSpacing = "teletextSpacing"
            case backgroundOpacity = "backgroundOpacity"
            case shadowXOffset = "shadowXOffset"
            case fontColor = "fontColor"
            case fontOpacity = "fontOpacity"
        }
    }

    public enum H264FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum CmafManifestCompression: String, CustomStringConvertible, Codable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct Job: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Role", location: .body(locationName: "role"), required: true, type: .string), 
            AWSShapeMember(label: "Queue", location: .body(locationName: "queue"), required: false, type: .string), 
            AWSShapeMember(label: "Settings", location: .body(locationName: "settings"), required: true, type: .structure), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "UserMetadata", location: .body(locationName: "userMetadata"), required: false, type: .map), 
            AWSShapeMember(label: "Timing", location: .body(locationName: "timing"), required: false, type: .structure), 
            AWSShapeMember(label: "OutputGroupDetails", location: .body(locationName: "outputGroupDetails"), required: false, type: .list), 
            AWSShapeMember(label: "JobTemplate", location: .body(locationName: "jobTemplate"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", location: .body(locationName: "errorCode"), required: false, type: .integer), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "ErrorMessage", location: .body(locationName: "errorMessage"), required: false, type: .string)
        ]
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html
        public let role: String
        /// Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
        public let queue: String?
        public let settings: JobSettings
        /// The time, in Unix epoch format in seconds, when the job got created.
        public let createdAt: TimeStamp?
        /// User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.
        public let userMetadata: [String: String]?
        public let timing: Timing?
        /// List of output group details
        public let outputGroupDetails: [OutputGroupDetail]?
        /// The job template that the job is created from, if it is created from a job template.
        public let jobTemplate: String?
        /// A portion of the job's ARN, unique within your AWS Elemental MediaConvert resources
        public let id: String?
        /// Error code for the job
        public let errorCode: Int32?
        public let status: JobStatus?
        /// Error message of Job
        public let errorMessage: String?

        public init(arn: String? = nil, role: String, queue: String? = nil, settings: JobSettings, createdAt: TimeStamp? = nil, userMetadata: [String: String]? = nil, timing: Timing? = nil, outputGroupDetails: [OutputGroupDetail]? = nil, jobTemplate: String? = nil, id: String? = nil, errorCode: Int32? = nil, status: JobStatus? = nil, errorMessage: String? = nil) {
            self.arn = arn
            self.role = role
            self.queue = queue
            self.settings = settings
            self.createdAt = createdAt
            self.userMetadata = userMetadata
            self.timing = timing
            self.outputGroupDetails = outputGroupDetails
            self.jobTemplate = jobTemplate
            self.id = id
            self.errorCode = errorCode
            self.status = status
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case role = "role"
            case queue = "queue"
            case settings = "settings"
            case createdAt = "createdAt"
            case userMetadata = "userMetadata"
            case timing = "timing"
            case outputGroupDetails = "outputGroupDetails"
            case jobTemplate = "jobTemplate"
            case id = "id"
            case errorCode = "errorCode"
            case status = "status"
            case errorMessage = "errorMessage"
        }
    }

    public struct ExceptionBody: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", location: .body(locationName: "message"), required: false, type: .string)
        ]
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct GetQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The name of the queue.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public enum H265Tiles: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum TimecodeSource: String, CustomStringConvertible, Codable {
        case embedded = "EMBEDDED"
        case zerobased = "ZEROBASED"
        case specifiedstart = "SPECIFIEDSTART"
        public var description: String { return self.rawValue }
    }

    public enum H265SampleAdaptiveOffsetFilterMode: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case adaptive = "ADAPTIVE"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public struct Mp4Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MoovPlacement", location: .body(locationName: "moovPlacement"), required: false, type: .enum), 
            AWSShapeMember(label: "Mp4MajorBrand", location: .body(locationName: "mp4MajorBrand"), required: false, type: .string), 
            AWSShapeMember(label: "FreeSpaceBox", location: .body(locationName: "freeSpaceBox"), required: false, type: .enum), 
            AWSShapeMember(label: "CslgAtom", location: .body(locationName: "cslgAtom"), required: false, type: .enum)
        ]
        public let moovPlacement: Mp4MoovPlacement?
        /// Overrides the "Major Brand" field in the output file. Usually not necessary to specify.
        public let mp4MajorBrand: String?
        public let freeSpaceBox: Mp4FreeSpaceBox?
        public let cslgAtom: Mp4CslgAtom?

        public init(moovPlacement: Mp4MoovPlacement? = nil, mp4MajorBrand: String? = nil, freeSpaceBox: Mp4FreeSpaceBox? = nil, cslgAtom: Mp4CslgAtom? = nil) {
            self.moovPlacement = moovPlacement
            self.mp4MajorBrand = mp4MajorBrand
            self.freeSpaceBox = freeSpaceBox
            self.cslgAtom = cslgAtom
        }

        private enum CodingKeys: String, CodingKey {
            case moovPlacement = "moovPlacement"
            case mp4MajorBrand = "mp4MajorBrand"
            case freeSpaceBox = "freeSpaceBox"
            case cslgAtom = "cslgAtom"
        }
    }

    public struct AudioSelector: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tracks", location: .body(locationName: "tracks"), required: false, type: .list), 
            AWSShapeMember(label: "ProgramSelection", location: .body(locationName: "programSelection"), required: false, type: .integer), 
            AWSShapeMember(label: "DefaultSelection", location: .body(locationName: "defaultSelection"), required: false, type: .enum), 
            AWSShapeMember(label: "ExternalAudioFileInput", location: .body(locationName: "externalAudioFileInput"), required: false, type: .string), 
            AWSShapeMember(label: "Pids", location: .body(locationName: "pids"), required: false, type: .list), 
            AWSShapeMember(label: "LanguageCode", location: .body(locationName: "languageCode"), required: false, type: .enum), 
            AWSShapeMember(label: "RemixSettings", location: .body(locationName: "remixSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "CustomLanguageCode", location: .body(locationName: "customLanguageCode"), required: false, type: .string), 
            AWSShapeMember(label: "Offset", location: .body(locationName: "offset"), required: false, type: .integer), 
            AWSShapeMember(label: "SelectorType", location: .body(locationName: "selectorType"), required: false, type: .enum)
        ]
        /// Identify a track from the input audio to include in this selector by entering the track index number. To include several tracks in a single audio selector, specify multiple tracks as follows. Using the console, enter a comma-separated list. For examle, type "1,2,3" to include tracks 1 through 3. Specifying directly in your JSON job file, provide the track numbers in an array. For example, "tracks": [1,2,3].
        public let tracks: [Int32]?
        /// Use this setting for input streams that contain Dolby E, to have the service extract specific program data from the track. To select multiple programs, create multiple selectors with the same Track and different Program numbers. In the console, this setting is visible when you set Selector type to Track. Choose the program number from the dropdown list. If you are sending a JSON file, provide the program ID, which is part of the audio metadata. If your input file has incorrect metadata, you can choose All channels instead of a program number to have the service ignore the program IDs and include all the programs in the track.
        public let programSelection: Int32?
        public let defaultSelection: AudioDefaultSelection?
        /// Specifies audio data from an external file source.
        public let externalAudioFileInput: String?
        /// Selects a specific PID from within an audio source (e.g. 257 selects PID 0x101).
        public let pids: [Int32]?
        /// Selects a specific language code from within an audio source.
        public let languageCode: LanguageCode?
        /// Use these settings to reorder the audio channels of one input to match those of another input. This allows you to combine the two files into a single output, one after the other.
        public let remixSettings: RemixSettings?
        /// Selects a specific language code from within an audio source, using the ISO 639-2 or ISO 639-3 three-letter language code
        public let customLanguageCode: String?
        /// Specifies a time delta in milliseconds to offset the audio from the input video.
        public let offset: Int32?
        public let selectorType: AudioSelectorType?

        public init(tracks: [Int32]? = nil, programSelection: Int32? = nil, defaultSelection: AudioDefaultSelection? = nil, externalAudioFileInput: String? = nil, pids: [Int32]? = nil, languageCode: LanguageCode? = nil, remixSettings: RemixSettings? = nil, customLanguageCode: String? = nil, offset: Int32? = nil, selectorType: AudioSelectorType? = nil) {
            self.tracks = tracks
            self.programSelection = programSelection
            self.defaultSelection = defaultSelection
            self.externalAudioFileInput = externalAudioFileInput
            self.pids = pids
            self.languageCode = languageCode
            self.remixSettings = remixSettings
            self.customLanguageCode = customLanguageCode
            self.offset = offset
            self.selectorType = selectorType
        }

        private enum CodingKeys: String, CodingKey {
            case tracks = "tracks"
            case programSelection = "programSelection"
            case defaultSelection = "defaultSelection"
            case externalAudioFileInput = "externalAudioFileInput"
            case pids = "pids"
            case languageCode = "languageCode"
            case remixSettings = "remixSettings"
            case customLanguageCode = "customLanguageCode"
            case offset = "offset"
            case selectorType = "selectorType"
        }
    }

    public struct DeleteQueueResponse: AWSShape {

    }

    public enum AacVbrQuality: String, CustomStringConvertible, Codable {
        case low = "LOW"
        case mediumLow = "MEDIUM_LOW"
        case mediumHigh = "MEDIUM_HIGH"
        case high = "HIGH"
        public var description: String { return self.rawValue }
    }

    public struct GetJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        /// the job ID of the job.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public enum RespondToAfd: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case respond = "RESPOND"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public struct FileSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SourceFile", location: .body(locationName: "sourceFile"), required: true, type: .string), 
            AWSShapeMember(label: "Convert608To708", location: .body(locationName: "convert608To708"), required: false, type: .enum), 
            AWSShapeMember(label: "TimeDelta", location: .body(locationName: "timeDelta"), required: false, type: .integer)
        ]
        /// External caption file used for loading captions. Accepted file extensions are 'scc', 'ttml', 'dfxp', 'stl', 'srt', and 'smi'.
        public let sourceFile: String
        public let convert608To708: FileSourceConvert608To708?
        /// Specifies a time delta in seconds to offset the captions from the source file.
        public let timeDelta: Int32?

        public init(sourceFile: String, convert608To708: FileSourceConvert608To708? = nil, timeDelta: Int32? = nil) {
            self.sourceFile = sourceFile
            self.convert608To708 = convert608To708
            self.timeDelta = timeDelta
        }

        private enum CodingKeys: String, CodingKey {
            case sourceFile = "sourceFile"
            case convert608To708 = "convert608To708"
            case timeDelta = "timeDelta"
        }
    }

    public enum M2tsSegmentationStyle: String, CustomStringConvertible, Codable {
        case maintainCadence = "MAINTAIN_CADENCE"
        case resetCadence = "RESET_CADENCE"
        public var description: String { return self.rawValue }
    }

    public enum QueueListBy: String, CustomStringConvertible, Codable {
        case name = "NAME"
        case creationDate = "CREATION_DATE"
        public var description: String { return self.rawValue }
    }

    public struct AvailBlanking: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailBlankingImage", location: .body(locationName: "availBlankingImage"), required: false, type: .string)
        ]
        /// Blanking image to be used. Leave empty for solid black. Only bmp and png images are supported.
        public let availBlankingImage: String?

        public init(availBlankingImage: String? = nil) {
            self.availBlankingImage = availBlankingImage
        }

        private enum CodingKeys: String, CodingKey {
            case availBlankingImage = "availBlankingImage"
        }
    }

    public struct ChannelMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OutputChannels", location: .body(locationName: "outputChannels"), required: true, type: .list)
        ]
        /// List of output channels
        public let outputChannels: [OutputChannelMapping]

        public init(outputChannels: [OutputChannelMapping]) {
            self.outputChannels = outputChannels
        }

        private enum CodingKeys: String, CodingKey {
            case outputChannels = "outputChannels"
        }
    }

    public enum MovReference: String, CustomStringConvertible, Codable {
        case selfContained = "SELF_CONTAINED"
        case external = "EXTERNAL"
        public var description: String { return self.rawValue }
    }

    public struct HlsSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AudioGroupId", location: .body(locationName: "audioGroupId"), required: false, type: .string), 
            AWSShapeMember(label: "AudioRenditionSets", location: .body(locationName: "audioRenditionSets"), required: false, type: .string), 
            AWSShapeMember(label: "SegmentModifier", location: .body(locationName: "segmentModifier"), required: false, type: .string), 
            AWSShapeMember(label: "AudioTrackType", location: .body(locationName: "audioTrackType"), required: false, type: .enum), 
            AWSShapeMember(label: "IFrameOnlyManifest", location: .body(locationName: "iFrameOnlyManifest"), required: false, type: .enum)
        ]
        /// Specifies the group to which the audio Rendition belongs.
        public let audioGroupId: String?
        /// List all the audio groups that are used with the video output stream. Input all the audio GROUP-IDs that are associated to the video, separate by ','.
        public let audioRenditionSets: String?
        /// String concatenated to end of segment filenames. Accepts "Format Identifiers":#format_identifier_parameters.
        public let segmentModifier: String?
        public let audioTrackType: HlsAudioTrackType?
        public let iFrameOnlyManifest: HlsIFrameOnlyManifest?

        public init(audioGroupId: String? = nil, audioRenditionSets: String? = nil, segmentModifier: String? = nil, audioTrackType: HlsAudioTrackType? = nil, iFrameOnlyManifest: HlsIFrameOnlyManifest? = nil) {
            self.audioGroupId = audioGroupId
            self.audioRenditionSets = audioRenditionSets
            self.segmentModifier = segmentModifier
            self.audioTrackType = audioTrackType
            self.iFrameOnlyManifest = iFrameOnlyManifest
        }

        private enum CodingKeys: String, CodingKey {
            case audioGroupId = "audioGroupId"
            case audioRenditionSets = "audioRenditionSets"
            case segmentModifier = "segmentModifier"
            case audioTrackType = "audioTrackType"
            case iFrameOnlyManifest = "iFrameOnlyManifest"
        }
    }

    public enum H264QualityTuningLevel: String, CustomStringConvertible, Codable {
        case singlePass = "SINGLE_PASS"
        case singlePassHq = "SINGLE_PASS_HQ"
        case multiPassHq = "MULTI_PASS_HQ"
        public var description: String { return self.rawValue }
    }

    public enum H265SlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HlsDirectoryStructure: String, CustomStringConvertible, Codable {
        case singleDirectory = "SINGLE_DIRECTORY"
        case subdirectoryPerStream = "SUBDIRECTORY_PER_STREAM"
        public var description: String { return self.rawValue }
    }

    public enum H264FramerateControl: String, CustomStringConvertible, Codable {
        case initializeFromSource = "INITIALIZE_FROM_SOURCE"
        case specified = "SPECIFIED"
        public var description: String { return self.rawValue }
    }

    public struct UpdateQueueRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "Name", location: .uri(locationName: "name"), required: true, type: .string)
        ]
        /// The new description for the queue, if you are changing it.
        public let description: String?
        public let status: QueueStatus?
        /// The name of the queue you are modifying.
        public let name: String

        public init(description: String? = nil, status: QueueStatus? = nil, name: String) {
            self.description = description
            self.status = status
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case status = "status"
            case name = "name"
        }
    }

    public enum DvbSubtitleShadowColor: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case black = "BLACK"
        case white = "WHITE"
        public var description: String { return self.rawValue }
    }

    public enum CmafStreamInfResolution: String, CustomStringConvertible, Codable {
        case include = "INCLUDE"
        case exclude = "EXCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum ProresSlowPal: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum CmafClientCache: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum H265TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum M2tsNielsenId3: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum H264AdaptiveQuantization: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case low = "LOW"
        case medium = "MEDIUM"
        case high = "HIGH"
        case higher = "HIGHER"
        case max = "MAX"
        public var description: String { return self.rawValue }
    }

    public enum CmafWriteHLSManifest: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct ProresSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FramerateConversionAlgorithm", location: .body(locationName: "framerateConversionAlgorithm"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateControl", location: .body(locationName: "framerateControl"), required: false, type: .enum), 
            AWSShapeMember(label: "CodecProfile", location: .body(locationName: "codecProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "Telecine", location: .body(locationName: "telecine"), required: false, type: .enum), 
            AWSShapeMember(label: "InterlaceMode", location: .body(locationName: "interlaceMode"), required: false, type: .enum), 
            AWSShapeMember(label: "FramerateNumerator", location: .body(locationName: "framerateNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParDenominator", location: .body(locationName: "parDenominator"), required: false, type: .integer), 
            AWSShapeMember(label: "ParControl", location: .body(locationName: "parControl"), required: false, type: .enum), 
            AWSShapeMember(label: "SlowPal", location: .body(locationName: "slowPal"), required: false, type: .enum), 
            AWSShapeMember(label: "ParNumerator", location: .body(locationName: "parNumerator"), required: false, type: .integer), 
            AWSShapeMember(label: "FramerateDenominator", location: .body(locationName: "framerateDenominator"), required: false, type: .integer)
        ]
        public let framerateConversionAlgorithm: ProresFramerateConversionAlgorithm?
        public let framerateControl: ProresFramerateControl?
        public let codecProfile: ProresCodecProfile?
        public let telecine: ProresTelecine?
        public let interlaceMode: ProresInterlaceMode?
        /// When you use the API for transcode jobs that use framerate conversion, specify the framerate as a fraction. For example,  24000 / 1001 = 23.976 fps. Use FramerateNumerator to specify the numerator of this fraction. In this example, use 24000 for the value of FramerateNumerator.
        public let framerateNumerator: Int32?
        /// Pixel Aspect Ratio denominator.
        public let parDenominator: Int32?
        public let parControl: ProresParControl?
        public let slowPal: ProresSlowPal?
        /// Pixel Aspect Ratio numerator.
        public let parNumerator: Int32?
        /// Framerate denominator.
        public let framerateDenominator: Int32?

        public init(framerateConversionAlgorithm: ProresFramerateConversionAlgorithm? = nil, framerateControl: ProresFramerateControl? = nil, codecProfile: ProresCodecProfile? = nil, telecine: ProresTelecine? = nil, interlaceMode: ProresInterlaceMode? = nil, framerateNumerator: Int32? = nil, parDenominator: Int32? = nil, parControl: ProresParControl? = nil, slowPal: ProresSlowPal? = nil, parNumerator: Int32? = nil, framerateDenominator: Int32? = nil) {
            self.framerateConversionAlgorithm = framerateConversionAlgorithm
            self.framerateControl = framerateControl
            self.codecProfile = codecProfile
            self.telecine = telecine
            self.interlaceMode = interlaceMode
            self.framerateNumerator = framerateNumerator
            self.parDenominator = parDenominator
            self.parControl = parControl
            self.slowPal = slowPal
            self.parNumerator = parNumerator
            self.framerateDenominator = framerateDenominator
        }

        private enum CodingKeys: String, CodingKey {
            case framerateConversionAlgorithm = "framerateConversionAlgorithm"
            case framerateControl = "framerateControl"
            case codecProfile = "codecProfile"
            case telecine = "telecine"
            case interlaceMode = "interlaceMode"
            case framerateNumerator = "framerateNumerator"
            case parDenominator = "parDenominator"
            case parControl = "parControl"
            case slowPal = "slowPal"
            case parNumerator = "parNumerator"
            case framerateDenominator = "framerateDenominator"
        }
    }

    public enum CmafWriteDASHManifest: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct InsertableImage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", location: .body(locationName: "duration"), required: false, type: .integer), 
            AWSShapeMember(label: "Height", location: .body(locationName: "height"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageX", location: .body(locationName: "imageX"), required: true, type: .integer), 
            AWSShapeMember(label: "Width", location: .body(locationName: "width"), required: false, type: .integer), 
            AWSShapeMember(label: "StartTime", location: .body(locationName: "startTime"), required: false, type: .string), 
            AWSShapeMember(label: "FadeIn", location: .body(locationName: "fadeIn"), required: false, type: .integer), 
            AWSShapeMember(label: "ImageInserterInput", location: .body(locationName: "imageInserterInput"), required: true, type: .string), 
            AWSShapeMember(label: "Opacity", location: .body(locationName: "opacity"), required: true, type: .integer), 
            AWSShapeMember(label: "ImageY", location: .body(locationName: "imageY"), required: true, type: .integer), 
            AWSShapeMember(label: "FadeOut", location: .body(locationName: "fadeOut"), required: false, type: .integer), 
            AWSShapeMember(label: "Layer", location: .body(locationName: "layer"), required: true, type: .integer)
        ]
        /// Use Duration (Duration) to set the time, in milliseconds, for the image to remain on the output video.
        public let duration: Int32?
        /// Specify the Height (Height) of the inserted image. Use a value that is less than or equal to the video resolution height. Leave this setting blank to use the native height of the image.
        public let height: Int32?
        /// Use Left (ImageX) to set the distance, in pixels, between the inserted image and the left edge of the frame. Required for BMP, PNG and TGA input.
        public let imageX: Int32
        /// Specify the Width (Width) of the inserted image. Use a value that is less than or equal to the video resolution width. Leave this setting blank to use the native width of the image.
        public let width: Int32?
        /// Use Start time (StartTime) to specify the video timecode when the image is inserted in the output. This must be in timecode (HH:MM:SS:FF or HH:MM:SS;FF) format.
        public let startTime: String?
        /// Use Fade in (FadeIut) to set the length, in milliseconds, of the inserted image fade in. If you don't specify a value for Fade in, the image will appear abruptly at the Start time.
        public let fadeIn: Int32?
        /// Use Image location (imageInserterInput) to specify the Amazon S3 location of the image to be inserted into the output. Use a 32 bit BMP, PNG, or TGA file that fits inside the video frame.
        public let imageInserterInput: String
        /// Use Opacity (Opacity) to specify how much of the underlying video shows through the inserted image. 0 is transparent and 100 is fully opaque. Default is 50.
        public let opacity: Int32
        /// Use Top (ImageY) to set the distance, in pixels, between the inserted image and the top edge of the video frame. Required for BMP, PNG and TGA input.
        public let imageY: Int32
        /// Use Fade out (FadeOut) to set the length, in milliseconds, of the inserted image fade out. If you don't specify a value for Fade out, the image will disappear abruptly at the end of the inserted image duration.
        public let fadeOut: Int32?
        /// Use Layer (Layer) to specify how overlapping inserted images appear. Images with higher values of layer appear on top of images with lower values of layer.
        public let layer: Int32

        public init(duration: Int32? = nil, height: Int32? = nil, imageX: Int32, width: Int32? = nil, startTime: String? = nil, fadeIn: Int32? = nil, imageInserterInput: String, opacity: Int32, imageY: Int32, fadeOut: Int32? = nil, layer: Int32) {
            self.duration = duration
            self.height = height
            self.imageX = imageX
            self.width = width
            self.startTime = startTime
            self.fadeIn = fadeIn
            self.imageInserterInput = imageInserterInput
            self.opacity = opacity
            self.imageY = imageY
            self.fadeOut = fadeOut
            self.layer = layer
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "duration"
            case height = "height"
            case imageX = "imageX"
            case width = "width"
            case startTime = "startTime"
            case fadeIn = "fadeIn"
            case imageInserterInput = "imageInserterInput"
            case opacity = "opacity"
            case imageY = "imageY"
            case fadeOut = "fadeOut"
            case layer = "layer"
        }
    }

    public enum ColorSpace: String, CustomStringConvertible, Codable {
        case follow = "FOLLOW"
        case rec601 = "REC_601"
        case rec709 = "REC_709"
        case hdr10 = "HDR10"
        case hlg2020 = "HLG_2020"
        public var description: String { return self.rawValue }
    }

    public enum OutputGroupType: String, CustomStringConvertible, Codable {
        case hlsGroupSettings = "HLS_GROUP_SETTINGS"
        case dashIsoGroupSettings = "DASH_ISO_GROUP_SETTINGS"
        case fileGroupSettings = "FILE_GROUP_SETTINGS"
        case msSmoothGroupSettings = "MS_SMOOTH_GROUP_SETTINGS"
        case cmafGroupSettings = "CMAF_GROUP_SETTINGS"
        public var description: String { return self.rawValue }
    }

    public enum H264TemporalAdaptiveQuantization: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public struct Ac3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bitrate", location: .body(locationName: "bitrate"), required: false, type: .integer), 
            AWSShapeMember(label: "CodingMode", location: .body(locationName: "codingMode"), required: false, type: .enum), 
            AWSShapeMember(label: "Dialnorm", location: .body(locationName: "dialnorm"), required: false, type: .integer), 
            AWSShapeMember(label: "DynamicRangeCompressionProfile", location: .body(locationName: "dynamicRangeCompressionProfile"), required: false, type: .enum), 
            AWSShapeMember(label: "SampleRate", location: .body(locationName: "sampleRate"), required: false, type: .integer), 
            AWSShapeMember(label: "LfeFilter", location: .body(locationName: "lfeFilter"), required: false, type: .enum), 
            AWSShapeMember(label: "MetadataControl", location: .body(locationName: "metadataControl"), required: false, type: .enum), 
            AWSShapeMember(label: "BitstreamMode", location: .body(locationName: "bitstreamMode"), required: false, type: .enum)
        ]
        /// Average bitrate in bits/second. Valid bitrates depend on the coding mode.
        public let bitrate: Int32?
        public let codingMode: Ac3CodingMode?
        /// Sets the dialnorm for the output. If blank and input audio is Dolby Digital, dialnorm will be passed through.
        public let dialnorm: Int32?
        public let dynamicRangeCompressionProfile: Ac3DynamicRangeCompressionProfile?
        /// Sample rate in hz. Sample rate is always 48000.
        public let sampleRate: Int32?
        public let lfeFilter: Ac3LfeFilter?
        public let metadataControl: Ac3MetadataControl?
        public let bitstreamMode: Ac3BitstreamMode?

        public init(bitrate: Int32? = nil, codingMode: Ac3CodingMode? = nil, dialnorm: Int32? = nil, dynamicRangeCompressionProfile: Ac3DynamicRangeCompressionProfile? = nil, sampleRate: Int32? = nil, lfeFilter: Ac3LfeFilter? = nil, metadataControl: Ac3MetadataControl? = nil, bitstreamMode: Ac3BitstreamMode? = nil) {
            self.bitrate = bitrate
            self.codingMode = codingMode
            self.dialnorm = dialnorm
            self.dynamicRangeCompressionProfile = dynamicRangeCompressionProfile
            self.sampleRate = sampleRate
            self.lfeFilter = lfeFilter
            self.metadataControl = metadataControl
            self.bitstreamMode = bitstreamMode
        }

        private enum CodingKeys: String, CodingKey {
            case bitrate = "bitrate"
            case codingMode = "codingMode"
            case dialnorm = "dialnorm"
            case dynamicRangeCompressionProfile = "dynamicRangeCompressionProfile"
            case sampleRate = "sampleRate"
            case lfeFilter = "lfeFilter"
            case metadataControl = "metadataControl"
            case bitstreamMode = "bitstreamMode"
        }
    }

    public enum Mpeg2FramerateConversionAlgorithm: String, CustomStringConvertible, Codable {
        case duplicateDrop = "DUPLICATE_DROP"
        case interpolate = "INTERPOLATE"
        public var description: String { return self.rawValue }
    }

    public enum Eac3AttenuationControl: String, CustomStringConvertible, Codable {
        case attenuate3Db = "ATTENUATE_3_DB"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public struct EmbeddedSourceSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Source608ChannelNumber", location: .body(locationName: "source608ChannelNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Source608TrackNumber", location: .body(locationName: "source608TrackNumber"), required: false, type: .integer), 
            AWSShapeMember(label: "Convert608To708", location: .body(locationName: "convert608To708"), required: false, type: .enum)
        ]
        /// Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough.
        public let source608ChannelNumber: Int32?
        /// Specifies the video track index used for extracting captions. The system only supports one input video track, so this should always be set to '1'.
        public let source608TrackNumber: Int32?
        public let convert608To708: EmbeddedConvert608To708?

        public init(source608ChannelNumber: Int32? = nil, source608TrackNumber: Int32? = nil, convert608To708: EmbeddedConvert608To708? = nil) {
            self.source608ChannelNumber = source608ChannelNumber
            self.source608TrackNumber = source608TrackNumber
            self.convert608To708 = convert608To708
        }

        private enum CodingKeys: String, CodingKey {
            case source608ChannelNumber = "source608ChannelNumber"
            case source608TrackNumber = "source608TrackNumber"
            case convert608To708 = "convert608To708"
        }
    }

    public enum Mpeg2Syntax: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case d10 = "D_10"
        public var description: String { return self.rawValue }
    }

    public struct Queue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubmittedJobsCount", location: .body(locationName: "submittedJobsCount"), required: false, type: .integer), 
            AWSShapeMember(label: "CreatedAt", location: .body(locationName: "createdAt"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", location: .body(locationName: "status"), required: false, type: .enum), 
            AWSShapeMember(label: "ProgressingJobsCount", location: .body(locationName: "progressingJobsCount"), required: false, type: .integer), 
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Type", location: .body(locationName: "type"), required: false, type: .enum), 
            AWSShapeMember(label: "LastUpdated", location: .body(locationName: "lastUpdated"), required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", location: .body(locationName: "name"), required: true, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// Estimated number of jobs in SUBMITTED status.
        public let submittedJobsCount: Int32?
        /// The timestamp in epoch seconds for queue creation.
        public let createdAt: TimeStamp?
        public let status: QueueStatus?
        /// Estimated number of jobs in PROGRESSING status.
        public let progressingJobsCount: Int32?
        /// An identifier for this resource that is unique within all of AWS.
        public let arn: String?
        /// A queue can be of two types: system or custom. System or built-in queues can't be modified or deleted by the user.
        public let `type`: `Type`?
        /// The timestamp in epoch seconds when the queue was last updated.
        public let lastUpdated: TimeStamp?
        /// A name you create for each queue. Each name must be unique within your account.
        public let name: String
        /// An optional description you create for each queue.
        public let description: String?

        public init(submittedJobsCount: Int32? = nil, createdAt: TimeStamp? = nil, status: QueueStatus? = nil, progressingJobsCount: Int32? = nil, arn: String? = nil, type: `Type`? = nil, lastUpdated: TimeStamp? = nil, name: String, description: String? = nil) {
            self.submittedJobsCount = submittedJobsCount
            self.createdAt = createdAt
            self.status = status
            self.progressingJobsCount = progressingJobsCount
            self.arn = arn
            self.`type` = `type`
            self.lastUpdated = lastUpdated
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case submittedJobsCount = "submittedJobsCount"
            case createdAt = "createdAt"
            case status = "status"
            case progressingJobsCount = "progressingJobsCount"
            case arn = "arn"
            case `type` = "type"
            case lastUpdated = "lastUpdated"
            case name = "name"
            case description = "description"
        }
    }

    public struct SpekeKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SystemIds", location: .body(locationName: "systemIds"), required: true, type: .list), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: true, type: .string), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: true, type: .string)
        ]
        /// Relates to SPEKE implementation. DRM system identifiers. DASH output groups support a max of two system ids. Other group types support one system id.
        public let systemIds: [String]
        /// Use URL (Url) to specify the SPEKE-compliant server that will provide keys for content.
        public let url: String
        /// The SPEKE-compliant server uses Resource ID (ResourceId) to identify content.
        public let resourceId: String

        public init(systemIds: [String], url: String, resourceId: String) {
            self.systemIds = systemIds
            self.url = url
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case systemIds = "systemIds"
            case url = "url"
            case resourceId = "resourceId"
        }
    }

    public enum OutputSdt: String, CustomStringConvertible, Codable {
        case sdtFollow = "SDT_FOLLOW"
        case sdtFollowIfPresent = "SDT_FOLLOW_IF_PRESENT"
        case sdtManual = "SDT_MANUAL"
        case sdtNone = "SDT_NONE"
        public var description: String { return self.rawValue }
    }

    public struct CaptionDestinationSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DvbSubDestinationSettings", location: .body(locationName: "dvbSubDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "SccDestinationSettings", location: .body(locationName: "sccDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "BurninDestinationSettings", location: .body(locationName: "burninDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TeletextDestinationSettings", location: .body(locationName: "teletextDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "TtmlDestinationSettings", location: .body(locationName: "ttmlDestinationSettings"), required: false, type: .structure), 
            AWSShapeMember(label: "DestinationType", location: .body(locationName: "destinationType"), required: true, type: .enum)
        ]
        public let dvbSubDestinationSettings: DvbSubDestinationSettings?
        public let sccDestinationSettings: SccDestinationSettings?
        public let burninDestinationSettings: BurninDestinationSettings?
        public let teletextDestinationSettings: TeletextDestinationSettings?
        public let ttmlDestinationSettings: TtmlDestinationSettings?
        public let destinationType: CaptionDestinationType

        public init(dvbSubDestinationSettings: DvbSubDestinationSettings? = nil, sccDestinationSettings: SccDestinationSettings? = nil, burninDestinationSettings: BurninDestinationSettings? = nil, teletextDestinationSettings: TeletextDestinationSettings? = nil, ttmlDestinationSettings: TtmlDestinationSettings? = nil, destinationType: CaptionDestinationType) {
            self.dvbSubDestinationSettings = dvbSubDestinationSettings
            self.sccDestinationSettings = sccDestinationSettings
            self.burninDestinationSettings = burninDestinationSettings
            self.teletextDestinationSettings = teletextDestinationSettings
            self.ttmlDestinationSettings = ttmlDestinationSettings
            self.destinationType = destinationType
        }

        private enum CodingKeys: String, CodingKey {
            case dvbSubDestinationSettings = "dvbSubDestinationSettings"
            case sccDestinationSettings = "sccDestinationSettings"
            case burninDestinationSettings = "burninDestinationSettings"
            case teletextDestinationSettings = "teletextDestinationSettings"
            case ttmlDestinationSettings = "ttmlDestinationSettings"
            case destinationType = "destinationType"
        }
    }

    public enum Ac3CodingMode: String, CustomStringConvertible, Codable {
        case codingMode10 = "CODING_MODE_1_0"
        case codingMode11 = "CODING_MODE_1_1"
        case codingMode20 = "CODING_MODE_2_0"
        case codingMode32Lfe = "CODING_MODE_3_2_LFE"
        public var description: String { return self.rawValue }
    }

    public enum H264GopSizeUnits: String, CustomStringConvertible, Codable {
        case frames = "FRAMES"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

}