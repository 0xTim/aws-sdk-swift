// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension WorkSpaces {

    public struct DescribeWorkspacesConnectionStatusResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "WorkspacesConnectionStatus", required: false, type: .list)
        ]
        /// The token to use to retrieve the next set of results, or null if there are no more results available.
        public let nextToken: String?
        /// Information about the connection status of the WorkSpace.
        public let workspacesConnectionStatus: [WorkspaceConnectionStatus]?

        public init(nextToken: String? = nil, workspacesConnectionStatus: [WorkspaceConnectionStatus]? = nil) {
            self.nextToken = nextToken
            self.workspacesConnectionStatus = workspacesConnectionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workspacesConnectionStatus = "WorkspacesConnectionStatus"
        }
    }

    public struct RebootWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedRequests", required: false, type: .list)
        ]
        /// Information about the WorkSpaces that could not be rebooted.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "FailedRequests"
        }
    }

    public struct DescribeWorkspaceBundlesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Bundles", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Information about the bundles.
        public let bundles: [WorkspaceBundle]?
        /// The token to use to retrieve the next set of results, or null if there are no more results available. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?

        public init(bundles: [WorkspaceBundle]? = nil, nextToken: String? = nil) {
            self.bundles = bundles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case bundles = "Bundles"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Workspaces", required: false, type: .list)
        ]
        /// The token to use to retrieve the next set of results, or null if there are no more results available. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?
        /// Information about the WorkSpaces. Because CreateWorkspaces is an asynchronous operation, some of the returned information could be incomplete.
        public let workspaces: [Workspace]?

        public init(nextToken: String? = nil, workspaces: [Workspace]? = nil) {
            self.nextToken = nextToken
            self.workspaces = workspaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workspaces = "Workspaces"
        }
    }

    public struct ModifyWorkspacePropertiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: true, type: .string), 
            AWSShapeMember(label: "WorkspaceProperties", required: true, type: .structure)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String
        /// The properties of the WorkSpace.
        public let workspaceProperties: WorkspaceProperties

        public init(workspaceId: String, workspaceProperties: WorkspaceProperties) {
            self.workspaceId = workspaceId
            self.workspaceProperties = workspaceProperties
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
            case workspaceProperties = "WorkspaceProperties"
        }
    }

    public struct RebootRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: true, type: .string)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
        }
    }

    public struct RevokeIpRulesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupId", required: true, type: .string), 
            AWSShapeMember(label: "UserRules", required: true, type: .list)
        ]
        /// The ID of the group.
        public let groupId: String
        /// The rules to remove from the group.
        public let userRules: [String]

        public init(groupId: String, userRules: [String]) {
            self.groupId = groupId
            self.userRules = userRules
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case userRules = "UserRules"
        }
    }

    public struct IpRuleItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ipRule", required: false, type: .string), 
            AWSShapeMember(label: "ruleDesc", required: false, type: .string)
        ]
        /// The IP address range, in CIDR notation.
        public let ipRule: String?
        /// The description.
        public let ruleDesc: String?

        public init(ipRule: String? = nil, ruleDesc: String? = nil) {
            self.ipRule = ipRule
            self.ruleDesc = ruleDesc
        }

        private enum CodingKeys: String, CodingKey {
            case ipRule = "ipRule"
            case ruleDesc = "ruleDesc"
        }
    }

    public struct FailedWorkspaceChangeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "WorkspaceId", required: false, type: .string)
        ]
        /// The textual error message.
        public let errorMessage: String?
        /// The error code.
        public let errorCode: String?
        /// The identifier of the WorkSpace.
        public let workspaceId: String?

        public init(errorMessage: String? = nil, errorCode: String? = nil, workspaceId: String? = nil) {
            self.errorMessage = errorMessage
            self.errorCode = errorCode
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorCode = "ErrorCode"
            case workspaceId = "WorkspaceId"
        }
    }

    public struct DescribeIpGroupsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Result", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// Information about the IP access control groups.
        public let result: [WorkspacesIpGroup]?
        /// The token to use to retrieve the next set of results, or null if there are no more results available. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?

        public init(result: [WorkspacesIpGroup]? = nil, nextToken: String? = nil) {
            self.result = result
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case result = "Result"
            case nextToken = "NextToken"
        }
    }

    public struct AssociateIpGroupsResult: AWSShape {

    }

    public struct DescribeWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "UserName", required: false, type: .string), 
            AWSShapeMember(label: "WorkspaceIds", required: false, type: .list), 
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "DirectoryId", required: false, type: .string)
        ]
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?
        /// The ID of the bundle. All WorkSpaces that are created from this bundle are retrieved. This parameter cannot be combined with any other filter.
        public let bundleId: String?
        /// The name of the directory user. You must specify this parameter with DirectoryId.
        public let userName: String?
        /// The IDs of the WorkSpaces. This parameter cannot be combined with any other filter. Because the CreateWorkspaces operation is asynchronous, the identifier it returns is not immediately available. If you immediately call DescribeWorkspaces with this identifier, no information is returned.
        public let workspaceIds: [String]?
        /// The maximum number of items to return.
        public let limit: Int32?
        /// The ID of the directory. In addition, you can optionally specify a specific directory user (see UserName). This parameter cannot be combined with any other filter.
        public let directoryId: String?

        public init(nextToken: String? = nil, bundleId: String? = nil, userName: String? = nil, workspaceIds: [String]? = nil, limit: Int32? = nil, directoryId: String? = nil) {
            self.nextToken = nextToken
            self.bundleId = bundleId
            self.userName = userName
            self.workspaceIds = workspaceIds
            self.limit = limit
            self.directoryId = directoryId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case bundleId = "BundleId"
            case userName = "UserName"
            case workspaceIds = "WorkspaceIds"
            case limit = "Limit"
            case directoryId = "DirectoryId"
        }
    }

    public struct CreateTagsResult: AWSShape {

    }

    public struct AuthorizeIpRulesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupId", required: true, type: .string), 
            AWSShapeMember(label: "UserRules", required: true, type: .list)
        ]
        /// The ID of the group.
        public let groupId: String
        /// The rules to add to the group.
        public let userRules: [IpRuleItem]

        public init(groupId: String, userRules: [IpRuleItem]) {
            self.groupId = groupId
            self.userRules = userRules
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case userRules = "UserRules"
        }
    }

    public struct RevokeIpRulesResult: AWSShape {

    }

    public struct RebuildRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: true, type: .string)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
        }
    }

    public struct DeleteIpGroupResult: AWSShape {

    }

    public struct DisassociateIpGroupsResult: AWSShape {

    }

    public struct ModificationState: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "Resource", required: false, type: .enum)
        ]
        /// The modification state.
        public let state: ModificationStateEnum?
        /// The resource.
        public let resource: ModificationResourceEnum?

        public init(state: ModificationStateEnum? = nil, resource: ModificationResourceEnum? = nil) {
            self.state = state
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case resource = "Resource"
        }
    }

    public struct DescribeWorkspaceDirectoriesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Directories", required: false, type: .list)
        ]
        /// The token to use to retrieve the next set of results, or null if there are no more results available. This token is valid for one day and must be used within that time frame.
        public let nextToken: String?
        /// Information about the directories.
        public let directories: [WorkspaceDirectory]?

        public init(nextToken: String? = nil, directories: [WorkspaceDirectory]? = nil) {
            self.nextToken = nextToken
            self.directories = directories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case directories = "Directories"
        }
    }

    public struct DeleteIpGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupId", required: true, type: .string)
        ]
        /// The ID of the IP access control group.
        public let groupId: String

        public init(groupId: String) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
        }
    }

    public enum Compute: String, CustomStringConvertible, Codable {
        case value = "VALUE"
        case standard = "STANDARD"
        case performance = "PERFORMANCE"
        case power = "POWER"
        case graphics = "GRAPHICS"
        public var description: String { return self.rawValue }
    }

    public struct DescribeTagsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagList", required: false, type: .list)
        ]
        /// The tags.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct UpdateRulesOfIpGroupResult: AWSShape {

    }

    public struct TerminateWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedRequests", required: false, type: .list)
        ]
        /// Information about the WorkSpaces that could not be terminated.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "FailedRequests"
        }
    }

    public struct WorkspaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: true, type: .string), 
            AWSShapeMember(label: "UserName", required: true, type: .string), 
            AWSShapeMember(label: "UserVolumeEncryptionEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "WorkspaceProperties", required: false, type: .structure), 
            AWSShapeMember(label: "DirectoryId", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "RootVolumeEncryptionEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "VolumeEncryptionKey", required: false, type: .string)
        ]
        /// The identifier of the bundle for the WorkSpace. You can use DescribeWorkspaceBundles to list the available bundles.
        public let bundleId: String
        /// The username of the user for the WorkSpace. This username must exist in the AWS Directory Service directory for the WorkSpace.
        public let userName: String
        /// Indicates whether the data stored on the user volume is encrypted.
        public let userVolumeEncryptionEnabled: Bool?
        /// The WorkSpace properties.
        public let workspaceProperties: WorkspaceProperties?
        /// The identifier of the AWS Directory Service directory for the WorkSpace. You can use DescribeWorkspaceDirectories to list the available directories.
        public let directoryId: String
        /// The tags for the WorkSpace.
        public let tags: [Tag]?
        /// Indicates whether the data stored on the root volume is encrypted.
        public let rootVolumeEncryptionEnabled: Bool?
        /// The KMS key used to encrypt data stored on your WorkSpace.
        public let volumeEncryptionKey: String?

        public init(bundleId: String, userName: String, userVolumeEncryptionEnabled: Bool? = nil, workspaceProperties: WorkspaceProperties? = nil, directoryId: String, tags: [Tag]? = nil, rootVolumeEncryptionEnabled: Bool? = nil, volumeEncryptionKey: String? = nil) {
            self.bundleId = bundleId
            self.userName = userName
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.workspaceProperties = workspaceProperties
            self.directoryId = directoryId
            self.tags = tags
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.volumeEncryptionKey = volumeEncryptionKey
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case userName = "UserName"
            case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
            case workspaceProperties = "WorkspaceProperties"
            case directoryId = "DirectoryId"
            case tags = "Tags"
            case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
            case volumeEncryptionKey = "VolumeEncryptionKey"
        }
    }

    public struct DeleteTagsResult: AWSShape {

    }

    public struct WorkspaceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RootVolumeSizeGib", required: false, type: .integer), 
            AWSShapeMember(label: "ComputeTypeName", required: false, type: .enum), 
            AWSShapeMember(label: "RunningMode", required: false, type: .enum), 
            AWSShapeMember(label: "RunningModeAutoStopTimeoutInMinutes", required: false, type: .integer), 
            AWSShapeMember(label: "UserVolumeSizeGib", required: false, type: .integer)
        ]
        /// The size of the root volume.
        public let rootVolumeSizeGib: Int32?
        /// The compute type. For more information, see Amazon WorkSpaces Bundles.
        public let computeTypeName: Compute?
        /// The running mode. For more information, see Manage the WorkSpace Running Mode.
        public let runningMode: RunningMode?
        /// The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60 minute intervals.
        public let runningModeAutoStopTimeoutInMinutes: Int32?
        /// The size of the user storage.
        public let userVolumeSizeGib: Int32?

        public init(rootVolumeSizeGib: Int32? = nil, computeTypeName: Compute? = nil, runningMode: RunningMode? = nil, runningModeAutoStopTimeoutInMinutes: Int32? = nil, userVolumeSizeGib: Int32? = nil) {
            self.rootVolumeSizeGib = rootVolumeSizeGib
            self.computeTypeName = computeTypeName
            self.runningMode = runningMode
            self.runningModeAutoStopTimeoutInMinutes = runningModeAutoStopTimeoutInMinutes
            self.userVolumeSizeGib = userVolumeSizeGib
        }

        private enum CodingKeys: String, CodingKey {
            case rootVolumeSizeGib = "RootVolumeSizeGib"
            case computeTypeName = "ComputeTypeName"
            case runningMode = "RunningMode"
            case runningModeAutoStopTimeoutInMinutes = "RunningModeAutoStopTimeoutInMinutes"
            case userVolumeSizeGib = "UserVolumeSizeGib"
        }
    }

    public struct AssociateIpGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupIds", required: true, type: .list), 
            AWSShapeMember(label: "DirectoryId", required: true, type: .string)
        ]
        /// The IDs of one or more IP access control groups.
        public let groupIds: [String]
        /// The ID of the directory.
        public let directoryId: String

        public init(groupIds: [String], directoryId: String) {
            self.groupIds = groupIds
            self.directoryId = directoryId
        }

        private enum CodingKeys: String, CodingKey {
            case groupIds = "GroupIds"
            case directoryId = "DirectoryId"
        }
    }

    public struct UserStorage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Capacity", required: false, type: .string)
        ]
        /// The size of the user storage.
        public let capacity: String?

        public init(capacity: String? = nil) {
            self.capacity = capacity
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "Capacity"
        }
    }

    public struct DefaultWorkspaceCreationProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserEnabledAsLocalAdministrator", required: false, type: .boolean), 
            AWSShapeMember(label: "EnableWorkDocs", required: false, type: .boolean), 
            AWSShapeMember(label: "CustomSecurityGroupId", required: false, type: .string), 
            AWSShapeMember(label: "DefaultOu", required: false, type: .string), 
            AWSShapeMember(label: "EnableInternetAccess", required: false, type: .boolean)
        ]
        /// Indicates whether the WorkSpace user is an administrator on the WorkSpace.
        public let userEnabledAsLocalAdministrator: Bool?
        /// Indicates whether the directory is enabled for Amazon WorkDocs.
        public let enableWorkDocs: Bool?
        /// The identifier of any security groups to apply to WorkSpaces when they are created.
        public let customSecurityGroupId: String?
        /// The organizational unit (OU) in the directory for the WorkSpace machine accounts.
        public let defaultOu: String?
        /// The public IP address to attach to all WorkSpaces that are created or rebuilt.
        public let enableInternetAccess: Bool?

        public init(userEnabledAsLocalAdministrator: Bool? = nil, enableWorkDocs: Bool? = nil, customSecurityGroupId: String? = nil, defaultOu: String? = nil, enableInternetAccess: Bool? = nil) {
            self.userEnabledAsLocalAdministrator = userEnabledAsLocalAdministrator
            self.enableWorkDocs = enableWorkDocs
            self.customSecurityGroupId = customSecurityGroupId
            self.defaultOu = defaultOu
            self.enableInternetAccess = enableInternetAccess
        }

        private enum CodingKeys: String, CodingKey {
            case userEnabledAsLocalAdministrator = "UserEnabledAsLocalAdministrator"
            case enableWorkDocs = "EnableWorkDocs"
            case customSecurityGroupId = "CustomSecurityGroupId"
            case defaultOu = "DefaultOu"
            case enableInternetAccess = "EnableInternetAccess"
        }
    }

    public struct WorkspaceConnectionStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionState", required: false, type: .enum), 
            AWSShapeMember(label: "WorkspaceId", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionStateCheckTimestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "LastKnownUserConnectionTimestamp", required: false, type: .timestamp)
        ]
        /// The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.
        public let connectionState: ConnectionState?
        /// The ID of the WorkSpace.
        public let workspaceId: String?
        /// The timestamp of the connection state check.
        public let connectionStateCheckTimestamp: TimeStamp?
        /// The timestamp of the last known user connection.
        public let lastKnownUserConnectionTimestamp: TimeStamp?

        public init(connectionState: ConnectionState? = nil, workspaceId: String? = nil, connectionStateCheckTimestamp: TimeStamp? = nil, lastKnownUserConnectionTimestamp: TimeStamp? = nil) {
            self.connectionState = connectionState
            self.workspaceId = workspaceId
            self.connectionStateCheckTimestamp = connectionStateCheckTimestamp
            self.lastKnownUserConnectionTimestamp = lastKnownUserConnectionTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case connectionState = "ConnectionState"
            case workspaceId = "WorkspaceId"
            case connectionStateCheckTimestamp = "ConnectionStateCheckTimestamp"
            case lastKnownUserConnectionTimestamp = "LastKnownUserConnectionTimestamp"
        }
    }

    public enum WorkspaceDirectoryState: String, CustomStringConvertible, Codable {
        case registering = "REGISTERING"
        case registered = "REGISTERED"
        case deregistering = "DEREGISTERING"
        case deregistered = "DEREGISTERED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public struct ModifyWorkspaceStateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: true, type: .string), 
            AWSShapeMember(label: "WorkspaceState", required: true, type: .enum)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String
        /// The WorkSpace state.
        public let workspaceState: TargetWorkspaceState

        public init(workspaceId: String, workspaceState: TargetWorkspaceState) {
            self.workspaceId = workspaceId
            self.workspaceState = workspaceState
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
            case workspaceState = "WorkspaceState"
        }
    }

    public struct WorkspacesIpGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "groupName", required: false, type: .string), 
            AWSShapeMember(label: "userRules", required: false, type: .list), 
            AWSShapeMember(label: "groupDesc", required: false, type: .string), 
            AWSShapeMember(label: "groupId", required: false, type: .string)
        ]
        /// The name of the group.
        public let groupName: String?
        /// The rules.
        public let userRules: [IpRuleItem]?
        /// The description of the group.
        public let groupDesc: String?
        /// The ID of the group.
        public let groupId: String?

        public init(groupName: String? = nil, userRules: [IpRuleItem]? = nil, groupDesc: String? = nil, groupId: String? = nil) {
            self.groupName = groupName
            self.userRules = userRules
            self.groupDesc = groupDesc
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "groupName"
            case userRules = "userRules"
            case groupDesc = "groupDesc"
            case groupId = "groupId"
        }
    }

    public struct DescribeIpGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "GroupIds", required: false, type: .list)
        ]
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?
        /// The maximum number of items to return.
        public let maxResults: Int32?
        /// The IDs of one or more IP access control groups.
        public let groupIds: [String]?

        public init(nextToken: String? = nil, maxResults: Int32? = nil, groupIds: [String]? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
            self.groupIds = groupIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case maxResults = "MaxResults"
            case groupIds = "GroupIds"
        }
    }

    public struct DescribeWorkspaceDirectoriesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DirectoryIds", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]
        /// The identifiers of the directories. If the value is null, all directories are retrieved.
        public let directoryIds: [String]?
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?

        public init(directoryIds: [String]? = nil, nextToken: String? = nil) {
            self.directoryIds = directoryIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case directoryIds = "DirectoryIds"
            case nextToken = "NextToken"
        }
    }

    public enum WorkspaceDirectoryType: String, CustomStringConvertible, Codable {
        case simpleAd = "SIMPLE_AD"
        case adConnector = "AD_CONNECTOR"
        public var description: String { return self.rawValue }
    }

    public struct RebuildWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedRequests", required: false, type: .list)
        ]
        /// Information about the WorkSpace if it could not be rebuilt.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "FailedRequests"
        }
    }

    public struct RootStorage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Capacity", required: false, type: .string)
        ]
        /// The size of the root volume.
        public let capacity: String?

        public init(capacity: String? = nil) {
            self.capacity = capacity
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "Capacity"
        }
    }

    public struct FailedCreateWorkspaceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceRequest", required: false, type: .structure), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string)
        ]
        /// Information about the WorkSpace.
        public let workspaceRequest: WorkspaceRequest?
        /// The error code.
        public let errorCode: String?
        /// The textual error message.
        public let errorMessage: String?

        public init(workspaceRequest: WorkspaceRequest? = nil, errorCode: String? = nil, errorMessage: String? = nil) {
            self.workspaceRequest = workspaceRequest
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceRequest = "WorkspaceRequest"
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct StopRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: false, type: .string)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String?

        public init(workspaceId: String? = nil) {
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]
        /// The key of the tag.
        public let key: String
        /// The value of the tag.
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct DeleteTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceId", required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", required: true, type: .list)
        ]
        /// The ID of the WorkSpace. To find this ID, use DescribeWorkspaces.
        public let resourceId: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceId: String, tagKeys: [String]) {
            self.resourceId = resourceId
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case tagKeys = "TagKeys"
        }
    }

    public struct CreateTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceId", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]
        /// The ID of the WorkSpace. To find this ID, use DescribeWorkspaces.
        public let resourceId: String
        /// The tags. Each WorkSpace can have a maximum of 50 tags.
        public let tags: [Tag]

        public init(resourceId: String, tags: [Tag]) {
            self.resourceId = resourceId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case tags = "Tags"
        }
    }

    public struct DescribeWorkspacesConnectionStatusRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "WorkspaceIds", required: false, type: .list)
        ]
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?
        /// The identifiers of the WorkSpaces. You can specify up to 25 WorkSpaces.
        public let workspaceIds: [String]?

        public init(nextToken: String? = nil, workspaceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.workspaceIds = workspaceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workspaceIds = "WorkspaceIds"
        }
    }

    public struct WorkspaceDirectory: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceSecurityGroupId", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryName", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "WorkspaceCreationProperties", required: false, type: .structure), 
            AWSShapeMember(label: "CustomerUserName", required: false, type: .string), 
            AWSShapeMember(label: "RegistrationCode", required: false, type: .string), 
            AWSShapeMember(label: "SubnetIds", required: false, type: .list), 
            AWSShapeMember(label: "IamRoleId", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryId", required: false, type: .string), 
            AWSShapeMember(label: "Alias", required: false, type: .string), 
            AWSShapeMember(label: "DirectoryType", required: false, type: .enum), 
            AWSShapeMember(label: "DnsIpAddresses", required: false, type: .list), 
            AWSShapeMember(label: "ipGroupIds", required: false, type: .list)
        ]
        /// The identifier of the security group that is assigned to new WorkSpaces.
        public let workspaceSecurityGroupId: String?
        /// The name of the directory.
        public let directoryName: String?
        /// The state of the directory's registration with Amazon WorkSpaces
        public let state: WorkspaceDirectoryState?
        /// The default creation properties for all WorkSpaces in the directory.
        public let workspaceCreationProperties: DefaultWorkspaceCreationProperties?
        /// The user name for the service account.
        public let customerUserName: String?
        /// The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.
        public let registrationCode: String?
        /// The identifiers of the subnets used with the directory.
        public let subnetIds: [String]?
        /// The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.
        public let iamRoleId: String?
        /// The directory identifier.
        public let directoryId: String?
        /// The directory alias.
        public let alias: String?
        /// The directory type.
        public let directoryType: WorkspaceDirectoryType?
        /// The IP addresses of the DNS servers for the directory.
        public let dnsIpAddresses: [String]?
        /// The identifiers of the IP access control groups associated with the directory.
        public let ipGroupIds: [String]?

        public init(workspaceSecurityGroupId: String? = nil, directoryName: String? = nil, state: WorkspaceDirectoryState? = nil, workspaceCreationProperties: DefaultWorkspaceCreationProperties? = nil, customerUserName: String? = nil, registrationCode: String? = nil, subnetIds: [String]? = nil, iamRoleId: String? = nil, directoryId: String? = nil, alias: String? = nil, directoryType: WorkspaceDirectoryType? = nil, dnsIpAddresses: [String]? = nil, ipGroupIds: [String]? = nil) {
            self.workspaceSecurityGroupId = workspaceSecurityGroupId
            self.directoryName = directoryName
            self.state = state
            self.workspaceCreationProperties = workspaceCreationProperties
            self.customerUserName = customerUserName
            self.registrationCode = registrationCode
            self.subnetIds = subnetIds
            self.iamRoleId = iamRoleId
            self.directoryId = directoryId
            self.alias = alias
            self.directoryType = directoryType
            self.dnsIpAddresses = dnsIpAddresses
            self.ipGroupIds = ipGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceSecurityGroupId = "WorkspaceSecurityGroupId"
            case directoryName = "DirectoryName"
            case state = "State"
            case workspaceCreationProperties = "WorkspaceCreationProperties"
            case customerUserName = "CustomerUserName"
            case registrationCode = "RegistrationCode"
            case subnetIds = "SubnetIds"
            case iamRoleId = "IamRoleId"
            case directoryId = "DirectoryId"
            case alias = "Alias"
            case directoryType = "DirectoryType"
            case dnsIpAddresses = "DnsIpAddresses"
            case ipGroupIds = "ipGroupIds"
        }
    }

    public struct DescribeWorkspaceBundlesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "BundleIds", required: false, type: .list), 
            AWSShapeMember(label: "Owner", required: false, type: .string)
        ]
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?
        /// The IDs of the bundles. This parameter cannot be combined with any other filter.
        public let bundleIds: [String]?
        /// The owner of the bundles. This parameter cannot be combined with any other filter. Specify AMAZON to describe the bundles provided by AWS or null to describe the bundles that belong to your account.
        public let owner: String?

        public init(nextToken: String? = nil, bundleIds: [String]? = nil, owner: String? = nil) {
            self.nextToken = nextToken
            self.bundleIds = bundleIds
            self.owner = owner
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case bundleIds = "BundleIds"
            case owner = "Owner"
        }
    }

    public struct CreateWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedRequests", required: false, type: .list), 
            AWSShapeMember(label: "PendingRequests", required: false, type: .list)
        ]
        /// Information about the WorkSpaces that could not be created.
        public let failedRequests: [FailedCreateWorkspaceRequest]?
        /// Information about the WorkSpaces that were created. Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call DescribeWorkspaces before the WorkSpace is created, the information returned can be incomplete.
        public let pendingRequests: [Workspace]?

        public init(failedRequests: [FailedCreateWorkspaceRequest]? = nil, pendingRequests: [Workspace]? = nil) {
            self.failedRequests = failedRequests
            self.pendingRequests = pendingRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "FailedRequests"
            case pendingRequests = "PendingRequests"
        }
    }

    public struct DisassociateIpGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupIds", required: true, type: .list), 
            AWSShapeMember(label: "DirectoryId", required: true, type: .string)
        ]
        /// The IDs of one or more IP access control groups.
        public let groupIds: [String]
        /// The ID of the directory.
        public let directoryId: String

        public init(groupIds: [String], directoryId: String) {
            self.groupIds = groupIds
            self.directoryId = directoryId
        }

        private enum CodingKeys: String, CodingKey {
            case groupIds = "GroupIds"
            case directoryId = "DirectoryId"
        }
    }

    public struct StopWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedRequests", required: false, type: .list)
        ]
        /// Information about the WorkSpaces that could not be stopped.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "FailedRequests"
        }
    }

    public struct RebootWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RebootWorkspaceRequests", required: true, type: .list)
        ]
        /// The WorkSpaces to reboot. You can specify up to 25 WorkSpaces.
        public let rebootWorkspaceRequests: [RebootRequest]

        public init(rebootWorkspaceRequests: [RebootRequest]) {
            self.rebootWorkspaceRequests = rebootWorkspaceRequests
        }

        private enum CodingKeys: String, CodingKey {
            case rebootWorkspaceRequests = "RebootWorkspaceRequests"
        }
    }

    public enum ModificationStateEnum: String, CustomStringConvertible, Codable {
        case updateInitiated = "UPDATE_INITIATED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public struct TerminateRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: true, type: .string)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
        }
    }

    public enum ConnectionState: String, CustomStringConvertible, Codable {
        case connected = "CONNECTED"
        case disconnected = "DISCONNECTED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public struct CreateIpGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupId", required: false, type: .string)
        ]
        /// The ID of the group.
        public let groupId: String?

        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
        }
    }

    public struct ModifyWorkspaceStateResult: AWSShape {

    }

    public struct RebuildWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RebuildWorkspaceRequests", required: true, type: .list)
        ]
        /// The WorkSpace to rebuild. You can specify a single WorkSpace.
        public let rebuildWorkspaceRequests: [RebuildRequest]

        public init(rebuildWorkspaceRequests: [RebuildRequest]) {
            self.rebuildWorkspaceRequests = rebuildWorkspaceRequests
        }

        private enum CodingKeys: String, CodingKey {
            case rebuildWorkspaceRequests = "RebuildWorkspaceRequests"
        }
    }

    public struct ComputeType: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .enum)
        ]
        /// The compute type.
        public let name: Compute?

        public init(name: Compute? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct TerminateWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TerminateWorkspaceRequests", required: true, type: .list)
        ]
        /// The WorkSpaces to terminate. You can specify up to 25 WorkSpaces.
        public let terminateWorkspaceRequests: [TerminateRequest]

        public init(terminateWorkspaceRequests: [TerminateRequest]) {
            self.terminateWorkspaceRequests = terminateWorkspaceRequests
        }

        private enum CodingKeys: String, CodingKey {
            case terminateWorkspaceRequests = "TerminateWorkspaceRequests"
        }
    }

    public enum RunningMode: String, CustomStringConvertible, Codable {
        case autoStop = "AUTO_STOP"
        case alwaysOn = "ALWAYS_ON"
        public var description: String { return self.rawValue }
    }

    public struct WorkspaceBundle: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "RootStorage", required: false, type: .structure), 
            AWSShapeMember(label: "UserStorage", required: false, type: .structure), 
            AWSShapeMember(label: "Owner", required: false, type: .string), 
            AWSShapeMember(label: "ComputeType", required: false, type: .structure), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Description", required: false, type: .string)
        ]
        /// The bundle identifier.
        public let bundleId: String?
        /// The size of the root volume.
        public let rootStorage: RootStorage?
        /// The size of the user storage.
        public let userStorage: UserStorage?
        /// The owner of the bundle. This is the account identifier of the owner, or AMAZON if the bundle is provided by AWS.
        public let owner: String?
        /// The compute type. For more information, see Amazon WorkSpaces Bundles.
        public let computeType: ComputeType?
        /// The name of the bundle.
        public let name: String?
        /// A description.
        public let description: String?

        public init(bundleId: String? = nil, rootStorage: RootStorage? = nil, userStorage: UserStorage? = nil, owner: String? = nil, computeType: ComputeType? = nil, name: String? = nil, description: String? = nil) {
            self.bundleId = bundleId
            self.rootStorage = rootStorage
            self.userStorage = userStorage
            self.owner = owner
            self.computeType = computeType
            self.name = name
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case bundleId = "BundleId"
            case rootStorage = "RootStorage"
            case userStorage = "UserStorage"
            case owner = "Owner"
            case computeType = "ComputeType"
            case name = "Name"
            case description = "Description"
        }
    }

    public struct CreateIpGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserRules", required: false, type: .list), 
            AWSShapeMember(label: "GroupDesc", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: true, type: .string)
        ]
        /// The rules to add to the group.
        public let userRules: [IpRuleItem]?
        /// The description of the group.
        public let groupDesc: String?
        /// The name of the group.
        public let groupName: String

        public init(userRules: [IpRuleItem]? = nil, groupDesc: String? = nil, groupName: String) {
            self.userRules = userRules
            self.groupDesc = groupDesc
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case userRules = "UserRules"
            case groupDesc = "GroupDesc"
            case groupName = "GroupName"
        }
    }

    public struct CreateWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Workspaces", required: true, type: .list)
        ]
        /// The WorkSpaces to create. You can specify up to 25 WorkSpaces.
        public let workspaces: [WorkspaceRequest]

        public init(workspaces: [WorkspaceRequest]) {
            self.workspaces = workspaces
        }

        private enum CodingKeys: String, CodingKey {
            case workspaces = "Workspaces"
        }
    }

    public struct StartRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "WorkspaceId", required: false, type: .string)
        ]
        /// The ID of the WorkSpace.
        public let workspaceId: String?

        public init(workspaceId: String? = nil) {
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceId = "WorkspaceId"
        }
    }

    public struct UpdateRulesOfIpGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupId", required: true, type: .string), 
            AWSShapeMember(label: "UserRules", required: true, type: .list)
        ]
        /// The ID of the group.
        public let groupId: String
        /// One or more rules.
        public let userRules: [IpRuleItem]

        public init(groupId: String, userRules: [IpRuleItem]) {
            self.groupId = groupId
            self.userRules = userRules
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case userRules = "UserRules"
        }
    }

    public struct ModifyWorkspacePropertiesResult: AWSShape {

    }

    public enum TargetWorkspaceState: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case adminMaintenance = "ADMIN_MAINTENANCE"
        public var description: String { return self.rawValue }
    }

    public struct StartWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StartWorkspaceRequests", required: true, type: .list)
        ]
        /// The WorkSpaces to start. You can specify up to 25 WorkSpaces.
        public let startWorkspaceRequests: [StartRequest]

        public init(startWorkspaceRequests: [StartRequest]) {
            self.startWorkspaceRequests = startWorkspaceRequests
        }

        private enum CodingKeys: String, CodingKey {
            case startWorkspaceRequests = "StartWorkspaceRequests"
        }
    }

    public enum ModificationResourceEnum: String, CustomStringConvertible, Codable {
        case rootVolume = "ROOT_VOLUME"
        case userVolume = "USER_VOLUME"
        case computeType = "COMPUTE_TYPE"
        public var description: String { return self.rawValue }
    }

    public struct StartWorkspacesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FailedRequests", required: false, type: .list)
        ]
        /// Information about the WorkSpaces that could not be started.
        public let failedRequests: [FailedWorkspaceChangeRequest]?

        public init(failedRequests: [FailedWorkspaceChangeRequest]? = nil) {
            self.failedRequests = failedRequests
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequests = "FailedRequests"
        }
    }

    public enum WorkspaceState: String, CustomStringConvertible, Codable {
        case pending = "PENDING"
        case available = "AVAILABLE"
        case impaired = "IMPAIRED"
        case unhealthy = "UNHEALTHY"
        case rebooting = "REBOOTING"
        case starting = "STARTING"
        case rebuilding = "REBUILDING"
        case maintenance = "MAINTENANCE"
        case adminMaintenance = "ADMIN_MAINTENANCE"
        case terminating = "TERMINATING"
        case terminated = "TERMINATED"
        case suspended = "SUSPENDED"
        case updating = "UPDATING"
        case stopping = "STOPPING"
        case stopped = "STOPPED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public struct StopWorkspacesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "StopWorkspaceRequests", required: true, type: .list)
        ]
        /// The WorkSpaces to stop. You can specify up to 25 WorkSpaces.
        public let stopWorkspaceRequests: [StopRequest]

        public init(stopWorkspaceRequests: [StopRequest]) {
            self.stopWorkspaceRequests = stopWorkspaceRequests
        }

        private enum CodingKeys: String, CodingKey {
            case stopWorkspaceRequests = "StopWorkspaceRequests"
        }
    }

    public struct DescribeTagsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceId", required: true, type: .string)
        ]
        /// The ID of the WorkSpace. To find this ID, use DescribeWorkspaces.
        public let resourceId: String

        public init(resourceId: String) {
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
        }
    }

    public struct AuthorizeIpRulesResult: AWSShape {

    }

    public struct Workspace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UserName", required: false, type: .string), 
            AWSShapeMember(label: "BundleId", required: false, type: .string), 
            AWSShapeMember(label: "State", required: false, type: .enum), 
            AWSShapeMember(label: "WorkspaceId", required: false, type: .string), 
            AWSShapeMember(label: "VolumeEncryptionKey", required: false, type: .string), 
            AWSShapeMember(label: "ModificationStates", required: false, type: .list), 
            AWSShapeMember(label: "IpAddress", required: false, type: .string), 
            AWSShapeMember(label: "RootVolumeEncryptionEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "DirectoryId", required: false, type: .string), 
            AWSShapeMember(label: "ComputerName", required: false, type: .string), 
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "SubnetId", required: false, type: .string), 
            AWSShapeMember(label: "ErrorMessage", required: false, type: .string), 
            AWSShapeMember(label: "UserVolumeEncryptionEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "WorkspaceProperties", required: false, type: .structure)
        ]
        /// The user for the WorkSpace.
        public let userName: String?
        /// The identifier of the bundle used to create the WorkSpace.
        public let bundleId: String?
        /// The operational state of the WorkSpace.
        public let state: WorkspaceState?
        /// The identifier of the WorkSpace.
        public let workspaceId: String?
        /// The KMS key used to encrypt data stored on your WorkSpace.
        public let volumeEncryptionKey: String?
        /// The modification states of the WorkSpace.
        public let modificationStates: [ModificationState]?
        /// The IP address of the WorkSpace.
        public let ipAddress: String?
        /// Indicates whether the data stored on the root volume is encrypted.
        public let rootVolumeEncryptionEnabled: Bool?
        /// The identifier of the AWS Directory Service directory for the WorkSpace.
        public let directoryId: String?
        /// The name of the WorkSpace, as seen by the operating system.
        public let computerName: String?
        /// If the WorkSpace could not be created, contains the error code.
        public let errorCode: String?
        /// The identifier of the subnet for the WorkSpace.
        public let subnetId: String?
        /// If the WorkSpace could not be created, contains a textual error message that describes the failure.
        public let errorMessage: String?
        /// Indicates whether the data stored on the user volume is encrypted.
        public let userVolumeEncryptionEnabled: Bool?
        /// The properties of the WorkSpace.
        public let workspaceProperties: WorkspaceProperties?

        public init(userName: String? = nil, bundleId: String? = nil, state: WorkspaceState? = nil, workspaceId: String? = nil, volumeEncryptionKey: String? = nil, modificationStates: [ModificationState]? = nil, ipAddress: String? = nil, rootVolumeEncryptionEnabled: Bool? = nil, directoryId: String? = nil, computerName: String? = nil, errorCode: String? = nil, subnetId: String? = nil, errorMessage: String? = nil, userVolumeEncryptionEnabled: Bool? = nil, workspaceProperties: WorkspaceProperties? = nil) {
            self.userName = userName
            self.bundleId = bundleId
            self.state = state
            self.workspaceId = workspaceId
            self.volumeEncryptionKey = volumeEncryptionKey
            self.modificationStates = modificationStates
            self.ipAddress = ipAddress
            self.rootVolumeEncryptionEnabled = rootVolumeEncryptionEnabled
            self.directoryId = directoryId
            self.computerName = computerName
            self.errorCode = errorCode
            self.subnetId = subnetId
            self.errorMessage = errorMessage
            self.userVolumeEncryptionEnabled = userVolumeEncryptionEnabled
            self.workspaceProperties = workspaceProperties
        }

        private enum CodingKeys: String, CodingKey {
            case userName = "UserName"
            case bundleId = "BundleId"
            case state = "State"
            case workspaceId = "WorkspaceId"
            case volumeEncryptionKey = "VolumeEncryptionKey"
            case modificationStates = "ModificationStates"
            case ipAddress = "IpAddress"
            case rootVolumeEncryptionEnabled = "RootVolumeEncryptionEnabled"
            case directoryId = "DirectoryId"
            case computerName = "ComputerName"
            case errorCode = "ErrorCode"
            case subnetId = "SubnetId"
            case errorMessage = "ErrorMessage"
            case userVolumeEncryptionEnabled = "UserVolumeEncryptionEnabled"
            case workspaceProperties = "WorkspaceProperties"
        }
    }

}