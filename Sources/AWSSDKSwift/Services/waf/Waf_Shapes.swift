// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Waf {

    public enum ChangeAction: String, CustomStringConvertible, Codable {
        case insert = "INSERT"
        case delete = "DELETE"
        public var description: String { return self.rawValue }
    }

    public struct UpdateSqlInjectionMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "SqlInjectionMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Updates", required: true, type: .list)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The SqlInjectionMatchSetId of the SqlInjectionMatchSet that you want to update. SqlInjectionMatchSetId is returned by CreateSqlInjectionMatchSet and by ListSqlInjectionMatchSets.
        public let sqlInjectionMatchSetId: String
        /// An array of SqlInjectionMatchSetUpdate objects that you want to insert into or delete from a SqlInjectionMatchSet. For more information, see the applicable data types:    SqlInjectionMatchSetUpdate: Contains Action and SqlInjectionMatchTuple     SqlInjectionMatchTuple: Contains FieldToMatch and TextTransformation     FieldToMatch: Contains Data and Type   
        public let updates: [SqlInjectionMatchSetUpdate]

        public init(changeToken: String, sqlInjectionMatchSetId: String, updates: [SqlInjectionMatchSetUpdate]) {
            self.changeToken = changeToken
            self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
            self.updates = updates
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
            case updates = "Updates"
        }
    }

    public struct Rule: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: false, type: .string), 
            AWSShapeMember(label: "RuleId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Predicates", required: true, type: .list)
        ]
        /// A friendly name or description for the metrics for this Rule. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change MetricName after you create the Rule.
        public let metricName: String?
        /// A unique identifier for a Rule. You use RuleId to get more information about a Rule (see GetRule), update a Rule (see UpdateRule), insert a Rule into a WebACL or delete a one from a WebACL (see UpdateWebACL), or delete a Rule from AWS WAF (see DeleteRule).  RuleId is returned by CreateRule and by ListRules.
        public let ruleId: String
        /// The friendly name or description for the Rule. You can't change the name of a Rule after you create it.
        public let name: String?
        /// The Predicates object contains one Predicate element for each ByteMatchSet, IPSet, or SqlInjectionMatchSet object that you want to include in a Rule.
        public let predicates: [Predicate]

        public init(metricName: String? = nil, ruleId: String, name: String? = nil, predicates: [Predicate]) {
            self.metricName = metricName
            self.ruleId = ruleId
            self.name = name
            self.predicates = predicates
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case ruleId = "RuleId"
            case name = "Name"
            case predicates = "Predicates"
        }
    }

    public struct UpdateSizeConstraintSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Updates", required: true, type: .list), 
            AWSShapeMember(label: "SizeConstraintSetId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// An array of SizeConstraintSetUpdate objects that you want to insert into or delete from a SizeConstraintSet. For more information, see the applicable data types:    SizeConstraintSetUpdate: Contains Action and SizeConstraint     SizeConstraint: Contains FieldToMatch, TextTransformation, ComparisonOperator, and Size     FieldToMatch: Contains Data and Type   
        public let updates: [SizeConstraintSetUpdate]
        /// The SizeConstraintSetId of the SizeConstraintSet that you want to update. SizeConstraintSetId is returned by CreateSizeConstraintSet and by ListSizeConstraintSets.
        public let sizeConstraintSetId: String

        public init(changeToken: String, updates: [SizeConstraintSetUpdate], sizeConstraintSetId: String) {
            self.changeToken = changeToken
            self.updates = updates
            self.sizeConstraintSetId = sizeConstraintSetId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case updates = "Updates"
            case sizeConstraintSetId = "SizeConstraintSetId"
        }
    }

    public struct ActivatedRule: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Priority", required: true, type: .integer), 
            AWSShapeMember(label: "Type", required: false, type: .enum), 
            AWSShapeMember(label: "Action", required: true, type: .structure), 
            AWSShapeMember(label: "RuleId", required: true, type: .string)
        ]
        /// Specifies the order in which the Rules in a WebACL are evaluated. Rules with a lower value for Priority are evaluated before Rules with a higher value. The value must be a unique integer. If you add multiple Rules to a WebACL, the values don't need to be consecutive.
        public let priority: Int32
        /// The rule type, either REGULAR, as defined by Rule, or RATE_BASED, as defined by RateBasedRule. The default is REGULAR. Although this field is optional, be aware that if you try to add a RATE_BASED rule to a web ACL without setting the type, the UpdateWebACL request will fail because the request tries to add a REGULAR rule with the specified ID, which does not exist. 
        public let `type`: WafRuleType?
        /// Specifies the action that CloudFront or AWS WAF takes when a web request matches the conditions in the Rule. Valid values for Action include the following:    ALLOW: CloudFront responds with the requested object.    BLOCK: CloudFront responds with an HTTP 403 (Forbidden) status code.    COUNT: AWS WAF increments a counter of requests that match the conditions in the rule and then continues to inspect the web request based on the remaining rules in the web ACL.   
        public let action: WafAction
        /// The RuleId for a Rule. You use RuleId to get more information about a Rule (see GetRule), update a Rule (see UpdateRule), insert a Rule into a WebACL or delete a one from a WebACL (see UpdateWebACL), or delete a Rule from AWS WAF (see DeleteRule).  RuleId is returned by CreateRule and by ListRules.
        public let ruleId: String

        public init(priority: Int32, type: WafRuleType? = nil, action: WafAction, ruleId: String) {
            self.priority = priority
            self.`type` = `type`
            self.action = action
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "Priority"
            case `type` = "Type"
            case action = "Action"
            case ruleId = "RuleId"
        }
    }

    public struct ListRateBasedRulesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of Rules that you want AWS WAF to return for this request. If you have more Rules than the number that you specify for Limit, the response includes a NextMarker value that you can use to get another batch of Rules.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more Rules than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of Rules. For the second and subsequent ListRateBasedRules requests, specify the value of NextMarker from the previous response to get information about another batch of Rules.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct GetIPSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IPSetId", required: true, type: .string)
        ]
        /// The IPSetId of the IPSet that you want to get. IPSetId is returned by CreateIPSet and by ListIPSets.
        public let iPSetId: String

        public init(iPSetId: String) {
            self.iPSetId = iPSetId
        }

        private enum CodingKeys: String, CodingKey {
            case iPSetId = "IPSetId"
        }
    }

    public struct ListIPSetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of IPSet objects that you want AWS WAF to return for this request. If you have more IPSet objects than the number you specify for Limit, the response includes a NextMarker value that you can use to get another batch of IPSet objects.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more IPSets than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of IPSets. For the second and subsequent ListIPSets requests, specify the value of NextMarker from the previous response to get information about another batch of ByteMatchSets.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public enum ParameterExceptionField: String, CustomStringConvertible, Codable {
        case change_action = "CHANGE_ACTION"
        case waf_action = "WAF_ACTION"
        case predicate_type = "PREDICATE_TYPE"
        case ipset_type = "IPSET_TYPE"
        case byte_match_field_type = "BYTE_MATCH_FIELD_TYPE"
        case sql_injection_match_field_type = "SQL_INJECTION_MATCH_FIELD_TYPE"
        case byte_match_text_transformation = "BYTE_MATCH_TEXT_TRANSFORMATION"
        case byte_match_positional_constraint = "BYTE_MATCH_POSITIONAL_CONSTRAINT"
        case size_constraint_comparison_operator = "SIZE_CONSTRAINT_COMPARISON_OPERATOR"
        case rate_key = "RATE_KEY"
        case rule_type = "RULE_TYPE"
        case next_marker = "NEXT_MARKER"
        public var description: String { return self.rawValue }
    }

    public struct CreateRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string)
        ]
        /// A friendly name or description for the metrics for this Rule. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change the name of the metric after you create the Rule.
        public let metricName: String
        /// A friendly name or description of the Rule. You can't change the name of a Rule after you create it.
        public let name: String
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String

        public init(metricName: String, name: String, changeToken: String) {
            self.metricName = metricName
            self.name = name
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case changeToken = "ChangeToken"
        }
    }

    public struct IPSet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IPSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "IPSetDescriptors", required: true, type: .list)
        ]
        /// The IPSetId for an IPSet. You use IPSetId to get information about an IPSet (see GetIPSet), update an IPSet (see UpdateIPSet), insert an IPSet into a Rule or delete one from a Rule (see UpdateRule), and delete an IPSet from AWS WAF (see DeleteIPSet).  IPSetId is returned by CreateIPSet and by ListIPSets.
        public let iPSetId: String
        /// A friendly name or description of the IPSet. You can't change the name of an IPSet after you create it.
        public let name: String?
        /// The IP address type (IPV4 or IPV6) and the IP address range (in CIDR notation) that web requests originate from. If the WebACL is associated with a CloudFront distribution and the viewer did not use an HTTP proxy or a load balancer to send the request, this is the value of the c-ip field in the CloudFront access logs.
        public let iPSetDescriptors: [IPSetDescriptor]

        public init(iPSetId: String, name: String? = nil, iPSetDescriptors: [IPSetDescriptor]) {
            self.iPSetId = iPSetId
            self.name = name
            self.iPSetDescriptors = iPSetDescriptors
        }

        private enum CodingKeys: String, CodingKey {
            case iPSetId = "IPSetId"
            case name = "Name"
            case iPSetDescriptors = "IPSetDescriptors"
        }
    }

    public struct DeleteRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct WebACLSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "WebACLId", required: true, type: .string)
        ]
        /// A friendly name or description of the WebACL. You can't change the name of a WebACL after you create it.
        public let name: String
        /// A unique identifier for a WebACL. You use WebACLId to get information about a WebACL (see GetWebACL), update a WebACL (see UpdateWebACL), and delete a WebACL from AWS WAF (see DeleteWebACL).  WebACLId is returned by CreateWebACL and by ListWebACLs.
        public let webACLId: String

        public init(name: String, webACLId: String) {
            self.name = name
            self.webACLId = webACLId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case webACLId = "WebACLId"
        }
    }

    public struct CreateXssMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "XssMatchSet", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateXssMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// An XssMatchSet.
        public let xssMatchSet: XssMatchSet?

        public init(changeToken: String? = nil, xssMatchSet: XssMatchSet? = nil) {
            self.changeToken = changeToken
            self.xssMatchSet = xssMatchSet
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case xssMatchSet = "XssMatchSet"
        }
    }

    public struct UpdateIPSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateIPSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct GetByteMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ByteMatchSetId", required: true, type: .string)
        ]
        /// The ByteMatchSetId of the ByteMatchSet that you want to get. ByteMatchSetId is returned by CreateByteMatchSet and by ListByteMatchSets.
        public let byteMatchSetId: String

        public init(byteMatchSetId: String) {
            self.byteMatchSetId = byteMatchSetId
        }

        private enum CodingKeys: String, CodingKey {
            case byteMatchSetId = "ByteMatchSetId"
        }
    }

    public struct GetChangeTokenRequest: AWSShape {
        /// The key for the payload

    }

    public struct UpdateWebACLResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateWebACL request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct DeleteWebACLRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "WebACLId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The WebACLId of the WebACL that you want to delete. WebACLId is returned by CreateWebACL and by ListWebACLs.
        public let webACLId: String

        public init(changeToken: String, webACLId: String) {
            self.changeToken = changeToken
            self.webACLId = webACLId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case webACLId = "WebACLId"
        }
    }

    public struct CreateByteMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// A friendly name or description of the ByteMatchSet. You can't change Name after you create a ByteMatchSet.
        public let name: String

        public init(changeToken: String, name: String) {
            self.changeToken = changeToken
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case name = "Name"
        }
    }

    public struct TimeWindow: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]
        /// The end of the time range from which you want GetSampledRequests to return a sample of the requests that your AWS resource received. Specify the date and time in the following format: "2016-09-27T14:50Z". You can specify any time range in the previous three hours.
        public let endTime: Double
        /// The beginning of the time range from which you want GetSampledRequests to return a sample of the requests that your AWS resource received. Specify the date and time in the following format: "2016-09-27T14:50Z". You can specify any time range in the previous three hours.
        public let startTime: Double

        public init(endTime: Double, startTime: Double) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct DeleteSizeConstraintSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteSizeConstraintSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct SizeConstraintSetUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SizeConstraint", required: true, type: .structure), 
            AWSShapeMember(label: "Action", required: true, type: .enum)
        ]
        /// Specifies a constraint on the size of a part of the web request. AWS WAF uses the Size, ComparisonOperator, and FieldToMatch to build an expression in the form of "Size ComparisonOperator size in bytes of FieldToMatch". If that expression is true, the SizeConstraint is considered to match.
        public let sizeConstraint: SizeConstraint
        /// Specify INSERT to add a SizeConstraintSetUpdate to a SizeConstraintSet. Use DELETE to remove a SizeConstraintSetUpdate from a SizeConstraintSet.
        public let action: ChangeAction

        public init(sizeConstraint: SizeConstraint, action: ChangeAction) {
            self.sizeConstraint = sizeConstraint
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case sizeConstraint = "SizeConstraint"
            case action = "Action"
        }
    }

    public struct CreateRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "Rule", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// The Rule returned in the CreateRule response.
        public let rule: Rule?

        public init(changeToken: String? = nil, rule: Rule? = nil) {
            self.changeToken = changeToken
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case rule = "Rule"
        }
    }

    public struct CreateRateBasedRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "Rule", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateRateBasedRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// The RateBasedRule that is returned in the CreateRateBasedRule response.
        public let rule: RateBasedRule?

        public init(changeToken: String? = nil, rule: RateBasedRule? = nil) {
            self.changeToken = changeToken
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case rule = "Rule"
        }
    }

    public struct UpdateXssMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Updates", required: true, type: .list)
        ]
        /// The XssMatchSetId of the XssMatchSet that you want to update. XssMatchSetId is returned by CreateXssMatchSet and by ListXssMatchSets.
        public let xssMatchSetId: String
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// An array of XssMatchSetUpdate objects that you want to insert into or delete from a XssMatchSet. For more information, see the applicable data types:    XssMatchSetUpdate: Contains Action and XssMatchTuple     XssMatchTuple: Contains FieldToMatch and TextTransformation     FieldToMatch: Contains Data and Type   
        public let updates: [XssMatchSetUpdate]

        public init(xssMatchSetId: String, changeToken: String, updates: [XssMatchSetUpdate]) {
            self.xssMatchSetId = xssMatchSetId
            self.changeToken = changeToken
            self.updates = updates
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSetId = "XssMatchSetId"
            case changeToken = "ChangeToken"
            case updates = "Updates"
        }
    }

    public struct DeleteIPSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteIPSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct ListRateBasedRulesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Rules", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of RuleSummary objects.
        public let rules: [RuleSummary]?
        /// If you have more Rules than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more Rules, submit another ListRateBasedRules request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(rules: [RuleSummary]? = nil, nextMarker: String? = nil) {
            self.rules = rules
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
            case nextMarker = "NextMarker"
        }
    }

    public struct HTTPRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientIP", required: false, type: .string), 
            AWSShapeMember(label: "Headers", required: false, type: .list), 
            AWSShapeMember(label: "Country", required: false, type: .string), 
            AWSShapeMember(label: "Method", required: false, type: .string), 
            AWSShapeMember(label: "URI", required: false, type: .string), 
            AWSShapeMember(label: "HTTPVersion", required: false, type: .string)
        ]
        /// The IP address that the request originated from. If the WebACL is associated with a CloudFront distribution, this is the value of one of the following fields in CloudFront access logs:    c-ip, if the viewer did not use an HTTP proxy or a load balancer to send the request    x-forwarded-for, if the viewer did use an HTTP proxy or a load balancer to send the request  
        public let clientIP: String?
        /// A complex type that contains two values for each header in the sampled web request: the name of the header and the value of the header.
        public let headers: [HTTPHeader]?
        /// The two-letter country code for the country that the request originated from. For a current list of country codes, see the Wikipedia entry ISO 3166-1 alpha-2.
        public let country: String?
        /// The HTTP method specified in the sampled web request. CloudFront supports the following methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT. 
        public let method: String?
        /// The part of a web request that identifies the resource, for example, /images/daily-ad.jpg.
        public let uRI: String?
        /// The HTTP version specified in the sampled web request, for example, HTTP/1.1.
        public let hTTPVersion: String?

        public init(clientIP: String? = nil, headers: [HTTPHeader]? = nil, country: String? = nil, method: String? = nil, uRI: String? = nil, hTTPVersion: String? = nil) {
            self.clientIP = clientIP
            self.headers = headers
            self.country = country
            self.method = method
            self.uRI = uRI
            self.hTTPVersion = hTTPVersion
        }

        private enum CodingKeys: String, CodingKey {
            case clientIP = "ClientIP"
            case headers = "Headers"
            case country = "Country"
            case method = "Method"
            case uRI = "URI"
            case hTTPVersion = "HTTPVersion"
        }
    }

    public enum WafRuleType: String, CustomStringConvertible, Codable {
        case regular = "REGULAR"
        case rate_based = "RATE_BASED"
        public var description: String { return self.rawValue }
    }

    public struct HTTPHeader: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Value", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// The value of one of the headers in the sampled web request.
        public let value: String?
        /// The name of one of the headers in the sampled web request.
        public let name: String?

        public init(value: String? = nil, name: String? = nil) {
            self.value = value
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case name = "Name"
        }
    }

    public struct GetWebACLResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "WebACL", required: false, type: .structure)
        ]
        /// Information about the WebACL that you specified in the GetWebACL request. For more information, see the following topics:    WebACL: Contains DefaultAction, MetricName, Name, an array of Rule objects, and WebACLId     DefaultAction (Data type is WafAction): Contains Type     Rules: Contains an array of ActivatedRule objects, which contain Action, Priority, and RuleId     Action: Contains Type   
        public let webACL: WebACL?

        public init(webACL: WebACL? = nil) {
            self.webACL = webACL
        }

        private enum CodingKeys: String, CodingKey {
            case webACL = "WebACL"
        }
    }

    public struct XssMatchSetSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A unique identifier for an XssMatchSet. You use XssMatchSetId to get information about a XssMatchSet (see GetXssMatchSet), update an XssMatchSet (see UpdateXssMatchSet), insert an XssMatchSet into a Rule or delete one from a Rule (see UpdateRule), and delete an XssMatchSet from AWS WAF (see DeleteXssMatchSet).  XssMatchSetId is returned by CreateXssMatchSet and by ListXssMatchSets.
        public let xssMatchSetId: String
        /// The name of the XssMatchSet, if any, specified by Id.
        public let name: String

        public init(xssMatchSetId: String, name: String) {
            self.xssMatchSetId = xssMatchSetId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSetId = "XssMatchSetId"
            case name = "Name"
        }
    }

    public struct CreateWebACLRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: true, type: .string), 
            AWSShapeMember(label: "DefaultAction", required: true, type: .structure), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A friendly name or description for the metrics for this WebACL. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change MetricName after you create the WebACL.
        public let metricName: String
        /// The action that you want AWS WAF to take when a request doesn't match the criteria specified in any of the Rule objects that are associated with the WebACL.
        public let defaultAction: WafAction
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// A friendly name or description of the WebACL. You can't change Name after you create the WebACL.
        public let name: String

        public init(metricName: String, defaultAction: WafAction, changeToken: String, name: String) {
            self.metricName = metricName
            self.defaultAction = defaultAction
            self.changeToken = changeToken
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case defaultAction = "DefaultAction"
            case changeToken = "ChangeToken"
            case name = "Name"
        }
    }

    public struct WafAction: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum)
        ]
        /// Specifies how you want AWS WAF to respond to requests that match the settings in a Rule. Valid settings include the following:    ALLOW: AWS WAF allows requests    BLOCK: AWS WAF blocks requests    COUNT: AWS WAF increments a counter of the requests that match all of the conditions in the rule. AWS WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify COUNT for the default action for a WebACL.  
        public let `type`: WafActionType

        public init(type: WafActionType) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
        }
    }

    public struct SqlInjectionMatchSetUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: true, type: .enum), 
            AWSShapeMember(label: "SqlInjectionMatchTuple", required: true, type: .structure)
        ]
        /// Specify INSERT to add a SqlInjectionMatchSetUpdate to a SqlInjectionMatchSet. Use DELETE to remove a SqlInjectionMatchSetUpdate from a SqlInjectionMatchSet.
        public let action: ChangeAction
        /// Specifies the part of a web request that you want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header.
        public let sqlInjectionMatchTuple: SqlInjectionMatchTuple

        public init(action: ChangeAction, sqlInjectionMatchTuple: SqlInjectionMatchTuple) {
            self.action = action
            self.sqlInjectionMatchTuple = sqlInjectionMatchTuple
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case sqlInjectionMatchTuple = "SqlInjectionMatchTuple"
        }
    }

    public struct CreateSqlInjectionMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "SqlInjectionMatchSet", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateSqlInjectionMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// A SqlInjectionMatchSet.
        public let sqlInjectionMatchSet: SqlInjectionMatchSet?

        public init(changeToken: String? = nil, sqlInjectionMatchSet: SqlInjectionMatchSet? = nil) {
            self.changeToken = changeToken
            self.sqlInjectionMatchSet = sqlInjectionMatchSet
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case sqlInjectionMatchSet = "SqlInjectionMatchSet"
        }
    }

    public enum MatchFieldType: String, CustomStringConvertible, Codable {
        case uri = "URI"
        case query_string = "QUERY_STRING"
        case header = "HEADER"
        case method = "METHOD"
        case body = "BODY"
        public var description: String { return self.rawValue }
    }

    public struct GetChangeTokenResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used in the request. Use this value in a GetChangeTokenStatus request to get the current status of the request. 
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct CreateXssMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// A friendly name or description for the XssMatchSet that you're creating. You can't change Name after you create the XssMatchSet.
        public let name: String

        public init(changeToken: String, name: String) {
            self.changeToken = changeToken
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case name = "Name"
        }
    }

    public struct RuleSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A unique identifier for a Rule. You use RuleId to get more information about a Rule (see GetRule), update a Rule (see UpdateRule), insert a Rule into a WebACL or delete one from a WebACL (see UpdateWebACL), or delete a Rule from AWS WAF (see DeleteRule).  RuleId is returned by CreateRule and by ListRules.
        public let ruleId: String
        /// A friendly name or description of the Rule. You can't change the name of a Rule after you create it.
        public let name: String

        public init(ruleId: String, name: String) {
            self.ruleId = ruleId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
            case name = "Name"
        }
    }

    public struct GetSizeConstraintSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SizeConstraintSet", required: false, type: .structure)
        ]
        /// Information about the SizeConstraintSet that you specified in the GetSizeConstraintSet request. For more information, see the following topics:    SizeConstraintSet: Contains SizeConstraintSetId, SizeConstraints, and Name     SizeConstraints: Contains an array of SizeConstraint objects. Each SizeConstraint object contains FieldToMatch, TextTransformation, ComparisonOperator, and Size     FieldToMatch: Contains Data and Type   
        public let sizeConstraintSet: SizeConstraintSet?

        public init(sizeConstraintSet: SizeConstraintSet? = nil) {
            self.sizeConstraintSet = sizeConstraintSet
        }

        private enum CodingKeys: String, CodingKey {
            case sizeConstraintSet = "SizeConstraintSet"
        }
    }

    public struct XssMatchSetUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchTuple", required: true, type: .structure), 
            AWSShapeMember(label: "Action", required: true, type: .enum)
        ]
        /// Specifies the part of a web request that you want AWS WAF to inspect for cross-site scripting attacks and, if you want AWS WAF to inspect a header, the name of the header.
        public let xssMatchTuple: XssMatchTuple
        /// Specify INSERT to add a XssMatchSetUpdate to an XssMatchSet. Use DELETE to remove a XssMatchSetUpdate from an XssMatchSet.
        public let action: ChangeAction

        public init(xssMatchTuple: XssMatchTuple, action: ChangeAction) {
            self.xssMatchTuple = xssMatchTuple
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchTuple = "XssMatchTuple"
            case action = "Action"
        }
    }

    public struct ListSqlInjectionMatchSetsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextMarker", required: false, type: .string), 
            AWSShapeMember(label: "SqlInjectionMatchSets", required: false, type: .list)
        ]
        /// If you have more SqlInjectionMatchSet objects than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more SqlInjectionMatchSet objects, submit another ListSqlInjectionMatchSets request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?
        /// An array of SqlInjectionMatchSetSummary objects.
        public let sqlInjectionMatchSets: [SqlInjectionMatchSetSummary]?

        public init(nextMarker: String? = nil, sqlInjectionMatchSets: [SqlInjectionMatchSetSummary]? = nil) {
            self.nextMarker = nextMarker
            self.sqlInjectionMatchSets = sqlInjectionMatchSets
        }

        private enum CodingKeys: String, CodingKey {
            case nextMarker = "NextMarker"
            case sqlInjectionMatchSets = "SqlInjectionMatchSets"
        }
    }

    public struct GetSampledRequestsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxItems", required: true, type: .long), 
            AWSShapeMember(label: "TimeWindow", required: true, type: .structure), 
            AWSShapeMember(label: "RuleId", required: true, type: .string), 
            AWSShapeMember(label: "WebAclId", required: true, type: .string)
        ]
        /// The number of requests that you want AWS WAF to return from among the first 5,000 requests that your AWS resource received during the time range. If your resource received fewer requests than the value of MaxItems, GetSampledRequests returns information about all of them. 
        public let maxItems: Int64
        /// The start date and time and the end date and time of the range for which you want GetSampledRequests to return a sample of requests. Specify the date and time in the following format: "2016-09-27T14:50Z". You can specify any time range in the previous three hours.
        public let timeWindow: TimeWindow
        ///  RuleId is one of two values:   The RuleId of the Rule for which you want GetSampledRequests to return a sample of requests.    Default_Action, which causes GetSampledRequests to return a sample of the requests that didn't match any of the rules in the specified WebACL.  
        public let ruleId: String
        /// The WebACLId of the WebACL for which you want GetSampledRequests to return a sample of requests.
        public let webAclId: String

        public init(maxItems: Int64, timeWindow: TimeWindow, ruleId: String, webAclId: String) {
            self.maxItems = maxItems
            self.timeWindow = timeWindow
            self.ruleId = ruleId
            self.webAclId = webAclId
        }

        private enum CodingKeys: String, CodingKey {
            case maxItems = "MaxItems"
            case timeWindow = "TimeWindow"
            case ruleId = "RuleId"
            case webAclId = "WebAclId"
        }
    }

    public struct UpdateRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "RuleId", required: true, type: .string), 
            AWSShapeMember(label: "Updates", required: true, type: .list)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The RuleId of the Rule that you want to update. RuleId is returned by CreateRule and by ListRules.
        public let ruleId: String
        /// An array of RuleUpdate objects that you want to insert into or delete from a Rule. For more information, see the applicable data types:    RuleUpdate: Contains Action and Predicate     Predicate: Contains DataId, Negated, and Type     FieldToMatch: Contains Data and Type   
        public let updates: [RuleUpdate]

        public init(changeToken: String, ruleId: String, updates: [RuleUpdate]) {
            self.changeToken = changeToken
            self.ruleId = ruleId
            self.updates = updates
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case ruleId = "RuleId"
            case updates = "Updates"
        }
    }

    public struct DeleteRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "RuleId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The RuleId of the Rule that you want to delete. RuleId is returned by CreateRule and by ListRules.
        public let ruleId: String

        public init(changeToken: String, ruleId: String) {
            self.changeToken = changeToken
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case ruleId = "RuleId"
        }
    }

    public struct DeleteWebACLResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteWebACL request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct UpdateSizeConstraintSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateSizeConstraintSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct FieldToMatch: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "Data", required: false, type: .string)
        ]
        /// The part of the web request that you want AWS WAF to search for a specified string. Parts of a request that you can search include the following:    HEADER: A specified request header, for example, the value of the User-Agent or Referer header. If you choose HEADER for the type, specify the name of the header in Data.    METHOD: The HTTP method, which indicated the type of operation that the request is asking the origin to perform. Amazon CloudFront supports the following methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT.    QUERY_STRING: A query string, which is the part of a URL that appears after a ? character, if any.    URI: The part of a web request that identifies a resource, for example, /images/daily-ad.jpg.    BODY: The part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. The request body immediately follows the request headers. Note that only the first 8192 bytes of the request body are forwarded to AWS WAF for inspection. To allow or block requests based on the length of the body, you can create a size constraint set. For more information, see CreateSizeConstraintSet.   
        public let `type`: MatchFieldType
        /// When the value of Type is HEADER, enter the name of the header that you want AWS WAF to search, for example, User-Agent or Referer. If the value of Type is any other value, omit Data. The name of the header is not case sensitive.
        public let data: String?

        public init(type: MatchFieldType, data: String? = nil) {
            self.`type` = `type`
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case data = "Data"
        }
    }

    public enum ChangeTokenStatus: String, CustomStringConvertible, Codable {
        case provisioned = "PROVISIONED"
        case pending = "PENDING"
        case insync = "INSYNC"
        public var description: String { return self.rawValue }
    }

    public struct CreateByteMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "ByteMatchSet", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateByteMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// A ByteMatchSet that contains no ByteMatchTuple objects.
        public let byteMatchSet: ByteMatchSet?

        public init(changeToken: String? = nil, byteMatchSet: ByteMatchSet? = nil) {
            self.changeToken = changeToken
            self.byteMatchSet = byteMatchSet
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case byteMatchSet = "ByteMatchSet"
        }
    }

    public struct IPSetSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IPSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The IPSetId for an IPSet. You can use IPSetId in a GetIPSet request to get detailed information about an IPSet.
        public let iPSetId: String
        /// A friendly name or description of the IPSet. You can't change the name of an IPSet after you create it.
        public let name: String

        public init(iPSetId: String, name: String) {
            self.iPSetId = iPSetId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case iPSetId = "IPSetId"
            case name = "Name"
        }
    }

    public struct ListByteMatchSetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of ByteMatchSet objects that you want AWS WAF to return for this request. If you have more ByteMatchSets objects than the number you specify for Limit, the response includes a NextMarker value that you can use to get another batch of ByteMatchSet objects.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more ByteMatchSets than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of ByteMatchSets. For the second and subsequent ListByteMatchSets requests, specify the value of NextMarker from the previous response to get information about another batch of ByteMatchSets.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct GetIPSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IPSet", required: false, type: .structure)
        ]
        /// Information about the IPSet that you specified in the GetIPSet request. For more information, see the following topics:    IPSet: Contains IPSetDescriptors, IPSetId, and Name     IPSetDescriptors: Contains an array of IPSetDescriptor objects. Each IPSetDescriptor object contains Type and Value   
        public let iPSet: IPSet?

        public init(iPSet: IPSet? = nil) {
            self.iPSet = iPSet
        }

        private enum CodingKeys: String, CodingKey {
            case iPSet = "IPSet"
        }
    }

    public enum WafActionType: String, CustomStringConvertible, Codable {
        case block = "BLOCK"
        case allow = "ALLOW"
        case count = "COUNT"
        public var description: String { return self.rawValue }
    }

    public struct UpdateRateBasedRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Updates", required: true, type: .list), 
            AWSShapeMember(label: "RateLimit", required: true, type: .long), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "RuleId", required: true, type: .string)
        ]
        /// An array of RuleUpdate objects that you want to insert into or delete from a RateBasedRule. 
        public let updates: [RuleUpdate]
        /// The maximum number of requests, which have an identical value in the field specified by the RateKey, allowed in a five-minute period. If the number of requests exceeds the RateLimit and the other predicates specified in the rule are also met, AWS WAF triggers the action that is specified for this rule.
        public let rateLimit: Int64
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The RuleId of the RateBasedRule that you want to update. RuleId is returned by CreateRateBasedRule and by ListRateBasedRules.
        public let ruleId: String

        public init(updates: [RuleUpdate], rateLimit: Int64, changeToken: String, ruleId: String) {
            self.updates = updates
            self.rateLimit = rateLimit
            self.changeToken = changeToken
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case updates = "Updates"
            case rateLimit = "RateLimit"
            case changeToken = "ChangeToken"
            case ruleId = "RuleId"
        }
    }

    public struct GetChangeTokenStatusResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeTokenStatus", required: false, type: .enum)
        ]
        /// The status of the change token.
        public let changeTokenStatus: ChangeTokenStatus?

        public init(changeTokenStatus: ChangeTokenStatus? = nil) {
            self.changeTokenStatus = changeTokenStatus
        }

        private enum CodingKeys: String, CodingKey {
            case changeTokenStatus = "ChangeTokenStatus"
        }
    }

    public struct UpdateByteMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "ByteMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Updates", required: true, type: .list)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The ByteMatchSetId of the ByteMatchSet that you want to update. ByteMatchSetId is returned by CreateByteMatchSet and by ListByteMatchSets.
        public let byteMatchSetId: String
        /// An array of ByteMatchSetUpdate objects that you want to insert into or delete from a ByteMatchSet. For more information, see the applicable data types:    ByteMatchSetUpdate: Contains Action and ByteMatchTuple     ByteMatchTuple: Contains FieldToMatch, PositionalConstraint, TargetString, and TextTransformation     FieldToMatch: Contains Data and Type   
        public let updates: [ByteMatchSetUpdate]

        public init(changeToken: String, byteMatchSetId: String, updates: [ByteMatchSetUpdate]) {
            self.changeToken = changeToken
            self.byteMatchSetId = byteMatchSetId
            self.updates = updates
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case byteMatchSetId = "ByteMatchSetId"
            case updates = "Updates"
        }
    }

    public struct GetXssMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSet", required: false, type: .structure)
        ]
        /// Information about the XssMatchSet that you specified in the GetXssMatchSet request. For more information, see the following topics:    XssMatchSet: Contains Name, XssMatchSetId, and an array of XssMatchTuple objects    XssMatchTuple: Each XssMatchTuple object contains FieldToMatch and TextTransformation     FieldToMatch: Contains Data and Type   
        public let xssMatchSet: XssMatchSet?

        public init(xssMatchSet: XssMatchSet? = nil) {
            self.xssMatchSet = xssMatchSet
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSet = "XssMatchSet"
        }
    }

    public struct SizeConstraintSet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SizeConstraints", required: true, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "SizeConstraintSetId", required: true, type: .string)
        ]
        /// Specifies the parts of web requests that you want to inspect the size of.
        public let sizeConstraints: [SizeConstraint]
        /// The name, if any, of the SizeConstraintSet.
        public let name: String?
        /// A unique identifier for a SizeConstraintSet. You use SizeConstraintSetId to get information about a SizeConstraintSet (see GetSizeConstraintSet), update a SizeConstraintSet (see UpdateSizeConstraintSet), insert a SizeConstraintSet into a Rule or delete one from a Rule (see UpdateRule), and delete a SizeConstraintSet from AWS WAF (see DeleteSizeConstraintSet).  SizeConstraintSetId is returned by CreateSizeConstraintSet and by ListSizeConstraintSets.
        public let sizeConstraintSetId: String

        public init(sizeConstraints: [SizeConstraint], name: String? = nil, sizeConstraintSetId: String) {
            self.sizeConstraints = sizeConstraints
            self.name = name
            self.sizeConstraintSetId = sizeConstraintSetId
        }

        private enum CodingKeys: String, CodingKey {
            case sizeConstraints = "SizeConstraints"
            case name = "Name"
            case sizeConstraintSetId = "SizeConstraintSetId"
        }
    }

    public struct DeleteRateBasedRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteRateBasedRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct ByteMatchSetSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ByteMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The ByteMatchSetId for a ByteMatchSet. You use ByteMatchSetId to get information about a ByteMatchSet, update a ByteMatchSet, remove a ByteMatchSet from a Rule, and delete a ByteMatchSet from AWS WAF.  ByteMatchSetId is returned by CreateByteMatchSet and by ListByteMatchSets.
        public let byteMatchSetId: String
        /// A friendly name or description of the ByteMatchSet. You can't change Name after you create a ByteMatchSet.
        public let name: String

        public init(byteMatchSetId: String, name: String) {
            self.byteMatchSetId = byteMatchSetId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case byteMatchSetId = "ByteMatchSetId"
            case name = "Name"
        }
    }

    public struct GetRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Rule", required: false, type: .structure)
        ]
        /// Information about the Rule that you specified in the GetRule request. For more information, see the following topics:    Rule: Contains MetricName, Name, an array of Predicate objects, and RuleId     Predicate: Each Predicate object contains DataId, Negated, and Type   
        public let rule: Rule?

        public init(rule: Rule? = nil) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
        }
    }

    public struct ListSizeConstraintSetsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SizeConstraintSets", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of SizeConstraintSetSummary objects.
        public let sizeConstraintSets: [SizeConstraintSetSummary]?
        /// If you have more SizeConstraintSet objects than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more SizeConstraintSet objects, submit another ListSizeConstraintSets request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(sizeConstraintSets: [SizeConstraintSetSummary]? = nil, nextMarker: String? = nil) {
            self.sizeConstraintSets = sizeConstraintSets
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case sizeConstraintSets = "SizeConstraintSets"
            case nextMarker = "NextMarker"
        }
    }

    public struct CreateSizeConstraintSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// A friendly name or description of the SizeConstraintSet. You can't change Name after you create a SizeConstraintSet.
        public let name: String

        public init(changeToken: String, name: String) {
            self.changeToken = changeToken
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case name = "Name"
        }
    }

    public struct ListByteMatchSetsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ByteMatchSets", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of ByteMatchSetSummary objects.
        public let byteMatchSets: [ByteMatchSetSummary]?
        /// If you have more ByteMatchSet objects than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more ByteMatchSet objects, submit another ListByteMatchSets request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(byteMatchSets: [ByteMatchSetSummary]? = nil, nextMarker: String? = nil) {
            self.byteMatchSets = byteMatchSets
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case byteMatchSets = "ByteMatchSets"
            case nextMarker = "NextMarker"
        }
    }

    public struct Predicate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "Negated", required: true, type: .boolean), 
            AWSShapeMember(label: "DataId", required: true, type: .string)
        ]
        /// The type of predicate in a Rule, such as ByteMatchSet or IPSet.
        public let `type`: PredicateType
        /// Set Negated to False if you want AWS WAF to allow, block, or count requests based on the settings in the specified ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, or SizeConstraintSet. For example, if an IPSet includes the IP address 192.0.2.44, AWS WAF will allow or block requests based on that IP address. Set Negated to True if you want AWS WAF to allow or block a request based on the negation of the settings in the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, or SizeConstraintSet. For example, if an IPSet includes the IP address 192.0.2.44, AWS WAF will allow, block, or count requests based on all IP addresses except 192.0.2.44.
        public let negated: Bool
        /// A unique identifier for a predicate in a Rule, such as ByteMatchSetId or IPSetId. The ID is returned by the corresponding Create or List command.
        public let dataId: String

        public init(type: PredicateType, negated: Bool, dataId: String) {
            self.`type` = `type`
            self.negated = negated
            self.dataId = dataId
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case negated = "Negated"
            case dataId = "DataId"
        }
    }

    public struct RuleUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: true, type: .enum), 
            AWSShapeMember(label: "Predicate", required: true, type: .structure)
        ]
        /// Specify INSERT to add a Predicate to a Rule. Use DELETE to remove a Predicate from a Rule.
        public let action: ChangeAction
        /// The ID of the Predicate (such as an IPSet) that you want to add to a Rule.
        public let predicate: Predicate

        public init(action: ChangeAction, predicate: Predicate) {
            self.action = action
            self.predicate = predicate
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case predicate = "Predicate"
        }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable {
        case eq = "EQ"
        case ne = "NE"
        case le = "LE"
        case lt = "LT"
        case ge = "GE"
        case gt = "GT"
        public var description: String { return self.rawValue }
    }

    public struct ListIPSetsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "IPSets", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of IPSetSummary objects.
        public let iPSets: [IPSetSummary]?
        /// If you have more IPSet objects than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more IPSet objects, submit another ListIPSets request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(iPSets: [IPSetSummary]? = nil, nextMarker: String? = nil) {
            self.iPSets = iPSets
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case iPSets = "IPSets"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListSizeConstraintSetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of SizeConstraintSet objects that you want AWS WAF to return for this request. If you have more SizeConstraintSets objects than the number you specify for Limit, the response includes a NextMarker value that you can use to get another batch of SizeConstraintSet objects.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more SizeConstraintSets than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of SizeConstraintSets. For the second and subsequent ListSizeConstraintSets requests, specify the value of NextMarker from the previous response to get information about another batch of SizeConstraintSets.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct DeleteRateBasedRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "RuleId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The RuleId of the RateBasedRule that you want to delete. RuleId is returned by CreateRateBasedRule and by ListRateBasedRules.
        public let ruleId: String

        public init(changeToken: String, ruleId: String) {
            self.changeToken = changeToken
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case ruleId = "RuleId"
        }
    }

    public struct ListXssMatchSetsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSets", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of XssMatchSetSummary objects.
        public let xssMatchSets: [XssMatchSetSummary]?
        /// If you have more XssMatchSet objects than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more XssMatchSet objects, submit another ListXssMatchSets request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(xssMatchSets: [XssMatchSetSummary]? = nil, nextMarker: String? = nil) {
            self.xssMatchSets = xssMatchSets
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSets = "XssMatchSets"
            case nextMarker = "NextMarker"
        }
    }

    public struct WebACLUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: true, type: .enum), 
            AWSShapeMember(label: "ActivatedRule", required: true, type: .structure)
        ]
        /// Specifies whether to insert a Rule into or delete a Rule from a WebACL.
        public let action: ChangeAction
        /// The ActivatedRule object in an UpdateWebACL request specifies a Rule that you want to insert or delete, the priority of the Rule in the WebACL, and the action that you want AWS WAF to take when a web request matches the Rule (ALLOW, BLOCK, or COUNT).
        public let activatedRule: ActivatedRule

        public init(action: ChangeAction, activatedRule: ActivatedRule) {
            self.action = action
            self.activatedRule = activatedRule
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case activatedRule = "ActivatedRule"
        }
    }

    public struct IPSetUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: true, type: .enum), 
            AWSShapeMember(label: "IPSetDescriptor", required: true, type: .structure)
        ]
        /// Specifies whether to insert or delete an IP address with UpdateIPSet.
        public let action: ChangeAction
        /// The IP address type (IPV4 or IPV6) and the IP address range (in CIDR notation) that web requests originate from.
        public let iPSetDescriptor: IPSetDescriptor

        public init(action: ChangeAction, iPSetDescriptor: IPSetDescriptor) {
            self.action = action
            self.iPSetDescriptor = iPSetDescriptor
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case iPSetDescriptor = "IPSetDescriptor"
        }
    }

    public struct ListWebACLsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of WebACL objects that you want AWS WAF to return for this request. If you have more WebACL objects than the number that you specify for Limit, the response includes a NextMarker value that you can use to get another batch of WebACL objects.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more WebACL objects than the number that you specify for Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of WebACL objects. For the second and subsequent ListWebACLs requests, specify the value of NextMarker from the previous response to get information about another batch of WebACL objects.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct UpdateRateBasedRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateRateBasedRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct ByteMatchSetUpdate: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: true, type: .enum), 
            AWSShapeMember(label: "ByteMatchTuple", required: true, type: .structure)
        ]
        /// Specifies whether to insert or delete a ByteMatchTuple.
        public let action: ChangeAction
        /// Information about the part of a web request that you want AWS WAF to inspect and the value that you want AWS WAF to search for. If you specify DELETE for the value of Action, the ByteMatchTuple values must exactly match the values in the ByteMatchTuple that you want to delete from the ByteMatchSet.
        public let byteMatchTuple: ByteMatchTuple

        public init(action: ChangeAction, byteMatchTuple: ByteMatchTuple) {
            self.action = action
            self.byteMatchTuple = byteMatchTuple
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case byteMatchTuple = "ByteMatchTuple"
        }
    }

    public struct GetRateBasedRuleManagedKeysResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ManagedKeys", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of IP addresses that currently are blocked by the specified RateBasedRule. 
        public let managedKeys: [String]?
        /// A null value and not currently used.
        public let nextMarker: String?

        public init(managedKeys: [String]? = nil, nextMarker: String? = nil) {
            self.managedKeys = managedKeys
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case managedKeys = "ManagedKeys"
            case nextMarker = "NextMarker"
        }
    }

    public struct GetRateBasedRuleManagedKeysRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleId", required: true, type: .string), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// The RuleId of the RateBasedRule for which you want to get a list of ManagedKeys. RuleId is returned by CreateRateBasedRule and by ListRateBasedRules.
        public let ruleId: String
        /// A null value and not currently used. Do not include this in your request.
        public let nextMarker: String?

        public init(ruleId: String, nextMarker: String? = nil) {
            self.ruleId = ruleId
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
            case nextMarker = "NextMarker"
        }
    }

    public struct SqlInjectionMatchTuple: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "FieldToMatch", required: true, type: .structure), 
            AWSShapeMember(label: "TextTransformation", required: true, type: .enum)
        ]
        /// Specifies where in a web request to look for snippets of malicious SQL code.
        public let fieldToMatch: FieldToMatch
        /// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on FieldToMatch before inspecting a request for a match.  CMD_LINE  When you're concerned that attackers are injecting an operating system commandline command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:   Delete the following characters: \ " ' ^   Delete spaces before the following characters: / (   Replace the following characters with a space: , ;   Replace multiple spaces with one space   Convert uppercase letters (A-Z) to lowercase (a-z)    COMPRESS_WHITE_SPACE  Use this option to replace the following characters with a space character (decimal 32):   \f, formfeed, decimal 12   \t, tab, decimal 9   \n, newline, decimal 10   \r, carriage return, decimal 13   \v, vertical tab, decimal 11   non-breaking space, decimal 160    COMPRESS_WHITE_SPACE also replaces multiple spaces with one space.  HTML_ENTITY_DECODE  Use this option to replace HTML-encoded characters with unencoded characters. HTML_ENTITY_DECODE performs the following operations:   Replaces (ampersand)quot; with "    Replaces (ampersand)nbsp; with a non-breaking space, decimal 160   Replaces (ampersand)lt; with a "less than" symbol   Replaces (ampersand)gt; with &gt;    Replaces characters that are represented in hexadecimal format, (ampersand)#xhhhh;, with the corresponding characters   Replaces characters that are represented in decimal format, (ampersand)#nnnn;, with the corresponding characters    LOWERCASE  Use this option to convert uppercase letters (A-Z) to lowercase (a-z).  URL_DECODE  Use this option to decode a URL-encoded value.  NONE  Specify NONE if you don't want to perform any text transformations.
        public let textTransformation: TextTransformation

        public init(fieldToMatch: FieldToMatch, textTransformation: TextTransformation) {
            self.fieldToMatch = fieldToMatch
            self.textTransformation = textTransformation
        }

        private enum CodingKeys: String, CodingKey {
            case fieldToMatch = "FieldToMatch"
            case textTransformation = "TextTransformation"
        }
    }

    public struct GetByteMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ByteMatchSet", required: false, type: .structure)
        ]
        /// Information about the ByteMatchSet that you specified in the GetByteMatchSet request. For more information, see the following topics:    ByteMatchSet: Contains ByteMatchSetId, ByteMatchTuples, and Name     ByteMatchTuples: Contains an array of ByteMatchTuple objects. Each ByteMatchTuple object contains FieldToMatch, PositionalConstraint, TargetString, and TextTransformation     FieldToMatch: Contains Data and Type   
        public let byteMatchSet: ByteMatchSet?

        public init(byteMatchSet: ByteMatchSet? = nil) {
            self.byteMatchSet = byteMatchSet
        }

        private enum CodingKeys: String, CodingKey {
            case byteMatchSet = "ByteMatchSet"
        }
    }

    public struct GetRateBasedRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Rule", required: false, type: .structure)
        ]
        /// Information about the RateBasedRule that you specified in the GetRateBasedRule request.
        public let rule: RateBasedRule?

        public init(rule: RateBasedRule? = nil) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
        }
    }

    public struct CreateIPSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// A friendly name or description of the IPSet. You can't change Name after you create the IPSet.
        public let name: String

        public init(changeToken: String, name: String) {
            self.changeToken = changeToken
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case name = "Name"
        }
    }

    public struct CreateIPSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "IPSet", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateIPSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// The IPSet returned in the CreateIPSet response.
        public let iPSet: IPSet?

        public init(changeToken: String? = nil, iPSet: IPSet? = nil) {
            self.changeToken = changeToken
            self.iPSet = iPSet
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case iPSet = "IPSet"
        }
    }

    public struct UpdateSqlInjectionMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateSqlInjectionMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct GetChangeTokenStatusRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string)
        ]
        /// The change token for which you want to get the status. This change token was previously returned in the GetChangeToken response.
        public let changeToken: String

        public init(changeToken: String) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct RateBasedRule: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: false, type: .string), 
            AWSShapeMember(label: "MatchPredicates", required: true, type: .list), 
            AWSShapeMember(label: "RateLimit", required: true, type: .long), 
            AWSShapeMember(label: "RuleId", required: true, type: .string), 
            AWSShapeMember(label: "RateKey", required: true, type: .enum), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// A friendly name or description for the metrics for a RateBasedRule. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change the name of the metric after you create the RateBasedRule.
        public let metricName: String?
        /// The Predicates object contains one Predicate element for each ByteMatchSet, IPSet, or SqlInjectionMatchSet object that you want to include in a RateBasedRule.
        public let matchPredicates: [Predicate]
        /// The maximum number of requests, which have an identical value in the field specified by the RateKey, allowed in a five-minute period. If the number of requests exceeds the RateLimit and the other predicates specified in the rule are also met, AWS WAF triggers the action that is specified for this rule.
        public let rateLimit: Int64
        /// A unique identifier for a RateBasedRule. You use RuleId to get more information about a RateBasedRule (see GetRateBasedRule), update a RateBasedRule (see UpdateRateBasedRule), insert a RateBasedRule into a WebACL or delete one from a WebACL (see UpdateWebACL), or delete a RateBasedRule from AWS WAF (see DeleteRateBasedRule).
        public let ruleId: String
        /// The field that AWS WAF uses to determine if requests are likely arriving from single source and thus subject to rate monitoring. The only valid value for RateKey is IP. IP indicates that requests arriving from the same IP address are subject to the RateLimit that is specified in the RateBasedRule.
        public let rateKey: RateKey
        /// A friendly name or description for a RateBasedRule. You can't change the name of a RateBasedRule after you create it.
        public let name: String?

        public init(metricName: String? = nil, matchPredicates: [Predicate], rateLimit: Int64, ruleId: String, rateKey: RateKey, name: String? = nil) {
            self.metricName = metricName
            self.matchPredicates = matchPredicates
            self.rateLimit = rateLimit
            self.ruleId = ruleId
            self.rateKey = rateKey
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case matchPredicates = "MatchPredicates"
            case rateLimit = "RateLimit"
            case ruleId = "RuleId"
            case rateKey = "RateKey"
            case name = "Name"
        }
    }

    public struct DeleteIPSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "IPSetId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The IPSetId of the IPSet that you want to delete. IPSetId is returned by CreateIPSet and by ListIPSets.
        public let iPSetId: String

        public init(changeToken: String, iPSetId: String) {
            self.changeToken = changeToken
            self.iPSetId = iPSetId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case iPSetId = "IPSetId"
        }
    }

    public struct GetRateBasedRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleId", required: true, type: .string)
        ]
        /// The RuleId of the RateBasedRule that you want to get. RuleId is returned by CreateRateBasedRule and by ListRateBasedRules.
        public let ruleId: String

        public init(ruleId: String) {
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
        }
    }

    public enum IPSetDescriptorType: String, CustomStringConvertible, Codable {
        case ipv4 = "IPV4"
        case ipv6 = "IPV6"
        public var description: String { return self.rawValue }
    }

    public struct IPSetDescriptor: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Type", required: true, type: .enum), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]
        /// Specify IPV4 or IPV6.
        public let `type`: IPSetDescriptorType
        /// Specify an IPv4 address by using CIDR notation. For example:   To configure AWS WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify 192.0.2.44/32.   To configure AWS WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify 192.0.2.0/24.   For more information about CIDR notation, see the Wikipedia entry Classless Inter-Domain Routing. Specify an IPv6 address by using CIDR notation. For example:   To configure AWS WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify 1111:0000:0000:0000:0000:0000:0000:0111/128.   To configure AWS WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify 1111:0000:0000:0000:0000:0000:0000:0000/64.  
        public let value: String

        public init(type: IPSetDescriptorType, value: String) {
            self.`type` = `type`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "Type"
            case value = "Value"
        }
    }

    public struct CreateSizeConstraintSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "SizeConstraintSet", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateSizeConstraintSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// A SizeConstraintSet that contains no SizeConstraint objects.
        public let sizeConstraintSet: SizeConstraintSet?

        public init(changeToken: String? = nil, sizeConstraintSet: SizeConstraintSet? = nil) {
            self.changeToken = changeToken
            self.sizeConstraintSet = sizeConstraintSet
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case sizeConstraintSet = "SizeConstraintSet"
        }
    }

    public struct SizeConstraint: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "FieldToMatch", required: true, type: .structure), 
            AWSShapeMember(label: "TextTransformation", required: true, type: .enum), 
            AWSShapeMember(label: "ComparisonOperator", required: true, type: .enum), 
            AWSShapeMember(label: "Size", required: true, type: .long)
        ]
        /// Specifies where in a web request to look for the size constraint.
        public let fieldToMatch: FieldToMatch
        /// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on FieldToMatch before inspecting a request for a match. Note that if you choose BODY for the value of Type, you must choose NONE for TextTransformation because CloudFront forwards only the first 8192 bytes for inspection.   NONE  Specify NONE if you don't want to perform any text transformations.  CMD_LINE  When you're concerned that attackers are injecting an operating system command line command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:   Delete the following characters: \ " ' ^   Delete spaces before the following characters: / (   Replace the following characters with a space: , ;   Replace multiple spaces with one space   Convert uppercase letters (A-Z) to lowercase (a-z)    COMPRESS_WHITE_SPACE  Use this option to replace the following characters with a space character (decimal 32):   \f, formfeed, decimal 12   \t, tab, decimal 9   \n, newline, decimal 10   \r, carriage return, decimal 13   \v, vertical tab, decimal 11   non-breaking space, decimal 160    COMPRESS_WHITE_SPACE also replaces multiple spaces with one space.  HTML_ENTITY_DECODE  Use this option to replace HTML-encoded characters with unencoded characters. HTML_ENTITY_DECODE performs the following operations:   Replaces (ampersand)quot; with "    Replaces (ampersand)nbsp; with a non-breaking space, decimal 160   Replaces (ampersand)lt; with a "less than" symbol   Replaces (ampersand)gt; with &gt;    Replaces characters that are represented in hexadecimal format, (ampersand)#xhhhh;, with the corresponding characters   Replaces characters that are represented in decimal format, (ampersand)#nnnn;, with the corresponding characters    LOWERCASE  Use this option to convert uppercase letters (A-Z) to lowercase (a-z).  URL_DECODE  Use this option to decode a URL-encoded value.
        public let textTransformation: TextTransformation
        /// The type of comparison you want AWS WAF to perform. AWS WAF uses this in combination with the provided Size and FieldToMatch to build an expression in the form of "Size ComparisonOperator size in bytes of FieldToMatch". If that expression is true, the SizeConstraint is considered to match.  EQ: Used to test if the Size is equal to the size of the FieldToMatch   NE: Used to test if the Size is not equal to the size of the FieldToMatch   LE: Used to test if the Size is less than or equal to the size of the FieldToMatch   LT: Used to test if the Size is strictly less than the size of the FieldToMatch   GE: Used to test if the Size is greater than or equal to the size of the FieldToMatch   GT: Used to test if the Size is strictly greater than the size of the FieldToMatch 
        public let comparisonOperator: ComparisonOperator
        /// The size in bytes that you want AWS WAF to compare against the size of the specified FieldToMatch. AWS WAF uses this in combination with ComparisonOperator and FieldToMatch to build an expression in the form of "Size ComparisonOperator size in bytes of FieldToMatch". If that expression is true, the SizeConstraint is considered to match. Valid values for size are 0 - 21474836480 bytes (0 - 20 GB). If you specify URI for the value of Type, the / in the URI counts as one character. For example, the URI /logo.jpg is nine characters long.
        public let size: Int64

        public init(fieldToMatch: FieldToMatch, textTransformation: TextTransformation, comparisonOperator: ComparisonOperator, size: Int64) {
            self.fieldToMatch = fieldToMatch
            self.textTransformation = textTransformation
            self.comparisonOperator = comparisonOperator
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case fieldToMatch = "FieldToMatch"
            case textTransformation = "TextTransformation"
            case comparisonOperator = "ComparisonOperator"
            case size = "Size"
        }
    }

    public struct ListRulesRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of Rules that you want AWS WAF to return for this request. If you have more Rules than the number that you specify for Limit, the response includes a NextMarker value that you can use to get another batch of Rules.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more Rules than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of Rules. For the second and subsequent ListRules requests, specify the value of NextMarker from the previous response to get information about another batch of Rules.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct GetXssMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSetId", required: true, type: .string)
        ]
        /// The XssMatchSetId of the XssMatchSet that you want to get. XssMatchSetId is returned by CreateXssMatchSet and by ListXssMatchSets.
        public let xssMatchSetId: String

        public init(xssMatchSetId: String) {
            self.xssMatchSetId = xssMatchSetId
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSetId = "XssMatchSetId"
        }
    }

    public struct UpdateIPSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "IPSetId", required: true, type: .string), 
            AWSShapeMember(label: "Updates", required: true, type: .list)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The IPSetId of the IPSet that you want to update. IPSetId is returned by CreateIPSet and by ListIPSets.
        public let iPSetId: String
        /// An array of IPSetUpdate objects that you want to insert into or delete from an IPSet. For more information, see the applicable data types:    IPSetUpdate: Contains Action and IPSetDescriptor     IPSetDescriptor: Contains Type and Value   
        public let updates: [IPSetUpdate]

        public init(changeToken: String, iPSetId: String, updates: [IPSetUpdate]) {
            self.changeToken = changeToken
            self.iPSetId = iPSetId
            self.updates = updates
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case iPSetId = "IPSetId"
            case updates = "Updates"
        }
    }

    public struct GetSizeConstraintSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SizeConstraintSetId", required: true, type: .string)
        ]
        /// The SizeConstraintSetId of the SizeConstraintSet that you want to get. SizeConstraintSetId is returned by CreateSizeConstraintSet and by ListSizeConstraintSets.
        public let sizeConstraintSetId: String

        public init(sizeConstraintSetId: String) {
            self.sizeConstraintSetId = sizeConstraintSetId
        }

        private enum CodingKeys: String, CodingKey {
            case sizeConstraintSetId = "SizeConstraintSetId"
        }
    }

    public struct CreateSqlInjectionMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// A friendly name or description for the SqlInjectionMatchSet that you're creating. You can't change Name after you create the SqlInjectionMatchSet.
        public let name: String

        public init(changeToken: String, name: String) {
            self.changeToken = changeToken
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case name = "Name"
        }
    }

    public struct CreateWebACLResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string), 
            AWSShapeMember(label: "WebACL", required: false, type: .structure)
        ]
        /// The ChangeToken that you used to submit the CreateWebACL request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?
        /// The WebACL returned in the CreateWebACL response.
        public let webACL: WebACL?

        public init(changeToken: String? = nil, webACL: WebACL? = nil) {
            self.changeToken = changeToken
            self.webACL = webACL
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case webACL = "WebACL"
        }
    }

    public struct DeleteSqlInjectionMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "SqlInjectionMatchSetId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The SqlInjectionMatchSetId of the SqlInjectionMatchSet that you want to delete. SqlInjectionMatchSetId is returned by CreateSqlInjectionMatchSet and by ListSqlInjectionMatchSets.
        public let sqlInjectionMatchSetId: String

        public init(changeToken: String, sqlInjectionMatchSetId: String) {
            self.changeToken = changeToken
            self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
        }
    }

    public struct ByteMatchTuple: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "FieldToMatch", required: true, type: .structure), 
            AWSShapeMember(label: "TargetString", required: true, type: .blob), 
            AWSShapeMember(label: "TextTransformation", required: true, type: .enum), 
            AWSShapeMember(label: "PositionalConstraint", required: true, type: .enum)
        ]
        /// The part of a web request that you want AWS WAF to search, such as a specified header or a query string. For more information, see FieldToMatch.
        public let fieldToMatch: FieldToMatch
        /// The value that you want AWS WAF to search for. AWS WAF searches for the specified string in the part of web requests that you specified in FieldToMatch. The maximum length of the value is 50 bytes. Valid values depend on the values that you specified for FieldToMatch:    HEADER: The value that you want AWS WAF to search for in the request header that you specified in FieldToMatch, for example, the value of the User-Agent or Referer header.    METHOD: The HTTP method, which indicates the type of operation specified in the request. CloudFront supports the following methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, and PUT.    QUERY_STRING: The value that you want AWS WAF to search for in the query string, which is the part of a URL that appears after a ? character.    URI: The value that you want AWS WAF to search for in the part of a URL that identifies a resource, for example, /images/daily-ad.jpg.    BODY: The part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. The request body immediately follows the request headers. Note that only the first 8192 bytes of the request body are forwarded to AWS WAF for inspection. To allow or block requests based on the length of the body, you can create a size constraint set. For more information, see CreateSizeConstraintSet.    If TargetString includes alphabetic characters A-Z and a-z, note that the value is case sensitive.  If you're using the AWS WAF API  Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes. For example, suppose the value of Type is HEADER and the value of Data is User-Agent. If you want to search the User-Agent header for the value BadBot, you base64-encode BadBot using MIME base64 encoding and include the resulting value, QmFkQm90, in the value of TargetString.  If you're using the AWS CLI or one of the AWS SDKs  The value that you want AWS WAF to search for. The SDK automatically base64 encodes the value.
        public let targetString: Data
        /// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on TargetString before inspecting a request for a match.  CMD_LINE  When you're concerned that attackers are injecting an operating system commandline command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:   Delete the following characters: \ " ' ^   Delete spaces before the following characters: / (   Replace the following characters with a space: , ;   Replace multiple spaces with one space   Convert uppercase letters (A-Z) to lowercase (a-z)    COMPRESS_WHITE_SPACE  Use this option to replace the following characters with a space character (decimal 32):   \f, formfeed, decimal 12   \t, tab, decimal 9   \n, newline, decimal 10   \r, carriage return, decimal 13   \v, vertical tab, decimal 11   non-breaking space, decimal 160    COMPRESS_WHITE_SPACE also replaces multiple spaces with one space.  HTML_ENTITY_DECODE  Use this option to replace HTML-encoded characters with unencoded characters. HTML_ENTITY_DECODE performs the following operations:   Replaces (ampersand)quot; with "    Replaces (ampersand)nbsp; with a non-breaking space, decimal 160   Replaces (ampersand)lt; with a "less than" symbol   Replaces (ampersand)gt; with &gt;    Replaces characters that are represented in hexadecimal format, (ampersand)#xhhhh;, with the corresponding characters   Replaces characters that are represented in decimal format, (ampersand)#nnnn;, with the corresponding characters    LOWERCASE  Use this option to convert uppercase letters (A-Z) to lowercase (a-z).  URL_DECODE  Use this option to decode a URL-encoded value.  NONE  Specify NONE if you don't want to perform any text transformations.
        public let textTransformation: TextTransformation
        /// Within the portion of a web request that you want to search (for example, in the query string, if any), specify where you want AWS WAF to search. Valid values include the following:  CONTAINS  The specified part of the web request must include the value of TargetString, but the location doesn't matter.  CONTAINS_WORD  The specified part of the web request must include the value of TargetString, and TargetString must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, TargetString must be a word, which means one of the following:    TargetString exactly matches the value of the specified part of the web request, such as the value of a header.    TargetString is at the beginning of the specified part of the web request and is followed by a character other than an alphanumeric character or underscore (_), for example, BadBot;.    TargetString is at the end of the specified part of the web request and is preceded by a character other than an alphanumeric character or underscore (_), for example, ;BadBot.    TargetString is in the middle of the specified part of the web request and is preceded and followed by characters other than alphanumeric characters or underscore (_), for example, -BadBot;.    EXACTLY  The value of the specified part of the web request must exactly match the value of TargetString.  STARTS_WITH  The value of TargetString must appear at the beginning of the specified part of the web request.  ENDS_WITH  The value of TargetString must appear at the end of the specified part of the web request.
        public let positionalConstraint: PositionalConstraint

        public init(fieldToMatch: FieldToMatch, targetString: Data, textTransformation: TextTransformation, positionalConstraint: PositionalConstraint) {
            self.fieldToMatch = fieldToMatch
            self.targetString = targetString
            self.textTransformation = textTransformation
            self.positionalConstraint = positionalConstraint
        }

        private enum CodingKeys: String, CodingKey {
            case fieldToMatch = "FieldToMatch"
            case targetString = "TargetString"
            case textTransformation = "TextTransformation"
            case positionalConstraint = "PositionalConstraint"
        }
    }

    public struct ListXssMatchSetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of XssMatchSet objects that you want AWS WAF to return for this request. If you have more XssMatchSet objects than the number you specify for Limit, the response includes a NextMarker value that you can use to get another batch of Rules.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more XssMatchSet objects than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of XssMatchSets. For the second and subsequent ListXssMatchSets requests, specify the value of NextMarker from the previous response to get information about another batch of XssMatchSets.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct UpdateRuleResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct UpdateXssMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateXssMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct SqlInjectionMatchSetSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SqlInjectionMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]
        /// A unique identifier for a SqlInjectionMatchSet. You use SqlInjectionMatchSetId to get information about a SqlInjectionMatchSet (see GetSqlInjectionMatchSet), update a SqlInjectionMatchSet (see UpdateSqlInjectionMatchSet), insert a SqlInjectionMatchSet into a Rule or delete one from a Rule (see UpdateRule), and delete a SqlInjectionMatchSet from AWS WAF (see DeleteSqlInjectionMatchSet).  SqlInjectionMatchSetId is returned by CreateSqlInjectionMatchSet and by ListSqlInjectionMatchSets.
        public let sqlInjectionMatchSetId: String
        /// The name of the SqlInjectionMatchSet, if any, specified by Id.
        public let name: String

        public init(sqlInjectionMatchSetId: String, name: String) {
            self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
            case name = "Name"
        }
    }

    public struct ListWebACLsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "WebACLs", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of WebACLSummary objects.
        public let webACLs: [WebACLSummary]?
        /// If you have more WebACL objects than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more WebACL objects, submit another ListWebACLs request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(webACLs: [WebACLSummary]? = nil, nextMarker: String? = nil) {
            self.webACLs = webACLs
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case webACLs = "WebACLs"
            case nextMarker = "NextMarker"
        }
    }

    public struct DeleteXssMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string)
        ]
        /// The XssMatchSetId of the XssMatchSet that you want to delete. XssMatchSetId is returned by CreateXssMatchSet and by ListXssMatchSets.
        public let xssMatchSetId: String
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String

        public init(xssMatchSetId: String, changeToken: String) {
            self.xssMatchSetId = xssMatchSetId
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSetId = "XssMatchSetId"
            case changeToken = "ChangeToken"
        }
    }

    public struct SizeConstraintSetSummary: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "SizeConstraintSetId", required: true, type: .string)
        ]
        /// The name of the SizeConstraintSet, if any.
        public let name: String
        /// A unique identifier for a SizeConstraintSet. You use SizeConstraintSetId to get information about a SizeConstraintSet (see GetSizeConstraintSet), update a SizeConstraintSet (see UpdateSizeConstraintSet), insert a SizeConstraintSet into a Rule or delete one from a Rule (see UpdateRule), and delete a SizeConstraintSet from AWS WAF (see DeleteSizeConstraintSet).  SizeConstraintSetId is returned by CreateSizeConstraintSet and by ListSizeConstraintSets.
        public let sizeConstraintSetId: String

        public init(name: String, sizeConstraintSetId: String) {
            self.name = name
            self.sizeConstraintSetId = sizeConstraintSetId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case sizeConstraintSetId = "SizeConstraintSetId"
        }
    }

    public struct DeleteByteMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "ByteMatchSetId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The ByteMatchSetId of the ByteMatchSet that you want to delete. ByteMatchSetId is returned by CreateByteMatchSet and by ListByteMatchSets.
        public let byteMatchSetId: String

        public init(changeToken: String, byteMatchSetId: String) {
            self.changeToken = changeToken
            self.byteMatchSetId = byteMatchSetId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case byteMatchSetId = "ByteMatchSetId"
        }
    }

    public struct UpdateByteMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the UpdateByteMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct SampledHTTPRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Timestamp", required: false, type: .timestamp), 
            AWSShapeMember(label: "Request", required: true, type: .structure), 
            AWSShapeMember(label: "Weight", required: true, type: .long), 
            AWSShapeMember(label: "Action", required: false, type: .string)
        ]
        /// The time at which AWS WAF received the request from your AWS resource, in Unix time format (in seconds).
        public let timestamp: Double?
        /// A complex type that contains detailed information about the request.
        public let request: HTTPRequest
        /// A value that indicates how one result in the response relates proportionally to other results in the response. A result that has a weight of 2 represents roughly twice as many CloudFront web requests as a result that has a weight of 1.
        public let weight: Int64
        /// The action for the Rule that the request matched: ALLOW, BLOCK, or COUNT.
        public let action: String?

        public init(timestamp: Double? = nil, request: HTTPRequest, weight: Int64, action: String? = nil) {
            self.timestamp = timestamp
            self.request = request
            self.weight = weight
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case request = "Request"
            case weight = "Weight"
            case action = "Action"
        }
    }

    public enum PositionalConstraint: String, CustomStringConvertible, Codable {
        case exactly = "EXACTLY"
        case starts_with = "STARTS_WITH"
        case ends_with = "ENDS_WITH"
        case contains = "CONTAINS"
        case contains_word = "CONTAINS_WORD"
        public var description: String { return self.rawValue }
    }

    public struct XssMatchTuple: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "FieldToMatch", required: true, type: .structure), 
            AWSShapeMember(label: "TextTransformation", required: true, type: .enum)
        ]
        /// Specifies where in a web request to look for cross-site scripting attacks.
        public let fieldToMatch: FieldToMatch
        /// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on FieldToMatch before inspecting a request for a match.  CMD_LINE  When you're concerned that attackers are injecting an operating system commandline command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:   Delete the following characters: \ " ' ^   Delete spaces before the following characters: / (   Replace the following characters with a space: , ;   Replace multiple spaces with one space   Convert uppercase letters (A-Z) to lowercase (a-z)    COMPRESS_WHITE_SPACE  Use this option to replace the following characters with a space character (decimal 32):   \f, formfeed, decimal 12   \t, tab, decimal 9   \n, newline, decimal 10   \r, carriage return, decimal 13   \v, vertical tab, decimal 11   non-breaking space, decimal 160    COMPRESS_WHITE_SPACE also replaces multiple spaces with one space.  HTML_ENTITY_DECODE  Use this option to replace HTML-encoded characters with unencoded characters. HTML_ENTITY_DECODE performs the following operations:   Replaces (ampersand)quot; with "    Replaces (ampersand)nbsp; with a non-breaking space, decimal 160   Replaces (ampersand)lt; with a "less than" symbol   Replaces (ampersand)gt; with &gt;    Replaces characters that are represented in hexadecimal format, (ampersand)#xhhhh;, with the corresponding characters   Replaces characters that are represented in decimal format, (ampersand)#nnnn;, with the corresponding characters    LOWERCASE  Use this option to convert uppercase letters (A-Z) to lowercase (a-z).  URL_DECODE  Use this option to decode a URL-encoded value.  NONE  Specify NONE if you don't want to perform any text transformations.
        public let textTransformation: TextTransformation

        public init(fieldToMatch: FieldToMatch, textTransformation: TextTransformation) {
            self.fieldToMatch = fieldToMatch
            self.textTransformation = textTransformation
        }

        private enum CodingKeys: String, CodingKey {
            case fieldToMatch = "FieldToMatch"
            case textTransformation = "TextTransformation"
        }
    }

    public struct DeleteByteMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteByteMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct GetSqlInjectionMatchSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SqlInjectionMatchSetId", required: true, type: .string)
        ]
        /// The SqlInjectionMatchSetId of the SqlInjectionMatchSet that you want to get. SqlInjectionMatchSetId is returned by CreateSqlInjectionMatchSet and by ListSqlInjectionMatchSets.
        public let sqlInjectionMatchSetId: String

        public init(sqlInjectionMatchSetId: String) {
            self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
        }

        private enum CodingKeys: String, CodingKey {
            case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
        }
    }

    public enum PredicateType: String, CustomStringConvertible, Codable {
        case ipmatch = "IPMatch"
        case bytematch = "ByteMatch"
        case sqlinjectionmatch = "SqlInjectionMatch"
        case sizeconstraint = "SizeConstraint"
        case xssmatch = "XssMatch"
        public var description: String { return self.rawValue }
    }

    public struct DeleteSizeConstraintSetRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "SizeConstraintSetId", required: true, type: .string)
        ]
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The SizeConstraintSetId of the SizeConstraintSet that you want to delete. SizeConstraintSetId is returned by CreateSizeConstraintSet and by ListSizeConstraintSets.
        public let sizeConstraintSetId: String

        public init(changeToken: String, sizeConstraintSetId: String) {
            self.changeToken = changeToken
            self.sizeConstraintSetId = sizeConstraintSetId
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
            case sizeConstraintSetId = "SizeConstraintSetId"
        }
    }

    public struct GetSqlInjectionMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SqlInjectionMatchSet", required: false, type: .structure)
        ]
        /// Information about the SqlInjectionMatchSet that you specified in the GetSqlInjectionMatchSet request. For more information, see the following topics:    SqlInjectionMatchSet: Contains Name, SqlInjectionMatchSetId, and an array of SqlInjectionMatchTuple objects    SqlInjectionMatchTuple: Each SqlInjectionMatchTuple object contains FieldToMatch and TextTransformation     FieldToMatch: Contains Data and Type   
        public let sqlInjectionMatchSet: SqlInjectionMatchSet?

        public init(sqlInjectionMatchSet: SqlInjectionMatchSet? = nil) {
            self.sqlInjectionMatchSet = sqlInjectionMatchSet
        }

        private enum CodingKeys: String, CodingKey {
            case sqlInjectionMatchSet = "SqlInjectionMatchSet"
        }
    }

    public enum TextTransformation: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case compress_white_space = "COMPRESS_WHITE_SPACE"
        case html_entity_decode = "HTML_ENTITY_DECODE"
        case lowercase = "LOWERCASE"
        case cmd_line = "CMD_LINE"
        case url_decode = "URL_DECODE"
        public var description: String { return self.rawValue }
    }

    public struct UpdateWebACLRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "DefaultAction", required: false, type: .structure), 
            AWSShapeMember(label: "Updates", required: false, type: .list), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "WebACLId", required: true, type: .string)
        ]
        /// A default action for the web ACL, either ALLOW or BLOCK. AWS WAF performs the default action if a request doesn't match the criteria in any of the rules in a web ACL.
        public let defaultAction: WafAction?
        /// An array of updates to make to the WebACL. An array of WebACLUpdate objects that you want to insert into or delete from a WebACL. For more information, see the applicable data types:    WebACLUpdate: Contains Action and ActivatedRule     ActivatedRule: Contains Action, Priority, RuleId, and Type     WafAction: Contains Type   
        public let updates: [WebACLUpdate]?
        /// The value returned by the most recent call to GetChangeToken.
        public let changeToken: String
        /// The WebACLId of the WebACL that you want to update. WebACLId is returned by CreateWebACL and by ListWebACLs.
        public let webACLId: String

        public init(defaultAction: WafAction? = nil, updates: [WebACLUpdate]? = nil, changeToken: String, webACLId: String) {
            self.defaultAction = defaultAction
            self.updates = updates
            self.changeToken = changeToken
            self.webACLId = webACLId
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case updates = "Updates"
            case changeToken = "ChangeToken"
            case webACLId = "WebACLId"
        }
    }

    public struct GetWebACLRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "WebACLId", required: true, type: .string)
        ]
        /// The WebACLId of the WebACL that you want to get. WebACLId is returned by CreateWebACL and by ListWebACLs.
        public let webACLId: String

        public init(webACLId: String) {
            self.webACLId = webACLId
        }

        private enum CodingKeys: String, CodingKey {
            case webACLId = "WebACLId"
        }
    }

    public enum ParameterExceptionReason: String, CustomStringConvertible, Codable {
        case invalid_option = "INVALID_OPTION"
        case illegal_combination = "ILLEGAL_COMBINATION"
        public var description: String { return self.rawValue }
    }

    public enum RateKey: String, CustomStringConvertible, Codable {
        case ip = "IP"
        public var description: String { return self.rawValue }
    }

    public struct ListSqlInjectionMatchSetsRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Limit", required: false, type: .integer), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// Specifies the number of SqlInjectionMatchSet objects that you want AWS WAF to return for this request. If you have more SqlInjectionMatchSet objects than the number you specify for Limit, the response includes a NextMarker value that you can use to get another batch of Rules.
        public let limit: Int32?
        /// If you specify a value for Limit and you have more SqlInjectionMatchSet objects than the value of Limit, AWS WAF returns a NextMarker value in the response that allows you to list another group of SqlInjectionMatchSets. For the second and subsequent ListSqlInjectionMatchSets requests, specify the value of NextMarker from the previous response to get information about another batch of SqlInjectionMatchSets.
        public let nextMarker: String?

        public init(limit: Int32? = nil, nextMarker: String? = nil) {
            self.limit = limit
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "Limit"
            case nextMarker = "NextMarker"
        }
    }

    public struct ListRulesResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "Rules", required: false, type: .list), 
            AWSShapeMember(label: "NextMarker", required: false, type: .string)
        ]
        /// An array of RuleSummary objects.
        public let rules: [RuleSummary]?
        /// If you have more Rules than the number that you specified for Limit in the request, the response includes a NextMarker value. To list more Rules, submit another ListRules request, and specify the NextMarker value from the response in the NextMarker value in the next request.
        public let nextMarker: String?

        public init(rules: [RuleSummary]? = nil, nextMarker: String? = nil) {
            self.rules = rules
            self.nextMarker = nextMarker
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
            case nextMarker = "NextMarker"
        }
    }

    public struct ByteMatchSet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ByteMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "ByteMatchTuples", required: true, type: .list)
        ]
        /// The ByteMatchSetId for a ByteMatchSet. You use ByteMatchSetId to get information about a ByteMatchSet (see GetByteMatchSet), update a ByteMatchSet (see UpdateByteMatchSet), insert a ByteMatchSet into a Rule or delete one from a Rule (see UpdateRule), and delete a ByteMatchSet from AWS WAF (see DeleteByteMatchSet).  ByteMatchSetId is returned by CreateByteMatchSet and by ListByteMatchSets.
        public let byteMatchSetId: String
        /// A friendly name or description of the ByteMatchSet. You can't change Name after you create a ByteMatchSet.
        public let name: String?
        /// Specifies the bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings.
        public let byteMatchTuples: [ByteMatchTuple]

        public init(byteMatchSetId: String, name: String? = nil, byteMatchTuples: [ByteMatchTuple]) {
            self.byteMatchSetId = byteMatchSetId
            self.name = name
            self.byteMatchTuples = byteMatchTuples
        }

        private enum CodingKeys: String, CodingKey {
            case byteMatchSetId = "ByteMatchSetId"
            case name = "Name"
            case byteMatchTuples = "ByteMatchTuples"
        }
    }

    public struct CreateRateBasedRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: true, type: .string), 
            AWSShapeMember(label: "RateLimit", required: true, type: .long), 
            AWSShapeMember(label: "ChangeToken", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "RateKey", required: true, type: .enum)
        ]
        /// A friendly name or description for the metrics for this RateBasedRule. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change the name of the metric after you create the RateBasedRule.
        public let metricName: String
        /// The maximum number of requests, which have an identical value in the field that is specified by RateKey, allowed in a five-minute period. If the number of requests exceeds the RateLimit and the other predicates specified in the rule are also met, AWS WAF triggers the action that is specified for this rule.
        public let rateLimit: Int64
        /// The ChangeToken that you used to submit the CreateRateBasedRule request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String
        /// A friendly name or description of the RateBasedRule. You can't change the name of a RateBasedRule after you create it.
        public let name: String
        /// The field that AWS WAF uses to determine if requests are likely arriving from a single source and thus subject to rate monitoring. The only valid value for RateKey is IP. IP indicates that requests that arrive from the same IP address are subject to the RateLimit that is specified in the RateBasedRule.
        public let rateKey: RateKey

        public init(metricName: String, rateLimit: Int64, changeToken: String, name: String, rateKey: RateKey) {
            self.metricName = metricName
            self.rateLimit = rateLimit
            self.changeToken = changeToken
            self.name = name
            self.rateKey = rateKey
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case rateLimit = "RateLimit"
            case changeToken = "ChangeToken"
            case name = "Name"
            case rateKey = "RateKey"
        }
    }

    public struct DeleteSqlInjectionMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteSqlInjectionMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct GetSampledRequestsResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "PopulationSize", required: false, type: .long), 
            AWSShapeMember(label: "SampledRequests", required: false, type: .list), 
            AWSShapeMember(label: "TimeWindow", required: false, type: .structure)
        ]
        /// The total number of requests from which GetSampledRequests got a sample of MaxItems requests. If PopulationSize is less than MaxItems, the sample includes every request that your AWS resource received during the specified time range.
        public let populationSize: Int64?
        /// A complex type that contains detailed information about each of the requests in the sample.
        public let sampledRequests: [SampledHTTPRequest]?
        /// Usually, TimeWindow is the time range that you specified in the GetSampledRequests request. However, if your AWS resource received more than 5,000 requests during the time range that you specified in the request, GetSampledRequests returns the time range for the first 5,000 requests.
        public let timeWindow: TimeWindow?

        public init(populationSize: Int64? = nil, sampledRequests: [SampledHTTPRequest]? = nil, timeWindow: TimeWindow? = nil) {
            self.populationSize = populationSize
            self.sampledRequests = sampledRequests
            self.timeWindow = timeWindow
        }

        private enum CodingKeys: String, CodingKey {
            case populationSize = "PopulationSize"
            case sampledRequests = "SampledRequests"
            case timeWindow = "TimeWindow"
        }
    }

    public struct DeleteXssMatchSetResponse: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChangeToken", required: false, type: .string)
        ]
        /// The ChangeToken that you used to submit the DeleteXssMatchSet request. You can also use this value to query the status of the request. For more information, see GetChangeTokenStatus.
        public let changeToken: String?

        public init(changeToken: String? = nil) {
            self.changeToken = changeToken
        }

        private enum CodingKeys: String, CodingKey {
            case changeToken = "ChangeToken"
        }
    }

    public struct XssMatchSet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "XssMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "XssMatchTuples", required: true, type: .list)
        ]
        /// A unique identifier for an XssMatchSet. You use XssMatchSetId to get information about an XssMatchSet (see GetXssMatchSet), update an XssMatchSet (see UpdateXssMatchSet), insert an XssMatchSet into a Rule or delete one from a Rule (see UpdateRule), and delete an XssMatchSet from AWS WAF (see DeleteXssMatchSet).  XssMatchSetId is returned by CreateXssMatchSet and by ListXssMatchSets.
        public let xssMatchSetId: String
        /// The name, if any, of the XssMatchSet.
        public let name: String?
        /// Specifies the parts of web requests that you want to inspect for cross-site scripting attacks.
        public let xssMatchTuples: [XssMatchTuple]

        public init(xssMatchSetId: String, name: String? = nil, xssMatchTuples: [XssMatchTuple]) {
            self.xssMatchSetId = xssMatchSetId
            self.name = name
            self.xssMatchTuples = xssMatchTuples
        }

        private enum CodingKeys: String, CodingKey {
            case xssMatchSetId = "XssMatchSetId"
            case name = "Name"
            case xssMatchTuples = "XssMatchTuples"
        }
    }

    public struct GetRuleRequest: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleId", required: true, type: .string)
        ]
        /// The RuleId of the Rule that you want to get. RuleId is returned by CreateRule and by ListRules.
        public let ruleId: String

        public init(ruleId: String) {
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
        }
    }

    public struct WebACL: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "MetricName", required: false, type: .string), 
            AWSShapeMember(label: "DefaultAction", required: true, type: .structure), 
            AWSShapeMember(label: "Rules", required: true, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "WebACLId", required: true, type: .string)
        ]
        /// A friendly name or description for the metrics for this WebACL. The name can contain only alphanumeric characters (A-Z, a-z, 0-9); the name can't contain whitespace. You can't change MetricName after you create the WebACL.
        public let metricName: String?
        /// The action to perform if none of the Rules contained in the WebACL match. The action is specified by the WafAction object.
        public let defaultAction: WafAction
        /// An array that contains the action for each Rule in a WebACL, the priority of the Rule, and the ID of the Rule.
        public let rules: [ActivatedRule]
        /// A friendly name or description of the WebACL. You can't change the name of a WebACL after you create it.
        public let name: String?
        /// A unique identifier for a WebACL. You use WebACLId to get information about a WebACL (see GetWebACL), update a WebACL (see UpdateWebACL), and delete a WebACL from AWS WAF (see DeleteWebACL).  WebACLId is returned by CreateWebACL and by ListWebACLs.
        public let webACLId: String

        public init(metricName: String? = nil, defaultAction: WafAction, rules: [ActivatedRule], name: String? = nil, webACLId: String) {
            self.metricName = metricName
            self.defaultAction = defaultAction
            self.rules = rules
            self.name = name
            self.webACLId = webACLId
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case defaultAction = "DefaultAction"
            case rules = "Rules"
            case name = "Name"
            case webACLId = "WebACLId"
        }
    }

    public struct SqlInjectionMatchSet: AWSShape {
        /// The key for the payload
        public static var members: [AWSShapeMember] = [
            AWSShapeMember(label: "SqlInjectionMatchSetId", required: true, type: .string), 
            AWSShapeMember(label: "SqlInjectionMatchTuples", required: true, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]
        /// A unique identifier for a SqlInjectionMatchSet. You use SqlInjectionMatchSetId to get information about a SqlInjectionMatchSet (see GetSqlInjectionMatchSet), update a SqlInjectionMatchSet (see UpdateSqlInjectionMatchSet), insert a SqlInjectionMatchSet into a Rule or delete one from a Rule (see UpdateRule), and delete a SqlInjectionMatchSet from AWS WAF (see DeleteSqlInjectionMatchSet).  SqlInjectionMatchSetId is returned by CreateSqlInjectionMatchSet and by ListSqlInjectionMatchSets.
        public let sqlInjectionMatchSetId: String
        /// Specifies the parts of web requests that you want to inspect for snippets of malicious SQL code.
        public let sqlInjectionMatchTuples: [SqlInjectionMatchTuple]
        /// The name, if any, of the SqlInjectionMatchSet.
        public let name: String?

        public init(sqlInjectionMatchSetId: String, sqlInjectionMatchTuples: [SqlInjectionMatchTuple], name: String? = nil) {
            self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
            self.sqlInjectionMatchTuples = sqlInjectionMatchTuples
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
            case sqlInjectionMatchTuples = "SqlInjectionMatchTuples"
            case name = "Name"
        }
    }

}