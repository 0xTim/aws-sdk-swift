// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
/**
The MIT License (MIT)

Copyright (c) 2017 Yuki Takei(noppoMan)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

import Foundation
import AWSSDKSwiftCore

extension Dax {

    public struct NodeTypeSpecificValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Value", required: false, type: .string), 
            AWSShapeProperty(label: "NodeType", required: false, type: .string)
        ]
        /// The parameter value for this node type.
        public let value: String?
        /// A node type to which the parameter value applies.
        public let nodeType: String?

        public init(value: String? = nil, nodeType: String? = nil) {
            self.value = value
            self.nodeType = nodeType
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.nodeType = dictionary["NodeType"] as? String
        }
    }

    public struct UpdateSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetGroup", required: false, type: .structure)
        ]
        /// The subnet group that has been modified.
        public let subnetGroup: SubnetGroup?

        public init(subnetGroup: SubnetGroup? = nil) {
            self.subnetGroup = subnetGroup
        }

        public init(dictionary: [String: Any]) throws {
            if let subnetGroup = dictionary["SubnetGroup"] as? [String: Any] { self.subnetGroup = try Dax.SubnetGroup(dictionary: subnetGroup) } else { self.subnetGroup = nil }
        }
    }

    public struct TagResourceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Tags", required: true, type: .list), 
            AWSShapeProperty(label: "ResourceName", required: true, type: .string)
        ]
        /// The tags to be assigned to the DAX resource. 
        public let tags: [Tag]
        /// The name of the DAX resource to which tags should be added.
        public let resourceName: String

        public init(tags: [Tag], resourceName: String) {
            self.tags = tags
            self.resourceName = resourceName
        }

        public init(dictionary: [String: Any]) throws {
            guard let tags = dictionary["Tags"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("Tags") }
            self.tags = try tags.map({ try Tag(dictionary: $0) })
            guard let resourceName = dictionary["ResourceName"] as? String else { throw InitializableError.missingRequiredParam("ResourceName") }
            self.resourceName = resourceName
        }
    }

    public struct UpdateSubnetGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetIds", required: false, type: .list), 
            AWSShapeProperty(label: "SubnetGroupName", required: true, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// A list of subnet IDs in the subnet group.
        public let subnetIds: [String]?
        /// The name of the subnet group.
        public let subnetGroupName: String
        /// A description of the subnet group.
        public let description: String?

        public init(subnetIds: [String]? = nil, subnetGroupName: String, description: String? = nil) {
            self.subnetIds = subnetIds
            self.subnetGroupName = subnetGroupName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetIds = dictionary["SubnetIds"] as? [String]
            guard let subnetGroupName = dictionary["SubnetGroupName"] as? String else { throw InitializableError.missingRequiredParam("SubnetGroupName") }
            self.subnetGroupName = subnetGroupName
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateSubnetGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetIds", required: true, type: .list), 
            AWSShapeProperty(label: "SubnetGroupName", required: true, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// A list of VPC subnet IDs for the subnet group.
        public let subnetIds: [String]
        /// A name for the subnet group. This value is stored as a lowercase string. 
        public let subnetGroupName: String
        /// A description for the subnet group
        public let description: String?

        public init(subnetIds: [String], subnetGroupName: String, description: String? = nil) {
            self.subnetIds = subnetIds
            self.subnetGroupName = subnetGroupName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetIds = dictionary["SubnetIds"] as? [String] else { throw InitializableError.missingRequiredParam("SubnetIds") }
            self.subnetIds = subnetIds
            guard let subnetGroupName = dictionary["SubnetGroupName"] as? String else { throw InitializableError.missingRequiredParam("SubnetGroupName") }
            self.subnetGroupName = subnetGroupName
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeParametersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Source", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterGroupName", required: true, type: .string), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// How the parameter is defined. For example, system denotes a system-defined parameter.
        public let source: String?
        /// The name of the parameter group.
        public let parameterGroupName: String
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
        public let maxResults: Int32?

        public init(source: String? = nil, parameterGroupName: String, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.source = source
            self.parameterGroupName = parameterGroupName
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.source = dictionary["Source"] as? String
            guard let parameterGroupName = dictionary["ParameterGroupName"] as? String else { throw InitializableError.missingRequiredParam("ParameterGroupName") }
            self.parameterGroupName = parameterGroupName
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct NotificationConfiguration: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "TopicStatus", required: false, type: .string), 
            AWSShapeProperty(label: "TopicArn", required: false, type: .string)
        ]
        /// The current state of the topic.
        public let topicStatus: String?
        /// The Amazon Resource Name (ARN) that identifies the topic. 
        public let topicArn: String?

        public init(topicStatus: String? = nil, topicArn: String? = nil) {
            self.topicStatus = topicStatus
            self.topicArn = topicArn
        }

        public init(dictionary: [String: Any]) throws {
            self.topicStatus = dictionary["TopicStatus"] as? String
            self.topicArn = dictionary["TopicArn"] as? String
        }
    }

    public struct ListTagsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "Tags", required: false, type: .list)
        ]
        /// If this value is present, there are additional results to be displayed. To retrieve them, call ListTags again, with NextToken set to this value.
        public let nextToken: String?
        /// A list of tags currently associated with the DAX cluster.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
        }
    }

    public struct RebootNodeResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Cluster", required: false, type: .structure)
        ]
        /// A description of the DAX cluster after a node has been rebooted.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        public init(dictionary: [String: Any]) throws {
            if let cluster = dictionary["Cluster"] as? [String: Any] { self.cluster = try Dax.Cluster(dictionary: cluster) } else { self.cluster = nil }
        }
    }

    public enum ChangeType: String, CustomStringConvertible {
        case immediate = "IMMEDIATE"
        case requires_reboot = "REQUIRES_REBOOT"
        public var description: String { return self.rawValue }
    }

    public struct Endpoint: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Address", required: false, type: .string), 
            AWSShapeProperty(label: "Port", required: false, type: .integer)
        ]
        /// The DNS hostname of the endpoint.
        public let address: String?
        /// The port number that applications should use to connect to the endpoint.
        public let port: Int32?

        public init(address: String? = nil, port: Int32? = nil) {
            self.address = address
            self.port = port
        }

        public init(dictionary: [String: Any]) throws {
            self.address = dictionary["Address"] as? String
            self.port = dictionary["Port"] as? Int32
        }
    }

    public struct ParameterNameValue: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterName", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterValue", required: false, type: .string)
        ]
        /// The name of the parameter.
        public let parameterName: String?
        /// The value of the parameter.
        public let parameterValue: String?

        public init(parameterName: String? = nil, parameterValue: String? = nil) {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }

        public init(dictionary: [String: Any]) throws {
            self.parameterName = dictionary["ParameterName"] as? String
            self.parameterValue = dictionary["ParameterValue"] as? String
        }
    }

    public struct CreateClusterResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Cluster", required: false, type: .structure)
        ]
        /// A description of the DAX cluster that you have created.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        public init(dictionary: [String: Any]) throws {
            if let cluster = dictionary["Cluster"] as? [String: Any] { self.cluster = try Dax.Cluster(dictionary: cluster) } else { self.cluster = nil }
        }
    }

    public struct DeleteSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "DeletionMessage", required: false, type: .string)
        ]
        /// A user-specified message for this action (i.e., a reason for deleting the subnet group).
        public let deletionMessage: String?

        public init(deletionMessage: String? = nil) {
            self.deletionMessage = deletionMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.deletionMessage = dictionary["DeletionMessage"] as? String
        }
    }

    public struct IncreaseReplicationFactorResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Cluster", required: false, type: .structure)
        ]
        /// A description of the DAX cluster. with its new replication factor.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        public init(dictionary: [String: Any]) throws {
            if let cluster = dictionary["Cluster"] as? [String: Any] { self.cluster = try Dax.Cluster(dictionary: cluster) } else { self.cluster = nil }
        }
    }

    public struct UpdateParameterGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterGroup", required: false, type: .structure)
        ]
        /// The parameter group that has been modified.
        public let parameterGroup: ParameterGroup?

        public init(parameterGroup: ParameterGroup? = nil) {
            self.parameterGroup = parameterGroup
        }

        public init(dictionary: [String: Any]) throws {
            if let parameterGroup = dictionary["ParameterGroup"] as? [String: Any] { self.parameterGroup = try Dax.ParameterGroup(dictionary: parameterGroup) } else { self.parameterGroup = nil }
        }
    }

    public struct CreateParameterGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterGroup", required: false, type: .structure)
        ]
        /// Represents the output of a CreateParameterGroup action.
        public let parameterGroup: ParameterGroup?

        public init(parameterGroup: ParameterGroup? = nil) {
            self.parameterGroup = parameterGroup
        }

        public init(dictionary: [String: Any]) throws {
            if let parameterGroup = dictionary["ParameterGroup"] as? [String: Any] { self.parameterGroup = try Dax.ParameterGroup(dictionary: parameterGroup) } else { self.parameterGroup = nil }
        }
    }

    public struct UpdateParameterGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterNameValues", required: true, type: .list), 
            AWSShapeProperty(label: "ParameterGroupName", required: true, type: .string)
        ]
        /// An array of name-value pairs for the parameters in the group. Each element in the array represents a single parameter.
        public let parameterNameValues: [ParameterNameValue]
        /// The name of the parameter group.
        public let parameterGroupName: String

        public init(parameterNameValues: [ParameterNameValue], parameterGroupName: String) {
            self.parameterNameValues = parameterNameValues
            self.parameterGroupName = parameterGroupName
        }

        public init(dictionary: [String: Any]) throws {
            guard let parameterNameValues = dictionary["ParameterNameValues"] as? [[String: Any]] else { throw InitializableError.missingRequiredParam("ParameterNameValues") }
            self.parameterNameValues = try parameterNameValues.map({ try ParameterNameValue(dictionary: $0) })
            guard let parameterGroupName = dictionary["ParameterGroupName"] as? String else { throw InitializableError.missingRequiredParam("ParameterGroupName") }
            self.parameterGroupName = parameterGroupName
        }
    }

    public struct DescribeParameterGroupsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterGroupNames", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// The names of the parameter groups.
        public let parameterGroupNames: [String]?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
        public let maxResults: Int32?

        public init(parameterGroupNames: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.parameterGroupNames = parameterGroupNames
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.parameterGroupNames = dictionary["ParameterGroupNames"] as? [String]
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct Tag: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Value", required: false, type: .string), 
            AWSShapeProperty(label: "Key", required: false, type: .string)
        ]
        /// The value of the tag. Tag values are case-sensitive and can be null. 
        public let value: String?
        /// The key for the tag. Tag keys are case sensitive. Every DAX cluster can only have one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        public let key: String?

        public init(value: String? = nil, key: String? = nil) {
            self.value = value
            self.key = key
        }

        public init(dictionary: [String: Any]) throws {
            self.value = dictionary["Value"] as? String
            self.key = dictionary["Key"] as? String
        }
    }

    public struct DeleteClusterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ClusterName", required: true, type: .string)
        ]
        /// The name of the cluster to be deleted.
        public let clusterName: String

        public init(clusterName: String) {
            self.clusterName = clusterName
        }

        public init(dictionary: [String: Any]) throws {
            guard let clusterName = dictionary["ClusterName"] as? String else { throw InitializableError.missingRequiredParam("ClusterName") }
            self.clusterName = clusterName
        }
    }

    public struct DecreaseReplicationFactorRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeProperty(label: "NodeIdsToRemove", required: false, type: .list), 
            AWSShapeProperty(label: "ClusterName", required: true, type: .string), 
            AWSShapeProperty(label: "NewReplicationFactor", required: true, type: .integer)
        ]
        /// The Availability Zone(s) from which to remove nodes.
        public let availabilityZones: [String]?
        /// The unique identifiers of the nodes to be removed from the cluster.
        public let nodeIdsToRemove: [String]?
        /// The name of the DAX cluster from which you want to remove nodes.
        public let clusterName: String
        /// The new number of nodes for the DAX cluster.
        public let newReplicationFactor: Int32

        public init(availabilityZones: [String]? = nil, nodeIdsToRemove: [String]? = nil, clusterName: String, newReplicationFactor: Int32) {
            self.availabilityZones = availabilityZones
            self.nodeIdsToRemove = nodeIdsToRemove
            self.clusterName = clusterName
            self.newReplicationFactor = newReplicationFactor
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
            self.nodeIdsToRemove = dictionary["NodeIdsToRemove"] as? [String]
            guard let clusterName = dictionary["ClusterName"] as? String else { throw InitializableError.missingRequiredParam("ClusterName") }
            self.clusterName = clusterName
            guard let newReplicationFactor = dictionary["NewReplicationFactor"] as? Int32 else { throw InitializableError.missingRequiredParam("NewReplicationFactor") }
            self.newReplicationFactor = newReplicationFactor
        }
    }

    public struct DescribeSubnetGroupsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "SubnetGroupNames", required: false, type: .list), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The name of the subnet group.
        public let subnetGroupNames: [String]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, subnetGroupNames: [String]? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.subnetGroupNames = subnetGroupNames
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.subnetGroupNames = dictionary["SubnetGroupNames"] as? [String]
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct DescribeParametersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Parameters", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// A list of parameters within a parameter group. Each element in the list represents one parameter.
        public let parameters: [Parameter]?
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?

        public init(parameters: [Parameter]? = nil, nextToken: String? = nil) {
            self.parameters = parameters
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let parameters = dictionary["Parameters"] as? [[String: Any]] {
                self.parameters = try parameters.map({ try Parameter(dictionary: $0) })
            } else { 
                self.parameters = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct ParameterGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Description", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterGroupName", required: false, type: .string)
        ]
        /// A description of the parameter group.
        public let description: String?
        /// The name of the parameter group.
        public let parameterGroupName: String?

        public init(description: String? = nil, parameterGroupName: String? = nil) {
            self.description = description
            self.parameterGroupName = parameterGroupName
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            self.parameterGroupName = dictionary["ParameterGroupName"] as? String
        }
    }

    public struct DescribeClustersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "Clusters", required: false, type: .list)
        ]
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// The descriptions of your DAX clusters, in response to a DescribeClusters request.
        public let clusters: [Cluster]?

        public init(nextToken: String? = nil, clusters: [Cluster]? = nil) {
            self.nextToken = nextToken
            self.clusters = clusters
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let clusters = dictionary["Clusters"] as? [[String: Any]] {
                self.clusters = try clusters.map({ try Cluster(dictionary: $0) })
            } else { 
                self.clusters = nil
            }
        }
    }

    public enum SourceType: String, CustomStringConvertible {
        case cluster = "CLUSTER"
        case parameter_group = "PARAMETER_GROUP"
        case subnet_group = "SUBNET_GROUP"
        public var description: String { return self.rawValue }
    }

    public struct DescribeEventsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "SourceName", required: false, type: .string), 
            AWSShapeProperty(label: "SourceType", required: false, type: .enum), 
            AWSShapeProperty(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "Duration", required: false, type: .integer), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format.
        public let startTime: String?
        /// The identifier of the event source for which events will be returned. If not specified, then all sources are included in the response.
        public let sourceName: String?
        /// The event source to retrieve events for. If no value is specified, all events are returned.
        public let sourceType: SourceType?
        /// The end of the time interval for which to retrieve events, specified in ISO 8601 format.
        public let endTime: String?
        /// The number of minutes' worth of events to retrieve.
        public let duration: Int32?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
        public let maxResults: Int32?

        public init(startTime: String? = nil, sourceName: String? = nil, sourceType: SourceType? = nil, endTime: String? = nil, duration: Int32? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.startTime = startTime
            self.sourceName = sourceName
            self.sourceType = sourceType
            self.endTime = endTime
            self.duration = duration
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.startTime = dictionary["StartTime"] as? String
            self.sourceName = dictionary["SourceName"] as? String
            if let sourceType = dictionary["SourceType"] as? String { self.sourceType = SourceType(rawValue: sourceType) } else { self.sourceType = nil }
            self.endTime = dictionary["EndTime"] as? String
            self.duration = dictionary["Duration"] as? Int32
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct UpdateClusterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NotificationTopicArn", required: false, type: .string), 
            AWSShapeProperty(label: "NotificationTopicStatus", required: false, type: .string), 
            AWSShapeProperty(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeProperty(label: "ClusterName", required: true, type: .string), 
            AWSShapeProperty(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeProperty(label: "ParameterGroupName", required: false, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// The Amazon Resource Name (ARN) that identifies the topic.
        public let notificationTopicArn: String?
        /// The current state of the topic.
        public let notificationTopicStatus: String?
        /// A range of time when maintenance of DAX cluster software will be performed. For example: sun:01:00-sun:09:00. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.
        public let preferredMaintenanceWindow: String?
        /// The name of the DAX cluster to be modified.
        public let clusterName: String
        /// A list of user-specified security group IDs to be assigned to each node in the DAX cluster. If this parameter is not specified, DAX assigns the default VPC security group to each node.
        public let securityGroupIds: [String]?
        /// The name of a parameter group for this cluster.
        public let parameterGroupName: String?
        /// A description of the changes being made to the cluster.
        public let description: String?

        public init(notificationTopicArn: String? = nil, notificationTopicStatus: String? = nil, preferredMaintenanceWindow: String? = nil, clusterName: String, securityGroupIds: [String]? = nil, parameterGroupName: String? = nil, description: String? = nil) {
            self.notificationTopicArn = notificationTopicArn
            self.notificationTopicStatus = notificationTopicStatus
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.clusterName = clusterName
            self.securityGroupIds = securityGroupIds
            self.parameterGroupName = parameterGroupName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.notificationTopicArn = dictionary["NotificationTopicArn"] as? String
            self.notificationTopicStatus = dictionary["NotificationTopicStatus"] as? String
            self.preferredMaintenanceWindow = dictionary["PreferredMaintenanceWindow"] as? String
            guard let clusterName = dictionary["ClusterName"] as? String else { throw InitializableError.missingRequiredParam("ClusterName") }
            self.clusterName = clusterName
            self.securityGroupIds = dictionary["SecurityGroupIds"] as? [String]
            self.parameterGroupName = dictionary["ParameterGroupName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DeleteSubnetGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetGroupName", required: true, type: .string)
        ]
        /// The name of the subnet group to delete.
        public let subnetGroupName: String

        public init(subnetGroupName: String) {
            self.subnetGroupName = subnetGroupName
        }

        public init(dictionary: [String: Any]) throws {
            guard let subnetGroupName = dictionary["SubnetGroupName"] as? String else { throw InitializableError.missingRequiredParam("SubnetGroupName") }
            self.subnetGroupName = subnetGroupName
        }
    }

    public struct DeleteParameterGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "DeletionMessage", required: false, type: .string)
        ]
        /// A user-specified message for this action (i.e., a reason for deleting the parameter group).
        public let deletionMessage: String?

        public init(deletionMessage: String? = nil) {
            self.deletionMessage = deletionMessage
        }

        public init(dictionary: [String: Any]) throws {
            self.deletionMessage = dictionary["DeletionMessage"] as? String
        }
    }

    public struct SubnetGroup: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetGroupName", required: false, type: .string), 
            AWSShapeProperty(label: "Subnets", required: false, type: .list), 
            AWSShapeProperty(label: "VpcId", required: false, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// The name of the subnet group.
        public let subnetGroupName: String?
        /// A list of subnets associated with the subnet group. 
        public let subnets: [Subnet]?
        /// The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.
        public let vpcId: String?
        /// The description of the subnet group.
        public let description: String?

        public init(subnetGroupName: String? = nil, subnets: [Subnet]? = nil, vpcId: String? = nil, description: String? = nil) {
            self.subnetGroupName = subnetGroupName
            self.subnets = subnets
            self.vpcId = vpcId
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetGroupName = dictionary["SubnetGroupName"] as? String
            if let subnets = dictionary["Subnets"] as? [[String: Any]] {
                self.subnets = try subnets.map({ try Subnet(dictionary: $0) })
            } else { 
                self.subnets = nil
            }
            self.vpcId = dictionary["VpcId"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateParameterGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Description", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterGroupName", required: true, type: .string)
        ]
        /// A description of the parameter group.
        public let description: String?
        /// The name of the parameter group to apply to all of the clusters in this replication group.
        public let parameterGroupName: String

        public init(description: String? = nil, parameterGroupName: String) {
            self.description = description
            self.parameterGroupName = parameterGroupName
        }

        public init(dictionary: [String: Any]) throws {
            self.description = dictionary["Description"] as? String
            guard let parameterGroupName = dictionary["ParameterGroupName"] as? String else { throw InitializableError.missingRequiredParam("ParameterGroupName") }
            self.parameterGroupName = parameterGroupName
        }
    }

    public struct DescribeDefaultParametersResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Parameters", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// A list of parameters. Each element in the list represents one parameter.
        public let parameters: [Parameter]?
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?

        public init(parameters: [Parameter]? = nil, nextToken: String? = nil) {
            self.parameters = parameters
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let parameters = dictionary["Parameters"] as? [[String: Any]] {
                self.parameters = try parameters.map({ try Parameter(dictionary: $0) })
            } else { 
                self.parameters = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct SecurityGroupMembership: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Status", required: false, type: .string), 
            AWSShapeProperty(label: "SecurityGroupIdentifier", required: false, type: .string)
        ]
        /// The status of this security group.
        public let status: String?
        /// The unique ID for this security group.
        public let securityGroupIdentifier: String?

        public init(status: String? = nil, securityGroupIdentifier: String? = nil) {
            self.status = status
            self.securityGroupIdentifier = securityGroupIdentifier
        }

        public init(dictionary: [String: Any]) throws {
            self.status = dictionary["Status"] as? String
            self.securityGroupIdentifier = dictionary["SecurityGroupIdentifier"] as? String
        }
    }

    public struct IncreaseReplicationFactorRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeProperty(label: "ClusterName", required: true, type: .string), 
            AWSShapeProperty(label: "NewReplicationFactor", required: true, type: .integer)
        ]
        /// The Availability Zones (AZs) in which the cluster nodes will be created. All nodes belonging to the cluster are placed in these Availability Zones. Use this parameter if you want to distribute the nodes across multiple AZs.
        public let availabilityZones: [String]?
        /// The name of the DAX cluster that will receive additional nodes.
        public let clusterName: String
        /// The new number of nodes for the DAX cluster.
        public let newReplicationFactor: Int32

        public init(availabilityZones: [String]? = nil, clusterName: String, newReplicationFactor: Int32) {
            self.availabilityZones = availabilityZones
            self.clusterName = clusterName
            self.newReplicationFactor = newReplicationFactor
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
            guard let clusterName = dictionary["ClusterName"] as? String else { throw InitializableError.missingRequiredParam("ClusterName") }
            self.clusterName = clusterName
            guard let newReplicationFactor = dictionary["NewReplicationFactor"] as? Int32 else { throw InitializableError.missingRequiredParam("NewReplicationFactor") }
            self.newReplicationFactor = newReplicationFactor
        }
    }

    public struct DescribeEventsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "Events", required: false, type: .list)
        ]
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// An array of events. Each element in the array represents one event.
        public let events: [Event]?

        public init(nextToken: String? = nil, events: [Event]? = nil) {
            self.nextToken = nextToken
            self.events = events
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let events = dictionary["Events"] as? [[String: Any]] {
                self.events = try events.map({ try Event(dictionary: $0) })
            } else { 
                self.events = nil
            }
        }
    }

    public struct Cluster: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ClusterDiscoveryEndpoint", required: false, type: .structure), 
            AWSShapeProperty(label: "ClusterName", required: false, type: .string), 
            AWSShapeProperty(label: "NodeType", required: false, type: .string), 
            AWSShapeProperty(label: "TotalNodes", required: false, type: .integer), 
            AWSShapeProperty(label: "SubnetGroup", required: false, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterGroup", required: false, type: .structure), 
            AWSShapeProperty(label: "Nodes", required: false, type: .list), 
            AWSShapeProperty(label: "Status", required: false, type: .string), 
            AWSShapeProperty(label: "SecurityGroups", required: false, type: .list), 
            AWSShapeProperty(label: "IamRoleArn", required: false, type: .string), 
            AWSShapeProperty(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeProperty(label: "ActiveNodes", required: false, type: .integer), 
            AWSShapeProperty(label: "NotificationConfiguration", required: false, type: .structure), 
            AWSShapeProperty(label: "NodeIdsToRemove", required: false, type: .list), 
            AWSShapeProperty(label: "ClusterArn", required: false, type: .string)
        ]
        /// The configuration endpoint for this DAX cluster, consisting of a DNS name and a port number. Client applications can specify this endpoint, rather than an individual node endpoint, and allow the DAX client software to intelligently route requests and responses to nodes in the DAX cluster.
        public let clusterDiscoveryEndpoint: Endpoint?
        /// The name of the DAX cluster.
        public let clusterName: String?
        /// The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)
        public let nodeType: String?
        /// The total number of nodes in the cluster.
        public let totalNodes: Int32?
        /// The subnet group where the DAX cluster is running.
        public let subnetGroup: String?
        /// The description of the cluster.
        public let description: String?
        /// The parameter group being used by nodes in the cluster.
        public let parameterGroup: ParameterGroupStatus?
        /// A list of nodes that are currently in the cluster.
        public let nodes: [Node]?
        /// The current status of the cluster.
        public let status: String?
        /// A list of security groups, and the status of each, for the nodes in the cluster.
        public let securityGroups: [SecurityGroupMembership]?
        /// A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.
        public let iamRoleArn: String?
        /// A range of time when maintenance of DAX cluster software will be performed. For example: sun:01:00-sun:09:00. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.
        public let preferredMaintenanceWindow: String?
        /// The number of nodes in the cluster that are active (i.e., capable of serving requests).
        public let activeNodes: Int32?
        /// Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).
        public let notificationConfiguration: NotificationConfiguration?
        /// A list of nodes to be removed from the cluster.
        public let nodeIdsToRemove: [String]?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster. 
        public let clusterArn: String?

        public init(clusterDiscoveryEndpoint: Endpoint? = nil, clusterName: String? = nil, nodeType: String? = nil, totalNodes: Int32? = nil, subnetGroup: String? = nil, description: String? = nil, parameterGroup: ParameterGroupStatus? = nil, nodes: [Node]? = nil, status: String? = nil, securityGroups: [SecurityGroupMembership]? = nil, iamRoleArn: String? = nil, preferredMaintenanceWindow: String? = nil, activeNodes: Int32? = nil, notificationConfiguration: NotificationConfiguration? = nil, nodeIdsToRemove: [String]? = nil, clusterArn: String? = nil) {
            self.clusterDiscoveryEndpoint = clusterDiscoveryEndpoint
            self.clusterName = clusterName
            self.nodeType = nodeType
            self.totalNodes = totalNodes
            self.subnetGroup = subnetGroup
            self.description = description
            self.parameterGroup = parameterGroup
            self.nodes = nodes
            self.status = status
            self.securityGroups = securityGroups
            self.iamRoleArn = iamRoleArn
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.activeNodes = activeNodes
            self.notificationConfiguration = notificationConfiguration
            self.nodeIdsToRemove = nodeIdsToRemove
            self.clusterArn = clusterArn
        }

        public init(dictionary: [String: Any]) throws {
            if let clusterDiscoveryEndpoint = dictionary["ClusterDiscoveryEndpoint"] as? [String: Any] { self.clusterDiscoveryEndpoint = try Dax.Endpoint(dictionary: clusterDiscoveryEndpoint) } else { self.clusterDiscoveryEndpoint = nil }
            self.clusterName = dictionary["ClusterName"] as? String
            self.nodeType = dictionary["NodeType"] as? String
            self.totalNodes = dictionary["TotalNodes"] as? Int32
            self.subnetGroup = dictionary["SubnetGroup"] as? String
            self.description = dictionary["Description"] as? String
            if let parameterGroup = dictionary["ParameterGroup"] as? [String: Any] { self.parameterGroup = try Dax.ParameterGroupStatus(dictionary: parameterGroup) } else { self.parameterGroup = nil }
            if let nodes = dictionary["Nodes"] as? [[String: Any]] {
                self.nodes = try nodes.map({ try Node(dictionary: $0) })
            } else { 
                self.nodes = nil
            }
            self.status = dictionary["Status"] as? String
            if let securityGroups = dictionary["SecurityGroups"] as? [[String: Any]] {
                self.securityGroups = try securityGroups.map({ try SecurityGroupMembership(dictionary: $0) })
            } else { 
                self.securityGroups = nil
            }
            self.iamRoleArn = dictionary["IamRoleArn"] as? String
            self.preferredMaintenanceWindow = dictionary["PreferredMaintenanceWindow"] as? String
            self.activeNodes = dictionary["ActiveNodes"] as? Int32
            if let notificationConfiguration = dictionary["NotificationConfiguration"] as? [String: Any] { self.notificationConfiguration = try Dax.NotificationConfiguration(dictionary: notificationConfiguration) } else { self.notificationConfiguration = nil }
            self.nodeIdsToRemove = dictionary["NodeIdsToRemove"] as? [String]
            self.clusterArn = dictionary["ClusterArn"] as? String
        }
    }

    public struct DescribeParameterGroupsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterGroups", required: false, type: .list)
        ]
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// An array of parameter groups. Each element in the array represents one parameter group.
        public let parameterGroups: [ParameterGroup]?

        public init(nextToken: String? = nil, parameterGroups: [ParameterGroup]? = nil) {
            self.nextToken = nextToken
            self.parameterGroups = parameterGroups
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            if let parameterGroups = dictionary["ParameterGroups"] as? [[String: Any]] {
                self.parameterGroups = try parameterGroups.map({ try ParameterGroup(dictionary: $0) })
            } else { 
                self.parameterGroups = nil
            }
        }
    }

    public struct Subnet: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetIdentifier", required: false, type: .string), 
            AWSShapeProperty(label: "SubnetAvailabilityZone", required: false, type: .string)
        ]
        /// The system-assigned identifier for the subnet.
        public let subnetIdentifier: String?
        /// The Availability Zone (AZ) for subnet subnet.
        public let subnetAvailabilityZone: String?

        public init(subnetIdentifier: String? = nil, subnetAvailabilityZone: String? = nil) {
            self.subnetIdentifier = subnetIdentifier
            self.subnetAvailabilityZone = subnetAvailabilityZone
        }

        public init(dictionary: [String: Any]) throws {
            self.subnetIdentifier = dictionary["SubnetIdentifier"] as? String
            self.subnetAvailabilityZone = dictionary["SubnetAvailabilityZone"] as? String
        }
    }

    public enum IsModifiable: String, CustomStringConvertible {
        case `true` = "TRUE"
        case `false` = "FALSE"
        case conditional = "CONDITIONAL"
        public var description: String { return self.rawValue }
    }

    public struct Parameter: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterType", required: false, type: .enum), 
            AWSShapeProperty(label: "NodeTypeSpecificValues", required: false, type: .list), 
            AWSShapeProperty(label: "AllowedValues", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterValue", required: false, type: .string), 
            AWSShapeProperty(label: "DataType", required: false, type: .string), 
            AWSShapeProperty(label: "ParameterName", required: false, type: .string), 
            AWSShapeProperty(label: "Source", required: false, type: .string), 
            AWSShapeProperty(label: "IsModifiable", required: false, type: .enum), 
            AWSShapeProperty(label: "ChangeType", required: false, type: .enum), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// Determines whether the parameter can be applied to any nodes, or only nodes of a particular type.
        public let parameterType: ParameterType?
        /// A list of node types, and specific parameter values for each node.
        public let nodeTypeSpecificValues: [NodeTypeSpecificValue]?
        /// A range of values within which the parameter can be set.
        public let allowedValues: String?
        /// The value for the parameter.
        public let parameterValue: String?
        /// The data type of the parameter. For example, integer:
        public let dataType: String?
        /// The name of the parameter.
        public let parameterName: String?
        /// How the parameter is defined. For example, system denotes a system-defined parameter.
        public let source: String?
        /// Whether the customer is allowed to modify the parameter.
        public let isModifiable: IsModifiable?
        /// The conditions under which changes to this parameter can be applied. For example, requires-reboot indicates that a new value for this parameter will only take effect if a node is rebooted.
        public let changeType: ChangeType?
        /// A description of the parameter
        public let description: String?

        public init(parameterType: ParameterType? = nil, nodeTypeSpecificValues: [NodeTypeSpecificValue]? = nil, allowedValues: String? = nil, parameterValue: String? = nil, dataType: String? = nil, parameterName: String? = nil, source: String? = nil, isModifiable: IsModifiable? = nil, changeType: ChangeType? = nil, description: String? = nil) {
            self.parameterType = parameterType
            self.nodeTypeSpecificValues = nodeTypeSpecificValues
            self.allowedValues = allowedValues
            self.parameterValue = parameterValue
            self.dataType = dataType
            self.parameterName = parameterName
            self.source = source
            self.isModifiable = isModifiable
            self.changeType = changeType
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            if let parameterType = dictionary["ParameterType"] as? String { self.parameterType = ParameterType(rawValue: parameterType) } else { self.parameterType = nil }
            if let nodeTypeSpecificValues = dictionary["NodeTypeSpecificValues"] as? [[String: Any]] {
                self.nodeTypeSpecificValues = try nodeTypeSpecificValues.map({ try NodeTypeSpecificValue(dictionary: $0) })
            } else { 
                self.nodeTypeSpecificValues = nil
            }
            self.allowedValues = dictionary["AllowedValues"] as? String
            self.parameterValue = dictionary["ParameterValue"] as? String
            self.dataType = dictionary["DataType"] as? String
            self.parameterName = dictionary["ParameterName"] as? String
            self.source = dictionary["Source"] as? String
            if let isModifiable = dictionary["IsModifiable"] as? String { self.isModifiable = IsModifiable(rawValue: isModifiable) } else { self.isModifiable = nil }
            if let changeType = dictionary["ChangeType"] as? String { self.changeType = ChangeType(rawValue: changeType) } else { self.changeType = nil }
            self.description = dictionary["Description"] as? String
        }
    }

    public struct DescribeSubnetGroupsResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetGroups", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string)
        ]
        /// An array of subnet groups. Each element in the array represents a single subnet group.
        public let subnetGroups: [SubnetGroup]?
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?

        public init(subnetGroups: [SubnetGroup]? = nil, nextToken: String? = nil) {
            self.subnetGroups = subnetGroups
            self.nextToken = nextToken
        }

        public init(dictionary: [String: Any]) throws {
            if let subnetGroups = dictionary["SubnetGroups"] as? [[String: Any]] {
                self.subnetGroups = try subnetGroups.map({ try SubnetGroup(dictionary: $0) })
            } else { 
                self.subnetGroups = nil
            }
            self.nextToken = dictionary["NextToken"] as? String
        }
    }

    public struct DescribeDefaultParametersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
        public let maxResults: Int32?

        public init(nextToken: String? = nil, maxResults: Int32? = nil) {
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct TagResourceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Tags", required: false, type: .list)
        ]
        /// The list of tags that are associated with the DAX resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
        }
    }

    public struct Event: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SourceName", required: false, type: .string), 
            AWSShapeProperty(label: "Message", required: false, type: .string), 
            AWSShapeProperty(label: "SourceType", required: false, type: .enum), 
            AWSShapeProperty(label: "Date", required: false, type: .timestamp)
        ]
        /// The source of the event. For example, if the event occurred at the node level, the source would be the node ID.
        public let sourceName: String?
        /// A user-defined message associated with the event.
        public let message: String?
        /// Specifies the origin of this event - a cluster, a parameter group, a node ID, etc.
        public let sourceType: SourceType?
        /// The date and time when the event occurred.
        public let date: String?

        public init(sourceName: String? = nil, message: String? = nil, sourceType: SourceType? = nil, date: String? = nil) {
            self.sourceName = sourceName
            self.message = message
            self.sourceType = sourceType
            self.date = date
        }

        public init(dictionary: [String: Any]) throws {
            self.sourceName = dictionary["SourceName"] as? String
            self.message = dictionary["Message"] as? String
            if let sourceType = dictionary["SourceType"] as? String { self.sourceType = SourceType(rawValue: sourceType) } else { self.sourceType = nil }
            self.date = dictionary["Date"] as? String
        }
    }

    public struct CreateClusterRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeProperty(label: "ReplicationFactor", required: true, type: .integer), 
            AWSShapeProperty(label: "NotificationTopicArn", required: false, type: .string), 
            AWSShapeProperty(label: "IamRoleArn", required: true, type: .string), 
            AWSShapeProperty(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeProperty(label: "ClusterName", required: true, type: .string), 
            AWSShapeProperty(label: "NodeType", required: true, type: .string), 
            AWSShapeProperty(label: "SubnetGroupName", required: false, type: .string), 
            AWSShapeProperty(label: "Tags", required: false, type: .list), 
            AWSShapeProperty(label: "SecurityGroupIds", required: false, type: .list), 
            AWSShapeProperty(label: "ParameterGroupName", required: false, type: .string), 
            AWSShapeProperty(label: "Description", required: false, type: .string)
        ]
        /// The Availability Zones (AZs) in which the cluster nodes will be created. All nodes belonging to the cluster are placed in these Availability Zones. Use this parameter if you want to distribute the nodes across multiple AZs.
        public let availabilityZones: [String]?
        /// The number of nodes in the DAX cluster. A replication factor of 1 will create a single-node cluster, without any read replicas. For additional fault tolerance, you can create a multiple node cluster with one or more read replicas. To do this, set ReplicationFactor to 2 or more.  AWS recommends that you have at least two read replicas per cluster. 
        public let replicationFactor: Int32
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will be sent.  The Amazon SNS topic owner must be same as the DAX cluster owner. 
        public let notificationTopicArn: String?
        /// A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.
        public let iamRoleArn: String
        /// Specifies the weekly time range during which maintenance on the DAX cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ddd are:    sun     mon     tue     wed     thu     fri     sat    Example: sun:05:00-sun:09:00   If you don't specify a preferred maintenance window when you create or modify a cache cluster, DAX assigns a 60-minute maintenance window on a randomly selected day of the week. 
        public let preferredMaintenanceWindow: String?
        /// The cluster identifier. This parameter is stored as a lowercase string.  Constraints:    A name must contain from 1 to 20 alphanumeric characters or hyphens.   The first character must be a letter.   A name cannot end with a hyphen or contain two consecutive hyphens.  
        public let clusterName: String
        /// The compute and memory capacity of the nodes in the cluster.
        public let nodeType: String
        /// The name of the subnet group to be used for the replication group.  DAX clusters can only run in an Amazon VPC environment. All of the subnets that you specify in a subnet group must exist in the same VPC. 
        public let subnetGroupName: String?
        /// A set of tags to associate with the DAX cluster. 
        public let tags: [Tag]?
        /// A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the security group ID is system-generated.) If this parameter is not specified, DAX assigns the default VPC security group to each node.
        public let securityGroupIds: [String]?
        /// The parameter group to be associated with the DAX cluster.
        public let parameterGroupName: String?
        /// A description of the cluster.
        public let description: String?

        public init(availabilityZones: [String]? = nil, replicationFactor: Int32, notificationTopicArn: String? = nil, iamRoleArn: String, preferredMaintenanceWindow: String? = nil, clusterName: String, nodeType: String, subnetGroupName: String? = nil, tags: [Tag]? = nil, securityGroupIds: [String]? = nil, parameterGroupName: String? = nil, description: String? = nil) {
            self.availabilityZones = availabilityZones
            self.replicationFactor = replicationFactor
            self.notificationTopicArn = notificationTopicArn
            self.iamRoleArn = iamRoleArn
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.clusterName = clusterName
            self.nodeType = nodeType
            self.subnetGroupName = subnetGroupName
            self.tags = tags
            self.securityGroupIds = securityGroupIds
            self.parameterGroupName = parameterGroupName
            self.description = description
        }

        public init(dictionary: [String: Any]) throws {
            self.availabilityZones = dictionary["AvailabilityZones"] as? [String]
            guard let replicationFactor = dictionary["ReplicationFactor"] as? Int32 else { throw InitializableError.missingRequiredParam("ReplicationFactor") }
            self.replicationFactor = replicationFactor
            self.notificationTopicArn = dictionary["NotificationTopicArn"] as? String
            guard let iamRoleArn = dictionary["IamRoleArn"] as? String else { throw InitializableError.missingRequiredParam("IamRoleArn") }
            self.iamRoleArn = iamRoleArn
            self.preferredMaintenanceWindow = dictionary["PreferredMaintenanceWindow"] as? String
            guard let clusterName = dictionary["ClusterName"] as? String else { throw InitializableError.missingRequiredParam("ClusterName") }
            self.clusterName = clusterName
            guard let nodeType = dictionary["NodeType"] as? String else { throw InitializableError.missingRequiredParam("NodeType") }
            self.nodeType = nodeType
            self.subnetGroupName = dictionary["SubnetGroupName"] as? String
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
            self.securityGroupIds = dictionary["SecurityGroupIds"] as? [String]
            self.parameterGroupName = dictionary["ParameterGroupName"] as? String
            self.description = dictionary["Description"] as? String
        }
    }

    public struct CreateSubnetGroupResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "SubnetGroup", required: false, type: .structure)
        ]
        /// Represents the output of a CreateSubnetGroup operation.
        public let subnetGroup: SubnetGroup?

        public init(subnetGroup: SubnetGroup? = nil) {
            self.subnetGroup = subnetGroup
        }

        public init(dictionary: [String: Any]) throws {
            if let subnetGroup = dictionary["SubnetGroup"] as? [String: Any] { self.subnetGroup = try Dax.SubnetGroup(dictionary: subnetGroup) } else { self.subnetGroup = nil }
        }
    }

    public struct DeleteClusterResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Cluster", required: false, type: .structure)
        ]
        /// A description of the DAX cluster that is being deleted.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        public init(dictionary: [String: Any]) throws {
            if let cluster = dictionary["Cluster"] as? [String: Any] { self.cluster = try Dax.Cluster(dictionary: cluster) } else { self.cluster = nil }
        }
    }

    public struct RebootNodeRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NodeId", required: true, type: .string), 
            AWSShapeProperty(label: "ClusterName", required: true, type: .string)
        ]
        /// The system-assigned ID of the node to be rebooted.
        public let nodeId: String
        /// The name of the DAX cluster containing the node to be rebooted.
        public let clusterName: String

        public init(nodeId: String, clusterName: String) {
            self.nodeId = nodeId
            self.clusterName = clusterName
        }

        public init(dictionary: [String: Any]) throws {
            guard let nodeId = dictionary["NodeId"] as? String else { throw InitializableError.missingRequiredParam("NodeId") }
            self.nodeId = nodeId
            guard let clusterName = dictionary["ClusterName"] as? String else { throw InitializableError.missingRequiredParam("ClusterName") }
            self.clusterName = clusterName
        }
    }

    public struct ParameterGroupStatus: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterApplyStatus", required: false, type: .string), 
            AWSShapeProperty(label: "NodeIdsToReboot", required: false, type: .list), 
            AWSShapeProperty(label: "ParameterGroupName", required: false, type: .string)
        ]
        /// The status of parameter updates. 
        public let parameterApplyStatus: String?
        /// The node IDs of one or more nodes to be rebooted.
        public let nodeIdsToReboot: [String]?
        /// The name of the parameter group.
        public let parameterGroupName: String?

        public init(parameterApplyStatus: String? = nil, nodeIdsToReboot: [String]? = nil, parameterGroupName: String? = nil) {
            self.parameterApplyStatus = parameterApplyStatus
            self.nodeIdsToReboot = nodeIdsToReboot
            self.parameterGroupName = parameterGroupName
        }

        public init(dictionary: [String: Any]) throws {
            self.parameterApplyStatus = dictionary["ParameterApplyStatus"] as? String
            self.nodeIdsToReboot = dictionary["NodeIdsToReboot"] as? [String]
            self.parameterGroupName = dictionary["ParameterGroupName"] as? String
        }
    }

    public enum ParameterType: String, CustomStringConvertible {
        case `default` = "DEFAULT"
        case node_type_specific = "NODE_TYPE_SPECIFIC"
        public var description: String { return self.rawValue }
    }

    public struct DecreaseReplicationFactorResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Cluster", required: false, type: .structure)
        ]
        /// A description of the DAX cluster, after you have decreased its replication factor.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        public init(dictionary: [String: Any]) throws {
            if let cluster = dictionary["Cluster"] as? [String: Any] { self.cluster = try Dax.Cluster(dictionary: cluster) } else { self.cluster = nil }
        }
    }

    public struct UpdateClusterResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Cluster", required: false, type: .structure)
        ]
        /// A description of the DAX cluster, after it has been modified.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        public init(dictionary: [String: Any]) throws {
            if let cluster = dictionary["Cluster"] as? [String: Any] { self.cluster = try Dax.Cluster(dictionary: cluster) } else { self.cluster = nil }
        }
    }

    public struct UntagResourceResponse: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "Tags", required: false, type: .list)
        ]
        /// The tag keys that have been removed from the cluster.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        public init(dictionary: [String: Any]) throws {
            if let tags = dictionary["Tags"] as? [[String: Any]] {
                self.tags = try tags.map({ try Tag(dictionary: $0) })
            } else { 
                self.tags = nil
            }
        }
    }

    public struct DeleteParameterGroupRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterGroupName", required: true, type: .string)
        ]
        /// The name of the parameter group to delete.
        public let parameterGroupName: String

        public init(parameterGroupName: String) {
            self.parameterGroupName = parameterGroupName
        }

        public init(dictionary: [String: Any]) throws {
            guard let parameterGroupName = dictionary["ParameterGroupName"] as? String else { throw InitializableError.missingRequiredParam("ParameterGroupName") }
            self.parameterGroupName = parameterGroupName
        }
    }

    public struct DescribeClustersRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ClusterNames", required: false, type: .list), 
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "MaxResults", required: false, type: .integer)
        ]
        /// The names of the DAX clusters being described.
        public let clusterNames: [String]?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. The value for MaxResults must be between 20 and 100.
        public let maxResults: Int32?

        public init(clusterNames: [String]? = nil, nextToken: String? = nil, maxResults: Int32? = nil) {
            self.clusterNames = clusterNames
            self.nextToken = nextToken
            self.maxResults = maxResults
        }

        public init(dictionary: [String: Any]) throws {
            self.clusterNames = dictionary["ClusterNames"] as? [String]
            self.nextToken = dictionary["NextToken"] as? String
            self.maxResults = dictionary["MaxResults"] as? Int32
        }
    }

    public struct Node: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ParameterGroupStatus", required: false, type: .string), 
            AWSShapeProperty(label: "Endpoint", required: false, type: .structure), 
            AWSShapeProperty(label: "NodeCreateTime", required: false, type: .timestamp), 
            AWSShapeProperty(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeProperty(label: "NodeId", required: false, type: .string), 
            AWSShapeProperty(label: "NodeStatus", required: false, type: .string)
        ]
        /// The status of the parameter group associated with this node. For example, in-sync.
        public let parameterGroupStatus: String?
        /// The endpoint for the node, consisting of a DNS name and a port number. Client applications can connect directly to a node endpoint, if desired (as an alternative to allowing DAX client software to intelligently route requests and responses to nodes in the DAX cluster.
        public let endpoint: Endpoint?
        /// The date and time (in UNIX epoch format) when the node was launched.
        public let nodeCreateTime: String?
        /// The Availability Zone (AZ) in which the node has been deployed.
        public let availabilityZone: String?
        /// A system-generated identifier for the node.
        public let nodeId: String?
        /// The current status of the node. For example: available.
        public let nodeStatus: String?

        public init(parameterGroupStatus: String? = nil, endpoint: Endpoint? = nil, nodeCreateTime: String? = nil, availabilityZone: String? = nil, nodeId: String? = nil, nodeStatus: String? = nil) {
            self.parameterGroupStatus = parameterGroupStatus
            self.endpoint = endpoint
            self.nodeCreateTime = nodeCreateTime
            self.availabilityZone = availabilityZone
            self.nodeId = nodeId
            self.nodeStatus = nodeStatus
        }

        public init(dictionary: [String: Any]) throws {
            self.parameterGroupStatus = dictionary["ParameterGroupStatus"] as? String
            if let endpoint = dictionary["Endpoint"] as? [String: Any] { self.endpoint = try Dax.Endpoint(dictionary: endpoint) } else { self.endpoint = nil }
            self.nodeCreateTime = dictionary["NodeCreateTime"] as? String
            self.availabilityZone = dictionary["AvailabilityZone"] as? String
            self.nodeId = dictionary["NodeId"] as? String
            self.nodeStatus = dictionary["NodeStatus"] as? String
        }
    }

    public struct ListTagsRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "NextToken", required: false, type: .string), 
            AWSShapeProperty(label: "ResourceName", required: true, type: .string)
        ]
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token.
        public let nextToken: String?
        /// The name of the DAX resource to which the tags belong.
        public let resourceName: String

        public init(nextToken: String? = nil, resourceName: String) {
            self.nextToken = nextToken
            self.resourceName = resourceName
        }

        public init(dictionary: [String: Any]) throws {
            self.nextToken = dictionary["NextToken"] as? String
            guard let resourceName = dictionary["ResourceName"] as? String else { throw InitializableError.missingRequiredParam("ResourceName") }
            self.resourceName = resourceName
        }
    }

    public struct UntagResourceRequest: AWSShape {
        /// The key for the payload
        public static let payload: String? = nil
        public static var parsingHints: [AWSShapeProperty] = [
            AWSShapeProperty(label: "ResourceName", required: true, type: .string), 
            AWSShapeProperty(label: "TagKeys", required: true, type: .list)
        ]
        /// The name of the DAX resource from which the tags should be removed.
        public let resourceName: String
        /// A list of tag keys. If the DAX cluster has any tags with these keys, then the tags are removed from the cluster.
        public let tagKeys: [String]

        public init(resourceName: String, tagKeys: [String]) {
            self.resourceName = resourceName
            self.tagKeys = tagKeys
        }

        public init(dictionary: [String: Any]) throws {
            guard let resourceName = dictionary["ResourceName"] as? String else { throw InitializableError.missingRequiredParam("ResourceName") }
            self.resourceName = resourceName
            guard let tagKeys = dictionary["TagKeys"] as? [String] else { throw InitializableError.missingRequiredParam("TagKeys") }
            self.tagKeys = tagKeys
        }
    }

}